<?xml version="1.0"?>
<doc>
<assembly>
<name>
Microsoft.CodeAnalysis.VisualBasic
</name>
</assembly>
<members>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.BoundExpression.SuppressVirtualCalls">
 <summary>
 Returns true if calls and delegate invocations with this
 expression as the receiver should be non-virtual calls.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.BoundExpression.IsLValue">
 <summary>
 Does expression refer to a physical memory location that can be modified?
 
 Note, Dev10 uses SXF_LVALUE flag on bound nodes to represent this concept.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundAddressOfOperator.GetDelegateResolutionResult(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder.DelegateResolutionResult@)">
 <summary>
 Gets the <see>Binder.DelegateResolutionResult</see> for the given targetType. 
 </summary>
 <remarks>
 One needs to call <see>GetConversionClassification</see> before in order to fill the cache.
 </remarks>
 <param name="targetType">Type of the target.</param>
 <returns>The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Binder.DelegateResolutionResult">Binder.DelegateResolutionResult</see> for the conversion 
 of the AddressOf operand to the target type
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundAddressOfOperator.GetConversionClassification(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Gets the conversion classification.
 </summary>
 <param name="targetType">The destination type to convert to.</param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup.MemberName">
 <summary>
 returns name used to lookup the method/property in the group.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup.ContainerOfFirstInGroup">
 <summary>
 returns the container of the first member in the group.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundYieldStatement.#ctor(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Boolean,System.Boolean)">
 <summary>
 Suppresses RValue validation when constructing the node. 
 Must be used _only_ when performing lambda inference where RValue inconsistency on this node is intentionally allowed.
 If such node makes into a regular bound tree it will be eventually rewritten (all Yields are rewritten at some point)
 and that will trigger validation.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundLateMemberAccess.SetAccessKind(Microsoft.CodeAnalysis.VisualBasic.LateBoundAccessKind)">
 <summary>
 Updates property access kind. To clear the access kind,
 'newAccessKind' should be Unknown. Otherwise, the current
 access kind should be Unknown or equal to 'newAccessKind'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundLateInvocation.SetAccessKind(Microsoft.CodeAnalysis.VisualBasic.LateBoundAccessKind)">
 <summary>
 Updates access kind. To clear the access kind,
 'newAccessKind' should be Unknown. Otherwise, the current
 access kind should be Unknown or equal to 'newAccessKind'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess.SetAccessKind(Microsoft.CodeAnalysis.VisualBasic.PropertyAccessKind)">
 <summary>
 Updates property access kind. To clear the access kind,
 'newAccessKind' should be Unknown. Otherwise, the current
 access kind should be Unknown or equal to 'newAccessKind'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess.GetTypeFromAccessKind(Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol,Microsoft.CodeAnalysis.VisualBasic.PropertyAccessKind)">
 <summary>
 If the access includes a set, the type of the expression
 is the type of the setter value parameter. Otherwise, the
 type of the expression is the return type of the getter.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.BoundDoLoopStatement.ConditionIsTop">
 <summary>
 Gets a value indicating whether this do loop is a DoTopLoop or not. In syntax error cases
 where both conditions are used, priority is given to the first one.
 It's recommended to consistently use this property instead of checking the TopConditionOpt and BottomConditionOpt
 directly.
 </summary>
 <value>
   <c>true</c> if this loop is a DoTopLoop; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.BoundDoLoopStatement.ConditionIsUntil">
 <summary>
 Gets a value indicating whether the condition of this do loop is &quot;until&quot; or not. In syntax error cases
 where both conditions are used, priority is given to the first one.
 It's recommended to consistently use this property instead of checking TopConditionIsUntil and BottomConditionIsUntil
 directly.
 </summary>
 <value>
   <c>true</c> if this loop is a DoTopLoop; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.BoundDoLoopStatement.ConditionOpt">
 <summary>
 Gets the optional bound condition expression for this do loop statement. In syntax error cases
 where both conditions are used, priority is given to the first one.
 It's recommended to consistently use this property instead of accessing TopConditionOpt or BottomConditionOpt
 directly.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.BoundWithStatement.ExpressionPlaceholder">
 <summary> Returns the placeholder used in this With statement to 
 substitute the expression in initial binding </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.BoundWithStatement.DraftInitializers">
 <summary>
 A draft version of initializers which will be used in this With statement. 
 Initializers are expressions which are used to capture expression in the current
 With statement; they can be empty in some cases like if the expression is a local 
 variable of value type.
 
 Note, the initializers returned by this property are 'draft' because they are 
 generated based on initial bound tree, the real initializers will be generated 
 in lowering based on lowered expression form.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.BoundWithStatement.DraftPlaceholderSubstitute">
 <summary>
 A draft version of placeholder substitute which will be used in this With statement. 
 
 Note, the placeholder substitute returned by this property is 'draft' because it is
 generated based on initial bound tree, the real substitute will be generated in lowering 
 based on lowered expression form.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.UnboundLambda.IsSingleLine">
 <summary>
 Should this lambda be treated as a single line lambda?
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.UnboundLambda.IsFunctionLambda">
 <summary>
 Is this a function lambda
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.UnboundLambda.InferReturnType(Microsoft.CodeAnalysis.VisualBasic.UnboundLambda.TargetSignature)">
 <summary>
 target.ReturnType is ignored and must be Void, only parameter types are taken into consideration.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.UnboundLambda.UnboundLambdaBindingCache">
 <summary>
 This class is used to cache various information about a lambda in the course of binding an expression/statement
 containing the lambda. Even though the members are public, they shouldn't be accessed directly by any code
 outside of the UnboundLambda class.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.BoundLambda.IsSingleLine">
 <summary>
 Should this lambda be treated as a single line lambda?
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundTreeVisitor.VisitExpressionWithStackGuard(System.Int32@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Consumers must provide implementation for <see cref="M:Microsoft.CodeAnalysis.VisualBasic.BoundTreeVisitor.VisitExpressionWithoutStackGuard(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)"/>.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundTreeVisitor.VisitExpressionWithoutStackGuard(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 We should be intentional about behavior of derived classes regarding guarding against stack overflow. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Analyzer.AnalyzeMethodBody(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundBlock,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Analyzes method body for error conditions such as definite assignments, unreachable code etc...
 
 This analysis is done when doing the full compile or when responding to GetCompileDiagnostics.
 This method assume that the trees are already bound and will not do any rewriting/lowering
 It is possible and common for this analysis to be done in the presence of errors.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.IntersectWith(`0@,`0@)">
 <summary>
 Mutate 'self' flow analysis state to reflect the fact that there is a control-flow
 convergence with the 'other' flow analysis state.  Return true if and only if the
 state has changed as a result of the Join.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.UnionWith(`0@,`0@)">
 <summary>
 Mutate 'self' flow analysis state to reflect the fact that there is a control-flow
 sequence with the 'other' flow analysis state - in other words, this occurs and then
 the other.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.AbstractLocalState.Clone">
 <summary>
 Produce a duplicate of this flow analysis state.
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.BlockNesting">
 <summary>
 BlockLevel is used to keep track of the lexical nesting level of label and goto statements. 
 The other most block has a path of {}
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.LabelStateAndNesting">
 <summary>
 The state associated with a label includes the statement itself, the local state and the nesting.
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.PendingBranch">
 <summary>
 A pending branch.  There are created for a return, break, continue, or goto statement.  The
 idea is that we don't know if the branch will eventually reach its destination because of an
 intervening finally block that cannot complete normally.  So we store them up and handle them
 as we complete processing each construct.  At the end of a block, if there are any pending
 branches to a label in that block we process the branch.  Otherwise we relay it up to the
 enclosing construct as a pending branch of the enclosing construct.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1._firstInRegion">
 <summary> Start of the region being analyzed, or Nothing if it is not a region based analysis </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1._lastInRegion">
 <summary> End of the region being analyzed, or Nothing if it is not a region based analysis </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1._region">
 <summary> Current region span, valid only for region based analysis </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1._regionPlace">
 <summary> Tells whether we are analyzing the position before, during, or after the region </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1._loopHeadState">
 <summary>
 A cache of the state at the backward branch point of each loop.  This is not needed
 during normal flow analysis, but is needed for region analysis.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.IsInsideRegion(Microsoft.CodeAnalysis.Text.TextSpan)">
 <summary> Checks if the text span passed is inside the region </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.EnterRegion">
 <summary>
 Subclasses may override EnterRegion to perform any actions at the entry to the region.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.LeaveRegion">
 <summary>
 Subclasses may override LeaveRegion to perform any action at the end of the region.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1._invalidRegion">
 <summary>
 If invalid region is dynamically detected this string contains text description of the reason.
 
 Currently only the following case can cause the region to be invalidated:
 
   - We have declaration of several variables using 'As New' having object
     initializer with implicit receiver; if region included such a receiver,
     it should include the whole declaration. Example:
         Dim a, b As New Clazz(...) With { .X = [| .Y |] }
 
   - Part of With statement expression which was not captured into locals and
     was not evaluated during With statement body execution. Example:
     initializer with implicit receiver; if region included such a receiver,
     it should include the whole declaration. Example:
         Dim sArray() As StructType = ...
         With sArray([| 0 |])
         End With
 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.compilation">
 <summary>
 The compilation in which the analysis is taking place.  This is needed to determine which
 conditional methods will be compiled and which will be omitted.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.symbol">
 <summary>
 The symbol of method whose body is being analyzed or field or property whose 
 initializer is being analyzed
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1._methodOrInitializerMainNode">
 <summary>
 The bound code of the method or initializer being analyzed
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1._labels">
 <summary>
 The flow analysis state at each label, computed by merging the state from branches to
 that label with the state when we fall into the label.  Entries are created when the
 label is encountered.  One case deserves special attention: when the destination of the
 branch is a label earlier in the code, it is possible (though rarely occurs in practice)
 that we are changing the state at a label that we've already analyzed. In that case we
 run another pass of the analysis to allow those changes to propagate. This repeats until
 no further changes to the state of these labels occurs.  This can result in quadratic
 performance in unlikely but possible code such as this: "int x; if (cond) goto l1; x =
 3; l5: print x; l4: goto l5; l3: goto l4; l2: goto l3; l1: goto l2;"
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1._labelsSeen">
 <summary> All of the labels seen so far in this forward scan of the body </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.backwardBranchChanged">
 <summary>
 Set to true after an analysis scan if the analysis was incomplete due to a backward
 "goto" branch changing some analysis result.  In this case the caller scans again (until
 this is false). Since the analysis proceeds by monotonically changing the state computed
 at each label, this must terminate.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1._pendingBranches">
 <summary> Actual storage for PendingBranches </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.State">
 <summary> The definite assignment and/or reachability state at the point currently being analyzed. </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.MeParameter">
 <summary>
 'Me' parameter, relevant for methods, fields, properties, otherwise Nothing
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.TrackUnassignments">
 <summary>
 Used only in the data flows out walker, we track unassignments as well as assignments
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1._nesting">
 <summary>
 The current lexical nesting in the BoundTree. 
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.diagnostics">
 <summary>
 Where all diagnostics are deposited.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1._suppressConstantExpressions">
 <summary> Indicates whether or not support of constant expressions (boolean and nothing)
 is enabled in this analyzer. In general, constant expressions support is enabled in analysis
 exposed to public API consumer and disabled when used from command-line compiler. </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.#ctor(Microsoft.CodeAnalysis.VisualBasic.FlowAnalysisInfo,System.Boolean)">
 <summary>
 Construct an object for outside-region analysis
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.#ctor(Microsoft.CodeAnalysis.VisualBasic.FlowAnalysisInfo,Microsoft.CodeAnalysis.VisualBasic.FlowAnalysisRegionInfo,System.Boolean,System.Boolean)">
 <summary>
 Construct an object for region-aware analysis
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.SetConditionalState(`0,`0)">
 <summary> Set conditional state </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.SetState(`0)">
 <summary> Set unconditional state </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.Split">
 <summary> Split state </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.Unsplit">
 <summary> Intersect and unsplit state </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.PendingBranches">
 <summary>
 Pending escapes generated in the current scope (or more deeply nested scopes). When jump
 statements (goto, break, continue, return) are processed, they are placed in the
 Me._pendingBranches buffer to be processed later by the code handling the destination
 statement. As a special case, the processing of try-finally statements might modify the
 contents of the Me._pendingBranches buffer to take into account the behavior of
 "intervening" finally clauses.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.Scan">
 <summary>
 Perform a single pass of flow analysis.  Note that after this pass,
 this.backwardBranchChanged indicates if a further pass is required.
 </summary>
 <returns>False if the region is invalid</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.Analyze">
 <returns>False if the region is invalid</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.MethodParameters">
 <summary>
 If analysis is being performed in a context of a method returns method's parameters, 
 otherwise returns an empty array
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.ShouldAnalyzeByRefParameters">
 <summary>
 Specifies whether or not method's ByRef parameters should be analyzed. If there's more than one location in
 the method being analyzed, then the method is partial and we prefer to report an out parameter in partial
 method error.
 Note: VB doesn't support "out" so it doesn't warn for unassigned parameters. However, check variables passed
 byref are assigned so that data flow analysis detects parameters flowing out.
 </summary>
 <returns>true if the out parameters of the method should be analyzed</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.MethodSymbol">
 <summary>
 Method symbol or nothing
 TODO: Need to try and get rid of this property
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.MethodReturnType">
 <summary>
 If analysis is being performed in a context of a method returns method's return type, 
 otherwise returns Nothing
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.LabelState(Microsoft.CodeAnalysis.VisualBasic.Symbols.LabelSymbol)">
 <summary>
 Return the flow analysis state associated with a label.
 </summary>
 <param name="label"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.SetUnreachable">
 <summary>
 Set the current state to one that indicates that it is unreachable.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.LoopHead(Microsoft.CodeAnalysis.VisualBasic.BoundLoopStatement)">
 <summary>
 Called at the point in a loop where the backwards branch would go to.
 </summary>
 <param name="node"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.LoopTail(Microsoft.CodeAnalysis.VisualBasic.BoundLoopStatement)">
 <summary>
 Called at the point in a loop where the backward branch is placed.
 </summary>
 <param name="node"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.ResolveBreaks(`0,Microsoft.CodeAnalysis.VisualBasic.Symbols.LabelSymbol)">
 <summary>
 Used to resolve exit statements in each statement form that has an Exit statement
 (loops, switch).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.ResolveContinues(Microsoft.CodeAnalysis.VisualBasic.Symbols.LabelSymbol)">
 <summary>
 Used to resolve continue statements in each statement form that supports it.
 </summary>
 <param name = "continueLabel"></param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.NoteBranch(Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass{`0}.PendingBranch,Microsoft.CodeAnalysis.VisualBasic.BoundStatement,Microsoft.CodeAnalysis.VisualBasic.BoundLabelStatement)">
 <summary>
 Subclasses override this if they want to take special actions on processing a goto
 statement, when both the jump and the label have been located.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.ResolveBranches(Microsoft.CodeAnalysis.VisualBasic.BoundLabelStatement)">
 <summary>
 To handle a label, we resolve all pending forward references to branches to that label.  Returns true if the state of
 the label changes as a result. 
 </summary>
 <param name = "target"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.SavePending">
 <summary>
 When branching into constructs that don't support jumps into/out of (i.e. lambdas), 
 we save the pending branches when visiting more nested constructs.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.RestorePending(Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass{`0}.SavedPending,System.Boolean)">
 <summary>
 We use this to restore the old set of pending branches and labels after visiting a construct that contains nested statements.
 </summary>
 <param name="oldPending">The old pending branches/labels, which are to be merged with the current ones</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.ResolveBranches(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.Symbols.LabelSymbol})">
 <summary>
 We look at all pending branches and attempt to resolve the branches with labels if the nesting of the 
 block is the nearest common parent to the branch and the label. Because the code is evaluated recursively 
 outward we only need to check if the current nesting is a prefix of both the branch and the label nesting.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.Unimplemented(Microsoft.CodeAnalysis.VisualBasic.BoundNode,System.String)">
 <summary>
 Report an unimplemented language construct.
 </summary>
 <param name = "node"></param>
 <param name = "feature"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.Visit(Microsoft.CodeAnalysis.VisualBasic.BoundNode,System.Boolean)">
 <summary>
 Visit a node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.VisitAlways(Microsoft.CodeAnalysis.VisualBasic.BoundNode,System.Boolean)">
 <summary>
 Visit a node, process 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.VisitCondition(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Visit a boolean condition expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.VisitRvalue(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass{`0}.ReadWriteContext,System.Boolean)">
 <summary>
 Visit a general expression, where we will only need to determine if variables are
 assigned (or not). That is, we will not be needing AssignedWhenTrue and
 AssignedWhenFalse.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.DefaultVisit(Microsoft.CodeAnalysis.VisualBasic.BoundNode)">
 <summary>
 Since each language construct must be handled according to the rules of the language specification,
 the default visitor reports that the construct for the node is not implemented in the compiler.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.FieldAccessMayRequireTracking(Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess)">
 <summary> Bound field access passed may require tracking if it is an access to a non-shared structure field </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1.VisitUnreachableReceiver(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 If a receiver is included in cases where the receiver will not be
 evaluated (an instance for a shared method for instance), we
 still want to visit the receiver but treat it as unreachable code.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.AlwaysAssignedWalker">
 <summary>
 A region analysis walker that computes the set of variables that are always assigned a value in the region.
 A variable is "always assigned" in a region if an analysis of the
 region that starts with the variable unassigned ends with the variable
 assigned.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicControlFlowAnalysis">
 <summary>
 This class implements the region control flow analysis operations.  Region control flow analysis provides
 information about statements which enter and leave a region. The analysis done lazily. When created, it performs
 no analysis, but simply caches the arguments. Then, the first time one of the analysis results is used it
 computes that one result and caches it. Each result is computed using a custom algorithm.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicControlFlowAnalysis.EntryPoints">
 <summary>
 A collection of statements outside the region that jump into the region.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicControlFlowAnalysis.ExitPoints">
 <summary>
 A collection of statements inside the region that jump to locations outside the region.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicControlFlowAnalysis.EndPointIsReachable">
 <summary>
 Returns true if and only if the last statement in the region can complete normally or the region contains no
 statements.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicControlFlowAnalysis.ReturnStatements">
 <summary>
 A collection of return, exit sub, exit function, exit operator and exit property statements found within the region that return to the enclosing method.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ControlFlowPass.LocalState.Clone">
 <summary> Produce a duplicate of this flow analysis state. </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ControlFlowPass.Analyze(Microsoft.CodeAnalysis.VisualBasic.FlowAnalysisInfo,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 Perform control flow analysis, reporting all necessary diagnostics.  Returns true if the end of
 the body might be reachable..
 </summary>
 <param name = "diagnostics"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDataFlowAnalysis">
 <summary>
 This class implements the region data flow analysis operations.  Region data flow analysis provides information
 how data flows into and out of a region.  The analysis is done lazily. When created, it performs no analysis, but
 simply caches the arguments. Then, the first time one of the analysis results is used it computes that one
 result and caches it. Each result is computed using a custom algorithm.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDataFlowAnalysis.VariablesDeclared">
 <summary>
 A collection of the local variables that are declared within the region. Note that the region must be 
 bounded by a method's body or a field's initializer, so parameter symbols are never included in the result.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDataFlowAnalysis.DataFlowsIn">
 <summary>
 A collection of the local variables for which a value assigned outside the region may be used inside the region.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDataFlowAnalysis.DataFlowsOut">
 <summary>
 A collection of the local variables for which a value assigned inside the region may be used outside the region.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDataFlowAnalysis.AlwaysAssigned">
 <summary>
 A collection of the local variables for which a value is always assigned inside the region.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDataFlowAnalysis.ReadInside">
 <summary>
 A collection of the local variables that are read inside the region.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDataFlowAnalysis.WrittenInside">
 <summary>
 A collection of local variables that are written inside the region.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDataFlowAnalysis.ReadOutside">
 <summary>
 A collection of the local variables that are read outside the region.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDataFlowAnalysis.WrittenOutside">
 <summary>
 A collection of local variables that are written inside the region.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDataFlowAnalysis.Captured">
 <summary>
 A collection of the local variables that have been referenced in anonymous functions
 and therefore must be moved to a field of a frame class.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.IntersectBitArrays(Microsoft.CodeAnalysis.BitVector@,Microsoft.CodeAnalysis.BitVector)">
 <summary>
 Intersect bit arrays taking into account 'all bits set' flag
 </summary>
 <remarks>receiver will be changed as a result</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.UnionBitArrays(Microsoft.CodeAnalysis.BitVector@,Microsoft.CodeAnalysis.BitVector)">
 <summary>
 Union bit arrays taking into account 'all bits set' flag
 </summary>
 <remarks>receiver will be changed as a result</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.LocalState.Clone">
 <summary>
 Produce a duplicate of this flow analysis state.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.SlotCollection">
 <summary>
 Collection of 0, 1 or more slots. Allows returning of several slots by some 
 DataFlowPass methods to handle cases where implicit receiver represents 
 several variables, like in:
     Dim a, b, c As New C(...) With {...}
 
 Because such constructions are very rare in real user code, the collection only 
 allocates an array builder for storing several values if there are indeed more 
 than one slot to be stored. Because the collection may optionally create an 
 array builder, collection's Free() method must be called when appropriate.
 
 Note that the collection is mutable, so one can add or modify the values.
 If some collection elements get replaced with 'SlotKind.NotTracked' collection
 does NOT "shrink", i.e. once allocated the array builder is not freed even if 
 all the elements are set to 'SlotKind.NotTracked'.
 
 Collection cannot store 'SlotKind.Unreachable' (0) which has a special meaning.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.AmbiguousLocalsPseudoSymbol">
 <summary> 
 AmbiguousLocalsPseudoSymbol is a pseudo-symbol used in flow analysis representing 
 a symbol of the implicit receiver in case Dim statement defines more than one variable,
 but uses the same object initializer for all of them, like: 
     Dim a,b As New C() With { .X = .Y } 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.VariableIdentifier">
 <summary> Represents variable symbol combined with the containing variable slot </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.SlotKind.NotTracked">
 <summary>
  Special slot for untracked variables
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.SlotKind.Unreachable">
 <summary>
 Special slot for tracking whether code is reachable
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.SlotKind.FunctionValue">
 <summary>
 Special slot for tracking the implicit local for the function return value
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.SlotKind.FirstAvailable">
 <summary>
 The first available slot for variables
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.initiallyAssignedVariables">
 <summary>
 Some variables that should be considered initially assigned.  Used for region analysis.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass._trackStructsWithIntrinsicTypedFields">
 <summary>
 Defines whether or not fields of intrinsic type should be tracked. Such fields should 
 not be tracked for error reporting purposes, but should be tracked for region flow analysis
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass._unusedVariables">
 <summary>
 Variables that were used anywhere, in the sense required to suppress warnings about unused variables.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass._writtenVariables">
 <summary>
 Variables that were initialized or written anywhere.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass._variableSlot">
 <summary> 
 A mapping from local variables to the index of their slot in a flow analysis local state. 
 WARNING: if variable identifier maps into SlotKind.NotTracked, it may mean that VariableIdentifier 
          is a structure without traceable fields. This mapping is created in MakeSlotImpl(...)
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.variableBySlot">
 <summary>
 A mapping from the local variable slot to the symbol for the local variable itself.  This is used in the
 implementation of region analysis (support for extract method) to compute the set of variables "always
 assigned" in a region of code.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.nextVariableSlot">
 <summary>
 Variable slots are allocated to local variables sequentially and never reused.  This is
 the index of the next slot number to use.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass._alreadyReported">
 <summary>
 Tracks variables for which we have already reported a definite assignment error.  This
 allows us to report at most one such error per variable.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass._seenOnErrorOrResume">
 <summary>
 Did we see [On Error] or [Resume] statement? Used to suppress some diagnostics.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.Analyze(Microsoft.CodeAnalysis.VisualBasic.FlowAnalysisInfo,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 Perform data flow analysis, reporting all necessary diagnostics.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.VariableSlot(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Int32)">
 <summary>
 Locals are given slots when their declarations are encountered.  We only need give slots to local variables, and 
 the "Me" variable of a structure constructs. Other variables are not given slots, and are therefore not tracked 
 by the analysis.  This returns SlotKind.NotTracked for a variable that is not tracked, for fields of structs 
 that have the same assigned status as the container, and for structs that (recursively) contain no data members.
 We do not need to track references to variables that occur before the variable is declared, as those are reported 
 in an earlier phase as "use before declaration". That allows us to avoid giving slots to local variables before
 processing their declarations.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.MakeSlotsForExpression(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Return the slot for a variable, or SlotKind.NotTracked if it is not tracked (because, for example, it is an empty struct).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.MakeSlot(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Int32)">
 <summary>
 Force a variable to have a slot.
 </summary>
 <param name = "local"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.IsSlotAlreadyReported(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Int32)">
 <summary> Calculates the flag of being already reported; for structure types
 the slot may be reported if ALL the children are reported </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.MarkSlotAsReported(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Int32)">
 <summary> Marks slot as reported, propagates 'reported' flag to the children if necessary </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.SetSlotUnassigned(System.Int32)">
 <summary> Unassign a slot for a regular variable </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.SetSlotAssigned(System.Int32,Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.LocalState@)">
 <summary>Assign a slot for a regular variable in a given state.</summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.SetSlotAssigned(System.Int32)">
 <summary>Assign a slot for a regular variable.</summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass._typeToMembersCache">
 <summary> Hash structure fields as we may query them many times </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.CheckAssigned(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass{Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.LocalState}.ReadWriteContext)">
 <summary>
 Check that the given variable is definitely assigned.  If not, produce an error.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.CheckAssigned(Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass{Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.LocalState}.ReadWriteContext)">
 <summary> Version of CheckAssigned for bound field access </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.IsAssigned(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Int32@)">
 <summary> Check node for being assigned, return the value of unassigned slot in unassignedSlot </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.EnableBreakingFlowAnalysisFeatures">
 <summary>
 Property controls Roslyn data flow analysis features which are disabled in command-line 
 compiler mode to maintain backward compatibility (mostly diagnostics not reported by Dev11), 
 but *enabled* in flow analysis API
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.ProcessCompilerGeneratedLocals">
 <summary>
 Specifies if the analysis should process compiler generated locals. 
 
 Note that data flow API should never report compiler generated variables 
 as well as those should not generate any diagnostics (like being unassigned, etc...).
 
 But when the analysis is used for iterators or async captures it should process 
 compiler generated locals as well...
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.ReportUnassigned(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass{Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.LocalState}.ReadWriteContext,System.Int32,Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess)">
 <summary>
 Report a given variable as not definitely assigned.  Once a variable has been so
 reported, we suppress further reports of that variable.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.Assign(Microsoft.CodeAnalysis.VisualBasic.BoundNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Boolean)">
 <summary>
 Mark a variable as assigned (or unassigned).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DataFlowPass.DeclaredVariableIsAlwaysAssignedBeforeInitializer(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundValuePlaceholderBase@)">
 <summary>
 A variable declared with As New can be considered assigned before the initializer is executed in case the variable
 is a value type. The reason is that in this case the initialization happens in place (not in a temporary) and 
 the variable already got the object creation expression assigned.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.DataFlowsInWalker">
 <summary>
 A region analysis walker that computes the set of variables whose values flow into (are used in)
 the region.
 An variable assigned outside is used inside if an analysis
 that leaves the variable unassigned on entry to the region would cause the
 generation of "unassigned" errors within the region.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.DataFlowsOutWalker">
 <summary>
 A region analysis walker that computes the set of variables for
 which their assigned values flow out of the region.
 A variable assigned inside is used outside if an analysis that
 treats assignments in the region as un-assigning the variable would
 cause "unassigned" errors outside the region.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.EntryPointsWalker">
 <summary>
 A region analysis walker that records jumps into the region.  Works by overriding NoteBranch, which is
 invoked by a superclass when the two endpoints of a jump have been identified.
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ExitPointsWalker">
 <summary>
 A region analysis walker that records jumps out of the region.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.FlowAnalysisRegionInfo.FirstInRegion">
 <summary> Region being analyzed: start node </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.FlowAnalysisRegionInfo.LastInRegion">
 <summary> Region being analyzed: end node </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.FlowAnalysisRegionInfo.Region">
 <summary> Region itself </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.FlowAnalysisPass.Analyze(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundBlock,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 The flow analysis pass.  This pass reports required diagnostics for unreachable
 statements and uninitialized variables (through the call to FlowAnalysisWalker.Analyze).
 </summary>
 <param name = "method">the method to be analyzed</param>
 <param name = "block">the method's body</param>
 <param name = "diagnostics">the receiver of the reported diagnostics</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ReadWriteWalker">
 <summary>
 A region analysis walker that records reads and writes of all variables, both inside and outside the region.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.RegionAnalysisContext">
 <summary>
 Represents analysis context attributes such as compilation, region, etc...
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.RegionAnalysisContext._compilation">
 <summary> Current compilation </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.RegionAnalysisContext._symbol">
 <summary> Method, field or property symbol </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.RegionAnalysisContext._boundNode">
 <summary> Bound node defining the root of the bound subtree to be analyzed </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.RegionAnalysisContext._firstInRegion">
 <summary> Region being analyzed: start node </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.RegionAnalysisContext._lastInRegion">
 <summary> Region being analyzed: end node </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.RegionAnalysisContext._region">
 <summary> Region itself </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.RegionAnalysisContext.Failed">
 <summary> True if the input was bad, such as no first and last nodes </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.RegionAnalysisContext.#ctor(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.BoundNode,Microsoft.CodeAnalysis.VisualBasic.BoundNode,Microsoft.CodeAnalysis.VisualBasic.BoundNode,Microsoft.CodeAnalysis.Text.TextSpan)">
 <summary>
 Construct context from model and region
 
 'boundNode' defines a bound sub-tree to be analyzed and is being used in 
 both region-based and not region based analysis processes. 
 
 The last three parameters define a region. In most cases firstInRegion and lastInRegion 
 are being used for identifying when we should enter or leave the region. 
 
 Text span is also being passed to define the region which is used in few places. Those 
 places can be rewritten to use first/last bound nodes, but simple [region.Contains(...)] 
 check simplifies the code significantly. (Note, C# implementation uses the same logic, 
 but calculates the region's text span based on first/last node; in VB to perform such 
 calculation would have to traverse bound subtree under first/last nodes to detect 
 region boundaries; we avoid this additional cost by passing the original text span as 
 a separate parameter because we do have it anyways)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.RegionAnalysisContext.#ctor(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 Construct context with Failed flag
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.RegionReachableWalker">
 <summary>
 A region analysis walker that computes whether or not the region completes normally.  It does this by determining 
 if the point at which the region ends is reachable.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.UnassignedVariablesWalker">
 <summary>
 An analysis that computes the set of variables that may be used
 before being assigned anywhere within a method.
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VariablesDeclaredWalker">
 <summary>
 A region analysis walker that records declared variables.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ForLoopVerification.VerifyForLoops(Microsoft.CodeAnalysis.VisualBasic.BoundBlock,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 A BoundForLoopStatement node has a list of control variables (from the attached next statement).
 When binding the control variable of a for/for each loop that is nested in another for/for each loop, it must be
 checked that the control variable has not been used by a containing for/for each loop. Because bound nodes do not
 know their parents and we try to avoid passing around a stack of variables, we just walk the bound tree after the
 initial binding to report this error.
 In addition, it must be checked that the control variables of the next statement match the loop. Because the inner 
 most loop contains the next with control variables from outer binders, checking this here is also convenient.

 There are two diagnostics reported by this walker:
 1. BC30069: For loop control variable '{0}' already in use by an enclosing For loop.
 2. BC30070: Next control variable does not match For loop control variable '{0}'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ForLoopVerification.ForLoopVerificationWalker.PreVisitForAndForEachStatement(Microsoft.CodeAnalysis.VisualBasic.BoundForStatement)">
 <summary>
 Checks if the control variable was already used in an enclosing for loop
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ForLoopVerification.ForLoopVerificationWalker.PostVisitForAndForEachStatement(Microsoft.CodeAnalysis.VisualBasic.BoundForStatement)">
 <summary>
 Checks if the control variables from the next statement match the control variable of the enclosing 
 for loop.
 Some loops may contain a next with multiple variables.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ForLoopVerification.ReferencedSymbol(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Gets the referenced symbol of the bound expression.
 Used for matching variables between For and Next statements.
 </summary>
 <param name="expression">The bound expression.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.InitializerRewriter">
 <summary>
 Turns the bound initializers into a list of bound assignment statements
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.InitializerRewriter.BuildConstructorBody(Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundStatement,Microsoft.CodeAnalysis.VisualBasic.Binder.ProcessedFieldOrPropertyInitializers,Microsoft.CodeAnalysis.VisualBasic.BoundBlock)">
 <summary>
 Builds a constructor body. 
 </summary>
 <remarks>
 Lowers initializers to fields assignments if not lowered yet and the first statement of the body isn't 
 a call to another constructor of the containing class. 
 </remarks>
 <returns>
 Bound block including 
  - call to a base constructor
  - field initializers and top-level code
  - remaining constructor statements (empty for a submission)
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.InitializerRewriter.RewriteInitializersAsStatements(Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedInteractiveInitializerMethod,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundInitializer})">
 <summary>
 Rewrites GlobalStatementInitializers to ExpressionStatements and gets the initializers for fields and properties.
 </summary>
 <remarks>
 Initializers for fields and properties cannot be rewritten to their final form at this place because they might need 
 to be rewritten to replace their placeholder expressions to the final locals or temporaries (e.g. in case of a field
 declaration with "AsNew" and multiple variable names. The final rewriting will during local rewriting.
 The statement list returned by this function can be copied into the initializer without reprocessing it.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.InitializerRewriter.HasExplicitMeConstructorCall(Microsoft.CodeAnalysis.VisualBasic.BoundBlock,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean@)">
 <summary> 
 Determines if this constructor calls another constructor of the constructor's containing class. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.IteratorAndAsyncCaptureWalker">
 <summary>
 A walker that computes the set of local variables of an iterator 
 method that must be moved to fields of the generated class.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.AttributeBinder">
 <summary>
 Binder used for attributes
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AttributeBinder._root">
 <summary> Root syntax node </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.AttributeBinder.Root">
 <summary> Field or property declaration statement syntax node </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AttributeBinder.GetBinder(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Some nodes have special binder's for their contents 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.AttributeSemanticModel">
 <summary>
 Binding info for attribute syntax and expressions that are part of a attribute.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AttributeSemanticModel.Create(Microsoft.CodeAnalysis.VisualBasic.AttributeBinder,System.Boolean)">
 <summary>
 Creates an AttributeSemanticModel that allows asking semantic questions about an attribute node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AttributeSemanticModel.CreateSpeculative(Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Int32)">
 <summary>
 Creates a speculative AttributeSemanticModel that allows asking semantic questions about an attribute node that did not appear in the original source code.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.BackstopBinder">
 <summary>
 Backstop that forms the end of the binder chain. Does nothing, and should never actually get hit. Provides
 asserts that methods never get called.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BackstopBinder.IsUnboundTypeAllowed(Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)">
 <summary>
 Returns true if the node is in a position where an unbound type
 such as (C(of)) is allowed.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolvedBinder">
 <summary>
 Causes lookups to assume that the given set of classes are having their 
 bases being resolved, so lookups should not check for base classes.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder">
 <summary>
 A Binder object represents a general location from where binding is happening, and provides
 virtual methods for looking up unqualified names, reporting errors, and also other
 operations that need to know about where binding happened from (accessibility checking,
 etc.) It also contains most of the methods related to general binding of constructs,
 although some large sections are factored into their own classes.

 Yes, Binder is a big grab bag of features. The reason for this is that binders are threaded
 through essentially ALL binding functions. So, basically Binder has all the features that
 need to be threaded through binding.

 Binder objects form a linked list and each binder links to its containing binder. Each
 binder only handles operations that it knows how to handles, and passes on other calls to
 its containing binder. This maintains separation of concerns and allows binders to be strung
 together in various configurations to enable different binding scenarios (e.g., debugger
 expression evaluator).

 In general, binder objects should be constructed via the BinderBuilder class.

 Binder class has GetBinder methods that return binders for scopes nested into the current
 binder scope. One should not expect to get a binder from the functions unless a syntax that
 originates a scope is passed as the argument. Also, the functions do not cross lambda
 boundaries, if binder's scope contains a lambda expression, binder will not return any
 binders for nodes contained in the lambda body. In order to get them, the lambda must be
 bound to BoundLambda node, which exposes LambdaBinder, which can be asked for binders in the
 lambda body (but it will not descend into nested lambdas). Currently, only
 <see cref="T:Microsoft.CodeAnalysis.VisualBasic.ExecutableCodeBinder"/>, <see cref="T:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.IncrementalBinder"/>
 and <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SpeculativeBinder"/> have special implementation of GetBinder functions,
 the rest just delegate to containing binder.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BinderSpecificLookupOptions(Microsoft.CodeAnalysis.VisualBasic.LookupOptions)">
 <summary>
 If the binding context requires specific binding options, then modify the given
 lookup options accordingly.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.Lookup(Microsoft.CodeAnalysis.VisualBasic.LookupResult,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Lookup the given name in the binder and containing binders.
 Returns the result of the lookup. See the definition of LookupResult for details.
 </summary>
 <remarks>
 This method is virtual, but usually there is no need to override it. It
 calls the virtual LookupInSingleBinder, which should be overridden instead,
 for each binder in turn, and merges the results.
 Overriding this method is needed only in limited scenarios, for example for
 a binder that binds query [Into] clause and has implicit qualifier.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.LookupInSingleBinder(Microsoft.CodeAnalysis.VisualBasic.LookupResult,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Lookup in just a single binder, without delegating to containing binder. The original
 binder passed in is used for accessibility checking and so forth.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CollectProbableExtensionMethodsInSingleBinder(System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Collect extension methods with the given name that are in scope in this binder.
 The passed in ArrayBuilder must be empty. Extension methods from the same containing type
 must be grouped together.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.AddExtensionMethodLookupSymbolsInfoInSingleBinder(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Lookup all names of extension methods that are available from a single binder, without delegating
 to containing binder. The original binder passed in is used for accessibility checking
 and so forth.
 Names that are available are inserted into "nameSet". This is a hashSet that accumulates
 names, and should be created with the VB identifierComparer.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.LookupLabelByNameToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Lookups labels by label names, returns a label or Nothing
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.AddLookupSymbolsInfoInSingleBinder(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Lookup all names that are available from a single binder, without delegating
 to containing binder. The original binder passed in is used for accessibility checking
 and so forth.
 Names that are available are inserted into "nameSet". This is a hashSet that accumulates
 names, and should be created with the VB identifierComparer.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CheckAccessibility(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Determine if "sym" is accessible from the location represented by this binder. For protected
 access, use the qualifier type "accessThroughType" if not Nothing (if Nothing just check protected
 access with no qualifier).
 </summary>
 <remarks>
 Overriding methods should consider <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Binder.IgnoresAccessibility"/>.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.IsAccessible(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Determine if "sym" is accessible from the location represented by this binder. For protected
 access, use the qualifier type "accessThroughType" if not Nothing (if Nothing just check protected
 access with no qualifier).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetBinder(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Some nodes have special binder's for their contents
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetBinder(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Some nodes have special binder's for their contents
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.ContainingMember">
 <summary>
 The member containing the binding context
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.IsInQuery">
 <summary>
 Tells whether binding is happening in a query context.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.IsInLambda">
 <summary>
 Tells whether binding is happening in a lambda context.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.IsUnboundTypeAllowed(Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)">
 <summary>
 Returns true if the node is in a position where an unbound type
 such as (C(of)) is allowed.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.ContainingType">
 <summary>
 The type containing the binding context
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.BindingTopLevelScriptCode">
 <summary>
 Returns true if the binder is binding top-level script code.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.ContainingNamespaceOrType">
 <summary>
 The namespace or type containing the binding context
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetSpecialType(Microsoft.CodeAnalysis.SpecialType,Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Get the built-in MSCORLIB type identified. If it's not available (an error type), then report the
 error with the given syntax and diagnostic bag. If the node and diagBag are Nothing, then don't report the error (not recommended).
 </summary>
 <param name="typeId">Type to get</param>
 <param name="node">Where to report the error, if any.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 This is a layer on top of the Compilation version that generates a diagnostic if the well-known
 type isn't found.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetInternalXmlHelperValueExtensionProperty">
 <summary>
 WARN: Retrieves the symbol but does not check its viability (accessibility, etc).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 This is a layer on top of the assembly version that generates a diagnostic if the well-known
 member isn't found.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetWellKnownTypeMember(Microsoft.CodeAnalysis.WellKnownMember,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 This is a layer on top of the Compilation version that generates a diagnostic if the well-known
 member isn't found.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.SourceModule">
 <summary>
 Get the source module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.Compilation">
 <summary>
 Get the compilation.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetErrorSymbol(System.String,Microsoft.CodeAnalysis.DiagnosticInfo,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.VisualBasic.LookupResultKind)">
 <summary>
 Get an error symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetLocation(Microsoft.CodeAnalysis.Text.TextSpan)">
 <summary>
 Get the Location associated with a given TextSpan.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetSyntaxReference(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Get a SyntaxReference associated with a given syntax node.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.SyntaxTree">
 <summary>
 Returns the syntax tree.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BasesBeingResolved">
 <summary>
 Called in member lookup right before going into the base class of a type. Results a set of named types whose
 bases classes are currently in the process of being resolved, so we shouldn't look into their bases
 again to prevent/detect circular references.
 </summary>
 <returns>Nothing if no bases being resolved, otherwise the set of bases being resolved.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.IgnoreBaseClassesInLookup">
 <summary>
 Called during member lookup before going into the base class of a type. If returns
 true, the base class is ignored. Primarily used for binding Imports.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.OptionStrict">
 <summary>
 Current Option Strict mode.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.OptionInfer">
 <summary>
 True if Option Infer On is in effect. False if Option Infer Off is in effect.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.OptionExplicit">
 <summary>
 True if Option Explicit On is in effect. False if Option Explicit Off is in effect.
 Note that even if Option Explicit Off is in effect, there are places (field initializers)
 where implicit variable declaration is not permitted. See the ImplicitVariablesDeclarationAllowedHere
 property also.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.OptionCompareText">
 <summary>
 True if Option Compare Text is in effect. False if Option Compare Binary is in effect.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.CheckOverflow">
 <summary>
 True if integer overflow checking is off.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.AllImplicitVariableDeclarationsAreHandled">
 <summary>
 True if implicit variable declaration is available within this binder, and the binder
 has already finished binding all possible implicit declarations inside (and is not accepting)
 any more.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.ImplicitVariableDeclarationAllowed">
 <summary>
 True if implicit variable declaration is allow by the language here. Differs from OptionExplicit
 in that it is only try if this binder is associated with a region that allows implicit variable
 declaration (field initializers and attributes don't, for example).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DeclareImplicitLocalVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Declare an implicit local variable. The type of the local is determined
 by the type character (if any) on the variable.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.ImplicitlyDeclaredVariables">
 <summary>
 Get all implicitly declared variables that were declared in this method body.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DisallowFurtherImplicitVariableDeclaration(Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Disallow additional local variable declaration and report delayed shadowing diagnostics.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetExitLabel(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Get the label that a Exit XXX statement should branch to, or Nothing if we are
 not inside a context that would be exited by that kind of statement. The passed in kind
 is the SyntaxKind for the exit statement that would target the label (e.g. SyntaxKind.ExitDoStatement).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetContinueLabel(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Get the label that a Continue XXX statement should branch to, or Nothing if we are
 not inside a context that would be exited by that kind of statement. The passed in kind
 is the SyntaxKind for the exit statement that would target the label (e.g. SyntaxKind.ContinueDoStatement).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetReturnLabel">
 <summary>
 Get the label that a Return statement should branch to, or Nothing if we are
 not inside a context that would be exited by that kind of statement. This method
 is equivalent to calling <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetExitLabel(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)"/> with the appropriate exit
 <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/>.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetLocalForFunctionValue">
 <summary>
 Get the special local symbol with the same name as the enclosing function.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.VisualBasic.ERRID)">
 <summary>
 Create a diagnostic at a particular syntax node and place it in a diagnostic bag.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnosticsIfObsolete(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Issue an error or warning for a symbol if it is Obsolete. If there is not enough
 information to report diagnostics, then store the symbols so that diagnostics
 can be reported at a later stage.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.BindingLocation">
 <summary>
 Returns the type of construct being bound (BaseTypes, MethodSignature,
 etc.) to allow the Binder to provide different behavior in certain cases.
 Currently, this property is only used by ShouldCheckConstraints.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.IsEarlyAttributeBinder">
 <summary>
 Returns true if the binder is performing early decoding of a
 (well-known) attribute.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.ShouldCheckConstraints">
 <summary>
 Return True if type constraints should be checked when binding.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.HasImportedXmlNamespaces">
 <summary>
 Returns True if the binder, or any containing binder, has xmlns Imports.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetInScopeXmlNamespaces(Microsoft.CodeAnalysis.ArrayBuilder{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
 <summary>
 Add { prefix, namespace } pairs from the explicitly declared namespaces in the
 XmlElement hierarchy. The order of the pairs is the order the xmlns attributes
 are declared on each element, and from innermost to outermost element.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReportUseSiteErrorForSynthesizedAttribute(Microsoft.CodeAnalysis.WellKnownMember,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 This method reports use site errors if a required attribute constructor is missing.
 Some attributes are considered to be optional (e.g. the CompilerGeneratedAttribute). In this case the use site
 errors will be ignored.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReportUseSiteErrorForSynthesizedAttribute(Microsoft.CodeAnalysis.WellKnownMember,Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 This method reports use site errors if a required attribute constructor is missing.
 Some attributes are considered to be optional (e.g. the CompilerGeneratedAttribute). In this case the use site
 errors will be ignored.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetWithStatementPlaceholderSubstitute(Microsoft.CodeAnalysis.VisualBasic.BoundValuePlaceholderBase)">
 <summary>
 Returns a placeholder substitute for a With statement placeholder specified or Nothing if not found

 Note: 'placeholder' is needed to make sure the binder can check that the placeholder is
 associated with the statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.IsSemanticModelBinder">
 <summary>
 Indicates that this binder is being used to answer SemanticModel questions (i.e. not
 for batch compilation).
 </summary>
 <remarks>
 Imports touched by a binder with this flag set are not consider "used".
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.AnonymousTypeCreationBinder">
 <summary>
 Binder to be used for binding New With { ... } expressions. 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Binder.AnonymousTypeCreationBinder._freeze">
 <summary>
 If set, the state of the binder shouldn't be modified by subsequent binding operations,
 which could be performed by SemanticModel in context of this binder.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.AnonymousTypeFieldInitializerBinder">
 <summary>
 Having this binder, which is created for each field initializer within AnonymousObjectCreationExpressionSyntax
 gives us the following advantages:
   - We no longer rely on transient state of AnonymousTypeField objects to detect out of order field references
     within initializers. This way we can be sure that result of binding performed by SemanticModel is consistent
     with result of initial binding of the entire node.
   - AnonymousTypeCreationBinder overrides CreateAnonymousObjectCreationExpression in such a way that it mutates
     its state. That overridden method shouldn't be called while we are binding each initializer (by queries, for example), 
     it should be called only by AnonymousTypeCreationBinder itself after all initializers are bound and we are producing 
     the resulting node. So having an extra binder in between takes care of that.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetAttributes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Binder},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol},Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData[],Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Gets but does not fully validate a symbol's attributes. Returns binding errors but not attribute usage and attribute specific errors.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.AttributeExpressionVisitor">
 <summary>
 Walk a custom attribute argument bound node and return a TypedConstant.  Verify that the expression is a constant expression.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ApplyImplicitConversion(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 This function must return a BoundConversion node in case of non-identity conversion.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ApplyConversion(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean,System.Boolean)">
 <summary>
 This function must return a BoundConversion node in case of explicit or non-identity conversion.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CreateConversionAndReportDiagnostic(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.VisualBasic.ConversionKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag,System.String,System.Boolean)">
 <summary>
 This function must return a BoundConversion node in case of non-identity conversion.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MakeVarianceConversionSuggestion(Microsoft.CodeAnalysis.VisualBasic.ConversionKind,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 Returns True if error or warning was reported.
 
 This function is invoked on the occasion of a Narrowing or NoConversion.
 It looks at the conversion. If the conversion could have been helped by variance in
 some way, it reports an error/warning message to that effect and returns true. This
 message is a substitute for whatever other conversion-failed message might have been displayed.

 Note: these variance-related messages will NOT show auto-correct suggestion of using CType. That's
 because, in these cases, it's more likely than not that CType will fail, so it would be a bad suggestion
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReclassifyExpression(Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.ConversionKind,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Handle expression reclassification, if any applicable.
 
 If function returns True, the "argument" parameter has been replaced
 with result of reclassification (possibly an error node) and appropriate
 diagnostic, if any, has been reported.
 
 If function returns false, the "argument" parameter must be unchanged and no 
 diagnostic should be reported. 
 
 conversionSemantics can be one of these: 
       SyntaxKind.CTypeKeyword, SyntaxKind.DirectCastKeyword, SyntaxKind.TryCastKeyword
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.DelegateResolutionResult">
 <summary>
 Structure is used to store all information which is needed to construct and classify a Delegate creation 
 expression later on.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindAddressOfExpression(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Binds the AddressOf expression.
 </summary>
 <param name="node">The AddressOf expression node.</param>
 <param name="diagnostics">The diagnostics.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindDelegateCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Binds the delegate creation expression.
 This comes in form of e.g.
 Dim del as new DelegateType(AddressOf methodName)
 </summary>
 <param name="delegateType">Type of the delegate.</param>
 <param name="argumentListOpt">The argument list.</param>
 <param name="node">Syntax node to attach diagnostics to in case the argument list is nothing.</param>
 <param name="diagnostics">The diagnostics.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.InterpretDelegateBinding(Microsoft.CodeAnalysis.VisualBasic.BoundAddressOfOperator,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean)">
 <summary>
 Resolves the target method for the delegate and classifies the conversion
 </summary>
 <param name="addressOfExpression">The bound AddressOf expression itself.</param>
 <param name="targetType">The delegate type to assign the result of the AddressOf operator to.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ResolveMethodForDelegateInvokeFullAndRelaxed(Microsoft.CodeAnalysis.VisualBasic.BoundAddressOfOperator,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Resolves the method for delegate invoke with all or relaxed arguments / return types. It also determines 
 the method conversion kind.
 </summary>
 <param name="addressOfExpression">The AddressOf expression.</param>
 <param name="toMethod">The delegate invoke method.</param>
 <param name="ignoreMethodReturnType">Ignore method's return type for the purpose of calculating 'methodConversions'.</param>
 <param name="diagnostics">The diagnostics.</param>
 <returns>The resolved method if any.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ResolveMethodForDelegateInvokeFullOrRelaxed(Microsoft.CodeAnalysis.VisualBasic.BoundAddressOfOperator,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean,System.Boolean@)">
 <summary>
 Resolves the method for delegate invoke with all or relaxed arguments / return types. It also determines 
 the method conversion kind.
 </summary>
 <param name="addressOfExpression">The AddressOf expression.</param>
 <param name="toMethod">The delegate invoke method.</param>
 <param name="ignoreMethodReturnType">Ignore method's return type for the purpose of calculating 'methodConversions'.</param>
 <param name="diagnostics">The diagnostics.</param>
 <param name="useZeroArgumentRelaxation">if set to <c>true</c> use zero argument relaxation.</param>
 <returns>The resolved method if any.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetDelegateMethodConversionBasedOnArguments(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Determines the method conversion for delegates based on the arguments.
 </summary>
 <param name="bestResult">The resolution result.</param>
 <param name="delegateInvoke">The delegate invoke method.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ClassifyAddressOfConversion(Microsoft.CodeAnalysis.VisualBasic.BoundAddressOfOperator,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Classifies the address of conversion. 
 </summary>
 <param name="source">The bound AddressOf expression.</param>
 <param name="destination">The target type to convert this AddressOf expression to.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CheckDelegateParameterModifier(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceParameterFlags,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Checks if a parameter is a ParamArray and reports this as an error.
 </summary>
 <param name="container">The containing type.</param>
 <param name="token">The current parameter token.</param>
 <param name="flag">The flags of this parameter.</param>
 <param name="diagnostics">The diagnostics.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReclassifyAddressOf(Microsoft.CodeAnalysis.VisualBasic.BoundAddressOfOperator,Microsoft.CodeAnalysis.VisualBasic.Binder.DelegateResolutionResult@,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean,System.Boolean)">
 <summary>
 Reclassifies the bound address of operator into a delegate creation expression (if there is no delegate 
 relaxation required) or into a bound lambda expression (which gets a delegate creation expression later on)
 </summary>
 <param name="addressOfExpression">The AddressOf expression.</param>
 <param name="delegateResolutionResult">The delegate resolution result.</param>
 <param name="targetType">Type of the target.</param>
 <param name="diagnostics">The diagnostics.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BuildDelegateRelaxationLambda(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup,Microsoft.CodeAnalysis.VisualBasic.ConversionKind,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Build a lambda that has a shape of the [delegateInvoke] and calls 
 the only method from the [methodGroup] passing all parameters of the lambda
 as arguments for the call.
 Note, that usually the receiver of the [methodGroup] should be captured before entering the 
 relaxation lambda in order to prevent its reevaluation every time the lambda is invoked and 
 prevent its mutation. 
 
             !!! Therefore, it is not common to call this overload directly. !!!
 
 </summary>
 <param name="syntaxNode">Location to use for various synthetic nodes and symbols.</param>
 <param name="delegateInvoke">The Invoke method to "implement".</param>
 <param name="methodGroup">The method group with the only method in it.</param>
 <param name="delegateRelaxation">Delegate relaxation to store within the new BoundLambda node.</param>
 <param name="diagnostics"></param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnosticAndProduceBadExpression(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.ERRID,System.Object[])">
 <summary>
 Report a diagnostic, and also produce an error expression with error type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnosticAndProduceBadExpression(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticInfo,Microsoft.CodeAnalysis.VisualBasic.BoundNode[])">
 <summary>
 Report a diagnostic, and also produce an error expression with error type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnosticAndProduceErrorTypeSymbol(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.ERRID,System.Object[])">
 <summary>
 Report a diagnostic, and also produce an error expression with error type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnosticAndProduceErrorTypeSymbol(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticInfo)">
 <summary>
 Report a diagnostic, and also produce an error expression with error type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Boolean,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 The dispatcher method that handles syntax nodes for all stand-alone expressions.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BadExpression(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Create a BoundBadExpression node for the given syntax node. No symbols or bound nodes are associated with it.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BadExpression(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Create a BoundBadExpression node for the given child-expression, which is preserved as a sub-expression. 
 No ResultKind is associated
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BadExpression(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundNode,Microsoft.CodeAnalysis.VisualBasic.LookupResultKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Create a BoundBadExpression node for the given child-expression, which is preserved as a sub-expression. 
 A ResultKind explains why the node is bad.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BadExpression(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundNode},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Create a BoundBadExpression node for the given child expression, which is preserved as a sub-expression. Symbols
 associated with the child node are not given a result kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindQualifiedName(Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 This function is only needed for SemanticModel to perform binding for erroneous cases.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 BindValue evaluates the node and returns a BoundExpression.  BindValue snaps expressions to values.  For now that means that method groups
 become invocations.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.AdjustReceiverTypeOrValue(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.QualificationKind@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@)">
 <summary>
 Adjusts receiver of a call or a member access.
  * will turn Unknown property access into Get property access
  * will turn TypeOrValueExpression into a value expression
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.AdjustReceiverAmbiguousTypeOrValue(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Adjusts receiver of a call or a member access if the receiver is an
 ambiguous BoundTypeOrValueExpression. This can only happen if the
 receiver is the LHS of a member access expression in which the
 RHS cannot be resolved (i.e. the RHS is an error or a late-bound
 invocation/access).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.AdjustReceiverValue(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Adjusts receiver of a call or a member access if it is a value
  * will turn Unknown property access into Get property access
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindRValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 BindRValue evaluates the node and returns a BoundExpression.  
 It ensures that the expression is a value that can be used on the right hand side of an assignment.  
 If not, it reports an error.
 
 Note that this function will reclassify all expressions to have their "default" type, i.e.
 Anonymous Delegate for a lambda, default array type for an array literal, will report an error 
 for an AddressOf, etc. So, if you are in a context where there is a known target type for the 
 expression, do not use this function. Instead, use BindValue followed by 
 ApplyImplicitConversion/ApplyConversion.  
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.IsLValueFieldAccess(Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Determine whether field access should be treated as LValue. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.KindOfContainingMethodAtRunTime">
 <summary>
 Return MethodKind corresponding to the method the code being interpreted is going to end up in.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GenerateDiagnosticsForDominantTypeInferenceInIfExpression(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary> Process the result of dominant type inference, generate diagnostics </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Binder.IsInsideChainedConstructorCallArguments">
 <summary>
 True if inside in binding arguments of constructor 
 call with {'Me'/'MyClass'/'MyBase'}.New(...) from another constructor
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CanAccessMyBase(System.Boolean,Microsoft.CodeAnalysis.VisualBasic.ERRID@)">
 <summary>
 Can we access MyBase in this location. If False is returned, 
 also returns the error id associated with that.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CanAccessMe(System.Boolean,Microsoft.CodeAnalysis.VisualBasic.ERRID@)">
 <summary>
 Can we access Me in this location. If False is returned, 
 also returns the error id associated with that.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CanAccessMyClass(System.Boolean,Microsoft.CodeAnalysis.VisualBasic.ERRID@)">
 <summary>
 Can we access MyClass in this location. If False is returned, 
 also returns the error id associated with that.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindSimpleName(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Second part of BindSimpleName.
 It is a separate function so that it could be called directly 
 when we have already looked up for the name.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindMemberAccess(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary> 
 Method binds member access in case when we got hold 
 of a bound node representing the left expression 
 </summary>
 <remarks> 
 The method is protected, so that it can be called from other 
 binders overriding TryBindMemberAccessWithLeftOmitted
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TryBindOmittedLeftForMemberAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Boolean@)">
 <summary> 
 Returns a bound node for left part of member access node with omitted left syntax. 
 In particular it handles member access inside With statement.
 
 By default the method delegates the work to it's containing binder or returns Nothing.
 </summary>
 <param name="accessingBinder">
 Specifies the binder which requests an access to the bound node for omitted left.
 </param>
 <param name="wholeMemberAccessExpressionBound">
 NOTE: in some cases, like for binding inside anonymous object creation expression, this 
 method returns bound node for the whole expression rather than only for omitted left part. 
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetLocalSymbolType(Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given a localSymbol and a syntaxNode where the symbol is used, safely return the symbol's type.
 </summary>
 <param name="localSymbol">The local symbol</param>
 <param name="node">The syntax node that references the symbol</param>
 <param name="diagnostics">diagnostic bag if errors are to be reported</param>
 <returns>Returns the symbol's type or an ErrorTypeSymbol if the local is referenced before its definition or if the symbol is still being bound.</returns>
 <remarks>This method safely returns a local symbol's type by checking for circular references or references before declaration.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CheckSharedSymbolAccess(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.QualificationKind,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Report diagnostics relating to access shared/nonshared symbols. Returns true if an ERROR (but not a warning)
 was reported. Also replaces receiver as a type with DefaultPropertyInstance when appropriate.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TryBindOmittedLeftForDictionaryAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary> 
 Returns a bound node for left part of dictionary access node with omitted left syntax. 
 In particular it handles dictionary access inside With statement.
 
 By default the method delegates the work to it's containing binder or returns Nothing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindArrayCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
  Handle ArrayCreationExpressionSyntax
   new integer(n)(,) {...}
   new integer() {...}
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindArrayInitializerList(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder.DimensionSize[],Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Binds CollectionInitializeSyntax. i.e. { expr, ... } from an ArrayCreationExpressionSyntax
 </summary>
 <param name="node">The collection initializer syntax</param>
 <param name="type">The type of array.</param>
 <param name="knownSizes">This is in/out.  It comes in with sizes from explicit bounds but will be updated based on the number of initializers for dimensions without bounds</param>
 <param name="diagnostics">Where to put errors</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindArrayInitializerList(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder.DimensionSize[],System.Boolean@,System.Int32@,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Binds CollectionInitializeSyntax. i.e. { expr, ... } from an ArrayCreationExpressionSyntax
 </summary>
 <param name="node">The collection initializer syntax</param>
 <param name="knownSizes">This is in/out.  It comes in with sizes from explicit bounds but will be updated based on the number of initializers for dimensions without bounds</param>
 <param name="hasDominantType">When the inferred type is Object() indicates that the dominant type algorithm computed this type.</param>
 <param name="numberOfCandidates" >The number of candidates found during inference</param>
 <param name="inferredElementType" >The inferred element type</param>
 <param name="diagnostics">Where to put errors</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindArrayBounds(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder.DimensionSize[],System.Boolean)">
 <summary>
 Bind the array bounds and return the sizes for each dimension.
 </summary>
 <param name="arrayBoundsOpt">The bounds</param>
 <param name="diagnostics">Where to put the errors</param>
 <param name="knownSizes">The bounds if they are constants, if argument is not specified this info is not returned </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.ImportsBinder">
 <summary>
 The Imports binder handles binding of Imports statements in files, and also the project-level imports.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ImportsBinder.ShouldReportUseSiteErrorForAlias(Microsoft.CodeAnalysis.DiagnosticInfo)">
 <summary>
 Checks use site error and returns True in case it should be reported for the alias. 
 In current implementation checks for errors #36924 and #36925
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.ProcessedFieldOrPropertyInitializers">
 <summary>
 Used to store the bound field and property initializers and the associated list of
 bound assignment statements because they are reused for multiple constructors
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Binder.ProcessedFieldOrPropertyInitializers.HasAnyErrors">
 <summary> 
 Indicate the fact that binding of initializers produced a tree with errors. 
 This property does not indicate whether or not a diagnostic was produced during the 
 binding of the initializers. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindFieldAndPropertyInitializers(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol,System.Collections.Immutable.ImmutableArray{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer}},Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedInteractiveInitializerMethod,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Binds all field initializers of a <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol"/>.
 </summary>
 <param name="symbol">The named type symbol where the field initializers are declared.</param>
 <param name="scriptInitializerOpt">Script initializer or Nothing if not binding top-level statements.</param>
 <param name="initializers">The initializers itself. For each partial type declaration there is an array of 
 field initializers</param>
 <param name="diagnostics">The diagnostics.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindArrayFieldImplicitInitializer(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundInitializer},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind an initializer for an implicitly allocated array field (for example: Private F(2) As Object).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindFieldInitializer(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol},Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundInitializer},Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 Binds the field initializer. A bound field initializer contains the bound field access and bound init value.
 </summary>
 <param name="fieldSymbols">The field symbol.</param>
 <param name="equalsValueOrAsNewSyntax">The syntax node for the optional initialization.</param>
 <param name="boundInitializers">The array of bound initializers to add the newly bound ones to.</param>
 <param name="diagnostics">The diagnostics.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindConstFieldInitializer(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundInitializer})">
 <summary>
 Checks for errors in the constant initialization of a field, and only returns a BoundFieldOrPropertyInitializer for
 decimals and dates because they aren't compile time constant in CLR. Other data type end up directly in metadata and 
 do not cause a BoundFieldOrPropertyInitializer node.
 </summary>
 <param name="fieldSymbol">The field symbol.</param>
 <param name="equalsValueOrAsNewSyntax">The syntax node for the optional initialization.</param>
 <param name="boundInitializers">The array of bound initializers to add the newly bound ones to.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindFieldAndEnumConstantInitializer(Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.ConstantValue@)">
 <summary>
 Binds constant initialization value of the field.
 </summary>
 <param name="fieldSymbol">The symbol.</param>
 <param name="equalsValueOrAsNewSyntax">The initialization syntax.</param>
 <param name="diagnostics">The diagnostics.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindLocalConstantInitializer(Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.ConstantValue@)">
 <summary>
 Binds a constant local's value. 
 </summary>
 <param name="symbol">The local symbol.</param>
 <param name="type">The local symbol's type. It is passed in because this method is called while the type is being resolved and before it is set.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindParameterDefaultValue(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.ConstantValue@)">
 <summary>
 Binds a parameter's default value syntax
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.IsConstructorCallAllowed(Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup)">
 <summary>
 Returns if all the rules for a "Me.New" or "MyBase.New" constructor call are satisfied:
   a) In instance constructor body
   b) First statement of that constructor
   c) "Me", "MyClass", or "MyBase" is the receiver.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindDirectConstructorCall(Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind a Me.New(...), MyBase.New (...), MyClass.New(...) constructor call. 
 (NOT a normal constructor call like New Type(...)).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindIndexedInvocationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Boolean,System.Boolean@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind an invocation expression representing an array access,
 delegate invocation, or default member.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindDefaultPropertyGroup(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Returns a BoundPropertyGroup if the expression represents a valid
 default property access. If there is a default property but the property
 access is invalid, a BoundBadExpression is returned. If there is no
 default property for the expression type, Nothing is returned.
 
 Note, that default Query Indexer may be a method, not a property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ShouldBindWithoutArguments(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Tests whether or not the method or property group should be bound without arguments. 
 In case of method group it may also update the group by filtering out all subs
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.OptimizeLibraryCall(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Boolean@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Optimizes some runtime library calls through replacing them with a literal if possible.
 VB Spec 11.2 defines the following runtime functions as being constant:
  - Microsoft.VisualBasic.Strings.ChrW
  - Microsoft.VisualBasic.Strings.Chr, if the constant value is between 0 and 128
  - Microsoft.VisualBasic.Strings.AscW, if the constant string is not empty
  - Microsoft.VisualBasic.Strings.Asc, if the constant string is not empty
 </summary>
 <param name="method">The method.</param>
 <param name="arguments">The arguments of the method call.</param>
 <param name="syntax">The syntax node for report errors.</param>
 <param name="diagnostics">The diagnostics.</param>
 <param name="hasErrors">Set to true if there are conversion errors (e.g. Asc("")). Otherwise it's not written to.</param>
 <returns>The constant value that replaces this node, or nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetSetOfTheBestCandidates(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.OverloadResolutionResult@,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol}@)">
 <summary>
Figure out the set of best candidates in the following preference order:
  1) Applicable
  2) TypeInferenceFailed
  3) ArgumentMismatch, GenericConstraintsViolated
  4) ArgumentCountMismatch
  5) BadGenericArity
  6) Ambiguous
  7) HasUseSiteError
  8) HasUnsupportedMetadata
 
 Also return the set of unique symbols behind the set.
 
 Returns type symbol for the common type, if any.
 Otherwise returns ErrorTypeSymbol.UnknownResultType.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReportOverloadResolutionFailureForASingleCandidate(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.VisualBasic.LookupResultKind,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.Boolean,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Should be kept in sync with OverloadResolution.MatchArguments. Anything that 
 OverloadResolution.MatchArguments flags as an error should be detected by 
 this function as well. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReportByRefConversionErrors(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.Candidate,Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Should be in sync with OverloadResolution.MatchArgumentToByRefParameter
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReportByValConversionErrors(Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Should be in sync with OverloadResolution.MatchArgumentToByValParameter.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.PassArguments(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Should be kept in sync with OverloadResolution.MatchArguments, which populates 
 data this function operates on.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.IsCallStatementContext(Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax)">
 <summary>
 Return true if the node is an immediate child of a call statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.Report_ERRID_ReadOnlyInClosure(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 If we are inside a lambda in a constructor and are passing ByRef a non-LValue field, which 
 would be an LValue field, if it were referred to in the constructor outside of a lambda, 
 we need to report an error because the operation will result in a simulated pass by
 ref (through a temp, without a copy back), which might be not the intent.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.LambdaReturnStatementsVisitor.CollectReturnExpressions(Microsoft.CodeAnalysis.VisualBasic.BoundBlock,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},System.Boolean)">
 <summary>
 Collects expressions that are effective return values of the lambda body.
 In iterators those would be arguments of Yield statements.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CanAddLookupSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Used by Add*LookupSymbolsInfo* to determine whether the symbol is of interest.
 Distinguish from <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CheckViability(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)"/>, which performs an analogous task for LookupSymbols*.
 </summary>
 <remarks>
 Does not consider <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.CanBeReferencedByName"/> - that is left to the caller.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup">
 <summary>
 This class handles binding of members of namespaces and types.
 The key member is Lookup, which handles looking up a name
 in a namespace or type, by name and arity, and produces a 
 lookup result. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.Lookup(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Lookup a member name in a namespace or type, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results. The supplied binder is used for accessibility
 checked and base class suppression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.Lookup(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Lookup a member name in a namespace, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results. The supplied binder is used for accessibility
 checked and base class suppression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupImmediate(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Lookup an immediate (without descending into modules) member name in a namespace, 
 returning a LookupResult that summarizes the results of the lookup. 
 See LookupResult structure for a detailed discussion of the meaning of the results. 
 The supplied binder is used for accessibility checks and base class suppression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInModules(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Lookup a member name in modules of a namespace, 
 returning a LookupResult that summarizes the results of the lookup. 
 See LookupResult structure for a detailed discussion of the meaning of the results. 
 The supplied binder is used for accessibility checks and base class suppression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.Lookup(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Lookup a member name in a type, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results. The supplied binder is used for accessibility
 checked and base class suppression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInClass(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Lookup a member name in a module, class, struct, enum, or delegate, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results. The supplied binder is used for accessibility
 checks and base class suppression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.FindWinRTMembers(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,System.Boolean,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions)">
 <summary>
 This function generalizes the idea of producing a set of non-conflicting
 WinRT members of a given type based on the results of some arbitrary lookup
 closure (which produces a LookupResult signifying success as IsGood).

 A non-conflicting WinRT member lookup looks for all members of projected
 WinRT interfaces which are implemented by a given type, discarding any 
 which have equal signatures.
 
 If <paramref name="lookupMembersNotDefaultProperties" /> is true then
 this function lookups up members with the given <paramref name="name" />,
 <paramref name="arity" />, and <paramref name="options" />. Otherwise, it looks for default properties.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInSubmissions(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Lookup a member name in a submission chain.
 </summary>
 <remarks>
 We start with the current submission class and walk the submission chain back to the first submission.
 The search has two phases
 1) We are looking for any symbol matching the given name, arity, and options. If we don't find any the search is over.
    If we find an overloadable symbol(s) (a method or a property) we start looking for overloads of this kind 
    (lookingForOverloadsOfKind) of symbol in phase 2.
 2) If a visited submission contains a matching member of a kind different from lookingForOverloadsOfKind we stop 
    looking further. Otherwise, if we find viable overload(s) we add them into the result. Overloads modifier is ignored.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.MergeInternalXmlHelperValueIfNecessary(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Include the InternalXmlHelper.Value extension property in the LookupResult
 if the container implements IEnumerable(Of XElement), the name is "Value",
 and the arity is 0.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.IsDerivedInterface(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Checks if two interfaces have a base-derived relationship
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.MergeInterfaceLookupResults(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.LookupResult,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol},System.Nullable{System.Boolean},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Merges two lookup results while eliminating symbols that are shadowed.
 Note that the final result may contain unrelated and possibly conflicting symbols as
 this helper is not intended to catch ambiguities.
 </summary>
 <param name="leaveEventsOnly">
 If is not Nothing and False filters out all Event symbols, and if is not Nothing 
 and True filters out all non-Event symbols, nos not have any effect otherwise.
 Is used for special handling of Events inside COM interfaces.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.CompactAndAppend(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 first.Where(t IsNot Nothing).Concat(second.Where(t IsNot Nothing))
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddBaseInterfacesToTheSearch(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo,System.Collections.Generic.Queue{Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AnyShadows(Microsoft.CodeAnalysis.VisualBasic.LookupResult)">
 <summary>
 if any symbol in the list Shadows. This implies that name is not visible through the base.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupWithoutInheritance(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Lookup a member name in a type without considering inheritance, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindObjectCollectionOrMemberInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundWithLValueExpressionPlaceholder,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Binds the object collection or member initializer from a object creation.
 E.g. "new CollType() From {...}" or "new AType() With {...}"
 </summary>
 <param name="initializedObjectType">The type of the created object expression.</param>
 <param name="syntaxNode">The object creation expression syntax.</param>
 <param name="diagnostics">The diagnostics.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindObjectInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundWithLValueExpressionPlaceholder,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind the ObjectInitializer.
 During the binding we basically bind the member access for each initializer, as well as the value that will be assigned.
 The main information stored in the bound node is a list of assignment operators (that may contain placeholders), as
 well as the information whether expression creates a temporary or not.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindCollectionInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Binds a object collection initializer.
 During the binding of this node we are binding calls to Add methods of the created object. Once the "collection" 
 type passed the requirements (same as for each collection requirements + must have accessible Add method), all 
 diagnostics are handled by the overload resolution.
 The bound node contains a list of call expressions (that may contain placeholders).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindCollectionInitializerElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundWithLValueExpressionPlaceholder,Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Binds a call expression for a given top level object collection initializer.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ValidateAndConvertIsExpressionArgument(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Validate and apply appropriate conversion for the target argument of Is/IsNot expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ForceLiftToEmptyString(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 This helper is used to wrap nullable argument into something that would return null string if argument is null.

 Unlike conversion to a string where nullable nulls result in an exception,         
 concatenation requires that nullable nulls are treated as null strings. 
 Note that conversion is treated as explicit conversion.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindUserDefinedShortCircuitingOperator(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.OverloadResolutionResult@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 This function builds a bound tree representing an overloaded short circuiting expression
 after determining that the necessary semantic conditions are met.
 
 An expression of the form:
 
     x AndAlso y  (where the type of x is X and the type of y is Y)
 
 is an overloaded short circuit operation if X and Y are user-defined types and an
 applicable operator And exists after applying normal operator resolution rules.
 
 Given an applicable And operator declared in type T, the following must be true:
 
     - The return type and parameter types must be T.
     - T must contain a declaration of operator IsFalse.
 
 If these conditions are met, the expression "x AndAlso y" is translated into:
 
     !T.IsFalse(temp = x) ? T.And(temp, y) : temp
 
 The temporary is necessary for evaluating x only once. Similarly, "x OrElse y" is
 translated into:
 
     !T.IsTrue(temp = x) ? T.Or(temp, y) : temp
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.SubstituteDBNullWithNothingString(Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Returns Symbol for String type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetSpecialTypeForBinaryOperator(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SpecialType,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Get symbol for a special type, reuse symbols for operand types to avoid type 
 lookups and construction of new instances of symbols.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetNullableTypeForBinaryOperator(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Get symbol for a Nullable type of particular type, reuse symbols for operand types to avoid type 
 lookups and construction of new instances of symbols.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ConvertNothingLiterals(Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 §11.12.2 Object Operands
 The value Nothing is treated as the default value of the type of 
 the other operand in a binary operator expression. In a unary operator expression, 
 or if both operands are Nothing in a binary operator expression, 
 the type of the operation is Integer or the only result type of the operator, 
 if the operator does not result in Integer.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindQueryExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind a Query Expression.
 This is the entry point.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindSubsequentQueryOperators(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given a result of binding of initial set of collection range variables, the source,
 bind the rest of the operators in the enumerator.
 
 There is a special method to bind an operator of each kind, the common thing among them is that
 all of them take the result we have so far, the source, and return result of an application 
 of one or two following operators. 
 Some of the methods also take operators enumerator in order to be able to do a necessary look-ahead
 and in some cases even to advance the enumerator themselves.
 Join and From operators absorb following Select or Let, that is when the process of binding of 
 a single operator actually handles two and advances the enumerator. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindFromQueryExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind query expression that starts with From keyword, as opposed to the one that starts with Aggregate.
 
     From {collection range variables} [{other operators}]
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindAggregateQueryExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind query expression that starts with Aggregate keyword, as opposed to the one that starts with From.
 
     Aggregate {collection range variables} [{other operators}] Into {aggregation range variables}
 
 If Into clause has one item, a single value is produced. If it has multiple items, values are
 combined into an instance of an Anonymous Type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindAggregateClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given result of binding preceding query operators, the source, bind the following Aggregate operator.
 
     {Preceding query operators} Aggregate {collection range variables} [{other operators}] Into {aggregation range variables}
 
 Depending on how many items we have in the INTO clause,
 we will interpret Aggregate operator as follows:

 FROM a in AA              FROM a in AA
 AGGREGATE b in a.BB  =>   LET count = (FROM b IN a.BB).Count()
 INTO Count()

 FROM a in AA              FROM a in AA
 AGGREGATE b in a.BB  =>   LET Group = (FROM b IN a.BB)
 INTO Count(),             Select a, Count=Group.Count(), Sum=Group.Sum(b=>b)
      Sum(b)

 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindFinalImplicitSelectClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Apply implicit Select operator at the end of the query to 
 ensure that at least one query operator is called.
 
 Basically makes query like: 
     From a In AA
 into:
     From a In AA Select a
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindSelectClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given result of binding preceding query operators, the source, bind the following Select operator.
 
     {Preceding query operators} Select {expression range variables}
 
 From a In AA Select b  ==> AA.Select(Function(a) b)
 
 From a In AA Select b, c  ==> AA.Select(Function(a) New With {b, c})
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindLetClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 Given result of binding preceding query operators, the source, bind the following Let operator.
 
     {Preceding query operators} Let {expression range variables}
 
 Ex: From a In AA Let b  ==> AA.Select(Function(a) New With {a, b})
 
 Ex: From a In AA Let b, c  ==> AA.Select(Function(a) New With {a, b}).Select(Function({a, b}) New With {a, b, c})
 
 Note, that preceding Select operator can introduce unnamed range variable, which is dropped by the Let
 
 Ex: From a In AA Select a + 1 Let b ==> AA.Select(Function(a) a + 1).Select(Function(unnamed) b)  
 
 Also, depending on the amount of expression range variables declared by the Let, and the following query operators,
 translation can produce a nested, as opposed to flat, compound variable.
 
 Ex: From a In AA Let b, c, d ==> AA.Select(Function(a) New With {a, b}).
                                     Select(Function({a, b}) New With {{a, b}, c}).
                                     Select(Function({{a, b}, c}) New With {a, b, c, d})   
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MustProduceFlatCompoundVariable(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator)">
 <summary>
 In some scenarios, it is safe to leave compound variable in nested form when there is an
 operator down the road that does its own projection (Select, Group By, ...). 
 All following operators have to take an Anonymous Type in both cases and, since there is no way to
 restrict the shape of the Anonymous Type in method's declaration, the operators should be
 insensitive to the shape of the Anonymous Type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MustProduceFlatCompoundVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator)">
 <summary>
 In some scenarios, it is safe to leave compound variable in nested form when there is an
 operator down the road that does its own projection (Select, Group By, ...). 
 All following operators have to take an Anonymous Type in both cases and, since there is no way to
 restrict the shape of the Anonymous Type in method's declaration, the operators should be
 insensitive to the shape of the Anonymous Type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindFromClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given result of binding preceding query operators, if any, bind the following From operator.
 
     [{Preceding query operators}] From {collection range variables}
 
 Ex: From a In AA  ==> AA
 
 Ex: From a In AA, b in BB  ==> AA.SelectMany(Function(a) BB, Function(a, b) New With {a, b})
 
 Ex: {source with range variable 'd'} From a In AA, b in BB  ==> source.SelectMany(Function(d) AA, Function(d, a) New With {d, a}).
                                                                        SelectMany(Function({d, a}) BB, 
                                                                                   Function({d, a}, b) New With {d, a, b})
 
 Note, that preceding Select operator can introduce unnamed range variable, which is dropped by the From
 
 Ex: From a In AA Select a + 1 From b in BB ==> AA.Select(Function(a) a + 1).
                                                   SelectMany(Function(unnamed) BB,
                                                              Function(unnamed, b) b)  
 
 Also, depending on the amount of collection range variables declared by the From, and the following query operators,
 translation can produce a nested, as opposed to flat, compound variable.
 
 Ex: From a In AA From b In BB, c In CC, d In DD ==> AA.SelectMany(Function(a) BB, Function(a, b) New With {a, b}).
                                                        SelectMany(Function({a, b}) CC, Function({a, b}, c) New With {{a, b}, c}).
                                                        SelectMany(Function({{a, b}, c}) DD, 
                                                                   Function({{a, b}, c}, d) New With {a, b, c, d})   
 
 If From operator translation results in a SelectMany call and the From is immediately followed by a Select or a Let operator, 
 they are absorbed by the From translation. When this happens, operatorsEnumerator is advanced appropriately.
 
 Ex: From a In AA From b In BB Select a + b ==> AA.SelectMany(Function(a) BB, Function(a, b) a + b)
 
 Ex: From a In AA From b In BB Let c ==> AA.SelectMany(Function(a) BB, Function(a, b) new With {a, b, c})
 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindCollectionRangeVariables(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 See comments for BindFromClause method, this method actually does all the work.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindInnerJoinClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax,System.Collections.Generic.HashSet{System.String},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given result of binding preceding query operators, the outer, bind the following Join operator.
 
     [{Preceding query operators}] Join {collection range variable} 
                                        [{additional joins}] 
                                   On {condition}
 
 Ex: From a In AA Join b in BB On Key(a) Equals Key(b)  ==> AA.Join(BB, Function(a) Key(a), Function(b) Key(b), 
                                                                    Function(a, b) New With {a, b})
 
 Ex: From a In AA                       AA.Join(
     Join b in BB                               BB.Join(CC, Function(b) Key(b), Function(c) Key(c),
          Join c in CC             ==>                  Function(b, c) New With {b, c}),
          On Key(c) Equals Key(b)               Function(a) Key(a), Function({b, c}) Key(b),
     On Key(a) Equals Key(b)                    Function(a, {b, c}) New With {a, b, c})
                                                                    
 
 Also, depending on the amount of collection range variables in scope, and the following query operators,
 translation can produce a nested, as opposed to flat, compound variable.
 
 Ex: From a In AA                       AA.Join(BB, Function(a) Key(a), Function(b) Key(b),
     Join b in BB                               Function(a, b) New With {a, b}).
     On Key(a) Equals Key(b)               Join(CC, Function({a, b}) Key(a, b), Function(c) Key(c),
     Join c in CC             ==>               Function({a, b}, c) New With {{a, b}, c}).
     On Key(c) Equals Key(a, b)            Join(DD, Function({{a, b}, c}) Key(a, b, c), Function(d) Key(d),
     Join d in DD                               Function({{a, b}, c}, d) New With {a, b, c, d})
     On Key(a, b, c) Equals Key(d)
 
 If Join is immediately followed by a Select or a Let operator, they are absorbed by the translation. 
 When this happens, operatorsEnumerator is advanced appropriately.
 
 Ex: From a In AA Join b in BB On Key(a) Equals Key(b)  ==> AA.Join(BB, Function(a) Key(a), Function(b) Key(b), 
     Select a + b                                                   Function(a, b) a + b)
 
 Ex: From a In AA Join b in BB On Key(a) Equals Key(b)  ==> AA.Join(BB, Function(a) Key(a), Function(b) Key(b), 
     Let c                                                   Function(a, b) New With {a, b, c})
 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindGroupJoinClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax,System.Collections.Generic.HashSet{System.String},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given result of binding preceding query operators, the outer, bind the following Group Join operator.
 
     [{Preceding query operators}] Group Join {collection range variable} 
                                              [{additional joins}] 
                                   On {condition}
                                   Into {aggregation range variables}
 
 Ex: From a In AA Group Join b in BB          AA.GroupJoin(BB, Function(a) Key(a), Function(b) Key(b), 
                  On Key(a) Equals Key(b) ==>              Function(a, group_b) New With {a, group_b.Count()})
                  Into Count()
 
 Also, depending on the amount of collection range variables in scope, and the following query operators,
 translation can produce a nested, as opposed to flat, compound variable (see BindInnerJoinClause for an example).
 
 Note, that type of the group must be inferred from the set of available GroupJoin operators in order to be able to 
 interpret the aggregation range variables. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindGroupByClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given result of binding preceding query operators, the source, bind the following Group By operator.
 
     [{Preceding query operators}] Group [{items expression range variables}] 
                                   By {keys expression range variables}
                                   Into {aggregation range variables}
 
 Ex: From a In AA Group By Key(a)          AA.GroupBy(Function(a) Key(a), 
                  Into Count()     ==>                Function(key, group_a) New With {key, group_a.Count()})
                  
 Ex: From a In AA Group Item(a)            AA.GroupBy(Function(a) Key(a), 
                  By Key(a)        ==>                Function(a) Item(a), 
                  Into Count()                        Function(key, group_a) New With {key, group_a.Count()})
 
 Note, that type of the group must be inferred from the set of available GroupBy operators in order to be able to 
 interpret the aggregation range variables. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindGroupByItems(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol}@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Returns Nothing if items were omitted.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.InferGroupType(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda,Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol},Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Infer type of the group for a Group By operator from the set of available GroupBy methods.
 
 In short, given already bound itemsLambda and keysLambda, this method performs overload
 resolution over the set of available GroupBy operator methods using fake Into lambda:
     Function(key, group As typeToBeInferred) New With {group}
 
 If resolution succeeds, the type inferred for the best candidate is our result.  
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.InferGroupType(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda,Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda,Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Infer type of the group for a Group Join operator from the set of available GroupJoin methods.
 
 In short, given already bound inner source and the join key lambdas, this method performs overload
 resolution over the set of available GroupJoin operator methods using fake Into lambda:
     Function(outerVar, group As typeToBeInferred) New With {group}
 
 If resolution succeeds, the type inferred for the best candidate is our result.  
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindIntoSelectorLambda(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean,System.Collections.Generic.HashSet{System.String},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax},System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder.IntoClauseBinder@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol}@)">
 <summary>
 This is a helper method to create a BoundQueryLambda for an Into clause 
 of a Group By or a Group Join operator. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindWhereClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given result of binding preceding query operators, the source, bind the following Where operator.
 
     {Preceding query operators} Where {expression}
 
 Ex: From a In AA Where a > 0 ==> AA.Where(Function(a) a > b)
 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindSkipWhileClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given result of binding preceding query operators, the source, bind the following Skip While operator.
 
     {Preceding query operators} Skip While {expression}
 
 Ex: From a In AA Skip While a > 0 ==> AA.SkipWhile(Function(a) a > b)
 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindTakeWhileClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given result of binding preceding query operators, the source, bind the following Take While operator.
 
     {Preceding query operators} Take While {expression}
 
 Ex: From a In AA Skip While a > 0 ==> AA.TakeWhile(Function(a) a > b)
 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindFilterQueryOperator(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax,System.String,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 This helper method does all the work to bind Where, Take While and Skip While query operators.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindDistinctClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given result of binding preceding query operators, the source, bind the following Distinct operator.
 
     {Preceding query operators} Distinct
 
 Ex: From a In AA Distinct ==> AA.Distinct()
 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindSkipClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given result of binding preceding query operators, the source, bind the following Skip operator.
 
     {Preceding query operators} Skip {expression}
 
 Ex: From a In AA Skip 10 ==> AA.Skip(10)
 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindTakeClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given result of binding preceding query operators, the source, bind the following Take operator.
 
     {Preceding query operators} Take {expression}
 
 Ex: From a In AA Take 10 ==> AA.Take(10)
 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindPartitionClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax,System.String,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 This helper method does all the work to bind Take and Skip query operators.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindOrderByClause(Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given result of binding preceding query operators, the source, bind the following Order By operator.
 
     {Preceding query operators} Order By {orderings}
 
 Ex: From a In AA Order By a ==> AA.OrderBy(Function(a) a)
 
 Ex: From a In AA Order By a.Key1, a.Key2 Descending ==> AA.OrderBy(Function(a) a.Key1).ThenByDescending(Function(a) a.Key2)
 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder">
 <summary>
 This is a top level binder used to bind bodies of query lambdas.
 It also contains a bunch of helper methods to bind bodies of a particular kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder.BindSelectClauseSelector(Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol}@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind body of a lambda representing Select operator selector in context of this binder.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder.BindExpressionRangeVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax},System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol}@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind Select like selector based on the set of expression range variables in context of this binder.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder.BindExpressionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{System.String},Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind ExpressionRangeVariableSyntax in context of this binder.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder.BindLetClauseVariableSelector(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol}@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind Let operator selector for a particular ExpressionRangeVariableSyntax.
 Takes care of "carrying over" of previously declared range variables as well as introduction of the new one.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder.BindAggregateClauseFirstSelector(Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol}@,Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase@,Microsoft.CodeAnalysis.VisualBasic.Binder.IntoClauseDisallowGroupReferenceBinder@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind body of a lambda representing first Select operator selector for an aggregate clause in context of this binder.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder.BindAbsorbingJoinSelector(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax}.Enumerator,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol}@,Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase@,Microsoft.CodeAnalysis.VisualBasic.Binder.IntoClauseDisallowGroupReferenceBinder@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind Join/From selector that absorbs following Select/Let in context of this binder.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder.BuildJoinSelector(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Bind Join/Let like and mixed selector in context of this binder.
 
 Join like selector: Function(a, b) New With {a, b}
 
 Let like selector: Function(a) New With {a, letExpressionRangeVariable}
 
 Mixed selector: Function(a, b) New With {a, b, letExpressionRangeVariable}
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder.BindJoinKeys(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol},Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda@,Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder@,Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda@,Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind key selectors for a Join/Group Join operator.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor">
 <summary>
 Helper visitor to determine what join sides are referenced by an expression.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder.EqualsOperandIsBadErrorVisitor">
 <summary>
 Helper visitor to report query specific errors for an operand of an Equals expression.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.IntoClauseBinder">
 <summary>
 Knows how to bind FunctionAggregationSyntax and GroupAggregationSyntax
 within particular [Into] clause. 
 
 Also implements Lookup/LookupNames methods to make sure that lookup without 
 container type, uses type of the group as the container type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.IntoClauseBinder.BindIntoSelector(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol},Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol},Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol},System.Collections.Generic.HashSet{System.String},Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax},System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol}@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given aggregationVariables, bind Into selector in context of this binder.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.IntoClauseBinder.BindAggregationRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax,System.Collections.Generic.HashSet{System.String},Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind AggregationRangeVariableSyntax in context of this binder.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.IntoClauseDisallowGroupReferenceBinder">
 <summary>
 Same as IntoClauseBinder, but disallows references to GroupAggregationSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindCollectionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Boolean,System.Collections.Generic.HashSet{System.String},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind CollectionRangeVariableSyntax, applying AsQueryable/AsEnumerable/Cast(Of Object) calls and 
 Select with implicit type conversion as appropriate.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ApplyImplicitCollectionConversion(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundQueryPart,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Apply "conversion" to the source based on the target AsClause Type of the CollectionRangeVariableSyntax.
 Returns implicit BoundQueryClause or the source, in case of an early failure.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ConvertToQueryableType(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol@)">
 <summary>
 Convert source expression to queryable type by inferring control variable type 
 and applying AsQueryable/AsEnumerable or Cast(Of Object) calls.   
 
 In case of success, returns possibly "converted" source and non-Nothing controlVariableType.
 In case of failure, returns passed in source and Nothing as controlVariableType.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.InferControlVariableType(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given query operator source, infer control variable type from available
 'Select' methods. 
 
 Returns inferred type or Nothing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.InferControlVariableType(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbol},System.Boolean@)">
 <summary>
 Given a set of 'Select' methods, infer control variable type. 
 
 Returns inferred type or Nothing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.InferControlVariableType(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 Given a method, infer control variable type. 
 
 Returns inferred type or Nothing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.LookupQueryOperator(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.String,Microsoft.CodeAnalysis.VisualBasic.BoundTypeArguments,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Return method group or Nothing in case nothing was found.
 Note, returned group might have ResultKind = "Inaccessible".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindQueryOperatorCall(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.String,Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 [methodGroup] can be Nothing if lookup didn't find anything.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 The dispatcher method that handles syntax nodes for all stand-alone statements.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.CheckOnErrorAndAwaitWalker">
 <summary>
 Check presence of [On Error]/[Resume] statements and report diagnostics based on presence of other
 "incompatible" statements.
 Report Async/Await diagnostics, which depends on surrounding context.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Binder.ArrayRankLimit">
 <summary> Defines max allowed rank of the array </summary>
 <remarks> Currently set to 32 because of COM+ array type limits </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodeLocalModifiersAndReportErrors(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Decodes a set of local declaration modifier flags and reports any errors with the flags.
 </summary>
 <param name="syntax">The syntax list of the modifiers.</param>
 <param name="diagBag">returns True if any errors are reported</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ComputeVariableType(Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Compute the type of a local symbol using the type character, as clause and equals value expression.
 1. Try to compute the type based on the identifier/modified identifier and as clause.  If there is a type then we're done.
 2. If OptionInfer is on then evaluate the expression and use that to infer the type.
 
 ComputeVariableType will only bind the value if the symbol does not have an explicit type.
 </summary>
 <param name="symbol">The local symbol</param>
 <param name="modifiedIdentifierOpt">The symbols modified identifier is there is one</param>
 <param name="asClauseOpt">The optional as clause</param>
 <param name="equalsValueOpt">The optional initializing expression</param>
 <param name="valueExpression">The bound initializing expression</param>
 <param name="asClauseType">The bound as clause type</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.InferForFromToVariableType(Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
  Infer the type of a for-from-to control variable.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.InferForEachVariableType(Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol@,System.Boolean@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.BoundLValuePlaceholder@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder@,System.Boolean@,System.Boolean@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
  Infer the type of a for-each control variable.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.InferVariableType(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Func{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Infer the type of a variable declared with an initializing expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.VerifyLocalSymbolNameAndSetType(Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Verifies that declaration of a local symbol does not cause name clashes.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.VerifyNameShadowingInMethodBody(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Should be called on the binder, at which the check should begin.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindBlock(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Binds a list of statements and puts in a scope.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindBlock(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Binds a list of statements and puts in a scope.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindForBlockParts(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,System.Boolean@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Binds all the common part for ForTo and ForEach loops except the loop body and the next variables.
 </summary>
 <param name="node">The node.</param>
 <param name="controlVariableSyntax">The control variable syntax.</param>
 <param name="declaredOrInferredLocalOpt">The declared or inferred local symbol.</param>
 <param name="controlVariable">The control variable.</param>
 <param name="diagnostics">The diagnostics.</param>
 <returns>true if there were errors; otherwise false</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindForLoopBodyAndNextControlVariables(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression}@,Microsoft.CodeAnalysis.VisualBasic.BoundBlock@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Binds loop body and the next variables for ForTo and ForEach loops.
 </summary>
 <remarks>
 The binding of the loop body and the next variables cannot happen before the local type inference has
 completed, which happens in the specialized binding functions for foreach and for loops. Otherwise we would
 loose the diagnostics from the type inference.
 </remarks>
 <param name="loopBody">The loop body.</param>
 <param name="nextVariables">The next variables.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindForLoopUserDefinedOperator(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Can return Nothing in case of failure.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.VerifyForControlVariableDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Verifies for control variable declaration and outputs diagnostics as needed.
 </summary>
 <param name="variableDeclarator">The variable declarator.</param>
 <param name="diagnostics">The diagnostics.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TryBindLoopControlVariable(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 This function tries to bind the given controlVariableSyntax. 
 If it was an identifier of a valid target, the bound node is written to controlVariable and true is returned.
 If something else was bound, that is not legal as a control variable (e.g. a property), a BoundBadNode is written 
 to controlVariable and false is returned.
 If nothing declared was found, false is returned and controlVariable is set to nothing. In this case it's safe to
 create a new local for the loop node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.VerifyForLoopControlReference(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 If the control variable was bound to a non bad expression, this function checks if the 
 bound expression is a variable and reports diagnostics appropriately.
 It reports the errors from 10.9.3 2.2
 </summary>
 <param name="controlVariable">The control variable.</param>
 <param name="diagnostics">The diagnostics.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.InterpretForEachStatementCollection(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol@,System.Boolean@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.BoundLValuePlaceholder@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder@,System.Boolean@,System.Boolean@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Verifies that the collection is either a string, and array or matches the design pattern criteria and reports 
 diagnostics appropriately.
 </summary>
 <param name="collection">The collection of the for each statement.</param>
 <param name="currentType">If the collection meets all criteria, currentType contains the type of the element from 
 the collection that get's returned by the current property.</param>
 <param name="isEnumerable">if set to <c>true</c>, the collection is enumerable (matches design pattern, IEnumerable 
 or IEnumerable(Of T); otherwise (string or arrays) it's set to false.</param>
 <param name="diagnostics">The diagnostics.</param>
 <returns>The collection which might have been converted to IEnumerable or IEnumerable(Of T) if needed.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MatchesForEachCollectionDesignPattern(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.BoundLValuePlaceholder@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Checks if the type of the collection matches the for each collection design pattern.
 </summary>
 <remarks>
 The rules are that the collection type must have an accessible GetEnumerator method that takes no parameters and
 returns a type that has both:
  - an accessible MoveNext method that takes no parameters and returns a Boolean
  - an accessible Current property that takes no parameters and is not WriteOnly

 NOTE: this function ONLY checks for a function named "GetEnumerator" with the appropriate properties.
 In the spec $10.9 it has these conditions: a type C is a "collection type" if one of
    (1) it satisfies MatchesForEachCollectionDesignPattern (i.e. has a method named GetEnumerator() which
        returns a type with MoveNext/Current); or
    (2) it implements System.Collections.Generic.IEnumerable(Of T); or
    (3) it implements System.Collections.IEnumerable.

 This function ONLY checks for part (1). Callers are expected to check for (2)/(3) themselves. The
 scenario where something satisfies (2/3) but not (1) is
   Class C 
       Implements IEnumerable
       Function g1() as IEnumerator implements IEnumerable.GetEnumerator : End Function
 
 Clearly this class does not have a method _named_ GetEnumerator, but it does implement IEnumerable.
 </remarks>
 <param name="collectionType">The type of the for each collection.</param>
 <param name="collection">The bound collection expression.</param>
 <param name="currentType">Return type of the property named "Current" if found.</param>
 <param name="boundGetEnumeratorCall">A bound call to GetEnumerator on the collection if found.</param>
 <param name="boundEnumeratorPlaceholder">A bound placeholder value for the collection local if GetEnumerator 
 was bound successful</param>
 <param name="boundMoveNextCall">A bound call to MoveNext on the instance returned by GetEnumerator if found.</param>
 <param name="boundCurrentAccess">A bound property access for "Current" on the instance returned by GetEnumerator if found.</param>
 <param name="collectionPlaceholder">A placeholder for the collection expression.</param>
 <param name="temporaryDiagnostics">An empty diagnostic bag to capture diagnostics that have to be reported if the
 collection matches the design pattern and that can be used instead of the generic error message in case non of the
 for each collection criteria match.</param>
 <returns>If all required methods have been successfully looked up and bound, true is being returned; otherwise false.
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CreateBoundInvocationExpressionFromMethodOrPropertyGroup(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Creates a BoundCall or BoundPropertyAccess from a MethodOrPropertyGroup.
 </summary>
 <remarks>
 This is not a general purpose helper!
 </remarks>
 <param name="syntax">The syntax node.</param>
 <param name="methodOrPropertyGroup">The method or property group.</param>
 <param name="diagnostics">The diagnostics.</param>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Binder.s_isFunctionWithoutArguments">
 <summary>
 Checks if a given symbol is a function that takes no parameters.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Binder.s_isReadablePropertyWithoutArguments">
 <summary>
 Checks if a given symbol is a property that is readable.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetMemberIfMatchesRequirements(System.String,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Func{Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Boolean},Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Returns the lookup result if at least one found symbol matches the requirements that are verified
 by using the given symbolChecker. Extension methods will be considered in this check.
 </summary>
 <param name="name">The name of the method or property to look for.</param>
 <param name="container">The container to look in.</param>
 <param name="symbolChecker">The symbol checker which performs additional checks.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.IsOrInheritsFromOrImplementsInterface(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol})">
 <summary>
 Determines whether derivedType is, inherits from or implements the given interface.
 </summary>
 <param name="derivedType">The possible derived type.</param>
 <param name="interfaceType">Type of the interface.</param>
 <param name="useSiteDiagnostics"/> 
 <param name="matchingInterfaces">A list of matching interfaces.</param>
 <returns>
   <c>true</c> if derivedType is, inherits from or implements the interface; otherwise, <c>false</c>.
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindUsingBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Initially binding using blocks.
 A Using statement names a resource that is supposed to be disposed on completion.
 The resource can be an expression or a list of local variables with initializers.
 the type of the resource must implement System.IDispose
 A using statement of the form:
      using Expression
          list_of_statements
      end using

 when the resource is a using locally declared variable no temporary is generated but the variable is read-only
 A using statement of the form:
      using v as new myDispose
          list_of_statements
      end using
 It is also possible to use multiple variable resources:
      using v1 as new myDispose, v2 as myDispose = new myDispose()
          list_of_statements
      end using
</summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ReportMutableStructureConstraintsInUsing(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>Check the given type of and report WRN_MutableGenericStructureInUsing if needed.</summary>
 <remarks>This function should only be called for a type of a using variable.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindSyncLockBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Binds a sync lock block.
 A SyncLock come in the following form:
 
 SyncLock &lt;expression&gt;
     &lt;body&gt;
 End SyncLock
 </summary>
 <param name="node">The node.</param>
 <param name="diagnostics">The diagnostics.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindTypeSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 Bind a type name using the given binder. Returns a type symbol if the binding bound to something,
 or an error symbol if the binding failed. In either case, errors may be reported via the
 context. For example, if an inaccessible type or type with the wrong arity was found, the best possible
 type is returned, but an error is also generated.
 </summary>
 <param name="typeSyntax">The syntax to bind.</param>
 <param name="diagBag">Place to put diagnostics. If no reasonable type was found, an undefined type
 diagnostic is placed in here. Other diagnostics (both related to the type being bound, or
 type arguments thereof) can be placed here also. </param>
 <returns>The best type that can be found, or and ErrorTypeSymbol if no reasonable type can be found.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindNamespaceOrTypeSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 Bind a type or namespace using the given binder. 
 </summary>
 <param name="typeSyntax">The syntax to bind.</param>
 <returns>The best type or namespace that can be found, or and ErrorTypeSymbol if no reasonable type can be found.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ConstructAndValidateConstraints(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol},Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Apply generic type arguments, returning the constructed type. Produces errors for constraints
 that aren't validated. If the wrong number of type arguments are supplied, the set of types
 is silently truncated or extended with the type parameters.
 </summary>
 <param name="genericType">The type to construct from</param>
 <param name="typeArguments">The types to apply</param>
 <param name="syntaxWhole">The place to report errors for the generic type as a whole</param>
 <param name="syntaxArguments">The place to report errors for each generic type argument.</param>
 <param name="diagnostics">The diagnostics collection.</param>
 <returns>The constructed generic type.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ResolveOverloadedMembers``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax})">
 <summary>
 Resolves overloaded methods or constructors or properties for SemanticModel.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder">
 <summary>
 The type binder class handles binding of type names.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.BindTypeSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean,System.Boolean)">
 <summary>
 Bind a type name using the given binder. Returns a type symbol if the binding bound
 to something, or an error symbol if the binding failed. In either case, errors may
 be reported via the context. For example, if an inaccessible type or type with the
 wrong arity was found, the best possible type is returned, but an error is also
 generated.
 </summary>
 <param name="typeSyntax">The syntax to bind.</param>
 <param name="binder">The binder to bind within. This binder is used for looking up
 unqualified names, accessibility checking, reporting errors, and probably other
 stuff too.</param>
 <returns>The best type that can be found, or and ErrorTypeSymbol if no reasonable type can be found.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.CheckForForwardedType(Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax@,System.String@,Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol@,System.Boolean@)">
 <summary>
 If lookup failed for a qualified name, we don't know which part of the lookup failed.  Therefore, we have
 to check for a type forwarder for each prefix of the name.
 </summary>
 <param name="containingAssembly">Starting assembly.</param>
 <param name="typeSyntax">Full name of type that failed lookup.  Shortened as different prefixes are checked.</param>
 <param name="diagName">GetBaseNamesForDiagnostic(typeSyntax) (basically dot-delimited list of names).  Shortened as different prefixes are checked.</param>
 <param name="forwardedToAssembly">Set if some prefix matches a forwarded type.</param>
 <param name="encounteredForwardingCycle">True if forwardedToAssembly is non-null and the type indicated by typeSyntax/diagName is in a forwarder cycle.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.GetForwardedToAssembly(Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol,System.String,System.Int32,System.Boolean@)">
 <summary>
 Look for a type forwarder for the given type in the containing assembly and any referenced assemblies.
 If one is found, search again in the target assembly.  Return the last assembly in the chain.
 </summary>
 <param name="containingAssembly">The assembly in which to look for the type forwarder.</param>
 <param name="fullName">The metadata name of the (potentially) forwarded type, including the arity (if non-zero).</param>
 <param name="arity">The arity of the forwarded type.</param>
 <param name="encounteredCycle">Set to true if a cycle was found in the type forwarders.</param>
 <returns></returns>
 <remarks>
 Since this method is intended to be used for error reporting, it stops as soon as it finds
 any type forwarder - it does not check other assemblies for consistency or better results.
 
 NOTE: unlike in C#, this method searches for type forwarders case-insensitively.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.BindNamespaceOrTypeSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 Bind a type or namespace using the given binder. 
 </summary>
 <param name="typeSyntax">The syntax to bind.</param>
 <param name="binder">The binder to bind within. This binder is used for looking up
 unqualified names, accessibility checking, reporting errors, and probably other stuff too.</param>
 <returns>The best type or namespace that can be found, or and ErrorTypeSymbol if no reasonable type can be found.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupTypeOrNamespaceSyntax(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 Lookup a typeSyntax, confining the lookup to namespaces or types. Returns a LookupResult
 that summarizes the results of the lookup, which might contain a Diagnostic associated with the lookup.
 However, other diagnostics associated with parts of the binding process (i.e., binding type arguments) 
 will be emitted via the diagnostic bag.
 
 The LookupResult will always have at most one symbol in it, since types and namespaces are not overloadable symbols.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.CheckSymbolIsType(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Check that the given symbol is a type. If it is a namespace, report an error into the diagnostic bag
 and return an error symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupPredefinedTypeName(Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedTypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@,System.Boolean)">
 <summary>
 Bind a built in type name to the correct type symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupArrayType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean,System.Boolean)">
 <summary>
 Bind array type syntax to the correct type symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupNullableType(Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 Bind Nullable (?) type syntax to the correct type symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupBasicName(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@)">
 <summary>
 Bind a basic name to a type or namespace.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupGenericName(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@,System.Boolean)">
 <summary>
 Bind a generic name to a type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupDottedName(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@,System.Boolean,System.Boolean)">
 <summary>
 Bind a dotted name to a type or namespace.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupGenericDottedName(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@,System.Boolean,System.Boolean)">
 <summary>
 Bind a generic dotted name to a type or namespace.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupGlobalName(Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Bind to the global namespace.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.BindTypeArguments(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 Bind a list of type arguments to their types.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.GetBaseNamesForDiagnostic(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Given a type syntax, strip out ?, (), (of xxx) stuff and return a string of the form
 x.y.z, for use in an error message.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DisallowTypeCharacter(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.ERRID)">
 <summary>
 If the identifier has a type character, report an error on it.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.FindFirstKeyword(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind[])">
 <summary>
 Given a list of keywords and an set of keywords kinds to search, return the first keyword
 in the list, if any, that matches one of the keyword kinds.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MapKeywordToFlag(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Map syntax kind of a modifier keyword to SourceMemberFlags value
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodeModifiers(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SourceMemberFlags,Microsoft.CodeAnalysis.VisualBasic.ERRID,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Decodes a set of modifier flags, reported any errors with the flags.
 </summary>
 <param name="syntax">The syntax list of the modifiers.</param>
 <param name="allowableModifiers">A bit-flag of the allowable modifiers. If a bit isn't set, an error occurs.</param>
 <param name="errIdBadModifier">Error ID to report if a bad modifier is found.</param>
 <param name="defaultAccessibility">The default accessibility. </param>
 <returns>Flags for the modifiers.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodeParameterModifiers(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.Binder.CheckParameterModifierDelegate,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Decode a list of parameter modifiers, and return the flags associated with it.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CreateNullableOf(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Create the Nullable version of a type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ApplyArrayRankSpecifiersToType(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Possible create the array version of type, given the element type and the array modifier syntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ApplyArrayRankSpecifiersAndBoundsToType(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Possibly create the array version of type, given the element type and the array modifier syntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CreateArrayOf(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Create the array version of type, given the element type and the array modifier syntax. Throws if
 there aren't any array modifiers and the result is not an array type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.HasDefaultType(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)">
 <summary>
 Given an identifier and an As clause, return true if the identifier does not have a type
 declared for it (e.g., no type character and no as clause).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.HasDefaultType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)">
 <summary>
 Given an identifier and an As clause, return true if the identifier does not have a type
 declared for it (e.g., no type character and no as clause).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.IsArrayType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax)">
 <summary>
 Given an identifier, return true if the identifier declares an array.
 (e.g., identifier  specifies ())
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext">
 <summary>
 Flags to specify where the decoding of the modified identifier's type happens.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.None">
 <summary>
 No context given (default).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.LambdaType">
 <summary>
 Modified identifier appeared in a lambda declaration.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.LocalType">
 <summary>
 Modified identifier appeared in a local declaration.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.FieldType">
 <summary>
 Modified identifier appeared in a field declaration.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.ParameterType">
 <summary>
 Modified identifier appeared in a parameter.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.QueryRangeVariableType">
 <summary>
 Modified identifier appeared in a query range variable declaration.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.LocalOrFieldType">
 <summary>
 Combined flag to express that a modified identifier appeared in a local or field declaration.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.LambdaParameterType">
 <summary>
 Combined flag to express that a modified identifier appeared in a parameter of a lambda.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodeModifiedIdentifierType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Func{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext)">
 <summary>
 Given a modified identifier and a type, return the actual type to use. Applies the type character
 and type modifiers to the given type.
 </summary>
 <param name="modifiedIdentifier">The modified identifier.</param>
 <param name="asClauseOrValueType">Bound type after the As or a type from the initializing value expression. Can be nothing if no type was supplied.</param>
 <param name="asClauseSyntaxOpt">If specified then it is the syntax for the as clause and the type is the bound type from this syntax.</param>
 <param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
 <returns>The type, as modified by the type character, type modifiers. Uses Object as default if needed.</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodeModifiedIdentifierType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,System.Func{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol@,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext)">
 <summary>
 Given a modified identifier and a type syntax, return the actual type to use. Applies the type character
 and type modifiers to the given type.
 </summary>
 <param name="modifiedIdentifier">The modified identifier.</param>
 <param name="asClauseOpt"> As clause syntax. Can be nothing if no type was supplied.</param>
 <param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
 <param name="asClauseType">The type of the AsClauseOpt before applying any modifiers</param>
 <returns>The type, as modified by the type character, type modifiers. Uses Object as default if needed.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodeModifiedIdentifierType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,System.Func{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext)">
 <summary>
 Given a modified identifier and a type syntax, return the actual type to use. Applies the type character
 and type modifiers to the given type.
 </summary>
 <param name="modifiedIdentifier">The modified identifier.</param>
 <param name="asClauseOpt"> As clause syntax. Can be nothing if no type was supplied.</param>
 <param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
 <returns>The type, as modified by the type character, type modifiers. Uses Object as default if needed.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodeIdentifierType(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,System.Func{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given a identifier and as clause syntax, return the actual type to use. Uses the type character or the type syntax.
 </summary>
 <param name="identifier">The identifier.</param>
 <param name="asClauseOpt">Syntax for optional as clause. Can be nothing if no type was supplied.</param>
 <param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
 <returns>The type, either from the type character or the as clause. Uses Object as default if needed.</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodeIdentifierType(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,System.Func{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given a identifier and as clause syntax, return the actual type to use. Uses the type character or the type syntax.
 </summary>
 <param name="identifier">The identifier.</param>
 <param name="asClauseOpt">Syntax for optional as clause. Can be nothing if no type was supplied.</param>
 <param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
 <returns>The type, either from the type character or the as clause. Uses Object as default if needed.</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodeIdentifierType(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Func{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext)">
 <summary>
 Given a identifier and a type, return the actual type to use. Uses the type character or the given type.
 </summary>
 <param name="identifier">The identifier.</param>
 <param name="asClauseType">Bound type after the As. Can be nothing if no type was supplied.</param>
 <param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
 <returns>The type, either from the type character or the as clause type. Uses Object as default if needed.</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodeOnOff(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Decode an option "On" or "Off" values into true or false. Not specified is considered true.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodeTextBinary(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Decode an option "Text" or "Binary" value into true or false. The syntax is not optional.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodeParameterListOfDelegateDeclaration(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Decode a parameter list from a delegate declaration into a list of parameter symbols.
 </summary>
 <param name="container">Containing method declaration.</param>
 <param name="syntaxOpt">Optional parameter list syntax</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodeParameterList(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.SourceMemberFlags,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Decode a parameter list into a list of parameter symbols.
 </summary>
 <param name="container">Containing method declaration.</param>
 <param name="isFromLambda">Parameter is for a lambda expression rather than a regular method.</param>
 <param name="syntaxOpt">Optional parameter list syntax</param>
 <remarks>DO NOT call this to get the parameters of a delegate declaration (<see>DecodeParameterListOfDelegateDeclaration</see>).</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.DecodePropertyParameterList(Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Decode a parameter list into a list of parameter symbols.
 </summary>
 <param name="container">Containing property declaration.</param>
 <param name="syntaxOpt">Optional parameter list syntax</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.ValidateSharedPropertyAndMethodModifiers(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.MemberModifiers,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Modifier validation code shared between properties and methods.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetExpressionConstantValueIfAny(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder.ConstantContext)">
 <summary>
 This function checks if the given expression is a constant from a language point of view and returns 
 constant value if it is. This is different from the fact that the bound node has a constant value. 
 This method also adds the required diagnostics for non const values.
 </summary>
 <param name="boundExpression">The bound expression.</param>
 <param name="diagnostics">The diagnostics.</param>
 <returns>ConstantValue if the bound expression is compile time constant and can be used 
 for const field/local initializations or enum member initializations. Nothing if not</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.GetAccessorName(System.String,Microsoft.CodeAnalysis.MethodKind,System.Boolean)">
 <summary>isWinMd says whether to mangle the name for winmdobj output. See the param tag for details.</summary>
 <param name="isWinMd">isWinMd is only necessary for set properties, so any MethodKind which is definitely not
 a set property can safely set this value to False.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.MatchesXmlnsImport(System.String,System.String)">
 <summary>
 Returns True if the xmlns { prefix, namespace } pair matches
 an Imports declaration and there aren't any xmlns declarations
 for the same prefix on any outer XElement scopes.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindXmlEmbeddedExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind the expression within the XmlEmbeddedExpressionSyntax,
 and wrap in a BoundXmlEmbeddedExpression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindInvocationExpressionIfGroupNotNothing(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 If the method or property group is not Nothing, bind as an invocation expression.
 Otherwise return a BoundBadExpression containing the arguments.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.CheckXmlFeaturesAllowed(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Check if XML features are allowed. If not, report an error and return a
 separate DiagnosticBag that can be used for binding sub-expressions.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.BindXmlnsAttributes(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax},System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.VisualBasic.Binder.XmlName,Microsoft.CodeAnalysis.VisualBasic.BoundXmlAttribute}@,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundXmlAttribute},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.ArrayBuilder{System.Collections.Generic.KeyValuePair{System.String,System.String}},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind any xmlns declaration attributes and return the bound nodes plus a Dictionary
 of { prefix, namespace } pairs that will be used for namespace lookup at and below
 the containing XmlElement. Any xmlns declarations that are redundant with Imports
 in scope (same prefix and namespace) are dropped, and instead, an entry is added
 to the 'importedNamespaces' collection. When the root XmlElement is generated,
 xmlns attributes will be added for all entries in importedNamespaces. Any attributes
 other than xmlns are added to the 'otherAttributes' collection for binding by the caller.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TryGetXmlnsAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax,System.String@,System.String@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,System.Boolean@,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 If the attribute represents an xmlns declaration, populate 'prefix' and 'namespace',
 and generate diagnostics and set hasErrors if there are errors. Returns True if this
 is an xmlns declaration, even if there are errors. Unless this attribute is from an
 Imports statement, generate the BoundExpression for the namespace as well.
 (For Imports, binding is skipped, since a BoundNode is not needed, and in the
 invalid case of "xmlns:p=&lt;%= expr %&gt;", expr may result in a cycle.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Binder.TryGetXmlnsPrefix(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax,System.String@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 If name is "xmlns", set prefix to String.Empty and return True.
 If name is "xmlns:p", set prefix to p and return True.
 Otherwise return False.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.XmlElementRootInfo">
 <summary>
 State tracked for the root XmlElement while binding nodes within the
 tree. This state is mutable since it includes the set of namespaces from
 Imports referenced within the tree. Ideally, this state would be part of the
 XmlRootElementBinder, but since this state is mutable, there would be
 issues caching and reusing the Binder. Instead, the state is passed
 explicitly as an argument to each binding method.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Binder.OptionStrictOffBinder">
 <summary>
 Makes it look like Option Strict is Off, all other operations
 are delegated up the chain.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ConditionalAccessBinder">
 <summary>
 A helper to bind conditional access. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ImportData">
 <summary>
 Data for Binder.BindImportClause that exposes dictionaries of
 the members and aliases that have been bound during the
 execution of BindImportClause. It is the responsibility of derived
 classes to update the dictionaries in AddMember and AddAlias.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LambdaBodyBinder">
 <summary>
 Provides context for binding body of a Lambda.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ObjectInitializerBinder">
 <summary>
 Special binder for binding ObjectInitializers. 
 This binder stores a reference to the receiver of the initialization, because fields in an object initializer can be 
 referenced with an omitted left expression in an member access expression (e.g. .Fieldname = .OtherFieldname).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ObjectInitializerBinder.TryBindOmittedLeftForMemberAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Boolean@)">
 <summary>
 Use the receiver of the ObjectCreationExpression as the omitted left of a member access.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ObjectInitializerBinder.TryBindOmittedLeftForDictionaryAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Use the receiver of the ObjectCreationExpression to as the omitted left of a dictionary access.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SourceMemberFlags">
 <summary>
 Holds information about a member in a compact form. Used for all non-type members for simplicity
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.MemberModifiers._foundFlags">
 <summary>
 These are the flags that are found in the syntax.  They must correspond to the modifiers list.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.MemberModifiers._computedFlags">
 <summary>
 These are flags that are implied or computed
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder">
 <summary>
 Binder used to bind statements inside With blocks. 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder._withBlockSyntax">
 <summary> Reference to a With statement syntax this binder is created for </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.Expression">
 <summary> Reference to an expression from With statement </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder._withBlockInfo">
 <summary> 
 Holds information needed by With block to properly bind 
 references to With block expression placeholder
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.ExpressionIsAccessedFromNestedLambda">
 <summary> 
 True if there were references to the With statement expression 
 placeholder which prevent ByRef local from being used 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.ExpressionPlaceholder">
 <summary>
 With statement expression placeholder is a bound node being used in initial binding
 to represent with statement expression. In lowering it is to be replaced with
 the lowered expression which will actually be emitted.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.DraftInitializers">
 <summary>
 A draft version of initializers which will be used in this With statement. 
 Initializers are expressions which are used to capture expression in the current
 With statement; they can be empty in some cases like if the expression is a local 
 variable of value type.
 
 Note, the initializers returned by this property are 'draft' because they are 
 generated based on initial bound tree, the real initializers will be generated 
 in lowering based on lowered expression form.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.DraftPlaceholderSubstitute">
 <summary>
 A draft version of placeholder substitute which will be used in this With statement. 
 
 Note, the placeholder substitute returned by this property is 'draft' because it is
 generated based on initial bound tree, the real substitute will be generated in lowering 
 based on lowered expression form.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.WithBlockInfo">
 <summary> Holds information needed by With block to properly bind 
 references to With block expression, placeholder, etc... </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.WithBlockInfo.OriginalExpression">
 <summary> Original bound expression from With statement </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.WithBlockInfo.ExpressionPlaceholder">
 <summary> Bound placeholder expression if used, otherwise Nothing </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.WithBlockInfo.Diagnostics">
 <summary> Diagnostics produced while binding the expression </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.WithBlockInfo.DraftInitializers">
 <summary> 
 Draft initializers for With statement, is based on initial binding tree 
 and is only to be used for warnings generation as well as for flow analysis 
 and semantic API; real initializers will be re-calculated in lowering
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.WithBlockInfo.DraftSubstitute">
 <summary> 
 Draft substitute for With expression placeholder, is based on initial 
 binding tree and is only to be used for warnings generation as well as 
 for flow analysis and semantic API; real substitute will be re-calculated 
 in lowering
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.WithBlockInfo.ExpressionHasByRefMeReference(System.Int32)">
 <summary>
 If With statement expression is being used from nested lambda there are some restrictions
 to the usage of Me reference in this expression. As these restrictions are only to be checked 
 in few scenarios, this flag is being calculated lazily.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.#ctor(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax)">
 <summary> Create a new instance of With statement binder for a statement syntax provided </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.ValueTypedMeReferenceFinder">
 <summary>
 A bound tree walker which search for a bound Me and MyClass references of value type. 
 Is being only used for calculating the value of 'ExpressionHasByRefMeReference'
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder.AssertExpressionIsNotFromStatementExpression(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary> Asserts that the node is NOT from With statement expression </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.BoundXmlContainerRewriterInfo">
 <summary>
 Binding state used by the rewriter for XContainer derived types.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.XmlNamespaceImportsBinder">
 <summary>
 A binder to expose namespaces from Imports&lt;xmlns:...&gt; statements.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.XmlElementBinder">
 <summary>
 A binder for XmlElement declarations.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ReducedExtensionPropertySymbol">
 <summary>
 An extension property in reduced form, with first parameter
 removed and exposed as an explicit receiver type.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.BinderBuilder">
 <summary>
 A BinderBuilder builds a linked list of Binder objects for various typical binders.
 
 Typically the binder chain looks something like this:
    BackstopBinder
    SourceModuleBinder
    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)
    ImportAliasesBinder (for project-level import aliases)
    SourceFileBinder
    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)
    ImportAliasesBinder (for file-level import aliases)
    NamespaceBinder... (for each namespace, starting at the global namespace)
    TypeBinder... (for each type, and nested type)
  (maybe more)
    DiagnosticBagBinder 
 
  Note: Binders are also built by the BinderCache class. Changes to how namespace and type Binders
  are built may need changes there also.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BinderBuilder.CreateBinderForSourceFileImports(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol,Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Creates a binder for a binding global imports in a source file. This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    SourceFileBinder
    NamespaceBinder (for the global namespace)
    IgnoreBaseClassesBinder (so that base classes are ignore during binding)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BinderBuilder.CreateBinderForProjectImports(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol,Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Creates a binder for a binding project-level imports. This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    ProjectImportsBinder
    NamespaceBinder (for the global namespace)
    IgnoreBaseClassesBinder (so that base classes are ignore during binding)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BinderBuilder.CreateBinderForSourceFile(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol,Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Creates a binder for a source file. This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)
    ImportAliasesBinder (for project-level import aliases)
    SourceFileBinder
    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)
    ImportAliasesBinder (for file-level import aliases)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BinderBuilder.CreateBinderForProjectLevelNamespace(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol,Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Creates a binder for a project level namespace declaration 
 This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)
    SourceFileBinder
    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)
    ImportAliasesBinder (for file-level import aliases)
    NamespaceBinder... (for each namespace, starting at the global namespace)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BinderBuilder.CreateBinderForNamespace(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol,Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol)">
 <summary>
 Creates a binder for a source namespace declaration (the part of a namespace
 in a single namespace declaration). This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)
    SourceFileBinder
    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)
    ImportAliasesBinder (for file-level import aliases)
    NamespaceBinder... (for each namespace, starting at the global namespace)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BinderBuilder.CreateBinderForType(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol,Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Creates a binder for a source type declaration (the part of a type in a single
 type declaration. For partial types this include just one part). This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)
    SourceFileBinder
    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)
    ImportAliasesBinder (for file-level import aliases)
    NamespaceBinder... (for each namespace, starting at the global namespace)
    NamedTypeBinder... (for each type, and nested type)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BinderBuilder.CreateBinderForAttribute(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol,Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Creates a binder for a source attribute block from the containing type or containing namespace.
 This binder is used by the normal compilation code path for source attributes. In this case, no
 containing binder exists.
 </summary>
 <param name="moduleSymbol"></param>
 <param name="tree"></param>
 <param name="target">The symbol which is the target of the attribute.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BinderBuilder.CreateBinderForAttribute(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Creates a binder for a source attribute block when a containing binder is available. Used by semantic model.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BinderBuilder.CreateBinderForParameterDefaultValue(Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Creates a binder for binding a source parameter's default value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BinderBuilder.CreateBinderForDocumentationComment(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentBinder.BinderType)">
 <summary>
 Creates a binder for binding for binding inside the interior of documentation comment 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BinderBuilder.CreateSourceModuleBinder(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol)">
 <summary>
 Create a binder for the source module. Includes the following:
    BackstopBinder
    SourceModuleBinder
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.BinderFactory">
 <summary>
 The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.BinderFactory"/> class finds the correct Binder to use for a node in a syntax
 tree, down to method level. Within a method, the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.ExecutableCodeBinder"/> has a
 cache of further binders within the method.
 
 The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.BinderFactory"/> caches results so that binders are efficiently reused between queries.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.BindingLocation">
 <summary>
 A specific location for binding.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.CatchBlockBinder">
 <summary>
 Binder used to bind Catch blocks. 
 It hosts the control variable (if one is declared) 
 and inherits BlockBaseBinder since there are no Exit/Continue for catch blocks. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ConstantFieldsInProgressBinder">
 <summary>
 This binder keeps track of the set of constant fields that are currently being evaluated
 so that the set can be passed into the next call to SourceFieldSymbol.ConstantValue (and
 its callers).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.DeclarationInitializerBinder">
 <summary>
 Binder used for field, auto property initializations and parameter default values.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DeclarationInitializerBinder._symbol">
 <summary>
 Backing field for the ContainingMember property
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DeclarationInitializerBinder._root">
 <summary> Root syntax node </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DeclarationInitializerBinder.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.DeclarationInitializerBinder"/> class.
 </summary>
 <param name="symbol">The field, property or parameter symbol with an initializer or default value.</param>
 <param name="next">The next binder.</param>
 <param name="root">Root syntax node</param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.DeclarationInitializerBinder.ContainingMember">
 <summary>
 The member containing the binding context. 
 This property is the main reason for this binder, because the binding context for an initialization 
 needs to be the field or property symbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.DeclarationInitializerBinder.Root">
 <summary> Field or property declaration statement syntax node </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.DefaultParametersInProgressBinder">
 <summary>
 This binder keeps track of the set of parameters that are currently being evaluated
 so that the set can be passed into the next call to ParameterSymbol.DefaultConstantValue (and
 its callers).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SymbolsInProgressBinder`1">
 <summary>
 This binder keeps track of the set of symbols that are currently being evaluated
 so that the set can be passed to methods to support breaking infinite recursion
 cycles.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.DescendantBinderFactory">
 <summary>
 Provides a way to obtain binders for descendant scopes in method or lambda body.
 Factory for a method body does not create binders for scopes inside a lambda, 
 contained by the method. A dedicated factory must be created for each lambda body.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentBinder">
 <summary>
 Binder used for interiors of documentation comment
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentBinder.CheckBinderSymbolRelationship(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Assuming there is one, the containing member of the binder is the commented symbol if and only if
 the commented symbol is a non-delegate named type.  (Otherwise, it is the containing type or namespace of the commented symbol.)
 </summary>
 <remarks>
 Delegates don't have user-defined members, so it makes more sense to treat
 them like methods.
 </remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentBinder.CommentedSymbol">
 <summary>
 Symbol commented with the documentation comment handled by this binder. In general,
 all name lookup is being performed in context of this symbol's containing symbol.
 We still need this symbol, though, to be able to find type parameters or parameters
 referenced from 'param', 'paramref', 'typeparam' and 'typeparamref' tags.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentBinder.RemoveOverriddenMethodsAndProperties(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Removes from symbol collection overridden methods or properties
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentCrefBinder">
 <summary>
 Binder used for interiors of documentation comment for binding 'cref' attribute value
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentParamBinder">
 <summary>
 Binder used for interiors of documentation comment for binding 'name' attribute 
 value of 'param' and 'paramref' documentation comment tags
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentTypeParamBinder">
 <summary>
 Binder used for interiors of documentation comment for binding 'name' attribute 
 value of 'typeparam' documentation comment tag
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentTypeParamRefBinder">
 <summary>
 Binder used for interiors of documentation comment for binding 'name' attribute 
 value of 'typeparamref' documentation comment tag
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.EarlyWellKnownAttributeBinder">
 <summary>
 This is a binder for use when early decoding of well known attributes. The binder will only bind expressions that can appear in an attribute.
 Its purpose is to allow a symbol to safely decode any attribute without the possibility of any attribute related infinite recursion during binding.
 If an attribute and its arguments are valid then this binder returns a BoundAttributeExpression otherwise it returns a BadExpression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.EarlyWellKnownAttributeBinder.CanBeValidAttributeArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Check that the syntax can appear in an attribute argument.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ExecutableCodeBinder">
 <summary>
 A ExecutableCodeBinder provides context for looking up labels within a context represented by a syntax node, 
 and also implementation of GetBinder. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.FinallyBlockBinder">
 <summary>
 Binder for Finally blocks. 
 Its purpose is to hide exit try label of the enclosing try binder.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ForOrForEachBlockBinder">
 <summary>
 Binder used to bind For and ForEach blocks. 
 It hosts the control variable (if one is declared) 
 and inherits ExitableStatementBinder to provide Continue/Exit labels if needed. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo">
 <summary>
 Holds all information needed to rewrite a bound for each node.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo.GetEnumerator">
 <summary>
 A bound call to the GetEnumerator method.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo.MoveNext">
 <summary>
 A bound call to the MoveNext method.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo.Current">
 <summary>
 A bound access to the Current property.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo.NeedToDispose">
 <summary>
 True is the enumerator needs or may need (in case of IEnumerator) to be disposed.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo.IsOrInheritsFromOrImplementsIDisposable">
 <summary>
 True if the enumerator is, inherits from or implements IDisposable.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo.DisposeCondition">
 <summary>
 The condition that is used to determine whether to call Dispose or not (contains a placeholder).
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo.DisposeCast">
 <summary>
 The conversion of the enumerator to the target type on which Dispose is called 
 (contains a placeholder).
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo.CurrentConversion">
 <summary>
 The conversion of the return value of the current call to the type of the control variable 
 (contains a placeholder).
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo.EnumeratorPlaceholder">
 <summary>
 Placeholder for the bound enumerator local. 
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo.CurrentPlaceholder">
 <summary>
 Placeholder for the bound call to the get_Current method.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo.CollectionPlaceholder">
 <summary>
 Placeholder for the collection; used only when the collection's type 
 is not an one dimensional array or string.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo.#ctor(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundLValuePlaceholder,Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder,Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo" /> class.
 </summary>
 <param name="getEnumerator">A bound call to the GetEnumerator method.</param>
 <param name="moveNext">A bound call to the MoveNext method.</param>
 <param name="current">A bound access to the Current property.</param>
 <param name="needToDispose">if set to <c>true</c> the enumerator needs to be disposed.</param>
 <param name="isOrInheritsFromOrImplementsIDisposable">if set to <c>true</c> the enumerator is or inherits from or implements IDisposable.</param>
 <param name="disposeCondition">The condition whether to call dispose or not.</param>
 <param name="disposeCast">The conversion of the enumerator to call Dispose on.</param>
 <param name="currentConversion">The conversion from Current return type to the type of the controlVariable.</param>
 <param name="enumeratorPlaceholder">The placeholder for the bound enumerator local.</param>
 <param name="currentPlaceholder">The placeholder for the expression that get's the current value.</param>
 <param name="collectionPlaceholder">The placeholder for the collection expression.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.GetTypeBinder">
 <summary>
 This binder is for binding the argument to GetType.  It traverses
 the syntax marking each open type ("unbound generic type" in the
 VB spec) as either allowed or not allowed, so that BindType can 
 appropriately return either the corresponding type symbol or an 
 error type.  
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.GetTypeBinder.OpenTypeVisitor">
 <summary>
 This visitor walks over a type expression looking for open types.
 Open types are allowed if an only if:
   1) There is no constructed generic type elsewhere in the visited syntax; and
   2) The open type is not used as a type argument or array/nullable
        element type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.GetTypeBinder.OpenTypeVisitor.Visit(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax,System.Boolean}@,System.Boolean)">
 <param name="typeSyntax">The argument to typeof.</param>
 <param name="allowedMap">
 Keys are GenericNameSyntax nodes representing unbound generic types.
 Values are false if the node should result in an error and true otherwise.
 </param>
 <param name="isOpenType">True if no constructed generic type was encountered.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.IgnoreBaseClassesBinder">
 <summary>
 Causes lookups to ignore base classes. Used for binding
 Imports statements.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ImplicitVariableBinder.#ctor(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 If Option Explicit is Off for this source file, then implicit variable declaration will be allowed
 in this binder. "containerOfLocals" is the container for implicitly declared variables.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ImplicitVariableBinder.DisallowFurtherImplicitVariableDeclaration(Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Disallow additional local variable declaration (make binder frozen)
 and report delayed shadowing diagnostics.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.ImplicitVariableBinder.AllImplicitVariableDeclarationsAreHandled">
 <summary>
 True if implicit variable declaration is done (binder is frozen and doesn't
 allow additional implicit variable declaration)
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.ImplicitVariableBinder.ImplicitVariableDeclarationAllowed">
 <summary>
 True if we are in a place that allows implicit variable declaration. This binder
 implies that.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.ImplicitVariableBinder.ImplicitlyDeclaredVariables">
 <summary>
 Get all implicitly declared variables that were declared in this method body. The binder
 must be frozen before this can be obtained.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ImplicitVariableBinder.DeclareImplicitLocalVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Declare an implicit local variable. The type of the local is determined
 by the type character (if any) on the variable.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ImplicitVariableBinder.RememberPossibleShadowingVariable(System.String,Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.VisualBasic.ERRID)">
 <summary>
 A tricky problem is reporting the "Variable 'x' hides a variable in an enclosing block" message if the variable in
 an enclosing block is an implicit variable that hasn't been declared yet. We handle this by remembering any variable
 declarations in enclosed blocks, and then report the error when the implicit variable is declared.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ImportAliasesBinder">
 <summary>
 A ImportAliasesBinder provides lookup for looking up import aliases (A = Foo.Bar),
 either at file level or project level.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ImportedTypesAndNamespacesMembersBinder">
 <summary>
 Provides lookup in imported namespaces and types (not the alias kind),
 either at file level or project level.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ImportedTypesAndNamespacesMembersBinder.CollectProbableExtensionMethodsInSingleBinder(System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Collect extension methods with the given name that are in scope in this binder.
 The passed in ArrayBuilder must be empty. Extension methods from the same containing type
 must be grouped together. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.InitializerSemanticModel.Create(Microsoft.CodeAnalysis.VisualBasic.DeclarationInitializerBinder,System.Boolean)">
 <summary>
 Creates an InitializerSemanticModel that allows asking semantic questions about an initializer node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.InitializerSemanticModel.CreateSpeculative(Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Int32)">
 <summary>
 Creates a speculative InitializerSemanticModel that allows asking semantic questions about an initializer node that did not appear in the original source code.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LocalBinderBuilder">
 <summary>
 The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.LocalBinderBuilder"/> is used to build up the map of all <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Binder"/>s within a method body, and the associated
 <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode"/>. To do so it traverses all the statements, handling blocks and other
 statements that create scopes. For efficiency reasons, it does not traverse into
 expressions. This means that blocks within lambdas and queries are not created. 
 Blocks within lambdas are bound by their own <see cref="T:Microsoft.CodeAnalysis.VisualBasic.LocalBinderBuilder"/> when they are 
 analyzed.

 For reasons of lifetime management, this type is distinct from the <see
 cref="T:Microsoft.CodeAnalysis.VisualBasic.BinderFactory"/> 
 which also creates a map from <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode"/> to <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Binder"/>. That type owns it's binders
 and that type's lifetime is that of the compilation. Therefore we do not store
 binders local to method bodies in that type's cache. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalBinderBuilder.VisitCompilationUnit(Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax)">
 <summary>
 Creates binders for top-level executable statements.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LocalInProgressBinder">
 <summary>
 This binder is for binding the initializer of an implicitly typed 
 local variable. While binding an implicitly typed local variable
 this binder is used to break cycles.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LocationSpecificBinder">
 <summary>
 A simple Binder that wraps another Binder and reports a specific
 binding location, but otherwise delegates to the other Binder.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LookupOptions">
 <summary>
 Options that can be used to modify the symbol lookup mechanism. Multiple options can be combined together.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.Default">
 <summary>
 Consider all symbols, using normal accessibility rules.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.NamespacesOrTypesOnly">
 <summary>
 Consider only namespaces and types.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.LabelsOnly">
 <summary>
 Consider only labels. If this is not set, labels are not considered at all.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.MustBeInstance">
 <summary>
 Do not consider symbols that are shared members.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.MustNotBeInstance">
 <summary>
 Do not consider symbols that are instance members.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.MustNotBeReturnValueVariable">
 <summary>
 Do not consider the return value local variable.
 This is similar to the C# LookupOption.MustBeInvocableMember.
 
 The only non-invocable member in Visual Basic is the function return variable 
 (see language specification 10.1.1). If this flag is set, lookup will not 
 return the function return variable, but instead return the containing function or property,
 and any overloads thereof.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.NoBaseClassLookup">
 <summary>
 Do not do lookup in base classes (similar to how types in Imports are bound).
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.IgnoreAccessibility">
 <summary>
 Ignore accessibility checking when determining if a symbol is a viable match.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.AllMethodsOfAnyArity">
 <summary>
 Consider methods of any arity (but still consider arity for other types of symbols).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.IgnoreExtensionMethods">
 <summary>
 Do not look for extension methods.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.EagerlyLookupExtensionMethods">
 <summary>
 Ensures that lookup eagerly looks for extension methods and merges them with 
 instance methods, if any. 
 
 If this flag is not set and lookup found viable instance method, it will not look 
 for extension methods that might be in scope. 
 
 It is not an error to combine this flag with LookupOptions.IgnoreExtensionMethods, 
 the LookupOptions.IgnoreExtensionMethods takes precedence. 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.MethodsOnly">
 <summary>
 Consider only methods. Used by Query Expressions.
 
 11.21.2 Queryable Types
 When binding well-known method names, non-methods are ignored for the purpose of 
 multiple inheritance in interfaces and extension method binding, although shadowing 
 semantics still apply.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.UseBaseReferenceAccessibility">
 <summary>
 Ignore 'throughType' in accessibility checking. Used in checking accessibility of symbols accessed via 'MyBase'.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.MustNotBeLocalOrParameter">
 <summary>
 Do not consider locals or parameters during lookup.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.EventsOnly">
 <summary>
 Consider only events. Used to indicate that lookup searches for events only. Is used
 to change lookup semantic for searching inside interfaces having CoClass attribute defined. 
 
 Essentially this is a special casing for searching events (and non-event symbols) in 
 COM interfaces, see the following example from Dev11 code:

 Performing a lookup in a CoClass interface affects how we treat ambiguities between events and other members.
 In COM, events are separated into their own binding space, thus it is possible for an event and member to have
 the same name.  This is not possible in the .NET world, but for backwards compatibility, especially with Office,
 the compiler will ignore ambiguities when performing a lookup in a CoClass interface.  Example:

     Interface _Foo
        Sub Quit

     Interface FooSource
        Event Quit

     &lt; System.Runtime.InteropServices.CoClass(GetType(FooClass)) &gt;
     Interface Foo : Inherits _Foo, FooSource

     Class FooClass : Implements Foo
         Event Quit Implements Foo.Quit
         Sub Quit Implements Foo.Quit

 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.NoSystemObjectLookupForInterfaces">
 <summary>
 When performing a lookup in interface do NOT lookup in System.Object 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.IgnoreCorLibraryDuplicatedTypes">
 <summary>
 Ignore duplicate types from the cor library.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LookupOptions.AllowIntrinsicAliases">
 <summary>
 Handle a case of being able to refer to System.Int32 through System.Integer.
 Same for other intrinsic types with intrinsic name different from emitted name.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SingleLookupResult">
 <summary> 
 Represents a result of lookup operation over a 0 or 1 symbol (as opposed to a scope).
 The typical use is to represent that a particular symbol is good/bad/unavailable.

For more explanation of Kind, Symbol, Error - see LookupResult.
 </summary> 
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LookupResult">
 <summary>
 A LookupResult summarizes the result of a name lookup, and allows combining name lookups
 from different scopes in an easy way.
 
 A LookupResult can be ONE OF:
    empty - nothing found.
    a non-accessible result - this kind of result means that search continues into further scopes of lower priority for
                      a viable result. An error is attached with the inaccessibility errors. Non-accessible results take priority over
                      non-viable results.
    a non-viable result - a result that means that the search continues into further scopes of lower priority for
                          a viable or non-accessible result. An error is attached with the error that indicates
                          why the result is non-viable.
    a bad symbol that stops further lookup -  this kind of result prevents lookup into further scopes of lower priority.
                      a diagnostic is attached explaining why the symbol is bad.
    ambiguous symbols.- In this case, an AmbiguousSymbolDiagnostic diagnostic has the other symbols. 
    a good symbol, or set of good overloaded symbols - no diagnostic is attached in this case
 
 Occasionally, good or ambiguous results are referred to as "viable" results.
 
 Multiple symbols can be represented in a single LookupResult. Multiple symbols are ONLY USED for overloadable
 entities, such an methods or properties, and represent all the symbols that overload resolution needs to consider.
 When ambiguous symbols are encountered, a single representative symbols is returned, with an attached AmbiguousSymbolDiagnostic
 from which all the ambiguous symbols can be retrieved. This implies that Lookup operations that are restricted to namespaces
 and/or types always create a LookupResult with 0 or 1 symbol.
 
 Note that the class is poolable so its instances can be obtained from a pool via GetInstance.
 Also it is a good idea to call Free on instances after they no longer needed.
 
 The typical pattern is "caller allocates / caller frees" -
    
    Dim result = LookupResult.GetInstance()
  
    scope.Lookup(result, "foo")
    ... use result ...
         
    result.Clear()
    anotherScope.Lookup(result, "moo")
    ... use result ...
 
    result.Free()   'result and its content is invalid after this
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LookupResult.SetFrom(Microsoft.CodeAnalysis.VisualBasic.SingleLookupResult)">
 <summary>
 Set current result according to another
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LookupResult.SetFrom(Microsoft.CodeAnalysis.VisualBasic.LookupResult)">
 <summary>
 Set current result according to another
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LookupResult.SetFrom(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Set current result according to a given symbol    
 </summary>
 <param name="s"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LookupResult.MergeOverloadedOrPrioritized(Microsoft.CodeAnalysis.VisualBasic.SingleLookupResult,System.Boolean)">
 <summary>
 Merge two results, returning the best. If there are
 multiple viable results, either produce a result with both symbols if they 
 can overload each other, or use the current.
 </summary>
 <param name="other">Other result.</param>
 <param name="checkIfCurrentHasOverloads">
 If the checkIfCurrentHasOverloads is True, then we only overload if every symbol in 
 our current result has "Overloads" modifier; otherwise we overload 
 regardless of the modifier.
 </param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LookupResult.CompareAccessibilityOfSymbolsConflictingInSameContainer(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Returns: negative value - when first lost, 0 - when neither lost, > 0 - when second lost.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LookupResult.ResolveAmbiguityInTheSameNamespace(Microsoft.CodeAnalysis.VisualBasic.SingleLookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol,Microsoft.CodeAnalysis.VisualBasic.LookupOptions)">
 <summary>
 Returns: negative value - when current lost, 0 - when neither lost, > 0 - when other lost.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LookupResult.ResolveAmbiguityInTheSameNamespace(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol)">
 <summary>
 Returns: negative value - when first lost, 0 - when neither lost, > 0 - when second lost.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LookupResult.ResolveAmbiguityBetweenTypeAndMergedNamespaceInTheSameNamespace(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Returns: negative value - when namespace lost, 0 - when neither lost, > 0 - when type lost.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LookupResult.ReplaceSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Replace the symbol replaced with a new one, but the kind
 and diagnostics retained from the current result. Typically used when constructing
 a type from a symbols and type arguments.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel">
 <summary>
 Binding info for expressions and statements that are part of a member declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetUpperBoundNode(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Get the highest bound node in the tree associated with a particular syntax node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Get the lowest bound node in the tree associated with a particular syntax node. Lowest is defined as last
 in a pre-order traversal of the bound tree.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetBindableParent(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 If node has an immediate parent that is an expression or statement or attribute, return
 that (making sure it can be bound on its own). Otherwise return Nothing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetBoundNodeSummary(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Get a summary of the bound nodes associated with a particular syntax nodes,
 and its parent. This is what the rest of the semantic model uses to determine
 what to return back.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetInvokeSummaryForRaiseEvent(Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax)">
 <summary>
 Gets a summary of the bound nodes associated with an underlying
 bound call node for a raiseevent statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.UnwrapRaiseEvent(Microsoft.CodeAnalysis.VisualBasic.BoundNode)">
 <summary>
 if "node" argument is a BoundRaiseEvent, returns its underlying boundcall instead.
 Otherwise returns "node" unchanged.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.IsStandaloneStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)">
 <summary>
 Return True if the statement can be bound by a Binder on its own.
 For example Catch statement cannot be bound on its own, only 
 as part of Try block. Similarly, Next statement cannot be bound on its own,
 only as part of For statement.
 
 Only handles statements that are in executable code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetSyntaxDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
 <summary>
 Get all of the syntax errors within the syntax tree associated with this
 object. Does not get errors involving declarations or compiling method bodies or initializers.
 </summary>
 <param name="span">Optional span within the syntax tree for which to get diagnostics.
 If no argument is specified, then diagnostics for the entire tree are returned.</param>
 <param name="cancellationToken">A cancellation token that can be used to cancel the
 process of obtaining the diagnostics.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetDeclarationDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
 <summary>
 Get all the syntax and declaration errors within the syntax tree associated with this object. Does not get
 errors involving compiling method bodies or initializers.
 </summary>
 <param name="span">Optional span within the syntax tree for which to get diagnostics.
 If no argument is specified, then diagnostics for the entire tree are returned.</param>
 <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
 <remarks>The declaration errors for a syntax tree are cached. The first time this method is called, a ll
 declarations are analyzed for diagnostics. Calling this a second time will return the cached diagnostics.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetMethodBodyDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
 <summary>
 Get all the syntax and declaration errors within the syntax tree associated with this object. Does not get
 errors involving compiling method bodies or initializers.
 </summary>
 <param name="span">Optional span within the syntax tree for which to get diagnostics.
 If no argument is specified, then diagnostics for the entire tree are returned.</param>
 <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
 <remarks>The declaration errors for a syntax tree are cached. The first time this method is called, a ll
 declarations are analyzed for diagnostics. Calling this a second time will return the cached diagnostics.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
 <summary>
 Get all the errors within the syntax tree associated with this object. Includes errors involving compiling
 method bodies or initializers, in addition to the errors returned by GetDeclarationDiagnostics.
 </summary>
 <param name="span">Optional span within the syntax tree for which to get diagnostics.
 If no argument is specified, then diagnostics for the entire tree are returned.</param>
 <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
 <remarks>
 Because this method must semantically all method bodies and initializers to check for diagnostics, it may
 take a significant amount of time. Unlike GetDeclarationDiagnostics, diagnostics for method bodies and
 initializers are not cached, the any semantic information used to obtain the diagnostics is discarded.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a type declaration, get the corresponding type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a type.</param>
 <returns>The type symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a enum declaration, get the corresponding type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares an enum.</param>
 <returns>The type symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a namespace declaration, get the corresponding type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a namespace.</param>
 <returns>The namespace symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBaseSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a method, property, or event declaration, get the corresponding symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a method, property, or event.</param>
 <returns>The method, property, or event symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a parameter declaration, get the corresponding parameter symbol.
 </summary>
 <param name="parameter">The syntax node that declares a parameter.</param>
 <returns>The parameter symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an import clause get the corresponding symbol for the import alias that was introduced.
 </summary>
 <param name="declarationSyntax">The import statement syntax node.</param>
 <returns>The alias symbol that was declared or Nothing if no alias symbol was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a type parameter declaration, get the corresponding type parameter symbol.
 </summary>
 <param name="typeParameter">The syntax node that declares a type parameter.</param>
 <returns>The type parameter symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetForEachStatementInfoWorker(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax)">
 <summary>
 Gets the semantic information of a for each statement.
 </summary>
 <param name="node">The for each syntax node.</param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.SyntaxTree">
 <summary> 
 The SyntaxTree that is bound
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetEnclosingBinderInternal(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Int32)">
 <summary>
 Get the correct enclosing binder for the given position, taking into account  
 block constructs and lambdas.
 </summary>
 <param name="memberBinder">Binder for the method body, lambda body, or field initializer. The
 returned binder will be nested inside the binder, or be this binder.</param>
 <param name="binderRoot">Syntax node that is the root of the construct associated with "memberBinder".</param>
 <param name="node">Syntax node that position is in.</param>
 <param name="position">Position we are finding the enclosing binder for.</param>
 <returns>The enclosing binder within "memberBinder" for the given position.</returns>
 <remarks>
 WARN WARN WARN: The result is not guaranteed to have IsSemanticModelBinder set.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.InQueryInterior(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Binder@)">
 <summary>
 If answer is True, the binder is returned via [binder] parameter.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.InAnonymousTypeInitializerInterior(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Binder@)">
 <summary>
 If answer is True, the binder is returned via [binder] parameter.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Get all bound nodes associated with a node, ordered from highest to lowest in the bound tree.
 Strictly speaking, the order is that of a pre-order traversal of the bound tree.
 As a side effect, caches nodes and binders.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.IsNonExpressionCollectionInitializer(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 A collection initializer syntax node is not always treated as a VB expression syntax node
 in case it's part of a CollectionInitializer (outer most or top level initializer).
 </summary>
 <param name="syntax">The syntax node to check.</param>
 <returns><c>True</c> if the syntax node represents an expression syntax, but it's not 
 an expression from the VB language point of view; otherwise <c>False</c>.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GuardedIncrementalBind(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Incrementally bind bindingRoot (which is always a non-lambda enclosed statement, or the
 root of this model). Side effect is to store nodes into the guarded node map.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetBindingRoot(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 In order that any expression level special binders are used, lambdas are fully resolved,
 and that any other binding context is correctly handled, we only use the binder to create bound
 nodes for:
   a) The root syntax of this semantic model (because there's nothing more outer to bind)
   b) A stand-alone statement is that is not inside a lambda.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.IncrementalBinder">
 <summary>
 The incremental binder is used when binding statements. Whenever a statement
 is bound, it checks the bound node cache to see if that statement was bound, 
 and returns it instead of rebinding it. 
 
 FOr example, we might have:
    While x > foo()
      y = y * x
      z = z + y
    End While
 
 We might first get semantic info about "z", and thus bind just the statement
 "z = z + y". Later, we might bind the entire While block. While binding the while
 block, we can reuse the binding we did of "z = z + y".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.IncrementalBinder.GetBinder(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 We override GetBinder so that the BindStatement override is still
 in effect on nested binders.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.IncrementalBinder.GetBinder(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 We override GetBinder so that the BindStatement override is still
 in effect on nested binders.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.SemanticModelMapsBuilder">
 <summary>
 Traverse a tree of bound nodes, and update the following maps inside the SemanticModel:
 
     guardedNodeMap  - a map from syntax node to bound nodes. Bound nodes are added in the order they are bound
                       traversing the tree, so they will be in order from upper to lower node.
 
     guardedQueryBindersMap - a map from query-specific syntax node to an array of binders used to
                              bind various children of the node.
 
     guardedAnonymousTypeBinderMap - a map from Anonymous Type initializer's FieldInitializerSyntax to
                                     Binder.AnonymousTypeFieldInitializerBinder used to bind its expression.
</summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.SemanticModelMapsBuilder.RecordNode(Microsoft.CodeAnalysis.VisualBasic.BoundNode,System.Boolean)">
 <summary>
 Should we record bound node mapping for this node? Generally, we ignore compiler generated, but optionally can
 allow.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.MethodBodyBinder">
 <summary>
 Provides context for binding body of a MethodSymbol. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodBodyBinder.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Create binder for binding the body of a method. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodBodySemanticModel.Create(Microsoft.CodeAnalysis.VisualBasic.SubOrFunctionBodyBinder,System.Boolean)">
 <summary>
 Creates an MethodBodySemanticModel that allows asking semantic questions about an attribute node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodBodySemanticModel.CreateSpeculative(Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Int32)">
 <summary>
 Creates a speculative MethodBodySemanticModel that allows asking semantic questions about an attribute node that did not appear in the original source code.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.MethodTypeParametersBinder">
 <summary>
 A MethodTypeParametersBinder provides the context for looking up type parameters on a method.
 It is split out since binding of type in the parameters and return value need to happen with a context
 that includes the type parameters, but we don't have a fully complete method symbol yet.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodTypeParametersBinder.LookupInSingleBinder(Microsoft.CodeAnalysis.VisualBasic.LookupResult,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Looks up the name in the type parameters
 a) type parameters in this type (but not outer or base types)
 Returns all members of that name, or empty list if none.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.NamedTypeBinder">
 <summary>
 A NamedTypeBinder provides the context for a type symbol; e.g., looking up names
 inside the type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.NamedTypeBinder.GetBinder(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Some nodes have special binder's for their contents 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.NamedTypeBinder.LookupInSingleBinder(Microsoft.CodeAnalysis.VisualBasic.LookupResult,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Gets all symbols of the particular name as 
 a) members of this type
 b) members of base types 
 c) type parameters in this type (but not outer or base types)
 In that order.
 
 Note, that section "11.4.4 Simple Name Expression" of VB Language spec 
 implies that type parameters are examined first, and only then members 
 of the type are examined. But this is inconsistent with Dev10 behavior.
 
 Returns all members of that name, or empty list if none.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.NamedTypeBinder.CollectProbableExtensionMethodsInSingleBinder(System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Collect extension methods with the given name that are in scope in this binder.
 The passed in ArrayBuilder must be empty. Extension methods from the same containing type
 must be grouped together. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.NamespaceBinder">
 <summary>
 A namespace binder provides the context for a namespace symbol; e.g., looking up names
 inside the namespace.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.NamespaceBinder.CollectProbableExtensionMethodsInSingleBinder(System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Collect extension methods with the given name that are in scope in this binder.
 The passed in ArrayBuilder must be empty. Extension methods from the same containing type
 must be grouped together. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ProjectImportsBinder">
 <summary>
 A ProjectImportsBinder provides the equivalent of a SourceFileBinder, but for the project-level
 imports, which don't live in any file.
 It primarily provides the services of getting locations of nodes, since it holds onto a SyntaxTree, although
 that tree isn't technically a source tree.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SemanticModelBinder">
 <summary>
 Returns True for <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Binder.IsSemanticModelBinder"/>
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SourceFileBinder">
 <summary>
 A SourceFileBinder provides the context associated with a give source file, not including the
 Imports statements (which have their own binders). It primarily provides the services of getting
 locations of node, since it holds onto a SyntaxTree.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SourceModuleBinder">
 <summary>
 A source module binder provides the context associated with a source module.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SpeculativeBinder">
 <summary>
 Binder used for speculatively binding.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SpeculativeMemberSemanticModel">
 <summary>
 Allows asking semantic questions about a TypeSyntax or RangeArgumentSyntax node within a member, that did not appear in the original source code.
 Typically, an instance is obtained by a call to SemanticModel.TryGetSpeculativeSemanticModel. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SpeculativeMemberSemanticModel.#ctor(Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Int32)">
 <summary>
 Creates a speculative SemanticModel for a TypeSyntax or a RangeArgumentSyntax node at a position within an existing MemberSemanticModel.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SpeculativeStatementBinder">
 <summary>
 Provides context for binding statements in speculative code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SpeculativeStatementBinder.#ctor(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Create binder for binding statements in speculative code. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SubOrFunctionBodyBinder">
 <summary>
 A SubOrFunctionBodyBinder provides context for looking up parameters/labels in a body of an executable entity (a method, lambda, or top-level script code), 
 and also for the implementation of ContainingMember, GetLocalForFunctionValue and GetBinder. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SymbolsInProgress`1">
 <summary>
 This is used while computing the values of constant symbols.  Since they can depend on each other,
 we need to keep track of which ones we are currently computing in order to avoid (and report) cycles.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager">
 <summary> 
 Manages anonymous types and delegates created on module level. All requests 
 for anonymous type/delegate symbols go via the instance of this class.
 
 Manager also is in charge of creating implementation types which are used in 
 emit phase to substitute anonymous type/delegate public symbols.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousType_IEquatable_EqualsMethodSymbol.BuildConditionForField(Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypePropertySymbol,Microsoft.CodeAnalysis.VisualBasic.BoundMeReference,Microsoft.CodeAnalysis.VisualBasic.BoundParameter,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary> 
 Builds a condition in the following form: 
 
 [preaction: localMyFieldBoxed = DirectCast(Me.field, System.Object)]
 [preaction: localOtherFieldBoxed = DirectCast(Other.field, System.Object)]
 IF(localMyFieldBoxed IsNot Nothing AndAlso localOtherFieldBoxed IsNot Nothing,
    localMyFieldBoxed.Equals(localOtherFieldBoxed),
    localMyFieldBoxed Is localOtherFieldBoxed
 ) 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.CheckAndReportMissingSymbols(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Checks if all special and well-known symbols required for emitting anonymous types 
 provided exist, if not reports errors and returns True.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.ContainingModule">
 <summary> Source module </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.Compilation">
 <summary> Owning compilationSource module </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.ConstructAnonymousTypeSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor)">
 <summary> 
 Given anonymous type descriptor provided construct an anonymous type symbol
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.ConstructAnonymousDelegateSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor)">
 <summary> 
 Given anonymous delegate descriptor provided, construct an anonymous delegate symbol
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.EqualsIgnoringCustomModifiers(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Compares anonymous types ignoring custom modifiers
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager._concurrentTypesCache">
 <summary> Cache of created anonymous types </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager._concurrentDelegatesCache">
 <summary> Cache of created anonymous delegates </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.ConstructAnonymousTypeImplementationSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypePublicSymbol)">
 <summary> 
 Given anonymous type public symbol construct an anonymous type symbol to be used 
 in emit; the type symbol is created based on generic type generated for each 
 'unique' anonymous type structure.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.ConstructAnonymousDelegateImplementationSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousDelegatePublicSymbol)">
 <summary> 
 Given anonymous delegate public symbol construct an anonymous type symbol to be 
 used in emit; the type symbol may be created based on generic type generated for 
 each 'unique' anonymous delegate structure OR if the delegate's signature is 
 'Sub()' it will be an instance of NonGenericAnonymousDelegateSymbol type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AssignTemplatesNamesAndCompile(Microsoft.CodeAnalysis.VisualBasic.MethodCompiler,Microsoft.CodeAnalysis.VisualBasic.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Resets numbering in anonymous type names and compiles the
 anonymous type methods. Also seals the collection of templates.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.TranslateAnonymousTypeSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Translates anonymous type public symbol into an implementation type symbol to be used in emit.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 Translates anonymous type method symbol into an implementation method symbol to be used in emit.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AllCreatedTemplates">
 <summary> Returns all templates owned by this type manager </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypePropertyPublicSymbol.PropertyIndex">
 <summary> Index of the property in the containing anonymous type </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegatePublicSymbol.GenerateDeclarationErrors(System.Threading.CancellationToken)">
 <summary>
 Force all declaration errors to be generated.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegatePublicSymbol.MapToImplementationSymbol">
 <summary> 
 Map an anonymous type or delegate public symbol to an implementation symbol to be 
 used in emit.
 
 NOTE: All anonymous types/delegated (except for delegate with signature 'Sub()') with the 
 same set of fields/parameters (field names and IsKey flags are taken into account) are 
 generated based on the same generic type template.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegatePublicSymbol.MapMethodToImplementationSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary> 
 Map an anonymous type or delegate's method symbol to an implementation method symbol to be used in emit
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegatePublicSymbol.FindSubstitutedMethodSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary> 
 Map an anonymous type or delegate's method symbol to a substituted method symbol.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.NonGenericAnonymousDelegateSymbol">
 <summary>
 This is a symbol to represent Anonymous Delegate for a lambda
 like:
        Sub() ...
 
 This delegate type doesn't have generic parameters. Unlike generic anonymous types,
 for which we are constructing new instance of substituted symbol for each use site 
 with reference to the location, we are creating new instance of this symbol with its
 own location for each use site. But all of them are representing the same delegate 
 type and are going to be equal to each other. 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypePropertySymbol.PropertyIndex">
 <summary> Index of the property in the containing anonymous type </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol._nameAndIndex">
 <summary>
 The name used to emit definition of the type. Will be set when the type's 
 metadata is ready to be emitted, Name property will throw exception if this field 
 is queried before that moment because the name is not defined yet.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol.TypeDescriptorKey">
 <summary>
 The key of the anonymous type descriptor used for this type template
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol.LocationAndNames">
 <summary> Describes the type descriptor location and property/parameter names associated with this location </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol.AdjustMetadataNames(Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor)">
 <summary>
 In emit phase every time a created anonymous type is referenced we try to adjust name of 
 template's fields as well as store the lowest location of the template. The last one will 
 be used for ordering templates and assigning emitted type names.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol.GenerateDeclarationErrors(System.Threading.CancellationToken)">
 <summary>
 Force all declaration errors to be generated.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorSymbol">
 <summary>
 This class represents a compiler generated parameterless constructor 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorSymbol.#ctor(Microsoft.CodeAnalysis.SyntaxReference,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorSymbol" /> class.
 </summary>
 <param name="syntaxReference"></param>
 <param name="container">The containing type for the synthesized constructor.</param>
 <param name="isShared">if set to <c>true</c> if this is a shared constructor.</param>
 <param name="isDebuggable">if set to <c>true</c> if this constructor will include debuggable initializers.</param>
 <param name="binder">Binder to be used for error reporting, or Nothing.</param>
 <param name="diagnostics">Diagnostic bag, or Nothing.</param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorSymbol.Parameters">
 <summary>
 The parameters forming part of this signature.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedStringSwitchHashMethod">
 <summary>
 This class represents a simple customizable hash method to hash the string constants
 corresponding to the case clause string constants.
 If we have at least one string type select case statement in a module that needs a
 hash table based jump table, we generate a single public string hash synthesized
 method (SynthesizedStringSwitchHashMethod) that is shared across the module.
 We must emit this function into the compiler generated PrivateImplementationDetails class.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedStringSwitchHashMethod.ComputeStringHash(System.String)">
 <summary>
 Compute the hashcode of a sub string using FNV-1a
 See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
 </summary>
 <remarks>
 This method should be kept consistent with MethodBodySynthesizer.ConstructStringSwitchHashFunctionBody
 The control flow in this method mimics lowered "for" loop. It is exactly what we want to emit
 to ensure that JIT can do range check hoisting.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedStringSwitchHashMethod.GetBoundMethodBody(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder@)">
 <summary>
 Construct a body for String Switch Hash Function
 </summary>
 <remarks>
 This method should be kept consistent with ComputeStringHash
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedStringSwitchHashMethod.Parameters">
 <summary>
 The parameters forming part of this signature.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Declaration">
<summary>
 A Declaration summarizes the declaration structure of a source file. Each entity declaration
 in the program that is a container (specifically namespaces, classes, interfaces, structs,
 and delegate declarations) is represented by a node in this tree.  At the top level, the
 compilation unit is treated as a declaration of the unnamed namespace.

 Special treatment is required for namespace declarations, because a single namespace
 declaration can declare more than one namespace.  For example, in the declaration

namespace A.B.C {}

we see that namespaces A and B and C are declared.  This declaration is represented as three
 declarations. All three of these ContainerDeclaration objects contain a reference to the
 syntax tree for the declaration.

 A "single" declaration represents a specific namespace or type declaration at a point in
 source code. A "root" declaration is a special single declaration which summarizes the
 contents of an entire file's types and namespaces.  Each source file is represented as a tree
 of single declarations.

 A "merged" declaration merges together one or more declarations for the same symbol.  For
 example, the root namespace has multiple single declarations (one in each source file) but
 there is a single merged declaration for them all.  Similarly partial classes may have
 multiple declarations, grouped together under the umbrella of a merged declaration.  In the
 common trivial case, a merged declaration for a single declaration contains only that single
 declaration.  The whole program, consisting of the set of all declarations in all of the
 source files, is represented by a tree of merged declarations.'''
</summary> 
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.DeclarationTable">
 <summary>
 A declaration table is a device which keeps track of type and namespace declarations from
 parse trees. It is optimized for the case where there is one set of declarations that stays
 constant, and a specific root namespace declaration corresponding to the currently edited
 file which is being added and removed repeatedly. It maintains a cache of information for
 "merging" the root declarations into one big summary declaration; this cache is efficiently
 re-used provided that the pattern of adds and removes is as we expect.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.DeclarationTableEntry">
 <summary>
 A wrapper around RootSingleNamespaceDeclaration. The namespace declaration
 is evaluated lazily to avoid evaluating the namespace and associated SyntaxTree
 for embedded syntax trees before we can determine whether the syntax tree is needed.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.GlobalNamespaceDeclaration">
 <summary>
 Represents global namespace. Namespace's name is always empty
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SingleNamespaceDeclaration.BestName``1(System.Collections.Immutable.ImmutableArray{``0},System.Boolean@)">
 <summary>
 This function is used to determine the best name of a type or namespace when there are multiple declarations that
 have the same name but with different spellings.
 If this declaration is part of the rootnamespace (specified by /rootnamespace:&lt;nsname&gt; this is considered the best name.
 Otherwise the best name of a type or namespace is the one that String.Compare considers to be less using a Ordinal.
 In practice this prefers uppercased or camelcased identifiers.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="singleDeclarations">The single declarations.</param>
 <param name="multipleSpellings">Set to true if there were multiple distinct spellings.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SingleNamespaceOrTypeDeclaration.BestName``1(System.Collections.Immutable.ImmutableArray{``0},System.Boolean@)">
 <summary>
 This function is used to determine the best name of a type or namespace when there are multiple declarations that
 have the same name but with different spellings.
 If this declaration is part of the rootnamespace (specified by /rootnamespace:&lt;nsname&gt; this is considered the best name.
 Otherwise the best name of a type or namespace is the one that String.Compare considers to be less using a Ordinal.
 In practice this prefers uppercased or camelcased identifiers.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="singleDeclarations">The single declarations.</param>
 <param name="multipleSpellings">Set to true if there were multiple distinct spellings.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol">
 <summary>
 An ArrayTypeSymbol represents an array type, such as Integer() or Object(,).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.CreateVBArray(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier},System.Int32,Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 Create a new ArrayTypeSymbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.CreateVBArray(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier},System.Int32,Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol)">
 <summary>
 Create a new ArrayTypeSymbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.CustomModifiers">
 <summary>
 Returns the list of custom modifiers, if any, associated with the array.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.Rank">
 <summary>
 Returns the number of dimensions of this array. A regular single-dimensional array
 has rank 1, a two-dimensional array has rank 2, etc.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.IsSZArray">
 <summary>
 Is this zero-based one-dimensional array, i.e. SZArray in CLR terms.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.Sizes">
 <summary>
 Specified sizes for dimensions, by position. The length can be less than <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.Rank"/>,
 meaning that some trailing dimensions don't have the size specified.
 The most common case is none of the dimensions have the size specified - an empty array is returned.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.LowerBounds">
 <summary>
 Specified lower bounds for dimensions, by position. The length can be less than <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.Rank"/>,
 meaning that some trailing dimensions don't have the lower bound specified.
 The most common case is all dimensions are zero bound - a null array is returned in this case.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.HasSameSizesAndLowerBoundsAs(Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol)">
 <summary>
 Note, <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.Rank"/> equality should be checked separately!!!
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.HasDefaultSizesAndLowerBounds">
 <summary>
 Normally VB arrays have default sizes and lower bounds - sizes are not specified and all dimensions are zero bound.
 This property should return false for any deviations.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.ElementType">
 <summary>
 Returns the type of the elements that are stored in this array.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.IsReferenceType">
 <summary>
 Returns true if this type is known to be a reference type. It is never the case
 that <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.IsValueType"/> both return true. However, for an unconstrained
 type parameter, <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.IsValueType"/> will both return false.
 </summary>
 <returns>True</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.IsValueType">
 <summary>
 Returns true if this type is known to be a value type. It is never the case
 that <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.IsValueType"/> both return true. However, for an unconstrained
 type parameter, <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.IsValueType"/> will both return false.
 </summary>
 <returns>False</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.GetMembers">
 <summary>
 Get all the members of this symbol.
 </summary>
 <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.GetMembers(System.String)">
 <summary>
 Get all the members of this symbol that have a particular name.
 </summary>
 <returns>An ImmutableArray containing all the members of this symbol with the given name. If there are
 no members with this name, returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.GetTypeMembers">
 <summary>
 Get all the members of this symbol that are types.
 </summary>
 <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.GetTypeMembers(System.String)">
 <summary>
 Get all the members of this symbol that are types that have a particular name, and any arity.
 </summary>
 <returns>An ImmutableArray containing all the types that are members of this symbol with the given name. 
 If this symbol has no type members with this name,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.GetTypeMembers(System.String,System.Int32)">
 <summary>
 Get all the members of this symbol that are types that have a particular name and arity.
 </summary>
 <returns>An ImmutableArray containing all the types that are members of this symbol with the given name and arity.
 If this symbol has no type members with this name and arity,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.Kind">
 <summary>
 Returns <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/> of the symbol.
 </summary>
 <returns><see cref="F:Microsoft.CodeAnalysis.SymbolKind.ArrayType"/></returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.TypeKind">
 <summary>
 Returns <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.TypeKind"/> of the symbol.
 </summary>
 <returns><see cref="F:Microsoft.CodeAnalysis.TypeKind.Array"/></returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.ContainingSymbol">
 <summary>
 Get the symbol that logically contains this symbol. 
 </summary>
 <returns>Nothing</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.Locations">
 <summary>
 Gets the locations where this symbol was originally defined, either in source
 or metadata. Some symbols (for example, partial classes) may be defined in more
 than one location.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.DeclaringSyntaxReferences">
 <summary>
 Get the syntax node(s) where this symbol was declared in source.
 </summary>
 <returns>
 An empty read-only array.
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.InternalSubstituteTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.SZOrMDArray.InternalSubstituteTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.SZArray">
 <summary>
 Represents SZARRAY - zero-based one-dimensional array 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.MDArray">
 <summary>
 Represents MDARRAY - multi-dimensional array (possibly of rank 1)
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData">
 <summary>
 Represents an attribute applied to a Symbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData.AttributeClass">
 <summary>
 Gets the attribute class being applied.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData.AttributeConstructor">
 <summary>
 Gets the constructor used in this application of the attribute.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData.ApplicationSyntaxReference">
 <summary>
 Gets a reference to the source for this application of the attribute. Returns null for applications of attributes on metadata Symbols.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData.ConstructorArguments">
 <summary>
 Gets the list of constructor arguments specified by this application of the attribute.  This list contains both positional arguments
 and named arguments that are formal parameters to the constructor.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData.NamedArguments">
 <summary>
 Gets the list of named field or property value arguments specified by this application of the attribute.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData.IsTargetAttribute(System.String,System.String,System.Boolean)">
 <summary>
 Compares the namespace and type name with the attribute's namespace and type name.  Returns true if they are the same.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData.IsTargetEarlyAttribute(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.AttributeDescription)">
 <summary>
 Checks if an applied attribute with the given attributeType matches the namespace name and type name of the given early attribute's description
 and the attribute description has a signature with parameter count equal to the given attribute syntax's argument list count.
 NOTE: We don't allow early decoded attributes to have optional parameters.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData.ToString">
 <summary>
 Returns the <see cref="T:System.String"/> that represents the current AttributeData.
 </summary>
 <returns>A <see cref="T:System.String"/> that represents the current AttributeData.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData.CommonAttributeClass">
 <summary>
 Gets the attribute class being applied as an <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData.CommonAttributeConstructor">
 <summary>
 Gets the constructor used in this application of the attribute as an <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData.CommonApplicationSyntaxReference">
 <summary>
 Gets a reference to the source for this application of the attribute. Returns null for applications of attributes on metadata Symbols.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData.DecodePermissionSetAttribute(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData,Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation}@)">
 <summary>
 Decodes PermissionSetAttribute applied in source to determine if it needs any fixup during codegen.
 </summary>
 <remarks>
 PermissionSetAttribute needs fixup when it contains an assignment to the 'File' property as a single named attribute argument.
 Fixup performed is ported from SecurityAttributes::FixUpPermissionSetAttribute.
 It involves following steps:
  1) Verifying that the specified file name resolves to a valid path.
  2) Reading the contents of the file into a byte array.
  3) Convert each byte in the file content into two bytes containing hexa-decimal characters.
  4) Replacing the 'File = fileName' named argument with 'Hex = hexFileContent' argument, where hexFileContent is the converted output from step 3) above.

 Step 1) is performed in this method, i.e. during binding.
 Remaining steps are performed during serialization as we want to avoid retaining the entire file contents throughout the binding/codegen pass.
 See <see cref="T:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference"/> for remaining fixup steps.
 </remarks>
 <returns>String containing the resolved file path if PermissionSetAttribute needs fixup during codegen, null otherwise.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData.ShouldEmitAttribute(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Boolean,System.Boolean)">
 <summary>
  This method determines if an applied attribute must be emitted. 
 Some attributes appear in symbol model to reflect the source code, but should not be emitted.
  </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicCustomModifier">
 <summary>
 Represents a custom modifier (modopt/modreq).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicCustomModifier.Modifier">
 <summary>
 A type used as a tag that indicates which type of modification applies.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol">
 <summary>
 Represents an event.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol.OriginalDefinition">
 <summary>
 Get the original definition of this symbol. If this symbol is derived from another
 symbol by (say) type substitution, this gets the original symbol, as it was defined
 in source or metadata.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol.HasSpecialName">
 <summary>
  True if this symbol has a special name (metadata flag SpecialName is set).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol.GetFieldAttributes">
 <summary>
 Gets the attributes on event's associated field, if any.
 </summary>
 <returns>Returns an array of <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData"/> or an empty array if there are no attributes.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol.AssociatedField">
 <summary>
 Backing field of the event, or Nothing if the event doesn't have any.
 </summary>
 <remarks>
 Events imported from metadata return Nothing.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol.DelegateParameters">
 <summary>
 Gets the parameters of this event. If this event has no parameters, returns
 an empty list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol.DelegateReturnType">
 <summary>
 Gets the return type of the event (typically System.Void). 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol.DelegateReturnTypeCustomModifiers">
 <summary>
 Returns the list of custom modifiers, if any, associated with the return type of the event. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol.DelegateInvokeMethod">
 <summary>
 Can be null in error cases.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol.Accept``2(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSymbolVisitor{``0,``1},``0)">
 <summary>
 Implements visitor pattern.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol">
 <summary>
 Represents a member variable -- a variable declared as a member of a Class or Structure. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.OriginalDefinition">
 <summary>
 Get the original definition of this symbol. If this symbol is derived from another
 symbol by (say) type substitution, this gets the original symbol, as it was defined
 in source or metadata.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.Type">
 <summary>
 Gets the type of this variable.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.HasDeclaredType">
 <summary>
 Gets a value indicating whether this instance has declared type. This means a field was declared with an AsClause
 or in case of const fields with an AsClause whose type is not System.Object
 </summary>
 <value>
 <c>true</c> if this instance has declared type; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.CustomModifiers">
 <summary>
 The list of custom modifiers, if any, associated with the member variable.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.AssociatedSymbol">
 <summary>
 If this variable serves as a backing variable for an automatically generated
 property or event, returns that property or event. 
 Otherwise returns Nothing.
 Note, the set of possible associated symbols might be expanded in the future to 
 reflect changes in the languages.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.IsReadOnly">
 <summary>
 Returns true if this variable was declared as ReadOnly 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.IsConst">
 <summary>
 Returns true if this field was declared as "const" (i.e. is a constant declaration), or
 is an Enum member.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.IsMetadataConstant">
 <summary>
 Gets a value indicating whether this instance is metadata constant. A field is considered to be 
 metadata constant if the field value is a valid default value for a field.
 </summary>
 <value>
 <c>true</c> if this instance is metadata constant; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.IsConstButNotMetadataConstant">
 <summary>
 Gets a value indicating whether this instance is const, but not metadata constant. A field is considered to be 
 const but not metadata constant if the const field's type is either Date or Decimal.
 </summary>
 <value>
 <c>true</c> if this instance is metadata constant; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.HasConstantValue">
 <summary>
 Returns false if the field wasn't declared as "const", or constant value was omitted or erroneous.
 True otherwise.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.ConstantValue">
 <summary>
 If IsConst returns true, then returns the value of the constant or Enum member.
 If IsConst return false, then returns Nothing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.GetConstantValue(Microsoft.CodeAnalysis.VisualBasic.SymbolsInProgress{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol})">
 <summary>
 Gets the constant value.
 </summary>
 <param name="inProgress">The previously visited const fields; used to detect cycles.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.GetInferredType(Microsoft.CodeAnalysis.VisualBasic.SymbolsInProgress{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol})">
 <summary>
 Const fields do not (always) have to be declared with a given type. To get the inferred type determined from
 the initialization this method should be called instead of "Type". For non const field this method returns the
 declared type.
 </summary>
 <param name="inProgress">The previously visited const fields; used to detect cycles.</param><returns></returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.HasSpecialName">
 <summary>
  True if this symbol has a special name (metadata flag SpecialName is set).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.HasRuntimeSpecialName">
 <summary>
 True if RuntimeSpecialName metadata flag is set for this symbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.IsNotSerialized">
 <summary>
 True if NotSerialized metadata flag is set for this symbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.MarshallingInformation">
 <summary>
 Describes how the field is marshalled when passed to native code.
 Null if no specific marshalling information is available for the field.
 </summary>
 <remarks>PE symbols don't provide this information and always return Nothing.</remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.MarshallingType">
 <summary>
 Returns the marshalling type of this field, or 0 if marshalling information isn't available.
 </summary>
 <remarks>
 By default this information is extracted from <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.MarshallingInformation"/> if available. 
 Since the compiler does only need to know the marshalling type of symbols that aren't emitted 
 PE symbols just decode the type from metadata and don't provide full marshalling information.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.TypeLayoutOffset">
 <summary>
 Offset assigned to the field when the containing type is laid out by the VM.
 Nothing if unspecified.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.MeParameter">
 <summary>
 Get the "this" parameter for this field.  This is only valid for source fields.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.IsCapturedFrame">
 <summary>
 Returns true when field is a backing field for a captured frame pointer (typically "Me").
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol.HighestPriorityUseSiteError">
 <summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsMetadataNewSlot(System.Boolean)">
 <summary>
 This method indicates whether or not the runtime will regard the method
 as newslot (as indicated by the presence of the "newslot" modifier in the
 signature).
 WARN WARN WARN: We won't have a final value for this until declaration
 diagnostics have been computed for all <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol"/>s,
 so pass ignoringInterfaceImplementationChanges: True if you need a value sooner
 and aren't concerned about tweaks made to satisfy interface implementation 
 requirements.
 NOTE: Not ignoring changes can only result in a value that is more true.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.MethodKind">
 <summary>
 Gets what kind of method this is. There are several different kinds of things in the
 VB language that are represented as methods. This property allow distinguishing those things
 without having to decode the name of the method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsMethodKindBasedOnSyntax">
 <summary>
 True, if the method kind was determined by examining a syntax node (i.e. for source methods -
 including substituted and retargeted ones); false, otherwise.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsVararg">
 <summary>
 Returns whether this method is using VARARG calling convention.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsCheckedBuiltin">
 <summary>
 Returns whether this built-in operator checks for integer overflow.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsGenericMethod">
 <summary>
 Returns whether this method is generic; i.e., does it have any type parameters?
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.Arity">
 <summary>
 Returns the arity of this method, or the number of type parameters it takes.
 A non-generic method has zero arity.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.TypeParameters">
 <summary>
 Get the type parameters on this method. If the method has not generic,
 returns an empty list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.TypeArguments">
 <summary>
 Returns the type arguments that have been substituted for the type parameters. 
 If nothing has been substituted for a give type parameters,
 then the type parameter itself is consider the type argument.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.OriginalDefinition">
 <summary>
 Get the original definition of this symbol. If this symbol is derived from another
 symbol by (say) type substitution, this gets the original symbol, as it was defined
 in source or metadata.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ConstructedFrom">
 <summary>
 Returns the method symbol that this method was constructed from. This method symbol
 has the same containing type (if any), but has type arguments that are the same
 as the type parameters (although its containing type might not).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsSub">
 <summary>
 Returns true if this method has no return type; i.e., is a Sub instead of a Function.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsAsync">
 <summary>
 Source: Returns whether this method is async; i.e., does it have the Async modifier?
 Metadata: Returns False; methods from metadata cannot be async.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsIterator">
 <summary>
 Source: Returns whether this method is an iterator; i.e., does it have the Iterator modifier?
 Metadata: Returns False; methods from metadata cannot be an iterator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ReturnType">
 <summary>
 Gets the return type of the method. If the method is a Sub, returns
 the same type symbol as is returned by Compilation.VoidType.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ReturnTypeCustomModifiers">
 <summary>
 Returns the list of custom modifiers, if any, associated with the returned value. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.GetReturnTypeAttributes">
 <summary>
 Returns the list of attributes, if any, associated with the return type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ParameterCount">
 <summary>
 Optimization: in many cases, the parameter count (fast) is sufficient and we
 don't need the actual parameter symbols (slow).
 </summary>
 <remarks>
 The default implementation is always correct, but may be unnecessarily slow.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.Parameters">
 <summary>
 Gets the parameters of this method. If this method has no parameters, returns
 an empty list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.Syntax">
 <summary>
 Should return syntax node that originated the method. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.CallsAreOmitted(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Returns true if calls to this method are omitted in the given syntax tree at the given syntax node location.
 Calls are omitted when the called method is a partial method with no implementation part, or when the
 called method is a conditional method whose condition is not true at the given syntax node location in the source file
 corresponding to the given syntax tree.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.CallsAreConditionallyOmitted(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Calls are conditionally omitted if all the following requirements are true:
  (a) Me.IsSub == True.
  (b) Containing type is not an interface type.
  (c) Me.IsConditional == True, i.e. it has at least one applied conditional attribute.
  (d) This method is not the Property Set method.
  (e) None of conditional symbols corresponding to these conditional attributes are true at the given syntax node location.
 </summary>
 <remarks>
 Forces binding and decoding of attributes.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.GetAppliedConditionalSymbols">
 <summary>
 Returns a sequence of preprocessor symbols specified in <see cref="T:System.Diagnostics.ConditionalAttribute"/> applied on this symbol, or null if there are none.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsConditional">
 <summary>
 Returns a flag indicating whether this symbol has at least one applied conditional attribute.
 </summary>
 <remarks>
 Forces binding and decoding of attributes.
 NOTE: Conditional symbols on the overridden method must be inherited by the overriding method, but the native VB compiler doesn't do so. We maintain compatibility.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.HasSpecialName">
 <summary>
 True if this symbol has a special name (metadata flag SpecialName is set).
 </summary>
 <remarks>
 This is set for methods with special semantics such as constructors or accessors
 as well as in special synthetic methods such as lambdas.
 Also set for methods marked with System.Runtime.CompilerServices.SpecialNameAttribute.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.AssociatedSymbol">
 <summary>
 If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,
 returns the property that this method is the getter or setter for.
 If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,
 returns the event that this method is the adder or remover for.
 Note, the set of possible associated symbols might be expanded in the future to 
 reflect changes in the languages.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.AssociatedAnonymousDelegate">
 <summary>
 If this method is a Lambda method (MethodKind = MethodKind.LambdaMethod) and 
 there is an anonymous delegate associated with it, returns this delegate.
 
 Returns Nothing if the symbol is not a lambda or if it does not have an
 anonymous delegate associated with it.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.OverriddenMethod">
 <summary>
 If this method overrides another method (because it both had the Overrides modifier
 and there correctly was a method to override), returns the overridden method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ExplicitInterfaceImplementations">
 <summary>
 Returns interface methods explicitly implemented by this method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsExternalMethod">
 <summary>
 Returns true if this method is not implemented in IL of the assembly it is defined in.
 </summary>
 <remarks>
 External methods are 
 1) Declare Subs and Declare Functions, 
 2) methods marked by <see cref="T:System.Runtime.InteropServices.DllImportAttribute"/>, 
 3) methods marked by <see cref="T:System.Runtime.CompilerServices.MethodImplAttribute"/> 
    with <see cref="T:System.Runtime.CompilerServices.MethodImplOptions.InternalCall"/> or 
    <see cref="T:System.Runtime.CompilerServices.MethodCodeType.Runtime"/> flags.
 4) Synthesized constructors of ComImport types
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.GetDllImportData">
 <summary>
 Returns platform invocation information for this method if it is a PlatformInvoke method, otherwise returns Nothing.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ReturnTypeMarshallingInformation">
 <summary>
 Marshalling information for return value (FieldMarshal in metadata). 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ImplementationAttributes">
 <summary>
 Misc implementation metadata flags (ImplFlags in metadata).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.GetSecurityInformation">
 <summary>
 Declaration security information associated with this method, or null if there is none.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.HasDeclarativeSecurity">
 <summary>
 True if the method has declarative security information (HasSecurity flags).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsExtensionMethod">
 <summary>
 Returns true if this method is an extension method from the VB language perspective; 
 i.e., declared with an Extension attribute and meets other language requirements.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.MayBeReducibleExtensionMethod">
 <summary>
 Returns true if this method might be a reducible extension method. This method may return true
 even if the method is not an extension method, but if it returns false, it must be the
 case that this is not an extension method.
 
 Allows checking extension methods from source in a quicker manner than fully binding attributes.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsOverloads">
 <summary>
 Returns true if this method hides a base method by name and signature.
 The equivalent of the "hidebysig" flag in metadata. 
 </summary>
 <remarks>
 This property should not be confused with general method overloading in Visual Basic, and is not directly related. 
 This property will only return true if this method hides a base method by name and signature (Overloads keyword).
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsRuntimeImplemented">
 <summary>
 True if the implementation of this method is supplied by the runtime.
 </summary>
 <remarks>
 <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsRuntimeImplemented"/> implies <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsExternalMethod"/>.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsEntryPointCandidate">
 <summary> 
 Determines whether this method is a candidate for a default 
 assembly entry point. Any method called "Main" is.
 </summary> 
 <returns>True if the method can be used as an entry point.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsAccessibleEntryPoint">
 <summary>
 Entry point is considered accessible if it is not private and none of the containing types is private (they all might be Family or Friend).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.HasEntryPointSignature">
 <summary> 
 Checks if the method has an entry point compatible signature, i.e. 
 - the return type is either void or int 
 - has either no parameter or a single parameter of type string[] 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.CheckCanConstructAndTypeArguments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol})">
 <summary> Checks for validity of Construct(...) on this method with these type arguments. </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.MeParameter">
 <summary>
 Call <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.TryGetMeParameter(Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol@)"/> and throw if it returns false.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.TryGetMeParameter(Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol@)">
 <returns>
 True if this <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol"/> type supports retrieving the Me parameter
 and false otherwise.  Note that a return value of true does not guarantee a non-Nothing
 <paramref name="meParameter"/> (e.g. fails for shared methods).
 </returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.HighestPriorityUseSiteError">
 <summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ReducedFrom">
 <summary>
 If this method is a reduced extension method, gets the extension method definition that
 this method was reduced from. Otherwise, returns Nothing.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.IsReducedExtensionMethod">
 <summary>
 Is this a reduced extension method?
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.CallsiteReducedFromMethod">
 <summary>
 If this method is a reduced extension method, gets the extension method (possibly constructed) that
 should be used at call site during ILGen. Otherwise, returns Nothing.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ReceiverType">
 <summary>
 If this method can be applied to an object, returns the type of object it is applied to.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.GetTypeInferredDuringReduction(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol)">
 <summary>
 If this method is a reduced extension method, returns a type inferred during reduction process for the type parameter. 
 </summary>
 <param name="reducedFromTypeParameter">Type parameter of the corresponding <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ReducedFrom"/> method.</param>
 <returns>Inferred type or Nothing if nothing was inferred.</returns>
 <exception cref="T:System.InvalidOperationException">If this is not a reduced extension method.</exception>
 <exception cref="T:System.ArgumentNullException">If <paramref name="reducedFromTypeParameter"/> is Nothing.</exception>
 <exception cref="T:System.ArgumentException">If <paramref name="reducedFromTypeParameter"/> doesn't belong to the corresponding <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ReducedFrom"/> method.</exception>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.FixedTypeParameters">
 <summary>
 Fixed type parameters for a reduced extension method or empty.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ReduceExtensionMethod(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Int32)">
 <summary>
 If this is an extension method that can be applied to a instance of the given type,
 returns the reduced method symbol thus formed. Otherwise, returns Nothing.
 
 Name lookup should use this method in order to capture proximity, which affects 
 overload resolution. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ReduceExtensionMethod(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 If this is an extension method that can be applied to a instance of the given type,
 returns the reduced method symbol thus formed. Otherwise, returns Nothing.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.Proximity">
 <summary>
 Proximity level of a reduced extension method.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.GetBoundMethodBody(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder@)">
 <summary> 
 Returns bound block representing method's body. This method is called 
 by 'method compiler' when it is ready to emit IL code for the method.
 
 The bound method body is typically a high-level tree - it may contain 
 lambdas, foreach etc... which will be processed in CompileMethod(...)
 </summary>
 <param name="methodBodyBinder">Optionally returns a binder, OUT parameter!</param>
 <remarks>
 The method MAY return a binder used for binding so it can be reused later in method compiler
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.GenerateDebugInfoImpl">
 <remarks>
 True iff the method contains user code.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.CalculateLocalSyntaxOffset(System.Int32,Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Calculates a syntax offset for a local (user-defined or long-lived synthesized) declared at <paramref name="localPosition"/>.
 Must be implemented by all methods that may contain user code.
 </summary>
 <remarks>
 Syntax offset is a unique identifier for the local within the emitted method body.
 It's based on position of the local declarator. In single-part method bodies it's simply the distance
 from the start of the method body syntax span. If a method body has multiple parts (such as a constructor 
 comprising of code for member initializers and constructor initializer calls) the offset is calculated
 as if all source these parts were concatenated together and prepended to the constructor body.
 The resulting syntax offset is then negative for locals defined outside of the constructor body.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.PreserveOriginalLocals">
 <summary>
 Specifies whether existing, "unused" locals (corresponding to proxies) are preserved during lambda rewriting.
 </summary>
 <remarks>
 This value will be checked by the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter"/> and is needed so that existing locals aren't
 omitted in the EE (method symbols in the EE will override this property to return True).
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.ISymbol_IsExtern">
 <summary>
 Returns true if this symbol is defined outside of the compilation.
 For instance if the method is <c>Declare Sub</c>.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.PartialImplementationPart">
 <summary>
 If this is a partial method declaration without a body, and the method also
 has a part that implements it with a body, returns that implementing
 definition.  Otherwise null.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol.PartialDefinitionPart">
 <summary>
 If this is a partial method with a body, returns the corresponding
 definition part (without a body).  Otherwise null.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol">
 <summary>
 Represents a type other than an array, a type parameter.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetSynthesizedImplements">
 <summary>
 Should return Nothing if there are none.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.Arity">
 <summary>
 Returns the arity of this type, or the number of type parameters it takes.
 A non-generic type has zero arity.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.TypeParameters">
 <summary>
 Returns the type parameters that this type has. If this is a non-generic type,
 returns an empty ImmutableArray.  
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.TypeArguments">
 <summary>
 Returns the type arguments that have been substituted for the type parameters. 
 If nothing has been substituted for a give type parameters,
 then the type parameter itself is consider the type argument.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.TypeArgumentsCustomModifiers">
 <summary>
 Returns custom modifiers for the type arguments that have been substituted for the type parameters. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.ConstructedFrom">
 <summary>
 Returns the type symbol that this type was constructed from. This type symbol
 has the same containing type, but has type arguments that are the same
 as the type parameters (although its containing type might not).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.EnumUnderlyingType">
 <summary>
 For enum types, gets the underlying type. Returns null on all other
 kinds of types.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.AssociatedSymbol">
 <summary>
 For implicitly declared delegate types returns the EventSymbol that caused this
 delegate type to be generated.
 For all other types returns null.
 Note, the set of possible associated symbols might be expanded in the future to 
 reflect changes in the languages.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.KnownCircularStruct">
 <summary>
 Returns True for one of the types from a set of Structure types if
 that set represents a cycle. This property is intended for flow
 analysis only since it is only implemented for source types,
 and only returns True for one of the types within a cycle, not all.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsExplicitDefinitionOfNoPiaLocalType">
 <summary>
 Is this a NoPia local type explicitly declared in source, i.e.
 top level type with a TypeIdentifier attribute on it?
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetGuidString(System.String@)">
 <summary>
 Returns true and a string from the first GuidAttribute on the type, 
 the string might be null or an invalid guid representation. False, 
 if there is no GuidAttribute with string argument.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.MangleName">
 <summary>
 Should the name returned by Name property be mangled with [`arity] suffix in order to get metadata name.
 Must return False for a type with Arity == 0.
 </summary>
 <remarks>
 Default implementation to force consideration of appropriate implementation for each new subclass
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.HasSpecialName">
 <summary>
  True if this symbol has a special name (metadata flag SpecialName is set).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsSerializable">
 <summary>
  True if this type is considered serializable (metadata flag Serializable is set).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.Layout">
 <summary>
 Type layout information (ClassLayout metadata and layout kind flags).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.DefaultMarshallingCharSet">
 <summary>
 The default charset used for type marshalling. 
 Can be changed via <see cref="T:System.Runtime.InteropServices.DefaultCharSetAttribute"/> applied on the containing module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.MarshallingCharSet">
 <summary>
 Marshalling charset of string data fields within the type (string formatting flags in metadata).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.DelegateInvokeMethod">
 <summary>
 For delegate types, gets the delegate's invoke method.  Returns null on
 all other kinds of types.  Note that it is possible to have an ill-formed 
 delegate type imported from metadata which does not have an Invoke method.
 Such a type will be classified as a delegate but its DelegateInvokeMethod
 would be null.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsMustInherit">
 <summary>
 Returns true if this type was declared as requiring a derived class;
 i.e., declared with the "MustInherit" modifier. Always true for interfaces.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsNotInheritable">
 <summary>
 Returns true if this type does not allow derived types; i.e., declared
 with the NotInheritable modifier, or else declared as a Module, Structure,
 Enum, or Delegate.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.MightContainExtensionMethods">
 <summary>
 If this property returns false, it is certain that there are no extension
 methods inside this type. If this property returns true, it is highly likely
 (but not certain) that this type contains extension methods. This property allows
 the search for extension methods to be narrowed much more quickly.
 
 !!! Note that this property can mutate during lifetime of the symbol !!!
 !!! from True to False, as we learn more about the type.             !!! 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.HasEmbeddedAttribute">
 <summary>
 Returns True if the type is marked by 'Microsoft.VisualBasic.Embedded' attribute. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsExtensibleInterfaceNoUseSiteDiagnostics">
 <summary>
 A Named type is an extensible interface if both the following are true:
 (a) It is an interface type and
 (b) It is either marked with 'TypeLibTypeAttribute( flags w/o TypeLibTypeFlags.FNonExtensible )' attribute OR
     is marked with 'InterfaceTypeAttribute( flags with ComInterfaceType.InterfaceIsIDispatch )' attribute OR
     inherits from an extensible interface type.
 Member resolution for Extensible interfaces is late bound, i.e. members are resolved at run time by looking up the identifier on the actual run-time type of the expression. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.AppendProbableExtensionMethods(System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol})">
 <summary>
 This method is an entry point for the Binder to collect extension methods with the given name
 declared within this named type. Overridden by RetargetingNamedTypeSymbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.BuildExtensionMethodsMap(System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol}},Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol)">
 <summary>
 This method is called for a type within a namespace when we are building a map of extension methods 
 for the whole (compilation merged or module level) namespace.
 
 The 'appendThrough' parameter allows RetargetingNamespaceSymbol to delegate majority of the work 
 to the underlying named type symbols, but still add RetargetingMethodSymbols to the map.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.AddExtensionMethodLookupSymbolsInfo(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 This is an entry point for the Binder. Its purpose is to add names of viable extension methods declared 
 in this type to nameSet parameter.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.AddExtensionMethodLookupSymbolsInfo(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Add names of viable extension methods declared in this type to nameSet parameter.
 
 The 'appendThrough' parameter allows RetargetingNamedTypeSymbol to delegate majority of the work 
 to the underlying named type symbol, but still perform viability check on RetargetingMethodSymbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.InstanceConstructors">
 <summary>
 Get the instance constructors for this type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.SharedConstructors">
 <summary>
 Get the shared constructors for this type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.Constructors">
 <summary>
 Get the instance and shared constructors for this type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsReferenceType">
 <summary>
 Returns true if this type is known to be a reference type. It is never the case
 that IsReferenceType and IsValueType both return true. However, for an unconstrained
 type parameter, IsReferenceType and IsValueType will both return false.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsValueType">
 <summary>
 Returns true if this type is known to be a value type. It is never the case
 that IsReferenceType and IsValueType both return true. However, for an unconstrained
 type parameter, IsReferenceType and IsValueType will both return false.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.CanConstruct">
 <summary>
 Returns True if this types has Arity >= 1 and Construct can be called. This is primarily useful
 when deal with error cases.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.Construct(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol[])">
 <summary>
 Returns a constructed type given its type arguments.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.Construct(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol})">
 <summary>
 Returns a constructed type given its type arguments.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.Construct(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol})">
 <summary>
 Construct a new type from this type, substituting the given type arguments for the 
 type parameters. This method should only be called if this named type does not have
 any substitutions applied for its own type arguments with exception of alpha-rename
 substitution (although it's container might have substitutions applied).
 </summary>
 <param name="typeArguments">A set of type arguments to be applied. Must have the same length
 as the number of type parameters that this type has.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.CheckCanConstructAndTypeArguments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol})">
 <summary> Checks for validity of Construct(...) on this type with these type arguments. </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.Construct(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Construct a new type from this type definition, substituting the given type arguments for the 
 type parameters. This method should only be called on the OriginalDefinition. Unlike previous 
 Construct method, this overload supports type parameter substitution on this type and any number
 of its containing types. See comments for TypeSubstitution type for more information.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.ConstructUnboundGenericType">
 <summary>
 Returns an unbound generic type of this generic named type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.DefaultPropertyName">
 <summary>
 Returns Default property name for the type.
 If there is no default property name, then Nothing is returned.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.TypeSubstitution">
 <summary>
 If this is a generic type instantiation or a nested type of a generic type instantiation,
 return TypeSubstitution for this construction. Nothing otherwise.
 Returned TypeSubstitution should target OriginalDefinition of the symbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.Name">
 <summary>
 Gets the name of this symbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.MemberNames">
 <summary>
 Collection of names of members declared within this type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsScriptClass">
 <summary>
 Returns true if the type is a Script class. 
 It might be an interactive submission class or a Script class in a csx file.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsSubmissionClass">
 <summary>
 Returns true if the type is a submission class. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsImplicitClass">
 <summary>
 Returns true if the type is the implicit class that holds onto invalid global members (like methods or
 statements in a non script file).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetMembers">
 <summary>
 Get all the members of this symbol.
 </summary>
 <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetMembers(System.String)">
 <summary>
 Get all the members of this symbol that have a particular name.
 </summary>
 <returns>An ImmutableArray containing all the members of this symbol with the given name. If there are
 no members with this name, returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetTypeMembers">
 <summary>
 Get all the members of this symbol that are types.
 </summary>
 <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetTypeMembers(System.String)">
 <summary>
 Get all the members of this symbol that are types that have a particular name, and any arity.
 </summary>
 <returns>An ImmutableArray containing all the types that are members of this symbol with the given name. 
 If this symbol has no type members with this name,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetTypeMembers(System.String,System.Int32)">
 <summary>
 Get all the members of this symbol that are types that have a particular name and arity.
 </summary>
 <returns>An ImmutableArray containing all the types that are members of this symbol with the given name and arity.
 If this symbol has no type members with this name and arity,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.DeclaredAccessibility">
 <summary>
 Get this accessibility that was declared on this symbol. For symbols that do
 not have accessibility declared on them, returns NotApplicable.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.Accept``2(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSymbolVisitor{``0,``1},``0)">
 <summary>
 Supports visitor pattern. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.Kind">
 <summary>
 Gets the kind of this symbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsComImport">
 <summary>
 Returns a flag indicating whether this symbol is ComImport.
 </summary>
 <remarks>
 A type can me marked as a ComImport type in source by applying the <see cref="T:System.Runtime.InteropServices.ComImportAttribute"/>
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.CoClassType">
 <summary>
 If CoClassAttribute was applied to the type returns the type symbol for the argument. 
 Type symbol may be an error type if the type was not found. Otherwise returns Nothing
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetAppliedConditionalSymbols">
 <summary>
 Returns a sequence of preprocessor symbols specified in <see cref="T:System.Diagnostics.ConditionalAttribute"/> applied on this symbol, or null if there are none.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsConditional">
 <summary>
 Returns a flag indicating whether this symbol has at least one applied conditional attribute.
 </summary>
 <remarks>
 Forces binding and decoding of attributes.
 NOTE: Conditional symbols on base type must be inherited by derived type, but the native VB compiler doesn't do so. We maintain compatibility.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetAttributeUsageInfo">
 <summary> 
 Gets the associated <see cref="T:Microsoft.CodeAnalysis.AttributeUsageInfo"/> for an attribute type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetSecurityInformation">
 <summary>
 Declaration security information associated with this type, or null if there is none.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.HasDeclarativeSecurity">
 <summary>
 True if the type has declarative security information (HasSecurity flags).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.MakeDeclaredBase(Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 NamedTypeSymbol calls derived implementations of this method when declared base type
 is needed for the first time.
 
 basesBeingResolved are passed if there are any types already have their bases resolved
 so that the derived implementation could avoid infinite recursion
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.MakeDeclaredInterfaces(Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 NamedTypeSymbol calls derived implementations of this method when declared interfaces
 are needed for the first time.
 
 basesBeingResolved are passed if there are any types already have their bases resolved
 so that the derived implementation could avoid infinite recursion
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetDeclaredBase(Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Base type as "declared".
 Declared base type may contain circularities.
 
 If DeclaredBase must be accessed while other DeclaredBases are being resolved, 
 the bases that are being resolved must be specified here to prevent potential infinite recursion.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetDeclaredInterfacesNoUseSiteDiagnostics(Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Interfaces as "declared".
 Declared interfaces may contain circularities.
 
 If DeclaredInterfaces must be accessed while other DeclaredInterfaces are being resolved, 
 the bases that are being resolved must be specified here to prevent potential infinite recursion.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.MakeAcyclicBaseType(Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 NamedTypeSymbol calls derived implementations of this method when acyclic base type
 is needed for the first time.
 This method typically calls GetDeclaredBase, filters for 
 illegal cycles and other conditions before returning result as acyclic.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.MakeAcyclicInterfaces(Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 NamedTypeSymbol calls derived implementations of this method when acyclic base interfaces
 are needed for the first time.
 This method typically calls GetDeclaredInterfaces, filters for 
 illegal cycles and other conditions before returning result as acyclic.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.BaseTypeNoUseSiteDiagnostics">
 <summary>
 Base type. 
 Could be Nothing for Interfaces or Object.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.InterfacesNoUseSiteDiagnostics">
 <summary>
 Interfaces that are implemented or inherited (if current type is interface itself).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetBestKnownBaseType">
 <summary>
 Returns declared base type or actual base type if already known
 This is only used by cycle detection code so that it can observe when cycles are broken 
 while not forcing actual Base to be realized.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetBestKnownInterfacesNoUseSiteDiagnostics">
 <summary>
 Returns declared interfaces or actual Interfaces if already known
 This is only used by cycle detection code so that it can observe when cycles are broken 
 while not forcing actual Interfaces to be realized.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsGenericType">
 <summary>
 True iff this type or some containing type has type parameters.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.OriginalDefinition">
 <summary>
 Get the original definition of this symbol. If this symbol is derived from another
 symbol by (say) type substitution, this gets the original symbol, as it was defined
 in source or metadata.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetEmittedNamespaceName">
 <summary>
 Should return full emitted namespace name for a top level type if the name 
 might be different in case from containing namespace symbol full name, Nothing otherwise.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.ImplementsAllMembersOfInterface(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Does this type implement all the members of the given interface. Does not include members
 of interfaces that iface inherits, only direct members.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsUnboundGenericType">
 <summary>
 True if this is a reference to an <em>unbound</em> generic type.  These occur only
 within a <code>GetType</code> expression.  A generic type is considered <em>unbound</em>
 if all of the type argument lists in its fully qualified name are empty.
 Note that the type arguments of an unbound generic type will be returned as error
 types because they do not really have type arguments.  An unbound generic type
 yields null for its BaseType and an empty result for its Interfaces.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GenerateDeclarationErrors(System.Threading.CancellationToken)">
 <summary>
 Force all declaration errors to be generated.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.GetSynthesizedNestedTypes">
 <summary>
 Return compiler generated nested types that are created at Declare phase, but not exposed through GetMembers and the like APIs.
 Should return Nothing if there are no such types.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsWindowsRuntimeImport">
 <summary>
 True if the type is a Windows runtime type.
 </summary>
 <remarks>
 A type can me marked as a Windows runtime type in source by applying the WindowsRuntimeImportAttribute.
 WindowsRuntimeImportAttribute is a pseudo custom attribute defined as an internal class in System.Runtime.InteropServices.WindowsRuntime namespace.
 This is needed to mark Windows runtime types which are redefined in mscorlib.dll and System.Runtime.WindowsRuntime.dll.
 These two assemblies are special as they implement the CLR's support for WinRT.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.ShouldAddWinRTMembers">
  <summary>
 True if the type should have its WinRT interfaces projected onto .NET types and
 have missing .NET interface members added to the type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol.IsInterface">
 <summary>
 Requires less computation than <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.TypeKind"/>== <see cref="F:Microsoft.CodeAnalysis.TypeKind.Interface"/>.
 </summary>
 <remarks>
 Metadata types need to compute their base types in order to know their TypeKinds, And that can lead
 to cycles if base types are already being computed.
 </remarks>
 <returns>True if this Is an interface type.</returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol">
 <summary>
 Represents a namespace.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.GetNamespaceMembers">
 <summary>
 Get all the members of this symbol that are namespaces.
 </summary>
 <returns>An ImmutableArray containing all the namespaces that are members of this symbol. If this symbol has no namespace members,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.GetModuleMembers">
 <summary>
 Get all the members of this symbol that are modules.
 </summary>
 <returns>An ImmutableArray containing all the types that are members of this namespace. If this namespace has no module members,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.GetModuleMembers(System.String)">
 <summary>
 Get all the members of this symbol that are modules that have a particular name
 </summary>
 <returns>An ImmutableArray containing all the modules that are members of this namespace with the given name. 
 If this symbol has no modules with this name,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.IsGlobalNamespace">
 <summary>
 Returns whether this namespace is the unnamed, global namespace that is 
 at the root of all namespaces.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.NamespaceKind">
 <summary>
 The kind of namespace: Module, Assembly or Compilation.
 Module namespaces contain only members from the containing module that share the same namespace name.
 Assembly namespaces contain members for all modules in the containing assembly that share the same namespace name.
 Compilation namespaces contain all members, from source or referenced metadata (assemblies and modules) that share the same namespace name.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.ContainingCompilation">
 <summary>
 The containing compilation for compilation namespaces.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.ConstituentNamespaces">
 <summary>
 If a namespace has Assembly or Compilation extent, it may be composed of multiple
 namespaces that are merged together. If so, ConstituentNamespaces returns
 all the namespaces that were merged. If this namespace was not merged, returns
 an array containing only this namespace.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.ContainingAssembly">
 <summary>
 Containing assembly.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.ContainingModule">
 <summary>
 Containing module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.Kind">
 <summary>
 Gets the kind of this symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.Accept``2(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSymbolVisitor{``0,``1},``0)">
 <summary>
 Implements visitor pattern.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.DeclaredAccessibility">
 <summary>
 Get this accessibility that was declared on this symbol. For symbols that do
 not have accessibility declared on them, returns NotApplicable.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.ObsoleteAttributeData">
 <summary>
 Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
 This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.DeclaredAccessibilityOfMostAccessibleDescendantType">
 <summary>
 Returns declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.GetDeclaredAccessibilityOfMostAccessibleDescendantType">
 <summary>
 Calculate declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Expected to be called at most once per namespace symbol, unless there is a race condition.
 
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.ContainsTypesAccessibleFrom(Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol)">
 <summary>
 Returns true if namespace contains types accessible from the target assembly.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.IsShared">
 <summary>
 Returns true if this symbol is "shared"; i.e., declared with the "Shared"
 modifier or implicitly always shared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.LookupNestedNamespace(System.Collections.Immutable.ImmutableArray{System.String})">
 <summary>
 Lookup a nested namespace.
 </summary>
 <param name="names">
 Sequence of names for nested child namespaces.
 </param>
 <returns>
 Symbol for the most nested namespace, if found. Nothing 
 if namespace or any part of it can not be found.
 </returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.LookupMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
 <summary>
 Lookup an immediately nested type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
 <param name="fullEmittedName">
 Full type name possibly with generic name mangling.
 </param>
 <returns>
 Symbol for the type, or MissingMetadataSymbol if the type isn't found.
 </returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.AppendProbableExtensionMethods(System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol})">
 <summary>
 This is an entry point for the Binder to collect extension methods with the given name 
 declared within this (compilation merged or module level) namespace, so that methods 
 from the same type are grouped together. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.AddExtensionMethodLookupSymbolsInfo(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 This is an entry point for the Binder. Its purpose is to add names of viable extension methods declared 
 in this (compilation merged or module level) namespace to nameSet parameter.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.AddExtensionMethodLookupSymbolsInfo(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol)">
 <summary>
 Add names of viable extension methods declared in this (compilation merged or module level) 
 namespace to nameSet parameter.
 
 The 'appendThrough' parameter allows RetargetingNamespaceSymbol to delegate majority of the work 
 to the underlying namespace symbol, but still perform viability check on RetargetingMethodSymbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.BuildExtensionMethodsMap(System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol}})">
 <summary>
 Populate the map with all probable extension methods declared within this namespace, so that methods from
 the same type were grouped together within each bucket. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.GetExtensionMethods(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},System.String)">
 <summary>
 Gets all extension methods in this namespace given a method's name. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.TypesToCheckForExtensionMethods">
 <summary>
 Return the set of types that should be checked for presence of extension methods in order to build
 a map of extension methods for the namespace. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.BuildExtensionMethodsMap(System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol}},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol}}})">
 <summary>
 Populate the map with all probable extension methods in membersByName parameter.
 
 Returns True if an extension method was appended, False otherwise.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol.BuildExtensionMethodsMapBucket(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 This method is overridden by RetargetingNamespaceSymbol and allows it to delegate majority of the work 
 to the underlying namespace symbol, but still retarget method symbols before they are added to the map
 of extension methods.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol">
 <summary>
 Represents a parameter of a method or property.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.OriginalDefinition">
 <summary>
 Get the original definition of this symbol. If this symbol is derived from another
 symbol by (say) type substitution, this gets the original symbol, as it was defined
 in source or metadata.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.IsByRef">
 <summary>
 Is this ByRef parameter.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.IsExplicitByRef">
 <summary>
 Is parameter explicitly declared ByRef. Can be different from IsByRef only for
 String parameters of Declare methods.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.IsMetadataOut">
 <summary>
 Is this Out parameter (metadata flag In is set).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.IsMetadataIn">
 <summary>
 Is this In parameter (metadata flag Out is set).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.IsOut">
 <summary>
 True if the parameter flows data out of the method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.MarshallingInformation">
 <summary>
 Describes how the parameter is marshalled when passed to native code.
 Null if no specific marshalling information is available for the parameter.
 </summary>
 <remarks>PE symbols don't provide this information and always return Nothing.</remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.MarshallingType">
 <summary>
 Returns the marshalling type of this field, or 0 if marshalling information isn't available.
 </summary>
 <remarks>
 By default this information is extracted from <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.MarshallingInformation"/> if available. 
 Since the compiler does only need to know the marshalling type of symbols that aren't emitted 
 PE symbols just decode the type from metadata and don't provide full marshalling information.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.Type">
 <summary>
 Gets the type of this parameter.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.CustomModifiers">
 <summary>
 The list of custom modifiers, if any, associated with the parameter.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.Ordinal">
 <summary>
 Gets the ordinal order of this parameter. The first type parameter has ordinal zero.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.IsParamArray">
 <summary>
 Returns true if this parameter was declared as a ParamArray. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.IsOptional">
 <summary>
 Returns true if this parameter was declared as Optional. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.HasExplicitDefaultValue">
 <summary>
 Returns true if the parameter explicitly specifies a default value to be passed
 when no value is provided as an argument to a call.
 </summary>
 <remarks>
 True if the parameter has a default value defined in source via an optional parameter syntax, 
 or the parameter is from metadata and HasDefault and Optional metadata flags are set,
 or the parameter is from metadata, has Optional flag set and <see cref="T:System.Runtime.CompilerServices.DateTimeConstantAttribute"/>
 or <see cref="T:System.Runtime.CompilerServices.DecimalConstantAttribute"/> is specified.
 
 The default value can be obtained with the <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.ExplicitDefaultValue"/> property.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.ExplicitDefaultValue">
 <summary>
 Returns the default value of this parameter. If <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.HasExplicitDefaultValue"/>
 returns false, then this property throws an InvalidOperationException.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.ObsoleteAttributeData">
 <summary>
 Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
 This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.ExplicitDefaultConstantValue(Microsoft.CodeAnalysis.VisualBasic.SymbolsInProgress{Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol})">
 <summary>
 Returns the default value of this parameter as a ConstantValue.
 Return nothing if there isn't a default value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.ChangeOwner(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Create a new ParameterSymbol with everything the same except the owner. Used for property
 accessor methods, for example.
 </summary>
 <remarks>
 Note: This is only implemented for those subclasses (e.g., SourceParameterSymbol) for which it
 is required. Thus, the base implementation throws an exception instead of being MustOverride.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol.CountOfCustomModifiersPrecedingByRef">
 <summary>
 The CLI spec says that custom modifiers must precede the ByRef type code in the encoding of a parameter.
 Unfortunately, the managed C++ compiler emits them in the reverse order.  In order to avoid breaking
 interop scenarios, we need to support such signatures. 
 Should be 0 for non-ref parameters.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol">
 <summary>
 Represents a property.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.OriginalDefinition">
 <summary>
 Get the original definition of this symbol. If this symbol is derived from another
 symbol by (say) type substitution, this gets the original symbol, as it was defined
 in source or metadata.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.Type">
 <summary>
 Gets the type of the property. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.TypeCustomModifiers">
 <summary>
 Returns the list of custom modifiers, if any, associated with the type of the property. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.Parameters">
 <summary>
 Gets the parameters of this property. If this property has no parameters, returns
 an empty list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.ParameterCount">
 <summary>
 Optimization: in many cases, the parameter count (fast) is sufficient and we
 don't need the actual parameter symbols (slow).
 </summary>
 <remarks>
 The default implementation is always correct, but may be unnecessarily slow.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.HasSpecialName">
 <summary>
  True if this symbol has a special name (metadata flag SpecialName is set).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.IsDefault">
 <summary>
 Returns true if this property is a default property. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.IsReadOnly">
 <summary>
 Returns true if this is a read-only property; i.e., has no set accessor.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.IsReadable">
 <summary>
 Indicates if the property can be read, which means this 
 type overrides OR inherits a getter for this property.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.IsWriteOnly">
 <summary>
 Returns true if this is a write-only property; i.e., has no get accessor.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.HasSet">
 <summary>
 Indicates if the property has a Set accessor.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.IsWritable(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Indicates if the property can be written into, which means this 
 property has a setter or it is a getter only autoproperty accessed 
 in a corresponding constructor or initializer
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.GetMethod">
 <summary>
 Gets the associated "get" method for this property. If this property
 has no get accessor, returns Nothing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.GetMostDerivedGetMethod">
 <summary>
 Retrieves Get method for this property or 'most derived' Get method from closest 
 overridden property if such property exists.
 
 NOTE: It is not possible in VB, but possible in other languages (for example in C#) to
       override read-write property an provide override only for setter, thus inheriting 
       getter's implementation. This method will find the Get method from the most-derived
       overridden property in this case
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.SetMethod">
 <summary>
 Gets the associated "set" method for this property. If this property
 has no set accessor, returns Nothing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.GetMostDerivedSetMethod">
 <summary>
 Retrieves Set method for this property or 'most derived' Set method from closest 
 overridden property if such property exists.
 
 NOTE: It is not possible in VB, but possible in other languages (for example in C#) to
       override read-write property an provide override only for getter, thus inheriting 
       setter's implementation. This method will find the Set method from the most-derived
       overridden property in this case
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.AssociatedField">
 <summary>
 Backing field of the property, or Nothing if the property doesn't have any.
 </summary>
 <remarks>
 Properties imported from metadata return Nothing.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.GetFieldAttributes">
 <summary>
 Gets the attributes on event's associated field, if any.
 </summary>
 <returns>Returns an array of <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData"/> or an empty array if there are no attributes.</returns>
 <remarks>
 Only WithEvent property may have any attributes applied on its backing field.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.IsOverloads">
 <summary>
 Returns true if this property hides a base property by name and signature.
 The equivalent of the "hidebysig" flag in metadata. 
 </summary>
 <remarks>
 This property should not be confused with general property overloading in Visual Basic, and is not directly related. 
 This property will only return true if this method hides a base property by name and signature (Overloads keyword).
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.OverriddenProperty">
 <summary>
 If this property overrides another property (because it both had the Overrides modifier
 and there correctly was a property to override), returns the overridden property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.GetAccessorOverride(System.Boolean)">
 <summary>
 Helper method for accessors to get the overridden accessor methods. Should only be called by the
 accessor method symbols.
 </summary>
 <param name="getter">True to get overridden getters, False to get overridden setters</param>
 <returns>All the accessors of the given kind implemented by this property.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.ExplicitInterfaceImplementations">
 <summary>
 Returns interface properties explicitly implemented by this property.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.MeParameter">
 <summary>
 Get the "this" parameter for this property.  This is only valid for source fields.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.HighestPriorityUseSiteError">
 <summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.IsWithEvents">
 <summary>
 Returns true if this property is an auto-created WithEvents property that 
 takes place of a field member when the field is marked as WithEvents.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.CloneParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol})">
 <summary>
 Clone the property parameters for the accessor method. The
 parameters are cloned (rather than referenced from the property)
 since the ContainingSymbol needs to be set to the accessor.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol.IsMyGroupCollectionProperty">
 <summary>
 Is this an auto-generated property of a group class?
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedStaticLocalBackingField">
 <summary>
 Represents a compiler generated field used to implement static locals.
 There are two kind of fields: the one, that holds the value, and the one, that holds initialization "flag".
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol">
 <summary>
 Represents a type parameter in a generic type or generic method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol.OriginalDefinition">
 <summary>
 Get the original definition of this symbol. If this symbol is derived from another
 symbol by (say) type substitution, this gets the original symbol, as it was defined
 in source or metadata.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol.Ordinal">
 <summary>
 Gets the ordinal order of this type parameter. The first type parameter has ordinal zero.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol.ConstraintTypes">
 <summary>
 Get the types that were directly specified as constraints on this type parameter.
 Duplicates and cycles are removed, although the collection may include redundant
 constraints where one constraint is a base type of another.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol.HasConstructorConstraint">
 <summary>
 Returns whether the parameterless constructor constraint was specified.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol.DeclaringMethod">
 <summary>
 The method that declares this type parameter 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol.DeclaringType">
 <summary>
 The type that declares this type parameter
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol.EnsureAllConstraintsAreResolved">
 <summary>
 Called by ConstraintTypes and Interfaces
 to allow derived classes to ensure constraints within the containing
 type or method are resolved in a consistent order, regardless of the
 order the callers query individual type parameters.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol.EnsureAllConstraintsAreResolved(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol})">
 <summary>
 Helper method to force type parameter constraints to be resolved.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol.GetConstraints(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterConstraint})">
 <summary>
 Get all constraints, with optional source location for each. This method
 is provided for constraint checking only, and should only be invoked
 for SourceTypeParameterSymbol or ErrorTypeParameterSymbol directly.
 There is currently no need to invoke this method for PETypeParameterSymbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol.ResolveConstraints(Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol})">
 <summary>
 Resolve constraints, binding and checking for conflicts as necessary. This is an
 internal method for resolving dependent sets of constraints and handling cycles.
 It will be called indirectly for core implementations (SourceTypeParameterSymbol and
 PETypeParameterSymbol) as a result of accessing constraint properties on this class.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol.InternalSubstituteTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol.ReducedFrom">
 <summary>
 If this is a type parameter of a reduced extension method, gets the type parameter definition that
 this type parameter was reduced from. Otherwise, returns Nothing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol.InternalSubstituteTypeParametersDistinct(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol})">
 <summary>
 Return an array of substituted type parameters with duplicates removed.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol">
 <summary>
 Symbol representing a using alias appearing in a compilation unit. 
 Generally speaking, these symbols do not appear in the set of symbols reachable
 from the unnamed namespace declaration.  In other words, when a using alias is used in a
 program, it acts as a transparent alias, and the symbol to which it is an alias is used in
 the symbol table.  For example, in the source code
 <pre>
 Imports o = System.Object
 Namespace NS
     partial class C : Inherits o : End Class
     partial class C : Inherits Object : End Class
     partial class C : Inherits System.Object : End Class
 End Namespace
 
 </pre>
 all three declarations for class C are equivalent and result in the same symbol table object for C. 
 However, these alias symbols do appear in the results of certain SemanticModel APIs. 
 Specifically, for the base clause of the first of C's class declarations, the
 following APIs may produce a result that contains an AliasSymbol:
 <pre>
     SemanticInfo SemanticModel.GetSemanticInfo(ExpressionSyntax expression);
     SemanticInfo SemanticModel.BindExpression(SyntaxNode location, ExpressionSyntax expression);
     SemanticInfo SemanticModel.BindType(SyntaxNode location, ExpressionSyntax type);
     SemanticInfo SemanticModel.BindNamespaceOrType(SyntaxNode location, ExpressionSyntax type);
 </pre>
 Also, the following are affected if container=Nothing (and, for the latter, when container=Nothing or arity=0):
 <pre>
     Public Function LookupNames(position As Integer, Optional container As NamespaceOrTypeSymbol = Nothing, Optional options As LookupOptions = LookupOptions.Default, Optional results As List(Of String) = Nothing) As IList(Of String)
     Public Function LookupSymbols(position As Integer,
                                  Optional container As NamespaceOrTypeSymbol = Nothing,
                                  Optional name As String = Nothing,
                                  Optional arity As Integer? = Nothing,
                                  Optional options As LookupOptions = LookupOptions.Default,
                                  Optional results As List(Of Symbol) = Nothing) As IList(Of Symbol)
 </pre>
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.Name">
 <summary>
 The alias name.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.Kind">
 <summary>
 Gets the kind of this symbol.
 </summary>
 <returns><see cref="F:Microsoft.CodeAnalysis.SymbolKind.Alias"/></returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.Target">
 <summary>
 Gets the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol"/> for the
 namespace or type referenced by the alias.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.Locations">
 <summary>
 Gets the locations where this symbol was originally defined.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.DeclaringSyntaxReferences">
 <summary>
 Get the syntax node(s) where this symbol was declared in source.
 </summary>
 <returns>
 The syntax node(s) that declared the symbol.
 </returns>
 <remarks>
 To go the opposite direction (from syntax node to symbol), see <see cref="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,System.Threading.CancellationToken)"/>.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.IsNotOverridable">
 <summary>
 Returns true if this symbol was declared to override a base class members and was
 also restricted from further overriding; i.e., declared with the "NotOverridable"
 modifier. Never returns true for types.
 </summary>
 <returns>False</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.IsMustOverride">
 <summary>
 Returns true if this symbol was declared as requiring an override; i.e., declared
 with the "MustOverride" modifier. Never returns true for types. 
 </summary>
 <returns>False</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.IsOverrides">
 <summary>
 Returns true if this symbol was declared to override a base class members; i.e., declared
 with the "Overrides" modifier. Still returns true if the members was declared
 to override something, but (erroneously) no member to override exists.
 </summary>
 <returns>False</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.IsOverridable">
 <summary>
 Returns true if this member is overridable, has an implementation,
 and does not override a base class member; i.e., declared with the "Overridable"
 modifier. Does not return true for members declared as MustOverride or Overrides.
 </summary>
 <returns>False</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.IsShared">
 <summary>
 Returns true if this symbol is "shared"; i.e., declared with the "Shared"
 modifier or implicitly always shared.
 </summary>
 <returns>False</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.DeclaredAccessibility">
 <summary>
 Get this accessibility that was declared on this symbol. For symbols that do
 not have accessibility declared on them, returns NotApplicable.
 </summary>
 <returns><see cref="F:Microsoft.CodeAnalysis.Accessibility.NotApplicable"/></returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.ContainingSymbol">
 <summary>
 Get the symbol that logically contains this symbol. 
 </summary>
 <returns>
 Using aliases in VB are always at the top
 level within a compilation unit, within the [Global] namespace declaration.  We
 return that as the "containing" symbol, even though the alias isn't a member of the
 namespace as such.
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.Equals(System.Object)">
 <summary>
 Determines whether the specified object is equal to the current object.
 </summary>
 <param name="obj">
 The object to compare with the current object. 
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol.GetHashCode">
 <summary>
 Returns a hash code for the current object.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor">
 <summary> 
 Describes anonymous type/delegate in terms of fields/parameters
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor.Location">
 <summary> Anonymous type/delegate location </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor.Fields">
 <summary> Anonymous type fields </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor.Key">
 <summary> 
 Anonymous type descriptor Key 
 
 The key is being used to separate anonymous type templates, for example in an anonymous type 
 symbol cache. The type descriptors with the same keys are supposed to map to 'the same' anonymous
 type template in terms of the same generic type being used for their implementation.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor.IsImplicitlyDeclared">
 <summary> Anonymous type is implicitly declared </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor.Parameters">
 <summary> Anonymous delegate parameters, including one for return type </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor.AssertGood">
 <summary>
 This is ONLY used for debugging purpose
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor.SubstituteTypeParametersIfNeeded(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution,Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor@)">
 <summary>
 Performs internal substitution of types in anonymous type descriptor fields and returns True 
 if any of the fields was changed, in which case a new descriptor is returned in newDescriptor
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField">
 <summary> 
 Describes anonymous type field in terms of its name, type and other attributes.
 Or describes anonymous delegate parameter, including "return" parameter, in terms 
 of its name, type and other attributes.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField.Name">
 <summary> Anonymous type field/parameter name, not nothing and not empty </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField.Location">
 <summary>Location of the field</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField.Type">
 <summary> Anonymous type field/parameter type, must be not nothing when 
 the field is passed to anonymous type descriptor </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField._type">
 <summary> 
 Anonymous type field/parameter type, may be nothing when field descriptor is created,
 must be assigned before passing the descriptor to anonymous type descriptor.
 Once assigned, is considered to be 'sealed'. 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField.IsKey">
 <summary> Anonymous type field is declared as a 'Key' field </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField.IsByRef">
 <summary>
 Does this describe a ByRef parameter of an Anonymous Delegate type
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField.AssertGood">
 <summary>
 This is ONLY used for debugging purpose
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.CRC32">
 <summary> 
 Module implements Dev11 class CRC32 used in anonymous type GetHashCode implementation
 See [...\Language\Shared\crc32.cpp] for details
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.CRC32.CalcEntry(System.UInt32)">
 <summary>
 This is actually calculating the reverse CRC
 computing the reverse CRC of 0 gives the table entry above
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol">
 <summary>
 Represents a .NET assembly. An assembly consists of one or more modules.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol._corLibrary">
 <summary>
 The system assembly, which provides primitive types like Object, String, etc., e.g. mscorlib.dll. 
 The value is provided by ReferenceManager and must not be modified. For SourceAssemblySymbol, non-missing 
 coreLibrary must match one of the referenced assemblies returned by GetReferencedAssemblySymbols() method of 
 the main module. If there is no existing assembly that can be used as a source for the primitive types, 
 the value is a Compilation.MissingCorLibrary. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.CorLibrary">
 <summary>
 The system assembly, which provides primitive types like Object, String, etc., e.g. mscorlib.dll. 
 The value is a MissingAssemblySymbol if none of the referenced assemblies can be used as a source for the 
 primitive types and the owning assembly cannot be used as the source too. Otherwise, it is one of 
 the referenced assemblies returned by GetReferencedAssemblySymbols() method or the owning assembly.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.SetCorLibrary(Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol)">
 <summary>
 A helper method for ReferenceManager to set the system assembly, which provides primitive 
 types like Object, String, etc., e.g. mscorlib.dll. 
 </summary>
 <param name="corLibrary"></param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.Name">
 <summary>
 Simple name of the assembly. 
 </summary>
 <remarks>
 This is equivalent to <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.Identity"/>.<see cref="P:Microsoft.CodeAnalysis.AssemblyIdentity.Name"/>, but may be 
 much faster to retrieve for source code assemblies, since it does not require binding the assembly-level
 attributes that contain the version number and other assembly information.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.IsInteractive">
 <summary>
 True if the assembly contains interactive code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetMetadata">
 <summary>
 If this symbol represents a metadata assembly returns the underlying <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata"/>.
 
 Otherwise, this returns <code>nothing</code>.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.Identity">
 <summary>
 Get the name of this assembly.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.Machine">
 <summary>
 Target architecture of the machine.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.Bit32Required">
 <summary>
 Indicates that this PE file makes Win32 calls. See CorPEKind.pe32BitRequired for more information (http://msdn.microsoft.com/en-us/library/ms230275.aspx).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.Modules">
 <summary>
 Gets a read-only list of all the modules in this assembly. (There must be at least one.) The first one is the main module
 that holds the assembly manifest.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GlobalNamespace">
 <summary>
 Gets the merged root namespace that contains all namespaces and types defined in the modules
 of this assembly. If there is just one module in this assembly, this property just returns the 
 GlobalNamespace of that module.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetAssemblyNamespace(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol)">
 <summary>
 Given a namespace symbol, returns the corresponding assembly specific namespace symbol
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.IsMissing">
 <summary>
 Does this symbol represent a missing assembly.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.ObsoleteAttributeData">
 <summary>
 Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
 This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.LookupTopLevelMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean)">
 <summary>
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
 <param name="emittedName">
 Full type name with generic name mangling.
 </param>
 <param name="digThroughForwardedTypes">
 Take forwarded types into account.
 </param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.LookupTopLevelMetadataTypeWithCycleDetection(Microsoft.CodeAnalysis.MetadataTypeName@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol},System.Boolean)">
 <summary>
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.  Detect cycles during lookup.
 </summary>
 <param name="emittedName">
 Full type name, possibly with generic name mangling.
 </param>
 <param name="visitedAssemblies">
 List of assemblies lookup has already visited (since type forwarding can introduce cycles).
 </param>
 <param name="digThroughForwardedTypes">
 Take forwarded types into account.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.ResolveForwardedType(System.String)">
 <summary>
 Returns the type symbol for a forwarded type based its canonical CLR metadata name.
 The name should refer to a non-nested type. If type with this name Is Not forwarded,
 null Is returned.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.TryLookupForwardedMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean)">
 <summary>
 Look up the given metadata type, if it Is forwarded.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.TryLookupForwardedMetadataTypeWithCycleDetection(Microsoft.CodeAnalysis.MetadataTypeName@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol},System.Boolean)">
 <summary>
 Look up the given metadata type, if it is forwarded.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetDeclaredSpecialType(Microsoft.CodeAnalysis.SpecialType)">
 <summary>
 Lookup declaration for predefined CorLib type in this Assembly. Only valid if this 
 assembly is the Cor Library
 </summary>
 <param name="type"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.RegisterDeclaredSpecialType(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Register declaration of predefined CorLib type in this Assembly.
 </summary>
 <param name="corType"></param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.KeepLookingForDeclaredSpecialTypes">
 <summary>
 Continue looking for declaration of predefined CorLib type in this Assembly
 while symbols for new type declarations are constructed.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetNoPiaResolutionAssemblies">
 <summary>
 Return an array of assemblies involved in canonical type resolution of
 NoPia local types defined within this assembly. In other words, all 
 references used by previous compilation referencing this assembly.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetLinkedReferencedAssemblies">
 <summary>
 Return an array of assemblies referenced by this assembly, which are linked (/l-ed) by 
 each compilation that is using this AssemblySymbol as a reference. 
 If this AssemblySymbol is linked too, it will be in this array too.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.IsLinked">
 <summary>
 Assembly is /l-ed by compilation that is using it as a reference.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetGuidString(System.String@)">
 <summary>
 Returns true and a string from the first GuidAttribute on the assembly, 
 the string might be null or an invalid guid representation. False, 
 if there is no GuidAttribute with string argument.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetInternalsVisibleToPublicKeys(System.String)">
 <summary>
 An empty list means there was no IVT attribute with matching <paramref name="simpleName"/>.
 An IVT attribute without a public key setting is represented by an entry that is empty in the returned list
 </summary>
 <param name="simpleName"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)">
 <summary>
 Get symbol for predefined type from Cor Library used by this assembly.
 </summary>
 <param name="type"></param>
 <returns>The symbol for the pre-defined type or Nothing if the type is not defined in the core library</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.ObjectType">
 <summary>
 The NamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of
 Error if there was no COR Library in a compilation using the assembly.
</summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetPrimitiveType(Microsoft.Cci.PrimitiveTypeCode)">
 <summary>
 Get symbol for predefined type from Cor Library used by this assembly.
 </summary>
 <param name="type"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetTypeByMetadataName(System.String)">
 <summary>
 Lookup a type within the assembly using its canonical CLR metadata name (names are compared case-sensitively).
 </summary>
 <param name="fullyQualifiedMetadataName">
 </param>
 <returns>
 Symbol for the type or null if type cannot be found or is ambiguous. 
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetTypeByMetadataName(System.String,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 Lookup a type within the assembly using its canonical CLR metadata name (names are compared case-sensitively).
 </summary>
 <param name="metadataName"></param>
 <param name="includeReferences">
 If search within assembly fails, lookup in assemblies referenced by the primary module.
 For source assembly, this is equivalent to all assembly references given to compilation.
 </param>
 <param name="isWellKnownType">
 Extra restrictions apply when searching for a well-known type.  In particular, the type must be public.
 </param>
 <param name="useCLSCompliantNameArityEncoding">
 While resolving the name, consider only types following CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).
 I.e. arity is inferred from the name and matching type must have the same emitted name and arity.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetTopLevelTypeByMetadataName(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean,System.Boolean)">
 <summary>
 Lookup a top level type within the assembly or one of the assemblies referenced by the primary module, 
 names are compared case-sensitively. In case of ambiguity, type from this assembly wins,
 otherwise Nothing is returned.
 </summary>
 <returns>
 Symbol for the type or Nothing if type cannot be found or ambiguous. 
 </returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.MightContainExtensionMethods">
 <summary>
 If this property returns false, it is certain that there are no extension
 methods (from language perspective) inside this assembly. If this property returns true, 
 it is highly likely (but not certain) that this type contains extension methods. 
 This property allows the search for extension methods to be narrowed much more quickly.
 
 !!! Note that this property can mutate during lifetime of the symbol !!!
 !!! from True to False, as we learn more about the assembly.         !!! 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
 <summary>
 Lookup member declaration in predefined CorLib type used by this Assembly.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol.GetDeclaredSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
 <summary>
 Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
 assembly is the Cor Library
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAttributeData">
 <summary>
 Class to represent custom attributes attached to symbols.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAttributeData.AttributeClass">
 <summary>
 The attribute class.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAttributeData.AttributeConstructor">
 <summary>
 The constructor on the attribute class.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAttributeData.CommonConstructorArguments">
 <summary>
 Constructor arguments on the attribute.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAttributeData.CommonNamedArguments">
 <summary>
 Named (property value) arguments on the attribute. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAttributeData.IsTargetAttribute(System.String,System.String,System.Boolean)">
 <summary>
 Matches an attribute by metadata namespace, metadata type name. Does not load the type symbol for
 the attribute.
 </summary>
 <param name="namespaceName"></param>
 <param name="typeName"></param>
 <returns>True if the attribute data matches.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAttributeData.GetTargetAttributeSignatureIndex(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.AttributeDescription)">
 <summary>
 Matches an attribute by metadata namespace, metadata type name and metadata signature. Does not load the
 type symbol for the attribute.
 </summary>
 <param name="description">Attribute to match.</param>
 <returns>
 An index of the target constructor signature in signatures array,
 -1 if this is not the target attribute.
 </returns>
 <remarks>Matching an attribute by name does not load the attribute class.</remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MemberRefMetadataDecoder">
 <summary>
 This subclass of MetadataDecoder is specifically for finding
 method symbols corresponding to method MemberRefs.  The parent 
 implementation is unsuitable because it requires a PEMethodSymbol
 for context when decoding method type parameters and no such
 context is available because it is precisely what we are trying
 to find.  Since we know in advance that there will be no context
 and that signatures decoded with this class will only be used
 for comparison (when searching through the methods of a known
 TypeSymbol), we can return indexed type parameters instead.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MemberRefMetadataDecoder.GetGenericMethodTypeParamSymbol(System.Int32)">
 <summary>
 We know that we'll never have a method context because that's what we're
 trying to find.  Instead, just return an indexed type parameter that will
 make comparison easier.
 </summary>
 <param name="position"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MemberRefMetadataDecoder.GetGenericTypeParamSymbol(System.Int32)">
 <summary>
 This override changes two things:
     1) Return type arguments instead of type parameters.
     2) Handle non-PE types.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MemberRefMetadataDecoder.FindMember(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Reflection.Metadata.MemberReferenceHandle,System.Boolean)">
 <summary> 
 Search through the members of a given type symbol to find the method that matches a particular signature. 
 </summary> 
 <param name="targetTypeSymbol">Type containing the desired method symbol.</param> 
 <param name="memberRef">A MemberRef handle that can be used to obtain the name and signature of the method</param> 
 <param name="methodsOnly">True to only return a method.</param> 
 <returns>The matching method symbol, or null if the inputs do not correspond to a valid method.</returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MetadataDecoder">
 <summary>
 Helper class to resolve metadata tokens and signatures.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MetadataDecoder._typeContextOpt">
 <summary>
 Type context for resolving generic type arguments.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MetadataDecoder._methodContextOpt">
 <summary>
 Method context for resolving generic method type arguments.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.Int32,Microsoft.CodeAnalysis.MetadataTypeName@)">
 <summary>
 Lookup a type defined in referenced assembly.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.String,Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean@)">
 <summary>
 Lookup a type defined in a module of a multi-module assembly.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean@)">
 <summary>
 Lookup a type defined in this module.
 This method will be called only if the type we are
 looking for hasn't been loaded yet. Otherwise, MetadataDecoder
 would have found the type in TypeDefRowIdToTypeMap based on its 
 TypeDef row id. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MetadataDecoder.IsOrClosedOverATypeFromAssemblies(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol})">
 <summary>
 Perform a check whether the type or at least one of its generic arguments 
 is defined in the specified assemblies. The check is performed recursively. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MetadataDecoder.SubstituteNoPiaLocalType(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.String,System.String,Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol)">
 <summary>
 Find canonical type for NoPia embedded type.
 </summary>
 <returns>
 Symbol for the canonical type or an ErrorTypeSymbol. Never returns null.
 </returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAssemblySymbol">
 <summary>
 Represents an assembly imported from a PE.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAssemblySymbol._assembly">
 <summary>
 An Assembly object providing metadata for the assembly.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAssemblySymbol._documentationProvider">
 <summary>
 A MetadataDocumentationProvider providing XML documentation for this assembly.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAssemblySymbol._modules">
 <summary>
 The list of contained PEModuleSymbol objects.
 The list doesn't use type ReadOnlyCollection(Of PEModuleSymbol) so that we
 can return it from Modules property as is.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAssemblySymbol._noPiaResolutionAssemblies">
 <summary>
 An array of assemblies involved in canonical type resolution of
 NoPia local types defined within this assembly. In other words, all 
 references used by a compilation referencing this assembly.
 The array and its content is provided by ReferenceManager and must not be modified.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAssemblySymbol._linkedReferencedAssemblies">
 <summary>
 An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
 each compilation that is using this AssemblySymbol as a reference. 
 If this AssemblySymbol is linked too, it will be in this array too.
 The array and its content is provided by ReferenceManager and must not be modified.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAssemblySymbol._isLinked">
 <summary>
 Assembly is /l-ed by compilation that is using it as a reference.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAssemblySymbol.LookupAssemblyForForwardedMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean,System.String@)">
 <summary>
 Look up the assembly to which the given metadata type Is forwarded.
 </summary>
 <param name="emittedName"></param>
 <param name="ignoreCase">Pass true to look up fullName case-insensitively.  WARNING: more expensive.</param>
 <param name="matchedName">Returns the actual casing of the matching name.</param>
 <returns>
 The assembly to which the given type Is forwarded Or null, if there isn't one.
 </returns>
 <remarks>
 The returned assembly may also forward the type.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAssemblySymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEEventSymbol">
 <summary>
 The class to represent all events imported from a PE/module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEEventSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEFieldSymbol">
 <summary>
 The class to represent all fields imported from a PE/module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEFieldSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEGlobalNamespaceSymbol._moduleSymbol">
 <summary>
 The module containing the namespace.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEGlobalNamespaceSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEMethodSymbol">
 <summary>
 The class to represent all methods imported from a PE/module.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEMethodSymbol._uncommonFields">
 <summary>
 A single field to hold optional auxiliary data.
 In many scenarios it is possible to avoid allocating this, thus saving total space in <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol"/>.
 Even for lazily-computed values, it may be possible to avoid allocating <see cref="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEMethodSymbol._uncommonFields"/> if
 the computed value is a well-known "empty" value. In this case, bits in <see cref="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEMethodSymbol._packedFlags"/> are used
 to indicate that the lazy values have been computed and, if <see cref="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEMethodSymbol._uncommonFields"/> is null, then
 the "empty" value should be inferred.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEMethodSymbol.UncommonFields">
 <summary>
 Holds infrequently accessed fields. See <seealso cref="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEMethodSymbol._uncommonFields"/> for an explanation.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEMethodSymbol.SetAssociatedProperty(Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEPropertySymbol,Microsoft.CodeAnalysis.MethodKind)">
 <summary>
 Associate the method with a particular property. Returns
 false if the method is already associated with a property or event.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEMethodSymbol.SetAssociatedEvent(Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEEventSymbol,Microsoft.CodeAnalysis.MethodKind)">
 <summary>
 Associate the method with a particular event. Returns
 false if the method is already associated with a property or event.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEMethodSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol">
 <summary>
 Represents a net-module imported from a PE. Can be a primary module of an assembly. 
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol._assemblySymbol">
 <summary>
 Owning AssemblySymbol. This can be a PEAssemblySymbol or a SourceAssemblySymbol.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol._module">
 <summary>
 A Module object providing metadata.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol._globalNamespace">
 <summary>
 Global namespace. 
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol._lazySystemTypeSymbol">
 <summary>
 Cache the symbol for well-known type System.Type because we use it frequently
 (for attributes).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol.s_defaultTypeMapCapacity">
 <summary>
 The same value as ConcurrentDictionary.DEFAULT_CAPACITY
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol.TypeHandleToTypeMap">
 <summary>
 This is a map from TypeDef handle to the target <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol"/>. 
 It is used by <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MetadataDecoder"/> to speed up type reference resolution
 for metadata coming from this module. The map is lazily populated
 as we load types from the module.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol.TypeRefHandleToTypeMap">
 <summary>
 This is a map from TypeRef row id to the target <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol"/>. 
 It is used by <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MetadataDecoder"/> to speed-up type reference resolution
 for metadata coming from this module. The map is lazily populated
 by <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MetadataDecoder"/> as we resolve TypeRefs from the module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol.GetAssemblyForForwardedType(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean,System.String@)">
 <summary>
 If this module forwards the given type to another assembly, return that assembly;
 otherwise, return Nothing.
 </summary>
 <param name="fullName">Type to look up.</param>
 <param name="ignoreCase">Pass true to look up fullName case-insensitively.  WARNING: more expensive.</param>
 <param name="matchedName">Returns the actual casing of the matching name.</param>
 <returns>Assembly symbol or Nothing.</returns>
 <remarks>
 The returned assembly may also forward the type.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol">
 <summary>
 The class to represent all types imported from a PE/module.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol._lazyNestedTypes">
 <summary>
 A map of types immediately contained within this type 
 grouped by their name (case-insensitively).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol._lazyMemberNames">
 <summary>
 A set of all the names of the members in this type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol._lazyMembers">
 <summary>
 A map of members immediately contained within this type 
 grouped by their name (case-insensitively).
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol._lazyTypeKind">
 <summary>
 Lazily initialized by TypeKind property.
 Using Integer type to make sure read/write operations are atomic.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol.IsValidWithEventsProperty(Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEPropertySymbol)">
 <summary>
 Some simple sanity checks if a property can actually be a withevents property
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol.MatchesContainingTypeParameters">
 <summary>
 Return true if the type parameters specified on the nested type (Me),
 that represent the corresponding type parameters on the containing
 types, in fact match the actual type parameters on the containing types.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol.GenerateDeclarationErrors(System.Threading.CancellationToken)">
 <summary>
 Force all declaration errors to be generated.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol.GetIndexOfFirstMember(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.SymbolKind)">
 <summary>
 Returns the index of the first member of the specific kind.
 Returns the number of members if not found.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol.GetMembers``1(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.SymbolKind,System.Int32)">
 <summary>
 Returns all members of the specific kind, starting at the optional offset.
 Members of the same kind are assumed to be contiguous.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbolWithEmittedNamespaceName">
 <summary>
 The class to represent top level types imported from a PE/module.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamespaceSymbol">
 <summary>
 The base class to represent a namespace imported from a PE/module.
 Namespaces that differ only by casing in name are merged.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamespaceSymbol.m_lazyMembers">
 <summary>
 A map of namespaces immediately contained within this namespace 
 grouped by their name (case-insensitively).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamespaceSymbol.m_lazyTypes">
 <summary>
 A map of types immediately contained within this namespace 
 grouped by their name (case-insensitively).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamespaceSymbol._lazyNoPiaLocalTypes">
 <summary>
 A map of NoPia local types immediately contained in this assembly.
 Maps fully-qualified type name to the row id.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamespaceSymbol.ContainingPEModule">
 <summary>
 Returns PEModuleSymbol containing the namespace.
 </summary>
 <returns>PEModuleSymbol containing the namespace.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamespaceSymbol.LoadAllMembers(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}})">
 <summary>
 Initializes m_Namespaces and m_Types maps with information about 
 namespaces and types immediately contained within this namespace.
 </summary>
 <param name="typesByNS">
 The sequence of groups of TypeDef row ids for types contained within the namespace, 
 recursively including those from nested namespaces. The row ids must be grouped by the 
 fully-qualified namespace name in case-sensitive manner. There could be multiple groups 
 for each fully-qualified namespace name. The groups must be sorted by their key in 
 case-insensitive manner. Empty string must be used as namespace name for types 
 immediately contained within Global namespace. Therefore, all types in THIS namespace, 
 if any, must be in several first IGroupings.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamespaceSymbol.LazyInitializeNamespaces(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}}}})">
 <summary>
 Create symbols for nested namespaces and initialize m_Namespaces map.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamespaceSymbol.LazyInitializeTypes(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}})">
 <summary>
 Create symbols for nested types and initialize m_Types map.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamespaceSymbol.AreTypesLoaded">
 <summary>
 For test purposes only.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamespaceSymbol.TypesToCheckForExtensionMethods">
 <summary>
 Return the set of types that should be checked for presence of extension methods in order to build
 a map of extension methods for the namespace. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENestedNamespaceSymbol">
 <summary>
 The class to represent all, but Global, namespaces imported from a PE/module.
 Namespaces that differ only by casing in name are merged.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENestedNamespaceSymbol.m_ContainingNamespaceSymbol">
 <summary>
 The parent namespace. There is always one, Global namespace contains all
 top level namespaces. 
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENestedNamespaceSymbol.m_Name">
 <summary>
 The name of the namespace.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENestedNamespaceSymbol._typesByNS">
 <summary>
 The sequence of groups of TypeDef row ids for types contained within the namespace, 
 recursively including those from nested namespaces. The row ids are grouped by the 
 fully-qualified namespace name in case-sensitive manner. There could be multiple groups 
 for each fully-qualified namespace name. The groups are sorted by their key  
 in case-insensitive manner. Empty string is used as namespace name for types 
 immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
 will be in several first IGroupings.
 
 This member is initialized by constructor and is cleared in EnsureAllMembersLoaded 
 as soon as symbols for children are created.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENestedNamespaceSymbol.#ctor(System.String,Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamespaceSymbol,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}})">
 <summary>
 Constructor.
 </summary>
 <param name="name">
 Name of the namespace, must be not empty.
 </param>
 <param name="containingNamespace">
 Containing namespace.
 </param>
 <param name="typesByNS">
 The sequence of groups of TypeDef row ids for types contained within the namespace, 
 recursively including those from nested namespaces. The row ids are grouped by the 
 fully-qualified namespace name in case-sensitive manner. There could be multiple groups 
 for each fully-qualified namespace name. The groups are sorted by their key  
 in case-insensitive manner. Empty string is used as namespace name for types 
 immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
 will be in several first IGroupings.
 </param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENestedNamespaceSymbol.GetDeclaredAccessibilityOfMostAccessibleDescendantType">
 <summary>
 Calculate declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Expected to be called at most once per namespace symbol, unless there is a race condition.
 
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENestedNamespaceSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEParameterSymbol">
 <summary>
 The class to represent all types imported from a PE/module.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEParameterSymbol._lazyHiddenAttributes">
 <summary>
 Attributes filtered out from m_lazyCustomAttributes, ParamArray, etc.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEParameterSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEPropertySymbol">
 <summary>
 The class to represent all properties imported from a PE/module.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEPropertySymbol.SetIsWithEvents(System.Boolean)">
 <summary>
 Marks property as definitely IsWithEvents or not.
 The effects of this change cannot be undone.
 Will have no effect if someone already asked if property is IsWithEvents (and will assert since it is not supposed to happen).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEPropertySymbol.DoSignaturesMatch(Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MetadataDecoder,Microsoft.CodeAnalysis.ParamInfo{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol}[],Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEMethodSymbol,Microsoft.CodeAnalysis.ParamInfo{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol}[],Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEMethodSymbol,Microsoft.CodeAnalysis.ParamInfo{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol}[])">
 <summary>
 For the property to be considered valid, accessor signatures must be consistent
 with each other, and accessor signatures must be consistent with the property
 signature ignoring ByRef. These requirements are stricter than Dev11 which
 allows many inconsistencies including different numbers of parameters.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEPropertySymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PETypeParameterSymbol">
 <summary>
 The class to represent all generic type parameters imported from a PE/module.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PETypeParameterSymbol._lazyBoundsErrorInfo">
 <summary>
 First error calculating bounds.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PETypeParameterSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAttributeData">
 <summary>
 Represents a retargeting custom attribute
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAttributeData.GetSystemType(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Gets the retargeted System.Type type symbol.
 </summary>
 <param name="targetSymbol">Target symbol on which this attribute is applied.</param>
 <returns>Retargeted System.Type type symbol.</returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol">
 <summary>
 Essentially this is a wrapper around another AssemblySymbol that is responsible for retargeting
 symbols from one assembly to another. It can retarget symbols for multiple assemblies at the same time. 
 
 For example, compilation C1 references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. 
 In this case, in context of C2, all types from v1 of Lib.dll leaking through C1 (through method 
 signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what 
 RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not 
 reference C1.m_AssemblySymbol, but reference a special RetargetingAssemblySymbol created for 
 C1 by ReferenceManager.
 
 Here is how retargeting is implemented in general:
 - Symbols from underlying assembly are substituted with retargeting symbols.
 - Symbols from referenced assemblies that can be reused as is (i.e. doesn't have to be retargeted) are
   used as is.
 - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol._underlyingAssembly">
 <summary>
 The underlying AssemblySymbol, it leaks symbols that should be retargeted.
 This cannot be an instance of RetargetingAssemblySymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol._modules">
 <summary>
 The list of contained ModuleSymbol objects. First item in the list
 is RetargetingModuleSymbol that wraps corresponding SourceModuleSymbol 
 from m_UnderlyingAssembly.Modules list, the rest are PEModuleSymbols for 
 added modules.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol._noPiaResolutionAssemblies">
 <summary>
 An array of assemblies involved in canonical type resolution of
 NoPia local types defined within this assembly. In other words, all 
 references used by a compilation referencing this assembly.
 The array and its content is provided by ReferenceManager and must not be modified.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol._linkedReferencedAssemblies">
 <summary>
 An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
 each compilation that is using this AssemblySymbol as a reference. 
 If this AssemblySymbol is linked too, it will be in this array too.
 The array and its content is provided by ReferenceManager and must not be modified.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol.m_NoPiaUnificationMap">
 <summary>
 A map from a local NoPia type to corresponding canonical type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol._isLinked">
 <summary>
 Assembly is /l-ed by compilation that is using it as a reference.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol._lazyCustomAttributes">
 <summary>
 Retargeted custom attributes
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol,System.Boolean)">
 <summary>
 Constructor.
 </summary>
 <param name="underlyingAssembly">
 The underlying AssemblySymbol, cannot be an instance of RetargetingAssemblySymbol.
 </param>
 <param name="isLinked">
 Assembly is /l-ed by compilation that is using it as a reference.
 </param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol.UnderlyingAssembly">
 <summary>
 The underlying AssemblySymbol.
 This cannot be an instance of RetargetingAssemblySymbol.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol.GetDeclaredSpecialType(Microsoft.CodeAnalysis.SpecialType)">
 <summary>
 Lookup declaration for FX type in this Assembly.
 </summary>
 <param name="type"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingEventSymbol._retargetingModule">
 <summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingEventSymbol._underlyingEvent">
 <summary>
 The underlying EventSymbol, cannot be another RetargetingEventSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingEventSymbol._lazyCustomAttributes">
 <summary>
 Retargeted custom attributes
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingEventSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingFieldSymbol">
 <summary>
 Represents a field in a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another FieldSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingFieldSymbol._retargetingModule">
 <summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingFieldSymbol._underlyingField">
 <summary>
 The underlying FieldSymbol, cannot be another RetargetingFieldSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingFieldSymbol._lazyCustomAttributes">
 <summary>
 Retargeted custom attributes
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingFieldSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingMethodSymbol">
 <summary>
 Represents a method in a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another MethodSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingMethodSymbol._retargetingModule">
 <summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingMethodSymbol._underlyingMethod">
 <summary>
 The underlying MethodSymbol, cannot be another RetargetingMethodSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingMethodSymbol._lazyCustomAttributes">
 <summary>
 Retargeted custom attributes
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingMethodSymbol._lazyReturnTypeCustomAttributes">
 <summary>
 Retargeted return type attributes
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingMethodSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol">
 <summary>
 Represents a primary module of a <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol"/>. Essentially this is a wrapper around 
 another <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol"/> that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 
 Here is how retargeting is implemented in general:
 - Symbols from underlying module are substituted with retargeting symbols.
 - Symbols from referenced assemblies that can be reused as is (i.e. don't have to be retargeted) are
   used as is.
 - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol._retargetingAssembly">
 <summary>
 Owning <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol"/>.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol._underlyingModule">
 <summary>
 The underlying <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol"/>, cannot be another <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol"/>.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol._retargetingAssemblyMap">
 <summary>
 The map that captures information about what assembly should be retargeted 
 to what assembly. Key is the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol"/> referenced by the underlying module,
 value is the corresponding <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol"/> referenced by this module, and corresponding
 retargeting map for symbols.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol._lazyCustomAttributes">
 <summary>
 Retargeted custom attributes
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol)">
 <summary>
 Constructor.
 </summary>
 <param name="retargetingAssembly">
 Owning assembly.
 </param>
 <param name="underlyingModule">
 Underlying <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol"/>, cannot be another <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol"/>.
 </param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol.UnderlyingModule">
 <summary>
 The underlying <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol"/>, cannot be another <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol"/>.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol.SetReferences(Microsoft.CodeAnalysis.ModuleReferences{Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol},Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol)">
 <summary>
 A helper method for ReferenceManager to set AssemblySymbols for assemblies 
 referenced by this module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol._symbolMap">
 <summary>
 Retargeting map from underlying module to this one.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.SymbolMap">
 <summary>
 Retargeting map from underlying module to the retargeting module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.RetargetingAssembly">
 <summary>
 RetargetingAssemblySymbol owning retargeting module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.RetargetingAssemblyMap">
 <summary>
 The map that captures information about what assembly should be retargeted 
 to what assembly. Key is the AssemblySymbol referenced by the underlying module,
 value is the corresponding AssemblySymbol referenced by the retargeting module, 
 and corresponding retargeting map for symbols.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.UnderlyingModule">
 <summary>
 The underlying ModuleSymbol for the retargeting module.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.IsOrClosedOverAnExplicitLocalType(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Perform a check whether the type or at least one of its generic arguments 
 is an explicitly defined local type. The check is performed recursively. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol">
 <summary>
 Represents a type of a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another NamedTypeSymbol that is responsible for retargeting referenced symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol._retargetingModule">
 <summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol._underlyingType">
 <summary>
 The underlying NamedTypeSymbol, cannot be another RetargetingNamedTypeSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol._lazyCustomAttributes">
 <summary>
 Retargeted custom attributes
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol.AppendProbableExtensionMethods(System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol})">
 <summary>
 This method is called directly by a Binder when it uses this type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol.AddExtensionMethodLookupSymbolsInfo(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 This method is called directly by a Binder when it uses this type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol.AddExtensionMethodLookupSymbolsInfoViabilityCheck(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Make sure we retarget methods when underlying type checks their viability.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol.GenerateDeclarationErrors(System.Threading.CancellationToken)">
 <summary>
 Force all declaration errors to be generated.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamespaceSymbol">
 <summary>
 Represents a namespace of a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another NamespaceSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamespaceSymbol._retargetingModule">
 <summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamespaceSymbol._underlyingNamespace">
 <summary>
 The underlying NamespaceSymbol, cannot be another RetargetingNamespaceSymbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamespaceSymbol.GetDeclaredAccessibilityOfMostAccessibleDescendantType">
 <summary>
 Calculate declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Expected to be called at most once per namespace symbol, unless there is a race condition.
 
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamespaceSymbol.AppendProbableExtensionMethods(System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol})">
 <summary>
 This method is called directly by a Binder when it uses this module level namespace.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamespaceSymbol.BuildExtensionMethodsMap(System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol}})">
 <summary>
 This method is called when this namespace is part of a merged namespace and we are trying to build
 a map of extension methods for the whole merged namespace.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamespaceSymbol.BuildExtensionMethodsMapBucket(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 Make sure we retarget methods when types of the underlying namespace add them to the map.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamespaceSymbol.AddExtensionMethodLookupSymbolsInfo(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 This method is called directly by a Binder when it uses this module level namespace.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamespaceSymbol.AddExtensionMethodLookupSymbolsInfoViabilityCheck(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Make sure we retarget methods when underlying namespace checks their viability.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamespaceSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingParameterSymbol">
 <summary>
 Represents a parameter of a RetargetingMethodSymbol. Essentially this is a wrapper around 
 another ParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingParameterSymbol._underlyingParameter">
 <summary>
 The underlying ParameterSymbol, cannot be another RetargetingParameterSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingParameterSymbol._lazyCustomAttributes">
 <summary>
 Retargeted custom attributes
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingParameterSymbol.RetargetingMethodParameterSymbol._retargetingMethod">
 <summary>
 Owning RetargetingMethodSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingParameterSymbol.RetargetingPropertyParameterSymbol._retargetingProperty">
 <summary>
 Owning RetargetingPropertySymbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingParameterSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingPropertySymbol._retargetingModule">
 <summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingPropertySymbol._underlyingProperty">
 <summary>
 The underlying PropertySymbol, cannot be another RetargetingPropertySymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingPropertySymbol._lazyCustomAttributes">
 <summary>
 Retargeted custom attributes
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingPropertySymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingTypeParameterSymbol">
 <summary>
 Represents a type parameter in a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another TypeParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingTypeParameterSymbol._retargetingModule">
 <summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingTypeParameterSymbol._underlyingTypeParameter">
 <summary>
 The underlying TypeParameterSymbol, cannot be another RetargetingTypeParameterSymbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingTypeParameterSymbol.DeclaringCompilation">
 <remarks>
 This is for perf, not for correctness.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAttributeData.GetTargetAttributeSignatureIndex(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.AttributeDescription)">
 <summary>
 This method finds an attribute by metadata name and signature. The algorithm for signature matching is similar to the one
 in Module.GetTargetAttributeSignatureIndex. Note, the signature matching is limited to primitive types
 and System.Type.  It will not match an arbitrary signature but it is sufficient to match the signatures of the current set of
 well known attributes.
 </summary>
 <param name="description">Attribute to match.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAttributeData.GetSystemType(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Gets the System.Type type symbol from targetSymbol's containing assembly.
 </summary>
 <param name="targetSymbol">Target symbol on which this attribute is applied.</param>
 <returns>System.Type type symbol.</returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventWellKnownAttributeData">
 <summary>
 Information decoded from well-known custom attributes applied on an event.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodEarlyWellKnownAttributeData">
 <summary>
 Information decoded from early well-known custom attributes applied on a method.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodWellKnownAttributeData">
 <summary>
 Information decoded from well-known custom attributes applied on a method.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterEarlyWellKnownAttributeData">
 <summary>
 Information decoded from early well-known custom attributes applied on a parameter.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeEarlyWellKnownAttributeData">
 <summary>
 Information decoded from early well-known custom attributes applied on a type.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.BaseTypeAnalysis.DependencyDesc">
 <summary>
 a link in a dependency chain
 it means that "dependent" is dependent on the rest of the chain.
 "kind" tells what kind of dependency this is.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.BaseTypeAnalysis.DependencyKind">
 <summary>
 Source types may have dependencies via inheritance or containment
 The diagnostics is different in those cases.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.BaseTypeAnalysis.GetDependenceDiagnosticForBase(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Given base being resolved chain and current type produce the diagnostics 
 or Nothing if there is no cycle detected
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.BaseTypeAnalysis.GetDependenceDiagnosticForBase(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Detects situations when a type participates in a dependency loop
 And generates appropriate diagnostics.
 No diagnostics means there was no loop
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.BaseTypeAnalysis.GetDependenceChain(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 if there is a dependency chain from "current" to the "root"
 Returning Nothing, means that there is no dependency
 Returning Empty, means that root and current are the same and we have a 0-length dependency
 Otherwise a dependence chain is formed.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.BaseTypeAnalysis.GetDependencyDiagnosticsForImportedClass(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Verifies that given symbol does not have loops in its inheritance chain
 and reports appropriate diagnostics.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.BaseTypeAnalysis.GetDependencyDiagnosticsForImportedBaseInterface(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Verifies that given symbol does not have loops in its inheritance hierarchy
 and reports appropriate diagnostics.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterDiagnosticInfo">
 <summary>
 A tuple of TypeParameterSymbol and DiagnosticInfo, created for errors
 reported from ConstraintsHelper rather than creating Diagnostics directly.
 This decouples constraints checking from syntax and Locations, and supports
 callers that may want to create Location instances lazily or not at all.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstraintsHelper">
 <summary>
 Helper methods for generic type parameter constraints. There are two sets of methods: one
 set for resolving constraint "bounds" (that is, determining the effective base type, interface set,
 etc.), and another set for checking for constraint violations in type and method references.
 
 Bounds are resolved by calling one of the ResolveBounds overloads. Typically bounds are
 resolved by each TypeParameterSymbol at, or before, one of the corresponding properties
 (BaseType, Interfaces, etc.) is accessed. Resolving bounds may result in errors (cycles,
 inconsistent constraints, etc.) and it is the responsibility of the caller to report any such
 errors as declaration errors or use-site errors (depending on whether the type parameter
 was from source or metadata) and to ensure bounds are resolved for source type parameters
 even if the corresponding properties are never accessed directly.
 
 Constraints are checked by calling one of the CheckConstraints or CheckAllConstraints
 overloads for any generic type or method reference from source. In some circumstances,
 references are checked at the time the generic type or generic method is bound and constructed
 by the Binder. In those case, it is sufficient to call one of the CheckConstraints overloads
 since compound types (such as A(Of T).B(Of U) or A(Of B(Of T))) are checked incrementally
 as each part is bound. In other cases however, constraint checking needs to be delayed to
 prevent cycles where checking constraints requires binding the syntax that is currently
 being bound (such as the constraint in Class C(Of T As C(Of T)). In those cases, the caller
 must lazily check constraints, and since the types may be compound types, it is necessary
 to call CheckAllConstraints.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstraintsHelper.DirectTypeConstraintKind">
 <summary>
 Enum used internally by RemoveDirectConstraintConflicts to
 track what type constraint has been seen, to report conflicts
 between { 'Structure', 'Class', [explicit type] }. The 'New'
 constraint does not need to be tracked for those conflicts.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstraintsHelper.RemoveDirectConstraintConflicts(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterConstraint},Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol},Microsoft.CodeAnalysis.VisualBasic.Symbols.DirectConstraintConflictKind,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterDiagnosticInfo})">
 <summary>
 Return the constraints for the type parameter with any cycles
 or conflicting constraints reported as errors and removed.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstraintsHelper.CheckAllConstraints(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterDiagnosticInfo},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterDiagnosticInfo}@)">
 <summary>
 Check all generic constraints on the given type and any containing types
 (such as A(Of T) in A(Of T).B(Of U)). This includes checking constraints
 on generic types within the type (such as B(Of T) in A(Of B(Of T)())).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstraintsHelper.CheckConstraints(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterDiagnosticInfo},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterDiagnosticInfo}@)">
 <summary>
 Check type parameters for the containing type or method symbol.
 The type parameters are assumed to be the original definitions of type
 parameters from the containing type or method, and the TypeSubstitution
 instance is used for substituting type parameters within the constraints
 of those type parameters, so the substitution should map from type
 parameters to type arguments.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstraintsHelper.GetNonInterfaceConstraint(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Return the most derived type from the set of constraint types on this type
 parameter and any type parameter it depends on. Returns Nothing if there
 are no concrete constraint types. If there are multiple constraints, returns
 the most derived, ignoring any subsequent constraints that are neither
 more or less derived. This method assumes there are no constraint cycles.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstraintsHelper.GetClassConstraint(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Return the most derived class type from the set of constraint types on this type
 parameter and any type parameter it depends on. Returns Nothing if there are
 no concrete constraint types. If there are multiple constraints, returns the most
 derived, ignoring any subsequent constraints that are neither more or less derived.
 This method assumes there are no constraint cycles. Unlike GetBaseConstraintType,
 this method will always return a NamedTypeSymbol representing a class: returning
 System.ValueType for value types, System.Array for arrays, and System.Enum for enums.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstraintsHelper.GetAllConstraints(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstraintsHelper.TypeParameterAndConstraint},System.Nullable{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterConstraint})">
 <summary>
 Populate the collection with all constraints for the type parameter, traversing
 any constraints that are also type parameters. The result is a collection of type
 and flag constraints, with no type parameter references. This method assumes
 there are no constraint cycles.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstraintsHelper.TypeParameterAndConstraint">
 <summary>
 A tuple of type parameter and constraint type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstraintsHelper.HasPublicParameterlessConstructor(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Return true if the class type has a public parameterless constructor.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstraintsHelper.ContainsTypeConstraint(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterConstraint},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Return true if the constraints collection contains the given type constraint.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolExtensions.IsEmbeddedSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 True if the syntax tree is an embedded syntax tree
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager">
 <summary> 
 Manages symbols from automatically embedded syntax trees. 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager._symbols">
 <summary> Automatically embedded symbols (types, methods and fields) used in the current compilation </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager._sealed">
 <summary>
 Non-0 indicates that the collection of referenced symbols is sealed
 and so no new symbols are supposed to be added.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager._standardModuleAttributeReferenced">
 <summary>
 True if StandardModuleAttribute was used in the current compilation
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager.RegisterModuleDeclaration">
 <summary>
 Marks StandardModuleAttributeReference type as being references in the 
 current compilation. This method is to be used when a new type symbol for a 
 module is being created; we cannot pass the actual StandardModuleAttribute 
 type symbol because the symbol table is being constructed and calling 
 Compilation.GetWellKnownType(...) will cause infinite recursion. It does
 not seem reasonable to special case this in symbol creation, so we just 
 mark StandardModuleAttribute attribute as referenced and then add 
 the actual symbol when MarkAllDeferredSymbols(...) is called.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager.MarkAllDeferredSymbolsAsReferenced(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 Mark all deferred types as referenced
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager.IsAnySymbolReferenced">
 <summary>
 Returns True if any embedded symbols are referenced.
 
 WARNING: the referenced symbols collection may not be sealed yet!!!
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager.GetCurrentReferencedSymbolsSnapshot(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbol},Roslyn.Utilities.ConcurrentSet{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Makes a snapshot of the current set of referenced symbols filtered by, 
 the set of symbols provided; may be called before the referenced symbol 
 collection is sealed.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager.MarkSymbolAsReferenced(Microsoft.CodeAnalysis.VisualBasic.Symbol,Roslyn.Utilities.ConcurrentSet{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Checks if the embedded symbol provided is in the collection and adds it 
 into collection if not.
 
 See description of AddReferencedSymbolWithDependents for more details of how 
 it actually works.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager.IsSymbolReferenced(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Returns True if the embedded symbol is known to be referenced in the current compilation.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager.SealCollection">
 <summary>
 Seals the collection of referenced symbols, all *new* symbols passed 
 to SpawnSymbolCollection(...) will cause assert and be ignored.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager.AddReferencedSymbolWithDependents(Microsoft.CodeAnalysis.VisualBasic.Symbol,Roslyn.Utilities.ConcurrentSet{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Checks if the embedded symbol provided is present in the 'allSymbols' and if not 
 adds it into 'allSymbols' as well as to the collection of referenced symbols 
 managed by this manager. Also adds all the 'dependent' symbols, i.e. symbols 
 which must also be marked as referenced if 'symbol' is referenced.
 
 NOTE that when a new embedded symbol is being added to the collection of referenced 
 symbols it should be added along with all the 'dependent' symbols. For example, if 
 we add a method symbol (T1.M1) we should ensure the containing type symbol (T1) is 
 added too, as well as its constructor (T1..ctor) and maybe attribute(s) (Attr1) set 
 on T1 and their constructors/fields (Attr1..ctor), etc...
 
 All dependent symbols must be added in the current thread not depending on 
 the other concurrent threads and avoiding possible race. Thus, let's suppose we have
 the following dependencies:
 
          T1.M1 -> { T1,  T1..ctor, Attr1, Attr1..ctor, ... }
 
 we cannot just check if T1.M1 exists in the collection of referenced symbols and not 
 add dependent symbols if it does; the reason is that T1.M1 may be added by a concurrent 
 thread, but its dependencies may not be added by that thread yet. So we need to 
 calculate all dependencies and try add all the symbols together.
 
 On the other hand it should be avoided that the method *always* goes through all
 the dependencies for each symbol even though it may be definitely known that the symbol
 is added in one of the previous operations by *the same thread*. To serve this purpose 
 the method uses 'allSymbols' collection to actually check whether or not the symbol 
 is added to the collection. This makes possible to reuse the same collection in several 
 consequent calls to AddReferencedSymbolWithDependents from the same thread; for example 
 in case one thread consequently adds lots of symbols, the thread may use the same 
 'allSymbols' instance for efficient symbol filtering.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager.VbCoreSyntaxTree">
 <summary>
 Lazily created parsed representation of VB Core content
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ErrorTypeSymbol.ErrorInfo">
 <summary>
 Returns information about the reason that this type is in error.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ErrorTypeSymbol.InternalSubstituteTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ErrorTypeSymbol.NonErrorGuessType">
 <summary> 
 If we believe we know which symbol the user intended, then we should retain that information
 in the corresponding error symbol - it can be useful for deciding how to handle the error.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ErrorTypeSymbol.ResultKind">
 <summary>
 Return why the candidate symbols were bad.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ErrorTypeSymbol.CandidateSymbols">
 <summary>
 When constructing this ErrorTypeSymbol, there may have been symbols that seemed to
 be what the user intended, but were unsuitable. For example, a type might have been
 inaccessible, or ambiguous. This property returns the possible symbols that the user
 might have intended. It will return no symbols if no possible symbols were found.
 See the CandidateReason property to understand why the symbols were unsuitable.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ErrorTypeSymbol.GenerateDeclarationErrors(System.Threading.CancellationToken)">
 <summary>
 Force all declaration errors to be generated.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSignatureComparer">
 <summary>
 Implementation of IEqualityComparer for EventSymbol, with options for various aspects
 to compare.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSignatureComparer.ExplicitEventImplementationComparer">
 <summary>
 This instance is used when trying to determine which implemented interface event is implemented
 by a event with an Implements clause, according to VB rules.
 This comparer uses event signature that may come from As clause delegate or from a parameter list.
 The event signatures are compared without regard to name (including the interface part, if any)
 and the return type must match. (NOTE: that return type of implementing event is always Void)
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSignatureComparer.OverrideSignatureComparer">
 <summary>
 This instance is used to check whether one event overrides another, according to the VB definition.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSignatureComparer.RuntimeEventSignatureComparer">
 <summary>
 This instance is intended to reflect the definition of signature equality used by the runtime (ECMA 335 Section 8.6.1.6).
 It considers type, name, parameters, and custom modifiers.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSignatureComparer.WinRTConflictComparer">
 <summary>
 This instance is used to compare potential WinRT fake events in type projection.
 
 FIXME(angocke): This is almost certainly wrong. The semantics of WinRT conflict 
 comparison should probably match overload resolution (i.e., we should not add a member
  to lookup that would result in ambiguity), but this is closer to what Dev12 does.
 
 The real fix here is to establish a spec for how WinRT conflict comparison should be
 performed. Once this is done we should remove these comments.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ExtendedErrorTypeSymbol">
 <summary>
 An error type symbol with name and diagnostic. More info can be added in the future.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ExtendedErrorTypeSymbol.ErrorInfo">
 <summary>
 Returns information about the reason that this type is in error.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer">
 <summary>
 Represents a field or property initializer. Holds the symbol and the syntax for the initialization.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer.FieldsOrProperties">
 <summary>
 The fields or properties being initialized, or Nothing if this represents an executable statement in script code.
 We can get into a multiple properties case when multiple WithEvents fields are initialized with As New ...
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer.Syntax">
 <summary>
 A reference to 
 <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax"/>, 
 <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax"/>, 
 <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax"/>,
 <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax"/> (top-level statement).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer.PrecedingInitializersLength">
 <summary>
 A sum of widths of spans of all preceding initializers
 (instance and static initializers are summed separately, and trivias are not counted).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer.#ctor(Microsoft.CodeAnalysis.SyntaxReference,System.Int32)">
 <summary>
 Initializer for an executable statement in script code.
 </summary>
 <param name="syntax">The initializer syntax for the statement.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol,Microsoft.CodeAnalysis.SyntaxReference,System.Int32)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer" /> structure.
 </summary>
 <param name="field">The field.</param>
 <param name="syntax">The initializer syntax for the field.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.SyntaxReference,System.Int32)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer" /> structure.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol,Microsoft.CodeAnalysis.SyntaxReference,System.Int32)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer" /> structure.
 </summary>
 <param name="property">The property.</param>
 <param name="syntax">The initializer syntax for the property.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.IndexedTypeParameterSymbol">
 <summary>
 Indexed type parameters are used in place of type parameters for method signatures.  There is
 a unique mapping from index to a single IndexedTypeParameterSymbol.  
 
 They don't have a containing symbol or locations.
 
 They do not have constraints, variance, or attributes. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.IndexedTypeParameterSymbol.Take(System.Int32)">
 <summary>
 Create a vector of n dummy type parameters.  Always reuses the same type parameter symbol
 for the same position.
 </summary>
 <param name="count"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.InstanceErrorTypeSymbol">
 <summary>
 The base class for potentially constructible (i.e. with known arity) error type symbols
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.InstanceErrorTypeSymbol.InternalSubstituteTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.InstanceTypeSymbol">
 <summary>
 An InstanceTypeSymbol is a NamedTypeSymbol that is a pure instance type, where the class
 (and any containing classes) have no type substitutions applied.
 This class provide shared implementation for types whose definition is (possibly lazily)
 constructed from source or metadata. It provides the shared implementation between these two, primarily
 the implementation of Construct and InternalSubstituteTypeParameters.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.InstanceTypeSymbol.InternalSubstituteTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedUnstructuredExceptionHandlingResumeLabel.ResumeStatement">
 <summary>
 A [Resume] or [On Error Resume Next] statement.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.LexicalSortKey">
 <summary>
 A structure used to lexically order symbols. For performance, it's important that this be 
 a STRUCTURE, and be able to be returned from a symbol without doing any additional allocations (even
 if nothing is cached yet.)
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.LexicalSortKey.EmbeddedKind">
 <summary>
 Embedded kind of the tree. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.LexicalSortKey.TreeOrdinal">
 <summary>
 If -1, symbol is in metadata or embedded or otherwise not it source.
 Note that TreeOrdinal is only used for EmbeddedSymbolKind.None trees, thus
 negative ordinals of embedded trees do not interfere
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.LexicalSortKey.Position">
 <summary>
 Position within the tree. Doesn't need to exactly match the span returned by Locations, just
 be good enough to sort. In other words, we don't need to go to extra work to return the location of the identifier,
 just some syntax location is fine.
 
 Negative value indicates that the structure was not initialized yet, is used for lazy 
 initializations only along with LexicalSortKey.NotInitialized
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LexicalSortKey.#ctor(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 WARNING: Only use this if the location is obtainable without allocating it (even if cached later). E.g., only
 if the location object is stored in the constructor of the symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LexicalSortKey.#ctor(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 WARNING: Only use this if the node is obtainable without allocating it (even if cached later). E.g., only
 if the node is stored in the constructor of the symbol. In particular, do not call this on the result of a GetSyntax()
 call on a SyntaxReference.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LexicalSortKey.#ctor(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 WARNING: Only use this if the token is obtainable without allocating it (even if cached later). E.g., only
 if the node is stored in the constructor of the symbol. In particular, do not call this on the result of a GetSyntax()
 call on a SyntaxReference.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LexicalSortKey.Compare(Microsoft.CodeAnalysis.VisualBasic.Symbols.LexicalSortKey@,Microsoft.CodeAnalysis.VisualBasic.Symbols.LexicalSortKey@)">
 <summary>
 Compare two lexical sort keys in a compilation.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MemberSignatureComparer">
 <summary>
 This class provides an easy way to combine a MethodSignatureComparer and a PropertySignatureComparer
 to create a unified MemberSignatureComparer (e.g. for use in a HashSet).
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.MemberSignatureComparer.WinRTComparer">
 <summary>
 This instance is used to compare potential WinRT fake members in type projection.
 
 FIXME(angocke): This is almost certainly wrong. The semantics of WinRT conflict 
 comparison should probably match overload resolution (i.e., we should not add a member
  to lookup that would result in ambiguity), but this is closer to what Dev12 does.
 
 The real fix here is to establish a spec for how WinRT conflict comparison should be
 performed. Once this is done we should remove these comments.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol">
 <summary>
 A MergedNamespaceSymbol represents a namespace that merges the contents of two or more other
 namespaces. Any sub-namespaces with the same names are also merged if they have two or more
 instances.
 
 Merged namespaces are used to merged the symbols from multiple metadata modules and the source "module"
 into a single symbol tree that represents all the available symbols. The compiler resolves names
 against Me merged set of symbols.
 
 Typically there will not be very many merged namespaces in a Compilation: only the root namespaces and
 namespaces that are used in multiple referenced modules. (Microsoft, System, System.Xml,
 System.Diagnostics, System.Threading, ...)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol.CreateGlobalNamespace(Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol)">
 <summary>
 Create a possibly merged namespace symbol representing global namespace on an assembly level.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol.Create(Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol.AssemblyMergedNamespaceSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol})">
 <summary>
 Create a possibly merged namespace symbol. If only a single namespace is passed it, it is just returned directly.
 If two or more namespaces are passed in, then a new merged namespace is created with the given extent and container.
 </summary>
 <param name="extent">The namespace extent to use, IF a merged namespace is created.</param>
 <param name="containingNamespace">The containing namespace to used, IF a merged namespace is created.</param>
 <param name="namespacesToMerge">One or more namespaces to merged. If just one, then it is returned.
 The merged namespace symbol may hold onto the array.</param>
 <returns></returns>A namespace symbol representing the merged namespace.(of /returns)
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol.CreateGlobalNamespace(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 Create a possibly merged namespace symbol representing global namespace on a compilation level.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol.CreateNamespaceGroup(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol})">
 <summary>
 Create a possibly merged namespace symbol (namespace group). If only a single namespace is passed it, it is just returned directly.
 If two or more namespaces are passed in, then a new merged namespace is created
 </summary>
 <param name="namespacesToMerge">One or more namespaces to merged. If just one, then it is returned.
 The merged namespace symbol may hold onto the array.</param>
 <returns></returns>A namespace symbol representing the merged namespace.(of /returns)
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol.Create(Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol.NamespaceGroupSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol})">
 <summary>
 Create a possibly merged namespace symbol (namespace group). If only a single namespace is passed it, it is just returned directly.
 If two or more namespaces are passed in, then a new merged namespace is created with the given extent and container.
 </summary>
 <param name="containingNamespace">The containing namespace to used, IF a merged namespace is created.</param>
 <param name="namespacesToMerge">One or more namespaces to merged. If just one, then it is returned.
 The merged namespace symbol may hold onto the array.</param>
 <returns></returns>A namespace symbol representing the merged namespace.(of /returns)
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol.SlowGetChildrenOfName(System.String)">
 <summary>
 Method that is called from the CachingLookup to lookup the children of a given name. Looks
 in all the constituent namespaces.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol.SlowGetChildNames(System.Collections.Generic.IEqualityComparer{System.String})">
 <summary>
 Method that is called from the CachingLookup to get all child names. Looks
 in all constituent namespaces.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol.GetDeclaredAccessibilityOfMostAccessibleDescendantType">
 <summary>
 Calculate declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Expected to be called at most once per namespace symbol, unless there is a race condition.
 
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol.RawContainsAccessibleTypes">
 <summary>
 For test purposes only.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol.CompilationMergedNamespaceSymbol.ContainsTypesAccessibleFrom(Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol)">
 <summary>
 Returns true if namespace contains types accessible from the target assembly.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol.CompilationMergedNamespaceSymbol.BuildExtensionMethodsMap(System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol}})">
 <summary>
 Populate the map with all extension methods declared within this namespace, so that methods from
 the same type are grouped together within each bucket. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.PEPropertyOrEventHelpers">
 <summary>
 Helper methods that exist to share code between properties and events.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MetadataOrSourceAssemblySymbol">
 <summary>
 Represents source or metadata assembly.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.MetadataOrSourceAssemblySymbol._lazySpecialTypes">
 <summary>
 An array of cached Cor types defined in this assembly.
 Lazily filled by GetSpecialType method.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.MetadataOrSourceAssemblySymbol._cachedSpecialTypes">
 <summary>
 How many Cor types have we cached so far.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialType(Microsoft.CodeAnalysis.SpecialType)">
 <summary>
 Lookup declaration for predefined CorLib type in this Assembly. Only should be
 called if it is know that this is the Cor Library (mscorlib).
 </summary>
 <param name="type"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MetadataOrSourceAssemblySymbol.RegisterDeclaredSpecialType(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Register declaration of predefined CorLib type in this Assembly.
 </summary>
 <param name="corType"></param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MetadataOrSourceAssemblySymbol.KeepLookingForDeclaredSpecialTypes">
 <summary>
 Continue looking for declaration of predefined CorLib type in this Assembly
 while symbols for new type declarations are constructed.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MetadataOrSourceAssemblySymbol.MakeFinalIVTDetermination(Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol)">
 <summary>
 Determine whether this assembly has been granted access to <paramref name="potentialGiverOfAccess"></paramref>.
 Assumes that the public key has been determined. The result will be cached.
 </summary>
 <param name="potentialGiverOfAccess"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.MetadataOrSourceAssemblySymbol._lazySpecialTypeMembers">
 <summary>
 Lazy cache of special members.
 Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
 <summary>
 Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
 assembly is the Cor Library
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolComparisonResults.RequiredExtraParameterMismatch">
 <summary> 
 One of the methods has more parameters than the other 
 AND 
 at least one of the extra parameters is NOT optional
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolComparisonResults.OptionalParameterMismatch">
 <summary> 
 One of the methods has more parameters than the other 
 AND at least one of the extra parameters IS optional
 OR 
 there is at least one parameter in one method with optionality (being optional or 
 required) not equal to that of the matching parameter from the other method
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolComparisonResults.TotalParameterCountMismatch">
 <summary>
 Mismatch in total number of parameters, both required and optional
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSignatureComparer">
 <summary>
 Implementation of IEqualityComparer for MethodSymbols, with options for various aspects
 to compare.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSignatureComparer.RuntimeMethodSignatureComparer">
 <summary>
 This instance is intended to reflect the definition of signature equality used by the runtime (ECMA 335 Section 8.6.1.6).
 It considers return type, name, parameters, calling convention, and custom modifiers.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSignatureComparer.AllAspectsSignatureComparer">
 <summary>
 This instance is used to compare all aspects.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSignatureComparer.ParametersAndReturnTypeSignatureComparer">
 <summary>
 This instance is used to compare parameter and return types, including byref.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSignatureComparer.CustomModifiersAndParametersAndReturnTypeSignatureComparer">
 <summary>
 This instance is used to compare custom modifiers, parameter and return types, including byref.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSignatureComparer.VisualBasicSignatureAndConstraintsAndReturnTypeComparer">
 <summary>
 This instance is used to search for methods that have the same signature, return type,
 and constraints according to the VisualBasic definition.  Custom modifiers are ignored.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSignatureComparer.RetargetedExplicitMethodImplementationComparer">
 <summary>
 This instance is used to search for methods that have identical signatures in every regard.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSignatureComparer.WinRTConflictComparer">
 <summary>
 This instance is used to compare potential WinRT fake methods in type projection.
 
 FIXME(angocke): This is almost certainly wrong. The semantics of WinRT conflict 
 comparison should probably match overload resolution (i.e., we should not add a member
  to lookup that would result in ambiguity), but this is closer to what Dev12 does.
 
 The real fix here is to establish a spec for how WinRT conflict comparison should be
 performed. Once this is done we should remove these comments.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSignatureComparer.AreConstraintTypesSubset(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol})">
 <summary>
 Returns true if the first set of constraint types
 is a subset of the second set.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbolExtensions.CanBeCalledWithNoParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 Determines if the method can be called with empty parameter list.
 </summary>
 <param name="method">The method.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbolExtensions.IsPartial(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary> 
 Determines if the method is partial 
 </summary>
 <param name="method">The method</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbolExtensions.IsPartialWithoutImplementation(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary> 
 Determines if the method is partial and does NOT have implementation provided 
 </summary>
 <param name="method">The method</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbolExtensions.IsUserDefinedOperator(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 Is method a user-defined operator.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingAssemblySymbol">
 <summary>
 A <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingAssemblySymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol"/> that represents
 an assembly that couldn't be found.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingCorLibrarySymbol">
 <summary>
 AssemblySymbol to represent missing, for whatever reason, CorLibrary.
 The symbol is created by ReferenceManager on as needed basis and is shared by all compilations
 with missing CorLibraries.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingCorLibrarySymbol._lazySpecialTypes">
 <summary>
 An array of cached Cor types defined in this assembly.
 Lazily filled by GetDeclaredSpecialType method.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingCorLibrarySymbol.GetDeclaredSpecialType(Microsoft.CodeAnalysis.SpecialType)">
 <summary>
 Lookup declaration for predefined CorLib type in this Assembly. Only should be
 called if it is know that this is the Cor Library (mscorlib).
 </summary>
 <param name="type"></param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingMetadataTypeSymbol">
 <summary>
 A MissingMetadataSymbol is a special kind of ErrorSymbol that represents
 a type symbol that was attempted to be read from metadata, but couldn't be
 found, because:
   a) The metadata file it lives in wasn't referenced
   b) The metadata file was referenced, but didn't contain the type
   c) The metadata file was referenced, contained the correct outer type, but
      didn't contains a nested type in that outer type.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingMetadataTypeSymbol.TopLevel">
 <summary>
 Represents not nested missing type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingMetadataTypeSymbol.TopLevel._lazyTypeId">
 <summary>
 SpecialType.TypeId
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingMetadataTypeSymbol.TopLevel.NamespaceName">
 <summary>
 This is the FULL namespace name (e.g., "System.Collections.Generic")
 of the type that couldn't be found.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingMetadataTypeSymbol.Nested">
 <summary>
 Represents nested missing type.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingModuleSymbol">
 <summary>
 A <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingModuleSymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol"/> that represents
 a module that couldn't be found.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingNamespaceSymbol">
 <summary>
 A <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingNamespaceSymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol"/> that represents
 a namespace that couldn't be found.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol">
 <summary>
 Represents a module within an assembly. Every assembly contains one or more modules.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.Ordinal">
 <summary>
 Module's ordinal within containing assembly's Modules array.
 0 - for a source module, etc.
 -1 - for a module that doesn't have containing assembly, or has it, but is not part of Modules array. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.Machine">
 <summary>
 Target architecture of the machine.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.Bit32Required">
 <summary>
 Indicates that this PE file makes Win32 calls. See CorPEKind.pe32BitRequired for more information (http://msdn.microsoft.com/en-us/library/ms230275.aspx).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.GlobalNamespace">
 <summary>
 Returns a NamespaceSymbol representing the global (root) namespace, with
 module extent, that can be used to browse all of the symbols defined in this module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.ContainingAssembly">
 <summary>
 Returns the containing assembly. Modules are always directly contained by an assembly,
 so this property always returns the same as ContainingSymbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.ReferencedAssemblies">
 <summary>
 Returns an array of assembly identities for assemblies referenced by this module.
 Items at the same position from ReferencedAssemblies And from ReferencedAssemblySymbols 
 correspond to each other.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.GetMetadata">
 <summary>
 If this symbol represents a metadata module returns the underlying <see cref="T:Microsoft.CodeAnalysis.ModuleMetadata"/>.
 
 Otherwise, this returns <code>nothing</code>.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.GetReferencedAssemblies">
 <summary>
 Returns an array of assembly identities for assemblies referenced by this module.
 Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
 should correspond to each other.
 
 The array and its content is provided by ReferenceManager and must not be modified.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.ReferencedAssemblySymbols">
 <summary>
 Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
 by this module. Items at the same position from ReferencedAssemblies And 
 from ReferencedAssemblySymbols correspond to each other.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.GetReferencedAssemblySymbols">
 <summary>
 Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
 by this module. Items at the same position from GetReferencedAssemblies and 
 from GetReferencedAssemblySymbols should correspond to each other. If reference is 
 not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
 corresponding item.
 
 The array and its content is provided by ReferenceManager and must not be modified.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.SetReferences(Microsoft.CodeAnalysis.ModuleReferences{Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol},Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol)">
 <summary>
 A helper method for ReferenceManager to set assembly identities for assemblies
 referenced by this module and corresponding AssemblySymbols.
 </summary>
 <param name="moduleReferences">A description of the assemblies referenced by this module.</param>

 <param name="originatingSourceAssemblyDebugOnly">
 Source assembly that triggered creation of this module symbol.
 For debug purposes only, this assembly symbol should not be persisted within
 this module symbol because the module can be shared across multiple source
 assemblies. This method will only be called for the first one.
 </param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.HasUnifiedReferences">
 <summary>
 True if this module has any unified references.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.GetUnificationUseSiteErrorInfo(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary> 
 Returns a unification use-site error (if any) for a symbol contained in this module 
 that is referring to a specified <paramref name="dependentType"/>.
 </summary> 
 <remarks> 
 If an assembly referenced by this module isn't exactly matching any reference given to compilation 
 the Assembly Manager might decide to use another reference if it matches except for version 
 (it unifies the version with the existing reference).  
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.LookupTopLevelMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
 <summary>
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
 <param name="emittedName">
 Full type name possibly with generic name mangling.
 </param>
 <returns>
 Symbol for the type, or MissingMetadataSymbol if the type isn't found.
 </returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.HasAssemblyCompilationRelaxationsAttribute">
 <summary>
 Returns true if there is any applied CompilationRelaxationsAttribute assembly attribute for this module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.HasAssemblyRuntimeCompatibilityAttribute">
 <summary>
 Returns true if there is any applied RuntimeCompatibilityAttribute assembly attribute for this module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.DefaultMarshallingCharSet">
 <summary>
 Default char set for contained types, or null if not specified.
 </summary>
 <remarks>
 Determined based upon value specified via <see cref="T:System.Runtime.InteropServices.DefaultCharSetAttribute"/> applied on this module.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.GetModuleNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)">
 <summary>
 Given a namespace symbol, returns the corresponding module specific namespace symbol
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.IsMissing">
 <summary>
 Does this symbol represent a missing Module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.MightContainExtensionMethods">
 <summary>
 If this property returns false, it is certain that there are no extension
 methods (from language perspective) inside this module. If this property returns true, 
 it is highly likely (but not certain) that this type contains extension methods. 
 This property allows the search for extension methods to be narrowed much more quickly.
 
 !!! Note that this property can mutate during lifetime of the symbol !!!
 !!! from True to False, as we learn more about the module.           !!! 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol.ObsoleteAttributeData">
 <summary>
 Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
 This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbolExtensions.IsOrInGenericType(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Safe to call on a null reference.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbolExtensions.FindFieldOrProperty(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,System.String,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Given a name, find a member field or property (ignoring all other members) in a type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbolExtensions.AsUnboundGenericType(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Given a possibly constructed/specialized generic type, create a symbol
 representing an unbound generic type for its definition.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceExtent">
 <summary>
 A NamespaceExtent represents whether a namespace contains types and sub-namespaces from a particular module,
 assembly, or merged across all modules (source and metadata) in a particular compilation.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceExtent.Kind">
 <summary>
 Returns what kind of extent: Module, Assembly, or Compilation.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceExtent.Module">
 <summary>
 If the Kind is ExtendKind.Module, returns the module symbol that this namespace
 encompasses. Otherwise throws InvalidOperationException.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceExtent.Assembly">
 <summary>
 If the Kind is ExtendKind.Assembly, returns the assembly symbol that this namespace
 encompasses. Otherwise throws InvalidOperationException.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceExtent.Compilation">
 <summary>
 If the Kind is ExtendKind.Compilation, returns the compilation symbol that this namespace
 encompasses. Otherwise throws InvalidOperationException.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceExtent.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol)">
 <summary>
 Create a NamespaceExtent that represents a given ModuleSymbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceExtent.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol)">
 <summary>
 Create a NamespaceExtent that represents a given AssemblySymbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceExtent.#ctor(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 Create a NamespaceExtent that represents a given Compilation.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol">
 <summary>
 Represents either a namespace or a type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.IsNamespace">
 <summary>
 Returns true if this symbol is a namespace. If its not a namespace, it must be a type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.IsType">
 <summary>
 Returns true if this symbols is a type. Equivalent to Not IsNamespace.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.GetMembers">
 <summary>
 Get all the members of this symbol.
 </summary>
 <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.GetMembersUnordered">
 <summary>
 Get all the members of this symbol. The members may not be in a particular order, and the order
 may not be stable from call-to-call.
 </summary>
 <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
 returns an empty ImmutableArray. Never returns null.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.GetMembers(System.String)">
 <summary>
 Get all the members of this symbol that have a particular name.
 </summary>
 <returns>An ImmutableArray containing all the members of this symbol with the given name. If there are
 no members with this name, returns an empty ImmutableArray. The result is deterministic (i.e. the same
 from call to call and from compilation to compilation). Members of the same kind appear in the result
 in the same order in which they appeared at their origin (metadata or source).
 Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.GetTypeMembersUnordered">
 <summary>
 Get all the type members of this symbol. The types may not be in a particular order, and the order
 may not be stable from call-to-call.
 </summary>
 <returns>An ImmutableArray containing all the type members of this symbol. If this symbol has no type members,
 returns an empty ImmutableArray. Never returns null.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.GetTypeMembers">
 <summary>
 Get all the members of this symbol that are types.
 </summary>
 <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.GetTypeMembers(System.String)">
 <summary>
 Get all the members of this symbol that are types that have a particular name, and any arity.
 </summary>
 <returns>An ImmutableArray containing all the types that are members of this symbol with the given name. 
 If this symbol has no type members with this name,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.GetTypeMembers(System.String,System.Int32)">
 <summary>
 Get all the members of this symbol that are types that have a particular name and arity.
 </summary>
 <returns>An ImmutableArray containing all the types that are members of this symbol with the given name and arity.
 If this symbol has no type members with this name and arity,
 returns an empty ImmutableArray. Never returns Nothing.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.IsMustOverride">
 <summary>
 Returns true if this symbol was declared as requiring an override; i.e., declared
 with the "MustOverride" modifier. Never returns true for types. 
 </summary>
 <returns>
 Always returns False.
 </returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.IsNotOverridable">
 <summary>
 Returns true if this symbol was declared to override a base class members and was
 also restricted from further overriding; i.e., declared with the "NotOverridable"
 modifier. Never returns true for types.
 </summary>
 <returns>
 Always returns False.
 </returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.IsOverridable">
 <summary>
 Returns true if this member is overridable, has an implementation,
 and does not override a base class member; i.e., declared with the "Overridable"
 modifier. Does not return true for members declared as MustOverride or Overrides.
 </summary>
 <returns>
 Always returns False.
 </returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.IsOverrides">
 <summary>
 Returns true if this symbol was declared to override a base class members; i.e., declared
 with the "Overrides" modifier. Still returns true if the members was declared
 to override something, but (erroneously) no member to override exists.
 </summary>
 <returns>
 Always returns False.
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.AddExtensionMethodLookupSymbolsInfo(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol}}})">
 <summary>
 This is a helper method shared between NamedTypeSymbol and NamespaceSymbol.
 
 Its purpose is to add names of probable extension methods found in membersByName parameter
 to nameSet parameter. Method's viability check is delegated to overridable method
 AddExtensionMethodLookupSymbolsInfoViabilityCheck, which is overridden by RetargetingNamedtypeSymbol
 and RetargetingNamespaceSymbol in order to perform the check on corresponding RetargetingMethodSymbol.
 
 Returns true if there were extension methods among the members, 
 regardless whether their names were added into the set. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.AddExtensionMethodLookupSymbolsInfoViabilityCheck(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Perform extension method viability check within AppendExtensionMethodNames method above.
 This method is overridden by RetargetingNamedtypeSymbol and RetargetingNamespaceSymbol in order to 
 perform the check on corresponding RetargetingMethodSymbol.
 
 Returns true if the method is viable. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol.GetNamespaceOrTypeByQualifiedName(System.Collections.Generic.IEnumerable{System.String})">
 <summary> 
 Finds types or namespaces described by a qualified name. 
 </summary> 
 <param name="qualifiedName">Sequence of simple plain names.</param>
  <returns> A set of namespace or type symbols with given qualified name (might comprise of types with multiple generic arities),  
 or an empty set if the member can't be found (the qualified name is ambiguous or the symbol doesn't exist). 
 </returns> 
 <remarks> 
 "C.D" matches C.D, C(Of T).D, C(Of S,T).D(Of U), etc. 
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingAssemblySymbol">
 <summary>
 A <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingAssemblySymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol"/> that represents
 an assembly that is not missing, i.e. the "real" thing.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingAssemblySymbol._emittedNameToTypeMap">
 <summary>
 This is a cache similar to the one used by MetaImport::GetTypeByName
 in native compiler. The difference is that native compiler pre-populates 
 the cache when it loads types. Here we are populating the cache only
 with things we looked for, so that next time we are looking for the same 
 thing, the lookup is fast. This cache also takes care of TypeForwarders. 
 Gives about 8% win on subsequent lookups in some scenarios.     
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingAssemblySymbol._lazyGlobalNamespace">
 <summary>
 The global namespace symbol. Lazily populated on first access.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingAssemblySymbol.IsMissing">
 <summary>
 Does this symbol represent a missing assembly.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingAssemblySymbol.GlobalNamespace">
 <summary>
 Gets the merged root namespace that contains all namespaces and types defined in the modules
 of this assembly. If there is just one module in this assembly, this property just returns the 
 GlobalNamespace of that module.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingAssemblySymbol.LookupTopLevelMetadataTypeWithCycleDetection(Microsoft.CodeAnalysis.MetadataTypeName@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol},System.Boolean)">
 <summary>
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.  Detect cycles during lookup.
 </summary>
 <param name="emittedName">
 Full type name, possibly with generic name mangling.
 </param>
 <param name="visitedAssemblies">
 List of assemblies lookup has already visited (since type forwarding can introduce cycles).
 </param>
 <param name="digThroughForwardedTypes">
 Take forwarded types into account.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingAssemblySymbol.CachedTypeByEmittedName(System.String)">
 <summary>
 For test purposes only.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingAssemblySymbol.EmittedNameToTypeMapCount">
 <summary>
 For test purposes only.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingModuleSymbol">
 <summary>
 A <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingModuleSymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol"/> that represents
 a module that is not missing, i.e. the "real" thing.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingModuleSymbol._moduleReferences">
 <summary>
 An array of <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol"/> objects corresponding to assemblies directly referenced by this module.
 </summary>
 <remarks>
 The contents are provided by ReferenceManager and may not be modified.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingModuleSymbol.IsMissing">
 <summary>
 Does this symbol represent a missing Module.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingModuleSymbol.GetReferencedAssemblies">
 <summary>
 Returns an array of assembly identities for assemblies referenced by this module.
 Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
 should correspond to each other.
 
 The array and its content is provided by ReferenceManager and must not be modified.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingModuleSymbol.GetReferencedAssemblySymbols">
 <summary>
 Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
 by this module. Items at the same position from GetReferencedAssemblies and 
 from GetReferencedAssemblySymbols should correspond to each other. If reference is 
 not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
 corresponding item.
 
 The array and its content is provided by ReferenceManager and must not be modified.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingModuleSymbol.SetReferences(Microsoft.CodeAnalysis.ModuleReferences{Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol},Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol)">
 <summary>
 A helper method for ReferenceManager to set assembly identities for assemblies 
 referenced by this module and corresponding AssemblySymbols.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingModuleSymbol.LookupTopLevelMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
 <summary>
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
 <param name="emittedName">
 Full type name, possibly with generic name mangling.
 </param>
 <returns>
 Symbol for the type, or MissingMetadataSymbol if the type isn't found.
 </returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.NoPiaAmbiguousCanonicalTypeSymbol">
 <summary>
 A NoPiaAmbiguousCanonicalTypeSymbol is a special kind of ErrorSymbol that represents
 a NoPia embedded type symbol that was attempted to be substituted with canonical type, 
 but the canonical type was ambiguous.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.NoPiaIllegalGenericInstantiationSymbol">
 <summary>
 A NoPiaIllegalGenericInstantiationSymbol is a special kind of ErrorSymbol that represents
 a generic type instantiation that cannot cross assembly boundaries according to NoPia rules.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.NoPiaMissingCanonicalTypeSymbol">
 <summary>
 A NoPiaMissingCanonicalTypeSymbol is a special kind of ErrorSymbol that represents
 a NoPia embedded type symbol that was attempted to be substituted with canonical type, 
 but the canonical type couldn't be found.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(Microsoft.CodeAnalysis.ObsoleteAttributeData@,System.Reflection.Metadata.EntityHandle,Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol)">
 <summary>
 Initialize the ObsoleteAttributeData by fetching attributes and decoding ObsoleteAttributeData. This can be 
 done for Metadata symbol easily whereas trying to do this for source symbols could result in cycles.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ObsoleteAttributeHelpers.GetObsoleteContextState(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Boolean)">
 <summary>
 This method checks to see if the given symbol is Obsolete or if any symbol in the parent hierarchy is Obsolete.
 </summary>
 <returns>
 True if some symbol in the parent hierarchy is known to be Obsolete. Unknown if any
 symbol's Obsoleteness is Unknown. False, if we are certain that no symbol in the parent
 hierarchy is Obsolete.
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Create a diagnostic for the given symbol. This could be an error or a warning based on
 the ObsoleteAttribute's arguments.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverriddenMembersResult`1">
 <summary>
 Groups the information computed by MakeOverriddenMembers.
 </summary>
 <remarks>
 In C# this class also stores hidden members (and is named OverriddenOrHiddenMembersResult). 
 The way VB warns on hidden members, this did not turn out to be useful.
 </remarks>
 <typeparam name="TSymbol">Expected to be a member symbol type (e.g. method, property).</typeparam>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverriddenMembersResult`1.OverriddenMembers">
 <summary>
 The member(s) that are potentially being overridden. This collection only contains 
 candidates having signature 'exactly' matching the signature of the method/property. 
 
 'Exact' signature match is defined as 'general' signature match plus NO
 mismatches in total number of parameters or optional parameter types.
 
 See comments on InaccessibleMembers for more details on 'general' signature match.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverriddenMembersResult`1.InexactOverriddenMembers">
 <summary>
 The member(s) that are potentially being overridden. This collection only contains 
 candidates having signature 'generally' matching the signature of the method/property. 
 
 Two signatures 'generally' match if DetailedSignatureCompare (...) returns no 
 mismatches defined in SymbolComparisonResults.AllMismatches ignoring mismatches 
 grouped in SymbolComparisonResults.MismatchesForConflictingMethods.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverriddenMembersResult`1.InaccessibleMembers">
 <summary>
 Members that would be in OverriddenMembers if they were accessible.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverriddenMembersResult`1.OverriddenMember">
 <summary>
 It Is Not suitable to call this method on a <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverriddenMembersResult`1"/> object
 associated with a member within substituted type, <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverriddenMembersResult`1.GetOverriddenMember(`0,`0)"/>
 should be used instead.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.PEOrSourceOrMergedNamespaceSymbol">
 <summary>
 Represents a namespace.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.PEOrSourceOrMergedNamespaceSymbol._lazyExtensionMethodsMap">
 <summary>
 For a given namespace in context of a particular Compilation all binders use 
 either a compilation merged namespace symbol, or a module level namespace symbol 
 (PE, Source or Retargeting). In order to speed-up lookup of extension methods performed 
 by a binder, we build and cache a map of all extension methods declared within the namespace 
 grouped by name (case-insensitively). 
 
 If binder uses compilation merged namespace symbol, the map is built across all underlying 
 module level namespace symbols, separate maps for underlying namespace symbols are not built.
 
 If binder uses Retargeting module level namespace symbol, we build the map for the underlying 
 namespace symbol instead and push all requests through the underlying namespace.
 
 The map actually stores ImmutableArray(Of MethodSymbol), but we are using ImmutableArray(Of Symbol)
 in order to be able to pass the map to a more general API.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.PEOrSourceOrMergedNamespaceSymbol.DeclaredAccessibilityOfMostAccessibleDescendantType">
 <summary>
 Returns declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.PEOrSourceOrMergedNamespaceSymbol.AppendProbableExtensionMethods(System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol})">
 <summary>
 This is an entry point for the Binder to collect extension methods with the given name 
 declared within this (compilation merged or module level) namespace, so that methods 
 from the same type are grouped together. 
 
 A cached map of extension methods is used to optimize the lookup.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.PEOrSourceOrMergedNamespaceSymbol.AddExtensionMethodLookupSymbolsInfo(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol)">
 <summary>
 Add names of viable extension methods declared in this (compilation merged or module level) 
 namespace to nameSet parameter.
 
 The 'appendThrough' parameter allows RetargetingNamespaceSymbol to delegate majority of the work 
 to the underlying namespace symbol, but still perform viability check on RetargetingMethodSymbol.
 
 A cached map of extension methods is used to optimize the operation.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.PEOrSourceOrMergedNamespaceSymbol.EnsureExtensionMethodsAreCollected">
 <summary>
 Build and cache a map of probable extension methods for this namespace.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.PointerTypeSymbol">
 <summary>
 An error type symbol to represent a pointer type.
 Pointer types are not supported by VB language, but internally
 we need to be able to match them in signatures of methods 
 imported from metadata.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.PreprocessingSymbol">
 <summary>
 Represents a preprocessing conditional compilation symbol.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySignatureComparer">
 <summary>
 Implementation of IEqualityComparer for PropertySymbols, with options for various aspects
 to compare.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySignatureComparer.AllAspectsSignatureComparer">
 <summary>
 This instance is used to compare all aspects.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySignatureComparer.RuntimePropertySignatureComparer">
 <summary>
 This instance is intended to reflect the definition of signature equality used by the runtime (ECMA 335 Section 8.6.1.6).
 It considers type, name, parameters, and custom modifiers.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySignatureComparer.RetargetedExplicitPropertyImplementationComparer">
 <summary>
 This instance is used to search for properties that have identical signatures in every regard.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySignatureComparer.WinRTConflictComparer">
 <summary>
 This instance is used to compare potential WinRT fake properties in type projection.
 
 FIXME(angocke): This is almost certainly wrong. The semantics of WinRT conflict 
 comparison should probably match overload resolution (i.e., we should not add a member
  to lookup that would result in ambiguity), but this is closer to what Dev12 does.
 
 The real fix here is to establish a spec for how WinRT conflict comparison should be
 performed. Once this is done we should remove these comments.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbolExtensions.GetCanBeCalledWithNoParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol)">
 <summary>
 Determines if the property can be accessed with empty parameter list.
 </summary>
 <param name="prop">The property.</param><returns></returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ReducedExtensionMethodSymbol">
 <summary>
 Represents a curried extension method definition - first parameter and fixed 
 type parameters removed.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ReducedExtensionMethodSymbol.Create(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,System.Int32)">
 <summary>
 If this is an extension method that can be applied to an instance of the given type,
 returns the curried method symbol thus formed. Otherwise, returns Nothing.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ReducedExtensionMethodSymbol.ReducedTypeParameterSymbol">
 <summary>
 Represents type parameter of a curried extension method definition.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ReducedExtensionMethodSymbol.ReducedParameterSymbol">
 <summary>
 Represents parameter of a curried extension method definition.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SignatureOnlyMethodSymbol">
 <summary>
 A representation of a method symbol that is intended only to be used for comparison purposes
 (esp in MethodSignatureComparer).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SignatureOnlyParameterSymbol">
 <summary>
 Intended to be used to create ParameterSymbols for a SignatureOnlyMethodSymbol.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SignatureOnlyPropertySymbol">
 <summary>
 A representation of a property symbol that is intended only to be used for comparison purposes
 (esp in PropertySignatureComparer).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol">
 <summary>
 Represents a Lambda parameter for a LambdaSymbol.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.CrefTypeParameterSymbol">
 <summary>
 Type parameters in documentation comments are complicated since they sort of act as declarations,
 rather than references. Like in the following example:
 
     <code>
         ''' <see CREF="TypeA(Of X, Y).MethodB(x As X, y As Y)"/>
         Class Clazz
             ...
     </code>
 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.CustomEventAccessorSymbol.IsSub">
 <remarks>
 We're going to ignore SourceMemberFlags.MethodIsSub and override IsSub explicitly.  We do this because
 the flags have to be set at construction time, but IsSub depends on IsWindowsRuntimeEvent, which depends
 on interface implementations, which we don't want to bind until the member list is complete.  (It's probably 
 okay now (2012/12/17), but it would be very fragile to take a dependency on the exact mechanism by which
  interface members are looked up.)
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.CustomEventAccessorSymbol.BindParameters(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind and validate parameters declared on the accessor.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.CustomModifierUtils.CopyParameterCustomModifiers(Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol@)">
 <summary>
 Returns True if <paramref name="thisParam"/> was modified.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.IAttributeTargetSymbol.DefaultAttributeLocation">
 <summary>
 Attribute location corresponding to this symbol.
 </summary>
 <remarks>
 Location of an attribute if an explicit location is not specified via attribute target specification syntax.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ImplementsHelper">
 <summary>
 Methods, Properties, and Events all have implements clauses and need to handle interface
 implementation. This module has helper methods and extensions for sharing by multiple
 symbol types.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ImplementsHelper.FindExplicitlyImplementedMember``1(``0,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.VisualBasic.LookupResultKind@)">
 <summary>
 Find the implemented method denoted by "implementedMemberSyntax" that matches implementingSym.
 Returns the implemented method, or Nothing if none.
 
 Also stores into "candidateSymbols" (if not Nothing) and resultKind the symbols and result kind that
 should be used for semantic model purposes.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ImplementsHelper.MembersAreMatchingForPurposesOfInterfaceImplementation(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Does 'implementingSym' match 'implementedSym' well enough to be considered a match for interface implementation?
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ImplementsHelper.ValidateImplementedMember``1(``0,``0,Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Perform additional validate of implementedSym and issue diagnostics.
 Return "implementedSym" if the symbol table should record implementedSym as the implemented
 symbol (even if diagnostics were issues). Returns Nothing if the code should not treat
 implementedSym as the implemented symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ImplementsHelper.ValidateImplementedMethodConstraints(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Validate method type parameter constraints. This is handled outside
 of ValidateImplementedMember because that method is invoked
 while computing the ExplicitInterfaceImplementations value on the
 implementing method, but method type parameters rely on the value
 of ExplicitInterfaceImplementations to determine constraints correctly.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ImplementsHelper.ComputeImplementationForInterfaceMember``1(``0,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.IEqualityComparer{``0})">
 <summary>
 Performs interface mapping to determine which symbol in this type or a base type
 actually implements a particular interface member.
 </summary>
 <typeparam name="TSymbol">MethodSymbol or PropertySymbol or EventSymbol (an interface member).</typeparam>
 <param name="interfaceMember">A non-null member on an interface type.</param>
 <param name="implementingType">The type implementing the interface member.</param>
 <param name="comparer">A comparer for comparing signatures of TSymbol according to metadata implementation rules.</param>
 <returns>The implementing member or Nothing, if there isn't one.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ImplementsHelper.FindImplicitImplementationDeclaredInType``1(``0,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.IEqualityComparer{``0})">
 <summary>
 Search the declared methods of a type for one that could be an implicit implementation
 of a given interface method (depending on interface declarations). It is assumed that the implementing
 type is not a source type.
 </summary>
 <typeparam name="TSymbol">MethodSymbol or PropertySymbol or EventSymbol (an interface member).</typeparam>
 <param name="interfaceMember">The interface member being implemented.</param>
 <param name="currType">The type on which we are looking for a declared implementation of the interface method.</param>
 <param name="comparer">A comparer for comparing signatures of TSymbol according to metadata implementation rules.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.ImplementsHelper.SubstituteExplicitInterfaceImplementations``1(System.Collections.Immutable.ImmutableArray{``0},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Given a set of explicit interface implementations that are undergoing substitution, return the substituted versions.
 </summary>
 <typeparam name="TSymbol">Type of the interface members (Method, Property, Event)</typeparam>
 <param name="unsubstitutedImplementations">The ROA of members that are being implemented</param>
 <param name="substitution">The type substitution</param>
 <returns>The substituted members.</returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ImplicitNamedTypeSymbol">
 <summary> 
 Represents implicit, script and submission classes. 
 </summary>    
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaParameterSymbol">
 <summary>
 Represents a Lambda parameter.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol">
 <summary>
 Represents a method symbol for a lambda method.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol.ReturnTypeIsBeingInferred">
 <summary>
 This symbol is used as the return type of a LambdaSymbol when we are interpreting 
 lambda's body in order to infer its return type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol.ReturnTypeIsUnknown">
 <summary>
 This symbol is used as the return type of a LambdaSymbol when we failed to 
 infer lambda's return type, but still want to interpret its body.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol.ReturnTypePendingDelegate">
 <summary>
 This symbol is used as the return type of a LambdaSymbol when we are dealing with
 query lambda and the return type should be taken from the target delegate upon
 successful conversion. The LambdaSymbol will be mutated then. 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol.ReturnTypeVoidReplacement">
 <summary>
 This symbol is used as the return type of a LambdaSymbol when System.Void is used in code.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol.ErrorRecoveryInferenceError">
 <summary>
 This symbol is used as a sentinel while we are binding a lambda in error recovery mode.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol.m_ReturnType">
 <summary>
 Can mutate for a query lambda from ReturnTypePendingDelegate 
 to the return type of the target delegate.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol.TryGetMeParameter(Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol@)">
 <summary>
 "Me" parameter for this lambda will be that of the containing symbol
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalDeclarationKind">
 <summary>
 Specifies the syntax that a user defined variable comes from.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalDeclarationKind.None">
 <summary> 
 The local is not user defined nor it is a copy of a user defined local (e.g. with a substituted type).
 Check the value of <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.SynthesizedKind"/> for the kind of synthesized variable.
 </summary> 
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalDeclarationKind.ImplicitVariable">
 <summary>
 Implicitly declared variable (w/o variable declaration).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalDeclarationKind.AmbiguousLocals">
 <summary> 
 Only used in flow analysis for the pseudo-local representing a symbol 
 of the implicit receiver in case Dim statement defines more than one 
 variable, but uses the same object initializer for all of them, like in: 
     Dim a,b As New C() With { .X = .Y } 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol">
 <summary>
 Represents a local variable (typically inside a method body). This could also be a local variable implicitly
 declared by a For, Using, etc. When used as a temporary variable, its container can also be a Field or Property Symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.Create(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalDeclarationKind)">
 <summary>
  Create a local symbol from a local variable declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.Create(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalDeclarationKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Create a local symbol associated with an identifier token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.Create(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalDeclarationKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String)">
 <summary>
 Create a local symbol associated with an identifier token and a different name.
 Used for WinRT event handler return value variable).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.Create(Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Create a local symbol with substituted type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.CreateInferredForFromTo(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax)">
 <summary>
 Create an inferred local symbol from a For from-to statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.CreateInferredForEach(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Create an inferred local symbol from a For-each statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Create a local variable symbol. Note: this does not insert it automatically into a
 local binder so that it can be found by lookup.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.IsReadOnly">
 <summary>
 Returns true if this local is a ReadOnly local. Compiler has a concept of ReadOnly locals.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.GetDeclaratorSyntax">
 <summary>
 Returns the syntax node that declares the variable.
 </summary>
 <remarks>
 All user-defined and long-lived synthesized variables must return a reference to a node that is 
 tracked by the EnC diffing algorithm. For example, for <see cref="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalDeclarationKind.Catch"/> variable
 the declarator is the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax"/> node, not the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax"/>
 that immediately contains the variable.
 
 The location of the declarator is used to calculate <see cref="F:Microsoft.CodeAnalysis.CodeGen.LocalDebugId.SyntaxOffset"/> during emit.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.IsImplicitlyDeclared">
 <summary>
 Was this local variable implicitly declared, because Option Explicit Off
 was in effect, and no other symbol was found with this name.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.ObsoleteAttributeData">
 <summary>
 Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
 This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.SourceLocalSymbol">
 <summary>
 Base class for any local symbol that can be referenced in source, might be implicitly declared.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.SourceLocalSymbolWithNonstandardName">
 <summary>
 Class for a local symbol that has a different name than the identifier token.
 In this case the real name is returned by the name property and the "VB User visible name" can be
 obtained by accessing the IdentifierToken.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.SourceLocalSymbolWithNonstandardName.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalDeclarationKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String)">
 <summary>
 Create a local variable symbol. Note: this does not insert it automatically into a
 local binder so that it can be found by lookup.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.InferredForEachLocalSymbol">
 <summary>
 A local symbol created by a for-each statement when Option Infer is on.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.InferredForEachLocalSymbol.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Create a local variable symbol. Note: this does not insert it automatically into a
 local binder so that it can be found by lookup.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.InferredForFromToLocalSymbol">
 <summary>
 A local symbol created by For from-to statement when Option Infer is on.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.InferredForFromToLocalSymbol.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax)">
 <summary>
 Create a local variable symbol. Note: this does not insert it automatically into a
 local binder so that it can be found by lookup.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.VariableLocalSymbol">
 <summary>
 A local symbol created from a variable declaration or a for statement with an as clause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.VariableLocalSymbol.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalDeclarationKind)">
 <summary>
 Create a local variable symbol. Note: this does not insert it automatically into a
 local binder so that it can be found by lookup.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.TypeSubstitutedLocalSymbol">
 <summary>
 Local symbol that is not associated with any source.
 </summary>
 <remarks>Generally used for temporary locals past the initial binding phase.</remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverloadingHelper">
 <summary>
 Function that help implement the overloading rules for VB, in particular the rules
 for recasing method and property names.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverloadingHelper.SetMetadataNameForAllOverloads(System.String,Microsoft.CodeAnalysis.SymbolKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Set the correct metadata name for all overloads of a particular name and symbol kind
 (must be method or property) inside a container.
 
 The rules are as follows:
    1) If a method or property overrides one from its base class, its metadata name
       must match that.
    2) If method overloads those in the base (because the Overloads keyword is used), and
       all metadata names in the base are consistent in case, use that name.
    3) All overloads with a class should match, except possibly for overrides. If there is
       an override or overload from base, use that. Otherwise, use casing of first member in
       class.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverloadingHelper.FindOverloads(System.String,Microsoft.CodeAnalysis.SymbolKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbol},System.Boolean@,System.Boolean@)">
 <summary>
 Collect all overloads in "container" of the given name and kind.
 Also determine if any have "Overloads" or "Overrides" specifiers.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverloadingHelper.SetMetadataNamesOfOverrides(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 For each member in "overloadedMembers" that is marked Overrides, set its
 metadata name to be the metadata name of its overridden member. Return the
 first such name, lexically.
 
 Note: can return null if no override member with an actual overridden member was found.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverloadingHelper.NameOfFirstMember(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 Return the name of the lexically first symbol in "overloadedMembers".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverloadingHelper.GetBaseMemberMetadataName(System.String,Microsoft.CodeAnalysis.SymbolKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Check all accessible, visible members of the base types of container for the given name and kind. If they
 all have the same case-sensitive metadata name, return that name. Otherwise, return Nothing.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverrideHidingHelper">
 <summary>
 Methods, Properties, and Events all can override or hide members. 
 This class has helper methods and extensions for sharing by multiple symbol types.
 </summary>
 
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverrideHidingHelper.CheckHidingAndOverridingForType(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Check for overriding and hiding errors in container and report them via diagnostics.
 </summary>
 <param name="container">Containing type to check. Should be an original definition.</param>
 <param name="diagnostics">Place diagnostics here.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverrideHidingHelper.CheckMembersAgainstBaseType(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Check each member of container for constraints against the base type. For methods and properties and events,
 checking overriding and hiding constraints. For other members, just check for hiding issues.
 </summary>
 <param name="container">Containing type to check. Should be an original definition.</param>
 <param name="diagnostics">Place diagnostics here.</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverrideHidingHelper.CheckAllAbstractsAreOverriddenAndNotHidden(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 If the "container" is a non-MustInherit, make sure it has no MustOverride Members
 If "container" is a non-MustInherit inheriting from a MustInherit, make sure that all MustOverride members
 have been overridden.
 If "container" is a MustInherit inheriting from a MustInherit, make sure that no MustOverride members
 have been shadowed.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverrideHidingHelper.CheckShadowing(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Report any diagnostics related to shadowing for a member.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverrideHidingHelper.CanOverrideOrHide(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Some symbols do not participate in overriding/hiding (e.g. constructors). Accessors are consider
 to override or hide.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverrideHidingHelper.RequiresExplicitOverride(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 If a method had an virtual inaccessible override, then an explicit override in metadata is needed
 to make it really override what it intends to override, and "skip" the inaccessible virtual
 method.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverrideHidingHelper`1">
 <summary>
 Many of the methods want to generically work on properties, methods (and maybe events) as TSymbol. We put all these
 methods into a generic class for convenience.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverrideHidingHelper`1.MakeOverriddenMembers(`0)">
 <summary>
 Walk up the type hierarchy from ContainingType and list members that this
 method overrides (accessible methods/properties with the same signature, if this
 method is declared "override").
 
 Methods in the overridden list may not be virtual or may have different
 accessibilities, types, accessors, etc.  They are really candidates to be
 overridden.
 
 All found accessible candidates of overridden members are collected in two 
 builders, those with 'exactly' matching signatures and those with 'generally'
 or 'inexactly' matching signatures. 'Exact' signature match is a 'general' 
 signature match which also does not have mismatches in total number of parameters
 and/or types of optional parameters. See also comments on correspondent 
 OverriddenMembersResult(Of TSymbol) properties.
 
 'Inexactly' matching candidates are only collected for reporting Dev10/Dev11
 errors like BC30697 and others. We collect 'inexact' matching candidates until 
 we find any 'exact' match.
 
 Also remembers inaccessible members that are found, but these do not prevent
 continuing to search for accessible members.
 
 </summary>
 <remarks>
 In the presence of non-VB types, the meaning of "same signature" is rather
 complicated.  If this method isn't from source, then it refers to the runtime's
 notion of signature (i.e. including return type, custom modifiers, etc).
 If this method is from source, use the VB version of signature. Note that 
 Dev10 C# has a rule that prefers members with less custom modifiers. Dev 10 VB has no
 such rule, so I'm not adding such a rule here.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverrideHidingHelper`1.FindOverriddenMembersInType(`0,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{`0},Microsoft.CodeAnalysis.ArrayBuilder{`0},Microsoft.CodeAnalysis.ArrayBuilder{`0})">
 <summary>
 Look for overridden members in a specific type. Return true if we find an overridden member candidate 
 with 'exact' signature match, or we hit a member that hides. See comments on MakeOverriddenMembers(...)
 for description of 'exact' and 'inexact' signature matches.
 
 Also remember any inaccessible members that we see.
 </summary>
 <param name="overridingSym">Syntax that overriding or hiding.</param>
 <param name="overridingIsFromSomeCompilation">True if "overridingSym" is from source (this.IsFromSomeCompilation).</param>
 <param name="overridingContainingType">The type that contains this method (this.ContainingType).</param>
 <param name="currType">The type to search.</param>
 <param name="overriddenBuilder">Builder to place exactly-matched overridden member candidates in. </param>
 <param name="inexactOverriddenMembers">Builder to place inexactly-matched overridden member candidates in. </param>
 <param name="inaccessibleBuilder">Builder to place exactly-matched inaccessible overridden member candidates in. </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.QuickAttributeChecker">
 <summary>
 The QuickAttributeChecker applies a simple fast heuristic for determining probable
 attributes without binding attribute types, just by looking at the final syntax of an 
 attribute usage. It is accessed via the QuickAttributeChecker property on Binder.
 </summary>
 <remarks>
 It works by maintaining a dictionary of all possible simple names that might map to a particular
 attribute.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.QuickAttributeChecker.AddName(System.String,Microsoft.CodeAnalysis.VisualBasic.Symbols.QuickAttributes)">
 <summary>
 Add a mapping from name to some attributes.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.QuickAttributeChecker.AddAlias(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax)">
 <summary>
 Process an alias clause and any imported mappings from it.
 E.g., If you have an alias Ex=Blah.Extension, add any mapping for Extension to those for Ex.
 Note that although, in VB, an alias cannot reference another alias, this code doesn't not attempt
 to distinguish between aliases and regular names, as that would add complexity to the data structure
 and would be unlikely to matter. This entire class is probabilistic anyone and is only used for quick
 checks.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.QuickAttributeChecker.CheckAttributes(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Check attribute lists quickly to see what attributes might be referenced.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.QuickAttributes">
 <summary>
 Indicate which attributes might be present. Could be extended to other attributes 
 if desired.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol">
 <summary>
 Represents a range variable symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.Create(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Create a range variable symbol associated with an identifier token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Create a range variable symbol not associated with an identifier token, i.e. with illegal name.
 Used for error recovery binding.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol">
 <summary>
 Represents an assembly built by compiler.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol._compilation">
 <summary>
 A Compilation the assembly is created for.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol.m_lazyIdentity">
 <summary>
 Assembly's identity.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol._modules">
 <summary>
 A list of modules the assembly consists of. 
 The first (index=0) module is a SourceModuleSymbol, which is a primary module, the rest are net-modules.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol._lazyDuplicateAttributeIndices">
 <summary>
 Indices of duplicate assembly attributes, i.e. attributes that bind to the same constructor and have identical arguments, that must not be emitted.
 </summary>
 <remarks>
 These indices correspond to the merged assembly attributes from source and added net modules, i.e. attributes returned by <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol.GetAttributes"/> method.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol.DeclaringCompilation">
 <summary>
 This override is essential - it's a base case of the recursive definition.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol.GetUniqueSourceAssemblyAttributes(System.Collections.Generic.HashSet{System.Int32}@)">
 <summary>
 Gets unique source assembly attributes that should be emitted,
 i.e. filters out attributes with errors and duplicate attributes.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol.IsIndexOfDuplicateAssemblyAttribute(System.Int32)">
 <summary>
 Returns true if the assembly attribute at the given index is a duplicate assembly attribute that must not be emitted.
 Duplicate assembly attributes are attributes that bind to the same constructor and have identical arguments.
 </summary>
 <remarks>
 This method must be invoked only after all the assembly attributes have been bound.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol.GetNetModuleAttributesBag">
 <summary>
 Returns a bag of netmodule assembly attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
 </summary>
 <remarks>
 Forces binding and decoding of attributes.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol.GetAttributes">
 <summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
 <remarks>
 NOTE: This method should always be kept as a NotOverridable method.
 If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol.GetSourceAttributesBag"/> method.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol.GetSourceDecodedWellKnownAttributeData">
 <summary>
 Returns data decoded from source assembly attributes or null if there are none.
 </summary>
 <returns>
 Forces binding and decoding of attributes.
 TODO: We should replace methods GetSourceDecodedWellKnownAttributeData and GetNetModuleDecodedWellKnownAttributeData with
 a single method GetDecodedWellKnownAttributeData, which merges DecodedWellKnownAttributeData from source and netmodule attributes.
 </returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol.Flags">
 <summary>
 This represents what the user claimed in source through the AssemblyFlagsAttribute.
 It may be modified as emitted due to presence or absence of the public key.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol.AssemblyVersionAttributeSetting">
 <summary>
 Raw assembly version as specified in the AssemblyVersionAttribute, or Nothing if none specified.
 If the string passed to AssemblyVersionAttribute contains * the version build and/or revision numbers are set to <see cref="T:System.UInt16"/>.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol.GetAssemblyLevelDeclarationErrors(System.Boolean)">
 <summary>
 Get assembly level declaration errors.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol.ReportDiagnosticsForSynthesizedAttributes(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 We may synthesize some well-known attributes for this assembly symbol.  However, at synthesis time, it is
 too late to report diagnostics or cancel the emit.  Instead, we check for use site errors on the types and members
 we know we'll need at synthesis time.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceClonedParameterSymbol">
 <summary>
 Represents a source parameter cloned from another <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceParameterSymbol"/> , 
 when they must share attribute data.
 </summary>  
 <remarks>
 For example, parameters on delegate Invoke method are cloned to delegate BeginInvoke, EndInvoke methods. 
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceComplexParameterSymbol">
 <summary>
 Represents a parameter symbol defined in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceComplexParameterSymbol.BoundAttributesSource">
 <summary>
 Symbol to copy bound attributes from, or null if the attributes are not shared among multiple source method symbols.
 </summary>
 <remarks>
 Used for partial method parameters: 
 Implementation parameter always copies its attributes from the corresponding definition parameter.
 Definition is always complex parameter and so it stores the attribute bag.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceComplexParameterSymbol.IsExplicitByRef">
 <summary>
 Is parameter explicitly declared ByRef. Can be different from IsByRef only for
 String parameters of Declare methods.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceDeclareMethodSymbol">
 <summary>
 Represents a declare method defined in source.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceDelegateMethodSymbol">
 <summary>
 This class represent a compiler generated method of a delegate type that is based upon source delegate or event delegate declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceDelegateMethodSymbol.IsExtensionMethod">
 <summary>
 Returns true if this method is an extension method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceDelegateMethodSymbol.IsExternalMethod">
 <summary>
 Gets a value indicating whether this instance is external method.
 </summary>
 <value>
 <c>true</c> if this instance is external method; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceDelegateMethodSymbol.TypeParameters">
 <summary>
 Get the type parameters on this method. If the method has not generic,
 returns an empty list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceDelegateMethodSymbol.IsImplicitlyDeclared">
 <summary>
 Gets a value indicating whether the symbol was generated by the compiler
 rather than declared explicitly.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceEnumConstantSymbol">
 <summary>
 Represents enum constant field in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceEventSymbol.IsTypeInferred">
 <summary>
 Indicates whether event created a new delegate type.
 In such case the Type must be added to the members of the containing type
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceEventSymbol.CheckExplicitImplementationTypes">
 <summary>
 Unless the type is inferred, check that all
 implemented events have the same type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceEventSymbol.GetAccessorImplementations(Microsoft.CodeAnalysis.MethodKind)">
 <summary>
 Helper method for accessors to get the overridden accessor methods. Should only be called by the
 accessor method symbols.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceEventSymbol.GetAttributes">
 <summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
 <remarks>
 NOTE: This method should always be kept as a NotOverridable method.
 If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceEventSymbol.GetAttributesBag"/> method.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol.SyntaxTree">
 <summary>
 Gets the syntax tree.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol.EqualsValueOrAsNewInitOpt">
 <summary> 
 Field initializer's declaration syntax node. 
 It can be a EqualsValueSyntax or AsNewClauseSyntax.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol.HasDeclaredType">
 <summary>
 Gets a value indicating whether this instance has declared type. This means not an inferred type.
 </summary>
 <value>
 <c>true</c> if this instance has declared type; otherwise, <c>false</c>.
 </value>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol.GetConstantValue(Microsoft.CodeAnalysis.VisualBasic.SymbolsInProgress{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol})">
 <summary>
 Gets the constant value.
 </summary>
 <param name="inProgress">The previously visited const fields; used to detect cycles.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol.GetAttributes">
 <summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
 <remarks>
 NOTE: This method should always be kept as a NotOverridable method.
 If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol.GetAttributesBag"/> method.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol.VerifyConstantValueMatches(Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData,Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation}@)">
 <summary>
 Verify the constant value matches the default value from any earlier attribute
 (DateTimeConstantAttribute or DecimalConstantAttribute).
 If not, report ERR_FieldHasMultipleDistinctConstantValues.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile.BoundFileInformation">
 <summary>
 The bound information from a file.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile.FileImportData">
 <summary>
 Data for Binder.BindImportClause that maintains flat lists
 of members and member syntax references in addition to
 the dictionaries needed by BindImportClause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile.ValidateImports(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.NamespaceOrTypeAndImportsClausePosition},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxReference},System.Collections.Generic.IReadOnlyDictionary{System.String,Microsoft.CodeAnalysis.VisualBasic.AliasAndImportsClausePosition},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Perform any validation of import statements that must occur
 after the import statements have been added to the SourceFile.
 Specifically, constraints are checked for generic type references.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile.MemberImports">
 <summary>
 Return the member imports for this file.
 Doesn't contain error types.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile.AliasImportsOpt">
 <summary>
 Return the alias imports for this file. May return Nothing if there are no alias imports.
 May contain aliases with error type targets.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile.XmlNamespacesOpt">
 <summary>
 Return the xmlns imports for this file. May return Nothing if there are no xmlns imports.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile.OptionStrict">
 <summary>
 Returns the value of the Option Strict declaration if there was one, otherwise Null.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile.OptionInfer">
 <summary>
 Returns the value of the Option Infer declaration if there was one, otherwise Null.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile.OptionExplicit">
 <summary>
 Returns the value of the Option Explicit declaration if there was one, otherwise Null.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile.OptionCompareText">
 <summary>
 Returns the value of the Option Compare Text/Binary declaration if there was one, otherwise Null. True means
 Text, False means Binary.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile.GenerateAllDeclarationErrors">
 <summary>
 Force all declaration errors to be generated.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile.GetDeclarationErrorsInSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
 <summary>
 Get all declaration errors in the given filterSpan.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol">
 <summary>
 Represents a named type symbol whose members are declared in source.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.SourceTypeFlags">
 <summary>
 Holds information about a SourceType in a compact form.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.ComputeTypeFlags(Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedTypeDeclaration,System.Boolean)">
 <summary>
 Compute the type flags from the declaration.
 This function DOES NOT diagnose errors in the modifiers. Given the set of modifiers,
 it produces the flags, even in the case of potentially conflicting modifiers. We have to
 return some answer even in the case of errors.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.GenerateDeclarationErrors(System.Threading.CancellationToken)">
 <summary>
 Force all declaration errors to be generated.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.VarianceContext">
 <summary>
 Following enum is used just to help give more specific error messages.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.BindAllMemberAttributes(System.Threading.CancellationToken)">
 <summary>
 Ensure all attributes on all members in the named type are bound.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.GetEmittedNamespaceName">
 <summary>
 Should return full emitted namespace name for a top level type if the name 
 might be different in case from containing namespace symbol full name, Nothing otherwise.
 
 Although namespaces unify based on case-insensitive name, VB uses the casing the namespace
 declaration surround the class definition for the name emitted to metadata. 
 
 Namespace FOO
    Class X
    End Class
 ENd Namespace
 Namespace foo
    Class Y
    End Class
 ENd Namespace
 
 In metadata, these are classes "FOO.X" and "foo.Y" (and thus appear in different namespaces
 when imported into C#.) This function determines the casing of the namespace part of a class, if needed
 to override the namespace name.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.SyntaxReferences">
 <summary>
 Syntax references of all parts of the type declaration. 
 Submission and script classes are represented by their containing <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax"/>,
 implicit class can be represented by <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax"/> or <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax"/>.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.MembersAndInitializers">
 <summary>
  Structure to wrap the different arrays of members.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.MembersAndInitializers.#ctor(System.Collections.Generic.Dictionary{System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol}},System.Collections.Immutable.ImmutableArray{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer}},System.Collections.Immutable.ImmutableArray{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer}},System.Int32,System.Int32)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.MembersAndInitializers" /> class.
 </summary>
 <param name="members">The members.</param>
 <param name="staticInitializers">The static initializers.</param>
 <param name="instanceInitializers">The instance initializers.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.MembersAndInitializersBuilder">
 <summary>
  Accumulates different members kinds used while building the members.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.AddInitializer(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer}@,System.Func{System.Int32,Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer},System.Int32@)">
 <summary>
 Adds a field initializer for the field to list of field initializers
 </summary>
 <param name="initializers">All initializers.</param>
 <param name="computeInitializer">Compute the field initializer to add to the list of initializers.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.AddInitializers(Microsoft.CodeAnalysis.ArrayBuilder{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer}}@,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer})">
 <summary>
 Adds an array of initializers to the member collections structure
 </summary>
 <param name="allInitializers">All initializers.</param>
 <param name="siblings">The siblings.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.FindPartialMethodDeclarations(Microsoft.CodeAnalysis.DiagnosticBag,System.Collections.Generic.Dictionary{System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol}})">
 <summary> Examines the members collection and builds a set of partial methods if any, otherwise returns nothing </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.ComparePartialMethodSignatures(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol)">
 <summary>
 Compares two methods to check if the 'candidate' can be an implementation of the 'partialDeclaration'.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.StructureCircularityDetectionDataSet">
 <summary> 
 Poolable data set to be used in structure circularity detection.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.StructureCircularityDetectionDataSet.s_pool">
 <summary> 
 Following C# implementation we keep up to 32 data sets so that we do not need to allocate 
 them over and over. In this implementation though, circularity detection in one type can trigger
 circularity detection in other types while it traverses the types tree. The traversal is being 
 performed breadth-first, so the number of data sets used by one thread is not longer than the 
 length of the longest structure-in-structure nesting chain.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.StructureCircularityDetectionDataSet.ProcessedTypes">
 <summary> Set of processed structure types </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.StructureCircularityDetectionDataSet.QueueElement">
 <summary> Queue element structure </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.StructureCircularityDetectionDataSet.Queue">
 <summary> Queue of the types to be processed </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.CheckStructureCircularity(Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Analyzes structure type for circularities. Reports only errors relevant for 'structBeingAnalyzed' type.
 </summary>
 <remarks>
 When VB Dev10 detects circularity it reports the error only once for each cycle. Thus, if the cycle 
 is {S1 --> S2 --> S3 --> S1}, only one error will be reported, which one of S1/S2/S3 will have error
 is non-deterministic (depends on the order of symbols in a hash table).
 
 Moreover, Dev10 analyzes the type graph and reports only one error in case S1 --> S2 --> S1 even if 
 there are two fields referencing S2 from S1.
 
 Example:
    Structure S2
      Dim s1 As S1
    End Structure
 
    Structure S3
      Dim s1 As S1
    End Structure
 
    Structure S1
      Dim s2 As S2  ' ERROR
      Dim s2_ As S2 ' NO ERROR 
      Dim s3 As S3  ' ERROR
    End Structure
 
 Dev10 also reports only one error for all the cycles starting with the same field, which one is reported 
 depends on the declaration order. Current implementation reports all of the cycles for consistency. 
 See testcases MultiplyCyclesInStructure03 and MultiplyCyclesInStructure04 (report different errors in Dev10).
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.DetectTypeCircularity_ShouldStepIntoType(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Simple check of whether or not we should step into the type 'typeToTest' during 
 type graph traversal inside 'DetectStructureCircularity' or 'GetDependenceChain'.
 
 The following rules are in place: 
   (a) we order all symbols according their first source location 
       comparison rules: first, source file names are compared, 
       then SourceSpan.Start is used for symbols inside the same file;
   (b) given this order we enter the loop if only 'typeToTest' is 'less' than 
       'structBeingAnalyzed';
   (c) we also always enter types from other modules
 
 !!! To be ONLY used in 'CheckStructureCircularity'.
 </summary>
 <returns>True if detect type circularity code should step into 'typeToTest' type </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.AnyInitializerToBeInjectedIntoConstructor(System.Collections.Generic.IEnumerable{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer}},System.Boolean)">
 <summary>
 Returns true if at least one of the elements of this list needs to be injected into a 
 constructor because it's not a const or it is a const and it's type is either decimal 
 or date. Non const fields always require a constructor, so this function should be called to 
 determine if a synthesized constructor is needed that is not listed in members list.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.CheckForOverloadOverridesShadowsClashesInSameType(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.MembersAndInitializers,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Performs a check for overloads/overrides/shadows conflicts, generates diagnostics.
 </summary>
 <param name="membersAndInitializers"></param>
 <param name="diagBag"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.AddDefaultConstructorIfNeeded(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.MembersAndInitializersBuilder,System.Boolean,Microsoft.CodeAnalysis.ArrayBuilder{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer}},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Check to see if we need a default instance|shared constructor, and if so, create it.
 
 NOTE: we only need a shared constructor if there are any initializers to be 
 injected into it, we don't create a constructor otherwise. In this case we also 
 ignore const fields which will still require to be injected, because in this case
 we don't see the constructor to be visible in symbol table.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.CreateSharedConstructorsForConstFieldsIfRequired(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 In case the passed initializers require a shared constructor, this method returns a new MethodSymbol instance for the 
 shared constructor if there is not already an explicit shared constructor
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.StaticInitializers">
 <summary>
 Gets the static initializers.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.InstanceInitializers">
 <summary>
 Gets the instance initializers.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.CheckForOverloadsErrors(Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Reports the overloads error for this type.
 </summary>
 <param name="diagnostics">The diagnostics.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.CheckForOperatorOverloadingErrors(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol},System.Int32,System.Collections.Generic.Dictionary{System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol}}.Enumerator,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol}@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Returns True if memberList(memberIndex) is an operator.
 Also performs operator overloading validation and reports appropriate errors.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.IsConflictingOperatorOverloading(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolComparisonResults,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol},System.Int32,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 See if any member in [memberList] starting with [memberIndex] conflict with [method],
 report appropriate error and return true. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.CheckInterfaceUnificationAndVariance(Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Check for two different diagnostics on the set of implemented interfaces:
   1) It is invalid for a type to directly (vs through a base class) implement two interfaces that
   unify (i.e. are the same for some substitution of type parameters).
 
   2) It is a warning to implement variant interfaces twice with type arguments that could cause
   ambiguity during method dispatch.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.ReportInterfaceUnificationError(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Interface1 and Interface2 conflict for some type arguments. Report the correct error in the correct location.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol.ReportVarianceAmbiguityWarning(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Interface1 and Interface2 have variable ambiguity. Report the warning in the correct location.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberFieldSymbol.GetInferredType(Microsoft.CodeAnalysis.VisualBasic.SymbolsInProgress{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol})">
 <summary>
 Gets the inferred type of this const field from the initialization value.
 </summary>
 <param name="inProgress">The previously visited const fields; used to detect cycles.</param><returns></returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberFieldSymbol.SourceFieldSymbolWithInitializer">
 <summary>
 A source field with an explicit initializer. In a declaration declaring multiple fields,
 such as "Dim a, b, c = d", this class is used for the first field only. (Other fields in
 the declaration are instances of SourceFieldSymbolSiblingInitializer.)
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberFieldSymbol.SourceFieldSymbolSiblingInitializer">
 <summary>
 A source field with an explicit initializer. In a declaration declaring multiple
 fields, such as "Dim a, b, c = d", this class is used for the fields other than
 the first. (The first field is an instance of SourceFieldSymbolWithInitializer.)
 An instance of this class holds a reference to the first field in the declaration
 and reuses the bound initializer from that field.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberMethodSymbol">
 <summary>
 Represents a method declared in source. 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberMethodSymbol._otherPartOfPartial">
 <summary>
 If this symbol represents a partial method definition or implementation part, its other part (if any).
 This should be set, if at all, before this symbol appears among the members of its owner.  
 The implementation part is not listed among the "members" of the enclosing type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberMethodSymbol._asyncStateMachineType">
 <summary>
 In case the method is an 'Async' method, stores the reference to a state machine type 
 synthesized in AsyncRewriter. Note, that this field is mutable and is being assigned  
 by calling AssignAsyncStateMachineType(...).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberMethodSymbol.StateFlags.SuppressDuplicateProcDefDiagnostics">
 <summary>
 If this flag is set this method will be ignored 
 in duplicated signature analysis, see ERR_DuplicateProcDef1 diagnostics.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberMethodSymbol.StateFlags.AllDiagnosticsReported">
 <summary>
 Set after all diagnostics have been reported for this symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberMethodSymbol.ValidateImplementedMethodConstraints(Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Validate method type parameter constraints against implemented methods.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberMethodSymbol.InitializePartialMethodParts(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberMethodSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberMethodSymbol)">
 <summary>
  This method is to be called to assign implementation to a partial method.
  </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol">
 <summary>
 Base class for method symbols that are associated with some syntax and can receive custom attributes (directly or indirectly via another source symbol).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.CreateDeclareMethod(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Creates a method symbol for Declare Sub or Function.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.DecodeOperatorModifiers(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Decode the modifiers on a user-defined operator, reporting errors where applicable. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.SetDiagnostics(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic})">
 <summary>
 Returns true if our diagnostics were used in the event that there were two threads racing.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.ShadowsExplicitly">
 <summary>
  True if 'Shadows' is explicitly specified in method's declaration.
  </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.OverloadsExplicitly">
 <summary> 
 True if 'Overloads' is explicitly specified in method's declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.OverridesExplicitly">
 <summary>
  True if 'Overrides' is explicitly specified in method's declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.HandlesEvents">
 <summary>
 True if 'Handles' is specified in method's declaration
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.NonMergedLocation">
 <summary>
  Return the location from syntax reference only.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.BindTypeParameterConstraints(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind the constraint declarations for the given type parameter.
 </summary>
 <remarks>
 The caller is expected to handle constraint checking and any caching of results.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.BoundAttributesSource">
 <summary>
 Symbol to copy bound attributes from, or null if the attributes are not shared among multiple source method symbols.
 </summary>
 <remarks>
 Used for example for event accessors. The "remove" method delegates attribute binding to the "add" method. 
 The bound attribute data are then applied to both accessors.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.BoundReturnTypeAttributesSource">
 <summary>
 Symbol to copy bound return type attributes from, or null if the attributes are not shared among multiple source symbols.
 </summary>
 <remarks>
 Used for property accessors. Getter copies its return type attributes from the property return type attributes.
 
 So far we only need to return <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol"/>. If we ever needed to return a <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol"/> 
 we could implement an interface on those two types.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.GetAttributes">
 <summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.GetReturnTypeAttributes">
 <summary>
 Returns the list of attributes, if any, associated with the return type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol.GetEarlyDecodedWellKnownAttributeData">
 <summary>
 Returns data decoded from early bound well-known attributes applied to the symbol or null if there are no applied attributes.
 </summary>
 <remarks>
 Forces binding and decoding of attributes.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol">
 <summary>
 Represents the primary module of an assembly being built by compiler.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol._assemblySymbol">
 <summary>
 Owning assembly.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol.DeclaringCompilation">
 <summary>
 This override is essential - it's a base case of the recursive definition.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol.GetAttributes">
 <summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
 <remarks>
 NOTE: This method should always be kept as a NotOverridable method.
 If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol.GetAttributesBag"/> method.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol.ModuleImportData">
 <summary>
 Data for Binder.BindImportClause that maintains flat lists of members, aliases,
 and corresponding syntax references in addition to the dictionaries needed by
 BindImportClause. The syntax references, instances of GlobalImportInfo, are used
 later, when validating constraints, to generate Locations for constraint errors.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol.ValidateImports(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.NamespaceOrTypeAndImportsClausePosition},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol.GlobalImportInfo},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.AliasAndImportsClausePosition},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol.GlobalImportInfo},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Perform any validation of import statements that must occur
 after the import statements have been added to the module.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol.ValidateImport(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol.GlobalImportInfo,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Perform validation of an import statement that must occur
 after the statement has been added to the module. Specifically,
 constraints are checked for generic type references.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol.GetDeclarationErrorsInTree(Microsoft.CodeAnalysis.SyntaxTree,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Func{System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},Microsoft.CodeAnalysis.SyntaxTree,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic}},System.Threading.CancellationToken)">
 <summary>
 Get all the declaration errors in a single tree.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol.GetAllDeclarationErrors(System.Threading.CancellationToken,System.Boolean@)">
 <summary>
 Get all the declaration errors.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol.AtomicStoreReferenceAndDiagnostics``1(``0@,``0,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CompilationStage,``0)">
 <summary>
 Atomically store value into variable, and store the diagnostics away for later retrieval.
 When this routine returns, variable is non-null. If this routine stored value into variable,
 then the diagnostic bag is saved away before the variable is stored and it returns True.
 Otherwise it returns False.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol">
 <summary>
 Represents a type or module declared in source. 
 Could be a class, structure, interface, delegate, enum, or module.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol._comClassData">
 <summary>
 Information for ComClass specific analysis and metadata generation, created
 once ComClassAttribute is encountered.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol._lazyCoClassType">
 <summary>
 Lazy CoClass type if the attribute is specified. Nothing if not.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.m_baseCycleDiagnosticInfo">
 <summary>
 In case a cyclic dependency was detected during base type resolution 
 this field stores the diagnostic.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.BindTypeParameterConstraints(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceTypeParameterOnTypeSymbol,Microsoft.CodeAnalysis.VarianceKind@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterConstraint}@,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind the constraint declarations for the given type parameter.
 </summary>
 <remarks>
 The caller is expected to handle constraint checking and any caching of results.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.GetDeclaredBaseSafe(Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 'Safe' version of GetDeclaredBase takes into account bases being resolved to make sure 
 we avoid infinite loops in some scenarios. Note that the cycle is being broken not when
 we detect it, but when we detect it on the 'smallest' type of the cycle, this brings stability 
 in multithreaded scenarios while still ensures that we don't loop more than twice.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.CheckBaseConstraints">
 <summary>
 Do additional verification of base types the after acyclic base is found. This is
 the chance to generate diagnostics that may require walking bases and as such
 can be performed only after the base has been determined and cycles broken.
 (For instance, checking constraints on Class B(Of T) Inherits A(Of B(Of T)).)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.CheckInterfacesConstraints">
 <summary>
 Do additional verification of interfaces after acyclic interfaces are found. This is
 the chance to generate diagnostics that may need to walk interfaces and as such
 can be performed only after the interfaces have been determined and cycles broken.
 (For instance, checking constraints on Class C(Of T) Implements I(Of C(Of T)).)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.FirstDeclarationWithExplicitBases">
 <summary>
 Return the first Class declaration with explicit base classes to use for
 checking base class constraints. Other type declarations (Structures,
 Modules, Interfaces) are ignored since other errors will have been
 reported if those types include bases.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.FirstDeclarationWithExplicitInterfaces">
 <summary>
 Return the first Class, Structure, or Interface declaration with explicit interfaces
 to use for checking interface constraints. Other type declarations (Modules) are
 ignored since other errors will have been reported if those types include interfaces.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.EnumUnderlyingType">
 <summary>
 For enum types, gets the underlying type. Returns null on all other
 kinds of types.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.GetAttributes">
 <summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.GetEarlyDecodedWellKnownAttributeData">
 <summary>
 Returns data decoded from early bound well-known attributes applied to the symbol or null if there are no applied attributes.
 </summary>
 <remarks>
 Forces binding and decoding of attributes.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.HasGuidAttribute">
 <summary>
 Is System.Runtime.InteropServices.GuidAttribute applied to this type in code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.HasClassInterfaceAttribute">
 <summary>
 Is System.Runtime.InteropServices.ClassInterfaceAttribute applied to this type in code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.HasComSourceInterfacesAttribute">
 <summary>
 Is System.Runtime.InteropServices.ComSourceInterfacesAttribute applied to this type in code.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.ComClassData">
 <summary>
 Encapsulates ComClass specific data and analysis.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.ComClassData._syntheticInterfaces">
 <summary>
 Synthesized ComClass interfaces, can have the following values:
     Null - not yet initialized,
     Empty - there are no synthesized ComClass interfaces.
     one interface - only class interface is synthesized.
     two interfaces - both class interface and event interface are synthesized. Class interface is followed by the event interface.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.ComClassData.GetSynthesizedEventInterface">
 <summary>
 Returns symbol for the event interface or Nothing when event interface is not synthesized.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.ComClassData.PerformComClassAnalysis(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol)">
 <summary>
 Perform ComClass specific validation and prepare for metadata generation.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.ComClassData.GetComVisibleState(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Return False if ComVisibleAttribute(False) is applied to the symbol, True otherwise.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.ComClassData.GetUserSpecifiedDispId(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Returns user defined DispId for a member or ReservedDispId.None if none specified.
 Also reports errors for reserved DispIds.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.PerformComClassAnalysis">
 <summary>
 Perform ComClass specific validation and prepare for metadata generation.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol.GroupCollectionComparer">
 <summary>
 Used to sort types - members of group collection.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamespaceSymbol.RegisterDeclaredCorTypes">
 <summary>
 Register COR types declared in this namespace, if any, in the COR types cache.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamespaceSymbol.GetSourcePathForDeclaration">
 <summary>
 Gets the filename of the first declaration that matches the given namespace name case sensitively.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamespaceSymbol.TypesToCheckForExtensionMethods">
 <summary>
 Return the set of types that should be checked for presence of extension methods in order to build
 a map of extension methods for the namespace. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamespaceSymbol.HasMultipleSpellings">
 <summary>
 Does this namespace have multiple different case-sensitive spellings
 (i.e., "Namespace FOO" and "Namespace foo". Includes parent namespace(s).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamespaceSymbol.GetDeclarationSpelling(Microsoft.CodeAnalysis.SyntaxTree,System.Int32)">
 <summary>
 Get the fully qualified namespace name using the spelling used in the declaration enclosing the given
 syntax tree and location.
 I.e., if this namespace was declared with:
 Namespace zAp
  Namespace FOO.bar
    'location
  End Namespace
 End Namespace
 Namespace ZAP
  Namespace foo.bar
  End Namespace
 End Namespace
 
 It would return "ProjectNamespace.zAp.FOO.bar".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceParameterSymbol.GetMatchingPropertyParameter">
 <summary>
 Is this an accessor parameter that came from the associated property? If so, 
 return it, else return Nothing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceParameterSymbol.GetAttributes">
 <summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceParameterSymbol.VerifyParamDefaultValueMatchesAttributeIfAny(Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Verify the default value matches the default value from any earlier attribute
 (DefaultParameterValueAttribute, DateTimeConstantAttribute or DecimalConstantAttribute).
 If not, report ERR_ParamDefaultValueDiffersFromAttribute.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceParameterSymbolBase">
 <summary>
 Base class for all parameters that are emitted.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertyAccessorSymbol.BindParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertyAccessorSymbol,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Bind parameters declared on the accessor and combine with any
 parameters declared on the property. If there are no explicit parameters
 and this is a setter, create a synthesized value parameter.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol.DeclarationSyntax">
 <summary> 
 Property declaration syntax node. 
 It is either PropertyStatement for normal properties or FieldDeclarationSyntax for WithEvents ones.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol.GetAttributes">
 <summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
 <remarks>
 NOTE: This method should always be kept as a NotOverridable method.
 If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol.GetAttributesBag"/> method.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol.OverloadsExplicitly">
 <summary> True if 'Overloads' is explicitly specified in method's declaration </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol.OverridesExplicitly">
 <summary> True if 'Overrides' is explicitly specified in method's declaration </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol.GetAccessorImplementations(System.Boolean)">
 <summary>
 Helper method for accessors to get the overridden accessor methods. Should only be called by the
 accessor method symbols.
 </summary>
 <param name="getter">True to get implemented getters, False to get implemented setters</param>
 <returns>All the accessors of the given kind implemented by this property.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol.Syntax">
 <summary> 
 Property declaration syntax node. 
 It is either PropertyStatement for normal properties or ModifiedIdentifier for WithEvents ones.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol.IsAccessibilityMoreRestrictive(Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Accessibility)">
 <summary>
 Return true if the accessor accessibility is more restrictive
 than the property accessibility, otherwise false.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol.GetAccessorBlockBeginLocation(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertyAccessorSymbol)">
 <summary>
 Returns the location (span) of the accessor begin block.
 (Used for consistency with the native compiler that
 highlights the entire begin block for certain diagnostics.)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol.ReportAccessorAccessibilityError(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax,Microsoft.CodeAnalysis.VisualBasic.ERRID,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Report an error associated with the accessor accessibility modifier.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol.SyntaxTree">
 <summary>
 Gets the syntax tree.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceSimpleParameterSymbol">
 <summary>
 Represents a parameters declared in source, that is not optional, does not have a default value, 
 attributes, or is a ParamArray. This is a separate class to save memory, since there are LOTS
 of parameters.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceTypeParameterSymbol">
 <summary>
 Represents a type parameter symbol defined in source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceTypeParameterSymbol.ReportRedundantConstraints">
 <summary>
 True if the redundant type parameter constraints should be reported as
 errors. For overridden methods, this is False since type substitution of type
 arguments for the base/interface may result in redundant constraints.
 </summary>
 <remarks>
 This is a method rather than a property since the
 implementation may be expensive.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceTypeParameterSymbol.CheckConstraintTypeConstraints(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterConstraint},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Check constraints of generic types referenced in constraint types. For instance,
 with "Interface I(Of T As I(Of T))", check T satisfies constraints on I(Of T). Those
 constraints are not checked when binding ConstraintTypes since ConstraintTypes
 has not been set on I(Of T) at that point.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceTypeParameterSymbol.GetLocation(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterDiagnosticInfo)">
 <summary>
 Return the source location of the error, if any. If there error was
 from a constraint, and that constraint was from source, its location
 is returned. Otherwise if the type parameter was from source, its
 location is returned. If neither is from source, Nothing is returned.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceTypeParameterOnTypeSymbol">
 <summary>
 Represents a type parameter on a source type (as opposed to a method).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceTypeParameterOnMethodSymbol">
 <summary>
 Represents a type parameter on a source method (as opposed to a type).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceWithEventsBackingFieldSymbol">
 <summary>
 Represents a backing field of WithEvents property. 
 Attributes applied on the property syntax are applied on the backing field.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedPropertyBackingFieldSymbol">
 <summary>
 Represents a compiler generated backing field for an automatically implemented property.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedEntryPointSymbol">
 <summary>
 Represents an interactive code entry point that is inserted into the compilation if there is not an existing one.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedEventAccessorSymbol.ConstructFieldLikeEventAccessorBody_Regular(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceEventSymbol,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Generate a thread-safe accessor for a field-like event.
 
 DelegateType tmp0 = _event; //backing field
 DelegateType tmp1;
 DelegateType tmp2;
 do {
     tmp1 = tmp0;
     tmp2 = (DelegateType)Delegate.Combine(tmp1, value); //Remove for -=
     tmp0 = Interlocked.CompareExchange&lt; DelegateType&gt; (ref _event, tmp2, tmp1);
 } while ((object)tmp0 != (object)tmp1);
 
 Note, if System.Threading.Interlocked.CompareExchange&lt;T&gt; Is Not available,
 we emit the following code And mark the method Synchronized (unless it Is a struct).
 
 _event = (DelegateType)Delegate.Combine(_event, value); //Remove for -=
 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedEventBackingFieldSymbol">
 <summary>
 Represents a compiler generated backing field for an event.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedEventBackingFieldSymbol.IsNotSerialized">
 <summary>
 System.NonSerializedAttribute applied on an event and determines serializability of its backing field.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedFieldSymbol">
 <summary>
 Represents a compiler generated field of given type and name.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol">
 <summary>
 Represents a synthesized lambda. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol.IsImplicitlyDeclared">
 <summary>
 Gets a value indicating whether the symbol was generated by the compiler
 rather than declared explicitly.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMainTypeEntryPoint">
 <summary>
 Represents a compiler generated "Main" sub.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMyGroupCollectionPropertyAccessorSymbol">
 <summary>
 Represents a compiler "MyGroupCollection" property accessor.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMyGroupCollectionPropertyBackingFieldSymbol">
 <summary>
 Represents a compiler generated field for a "MyGroupCollection" property.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMyGroupCollectionPropertySymbol">
 <summary>
 Represents a compiler "MyGroupCollection" property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedSubmissionConstructorSymbol.#ctor(Microsoft.CodeAnalysis.SyntaxReference,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorSymbol" /> class.
 </summary>
 <param name="container">The containing type for the synthesized constructor.</param>
 <param name="isShared">if set to <c>true</c> if this is a shared constructor.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedWithEventsAccessorSymbol">
 <summary>
 WithEvents property accessor.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.UnboundLambdaParameterSymbol">
 <summary>
 Represents a Lambda parameter for an UnboundLambda.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedErrorType.InternalSubstituteTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedFieldSymbol">
 <summary>
 Represents a member variable (field) that has undergone type substitution.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol">
 <summary>
 Represents a method that has undergone type substitution. This is use for a method
 inside a generic type that has undergone type substitution. It also serves as a base class
 for ConstructedMethodSymbol, which is used for a method after type substitution in the method type parameters.  
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol.TypeSubstitution">
 <summary>
 If this is a generic method return TypeSubstitution for it. 
 TypeSubstitution for containing type otherwise.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol.EqualsWithNoRegardToTypeArguments``1(``0)">
 <summary>
 Compare with no regard to type arguments.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol.SpecializedMethod">
 <summary>
 Base class for symbols representing non-generic or open generic methods contained within constructed generic type.
 For example: A(Of Integer).B, A(Of Integer).B.C or A(Of Integer).B.C(Of ).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol.SetAssociatedPropertyOrEvent(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Associate the method with a particular property. Returns
 false if the method is already associated with a property.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol.SpecializedNonGenericMethod">
 <summary>
 Symbol representing non-generic method directly or indirectly contained within constructed
 generic type.
 For example: A(Of Integer).B or A(Of Integer).B.C
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol.SpecializedGenericMethod">
 <summary>
 Symbol representing open generic method directly or indirectly contained within constructed
 generic type.
 For example: A(Of Integer).B(Of ) or A(Of Integer).B.C(Of , )
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol.SpecializedGenericMethod._typeParameters">
 <summary>
 Alpha-renamed type parameters, i.e. type parameters with constraints substituted according
 to containing type's TypeSubstitution.
 For example:
     Class A (Of T)
         Sub B(Of S As T)()
         End Sub
     End Class
  
 Given a method A(Of IComparable).B(Of ), alpha-renamed type parameter S will have type constraint IComparable.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol.ConstructedMethod">
 <summary>
 Base class for symbols representing constructed generic methods.
 For example: A(Of Integer), A.B(Of Integer), A(Of Integer).B.C(Of Integer).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol.ConstructedSpecializedGenericMethod">
 <summary>
 Symbols representing constructed generic method that is contained within constructed generic type.
 For example: A(Of Integer).B(Of Integer), A(Of Integer).B.C(Of Integer).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol.ConstructedSpecializedGenericMethod._constructedFrom">
 <summary>
 Symbol for the ConstructedFrom method.
      A(Of Integer).B(Of ) for A(Of Integer).B(Of Integer),
      A(Of Integer).B.C(Of ) for A(Of Integer).B.C(Of Integer)
 
 All types in its containership hierarchy must be either constructed or non-generic, or original definitions.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol.ConstructedNotSpecializedGenericMethod">
 <summary>
 Symbols representing constructed generic method that isn't contained within constructed generic type.
 For example: A.B(Of Integer), but not A(Of Integer).B.C(Of Integer).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType">
 <summary>
 A SubstitutedNamedType represents a named type that has had some sort
 of substitution applied to it. I.e., its not a pure instance type, but at least
 one type parameter in this type or a containing type has a substitution made for
 it. 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType._substitution">
 <summary>
 Type substitution for this symbol, it targets OriginalDefinition of the symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.EqualsWithNoRegardToTypeArguments``1(``0)">
 <summary>
 Compare SubstitutedNamedTypes with no regard to type arguments.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.SpecializedType">
 <summary>
 Base class for symbols representing non-generic or open generic types contained within constructed generic type.
 For example: A(Of Integer).B, A(Of Integer).B.C or A(Of Integer).B.C(Of ).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.SpecializedType._container">
 <summary>
  Symbol for the containing type, either specialized or constructed.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.SpecializedGenericType">
 <summary>
 Symbol representing open generic type directly or indirectly contained within constructed
 generic type.
 For example: A(Of Integer).B(Of ) or A(Of Integer).B.C(Of , )
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.SpecializedGenericType._typeParameters">
 <summary>
 Alpha-renamed type parameters, i.e. type parameters with constraints substituted according
 to containing type's TypeSubstitution.
 For example:
     Class A (Of T)
         Class B(Of S As T)
             Dim x As A(Of Integer).B(Of S) 'error BC32044: Type argument 'S' does not inherit from or implement the constraint type 'Integer'.
         End Class
     End Class
  
 Given a type A(Of IComparable).B(Of ), alpha-renamed type parameter S will have type constraint IComparable.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.SpecializedGenericType.InternalSubstituteTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.SpecializedNonGenericType">
 <summary>
 Symbol representing non-generic type directly or indirectly contained within constructed
 generic type.
 For example: A(Of Integer).B or A(Of Integer).B.C
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.SpecializedNonGenericType.InternalSubstituteTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.ConstructedType">
 <summary>
 Base class for symbols representing constructed generic types.
 For example: A(Of Integer), A.B(Of Integer), A(Of Integer).B.C(Of Integer).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.ConstructedInstanceType">
 <summary>
 Symbols representing constructed generic type that isn't contained within another constructed generic type.
 For example: A(Of Integer), A.B(Of Integer), but not A(Of Integer).B.C(Of Integer).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.ConstructedInstanceType.InternalSubstituteTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.ConstructedSpecializedGenericType">
 <summary>
 Symbols representing constructed generic type that is contained within another constructed generic type.
 For example: A(Of Integer).B(Of Integer), A(Of Integer).B.C(Of Integer).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.ConstructedSpecializedGenericType._constructedFrom">
 <summary>
 Symbol for the ConstructedFrom type.
      A(Of Integer).B(Of ) for A(Of Integer).B(Of Integer),
      A(Of Integer).B.C(Of ) for A(Of Integer).B.C(Of Integer)
 
 All types in its containership hierarchy must be either constructed or non-generic, or original definitions.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.ConstructedSpecializedGenericType.InternalSubstituteTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.GenerateDeclarationErrors(System.Threading.CancellationToken)">
 <summary>
 Force all declaration errors to be generated.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedParameterSymbol">
 <summary>
 Represents a parameter that has undergone type substitution.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedParameterSymbol.SubstitutedMethodParameterSymbol">
 <summary>
 Represents a method parameter that has undergone type substitution.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedParameterSymbol.SubstitutedPropertyParameterSymbol">
 <summary>
 Represents a property parameter that has undergone type substitution.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedPropertySymbol">
 <summary>
 Represents a property that has undergone type substitution.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedTypeParameterSymbol">
 <summary>
 A SubstitutedTypeParameterSymbol represents an alpha-renamed type parameter.
 They are created only for open generic types and methods that are contained within a 
 constructed generic type.
 
 Alpha-renamed type parameters have their constraints substituted according
 to type/method's containing type's TypeSubstitution.
 For example:
     Class A (Of T)
         Class B(Of S As T)
         End Class
     End Class
  
 Given a type A(Of IComparable).B(Of ), alpha-renamed type parameter T will have type constraint IComparable.
 The rest will be exactly as for the original type parameter T. In fact, OriginalDefinition will return symbol for T.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedTypeParameterSymbol._containingSymbol">
 <summary>
 Containing type or method.
 The field is not read-only because it is initialized after construction through
 SetContainingSymbol() method.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedTypeParameterSymbol.InternalSubstituteTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.IsCompilationOutputWinMdObj(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Does the compilation this symbol belongs to output to a winmdobj?
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.GetKindText(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 String such as 'class', 'interface' etc that can be used in error messages.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.GetPropertyKindText(Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol)">
 <summary>
 String "ReadOnly", "WriteOnly", or "" describing the kind of property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.MatchesAnyName(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol},System.String)">
 <summary>
 Checks if there is a name match with any type parameter.
 </summary>
 <param name="this"></param>
 <param name="name"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.IsOverloadable(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Returns true if this symbols can overload another of the same kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.IsOverloadable(Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol)">
 <summary>
 Returns true if this property can overload another.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.IsOverloads(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Helper that tells if symbol has Overloads (hidebysig) on it
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.IsShadows(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Member that does not have Overloads, is considered Shadows (hidebyname)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.IsInstanceMember(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Is the symbol an instance member (i.e. access requires a receiver)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.RequiresImplementation(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Is this a member of a interface that requires implementation?
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.IsPropertyAndNotWithEvents(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Returns True for "regular" properties (those that are not WithEvents.
 Typically used for OHI diagnostics where WithEvents properties are treated as variables.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.IsDefaultValueTypeConstructor(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 default zero-init constructor symbol is added to a struct when it does not define 
 its own parameterless public constructor.
 We do not emit this constructor and do not call it 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.OverriddenMember(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Return the overridden symbol for either a method or property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.GetArity(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary> 
 Return the arity of a member. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.GetMeParameter(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary> 
 Returns the Me symbol associated with a member. 
 sym must be a member (method, field or property)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.IsUserDefinedOperator(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Is symbol a user-defined operator method.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions.IsHiddenByEmbeddedAttribute(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Does symbol or its containing type have Microsoft.VisualBasic.Embedded() attribute
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames">
 <summary>
 Helper class to generate synthesized names.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames.MakeStateMachineTypeName(System.String,System.Int32,System.Int32)">
 <summary>
 Generates the name of a state machine's type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames.MakeStateMachineStateFieldName">
 <summary>
 Generates the name of a state machine 'state' field 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames.MakeCachedFrameInstanceName">
 <summary>
 Generates the name of a static lambda display class instance cache
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames.MakeStateMachineBuilderFieldName">
 <summary>
 Generates the name of a state machine 'builder' field 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames.MakeIteratorCurrentFieldName">
 <summary>
 Generates the name of a field that backs Current property
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames.MakeStateMachineAwaiterFieldName(System.Int32)">
 <summary>
 Generates the name of a state machine's awaiter field 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames.MakeStateMachineParameterName(System.String)">
 <summary>
 Generates the name of a state machine's parameter name
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames.MakeIteratorParameterProxyName(System.String)">
 <summary>
 Generates the name of a state machine's parameter name
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames.MakeIteratorInitialThreadIdName">
 <summary>
 Generates the name of a field where initial thread ID is stored
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames.TryParseHoistedUserVariableName(System.String,System.String@)">
 <summary>
 Try to parse the local (or parameter) name and return <paramref name="variableName"/> if successful.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames.TryParseStateMachineHoistedUserVariableName(System.String,System.String@,System.Int32@)">
 <summary>
 Try to parse the local name and return <paramref name="variableName"/> and <paramref name="index"/> if successful.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames.MakeStateMachineCapturedMeName">
 <summary>
 Generates the name of a state machine field name for captured me reference
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames.MakeStateMachineCapturedClosureMeName(System.String)">
 <summary>
 Generates the name of a state machine field name for captured me reference of lambda closure
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedAttributeData">
 <summary>
 Class to represent a synthesized attribute
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedAttributeData.Create(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.WellKnownMember,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TypedConstant},System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{System.String,Microsoft.CodeAnalysis.TypedConstant}})">
 <summary>
 Synthesizes attribute data for given constructor symbol.
 If the constructor has UseSiteErrors and the attribute is optional returns Nothing.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedBackingFieldBase`1">
 <summary>
 Represents a base type for compiler generated backing fields.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedClonedTypeParameterSymbol">
 <summary>
 Type parameter that represents another type parameter while being applied on a different symbol
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase">
 <summary>
 This class represents a base class for compiler generated constructors
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.m_isShared">
 <summary>
 Flag to indicate if this is a shared constructor or an instance constructor.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.#ctor(Microsoft.CodeAnalysis.SyntaxReference,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase" /> class.
 </summary>
 <param name="container">The containing type for the synthesized constructor.</param>
 <param name="isShared">if set to <c>true</c> if this is a shared constructor.</param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.Name">
 <summary>
 Gets the symbol name. Returns the empty string if unnamed.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.DeclaredAccessibility">
 <summary>
 Gets a <see cref="T:Microsoft.CodeAnalysis.Accessibility" /> indicating the declared accessibility for the symbol.
 Returns NotApplicable if no accessibility is declared.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.IsMustOverride">
 <summary>
 Gets a value indicating whether this instance is abstract or not.
 </summary>
 <value>
 <c>true</c> if this instance is abstract; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.IsNotOverridable">
 <summary>
 Gets a value indicating whether this instance is not overridable.
 </summary>
 <value>
 <c>true</c> if this instance is not overridable; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.IsOverloads">
 <summary>
 Gets a value indicating whether this instance is overloads.
 </summary>
 <value>
 <c>true</c> if this instance is overloads; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.IsOverridable">
 <summary>
 Gets a value indicating whether this instance is overridable.
 </summary>
 <value>
 <c>true</c> if this instance is overridable; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.IsOverrides">
 <summary>
 Gets a value indicating whether this instance is overrides.
 </summary>
 <value>
 <c>true</c> if this instance is overrides; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.IsShared">
 <summary>
 Gets a value indicating whether this instance is shared.
 </summary>
 <value>
   <c>true</c> if this instance is shared; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.IsSub">
 <summary>
 Gets a value indicating whether this instance is sub.
 </summary>
 <value>
   <c>true</c> if this instance is sub; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.Locations">
 <summary>
 A potentially empty collection of locations that correspond to this instance.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.MethodKind">
 <summary>
 Gets what kind of method this is. There are several different kinds of things in the
 VB language that are represented as methods. This property allow distinguishing those things
 without having to decode the name of the method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase.ReturnType">
 <summary>
 Gets the return type of the method.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol">
 <summary>
 This class represent a compiler generated method
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.#ctor(System.String,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.SourceMemberFlags,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol" /> class. The parameters are not initialized and need to be set 
 by using the <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.SetParameters(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol})" /> method.
 </summary>
 <param name="name">The name of this method.</param>
 <param name="containingSymbol">The containing symbol.</param>
 <param name="flags">The flags for this method.</param>
 <param name="returnType">The return type.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.SetParameters(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol})">
 <summary>
 Sets the parameters.
 </summary>
 <param name="parameters">The parameters.</param>
 <remarks>
 Note: This should be called at most once, immediately after the symbol is constructed. The parameters aren't 
 Note: passed to the constructor because they need to have their container set correctly.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.Arity">
 <summary>
 Returns the arity of this method, or the number of type parameters it takes.
 A non-generic method has zero arity.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.AssociatedSymbol">
 <summary>
 If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,
 returns the property that this method is the getter or setter for.
 If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,
 returns the event that this method is the adder or remover for.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.CallingConvention">
 <summary>
 Calling convention of the signature.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.ContainingSymbol">
 <summary>
 Gets the <see cref="T:Microsoft.CodeAnalysis.ISymbol" /> for the immediately containing symbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.DeclaredAccessibility">
 <summary>
 Gets a <see cref="T:Microsoft.CodeAnalysis.Accessibility" /> indicating the declared accessibility for the symbol.
 Returns NotApplicable if no accessibility is declared.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.ExplicitInterfaceImplementations">
 <summary>
 Returns interface methods explicitly implemented by this method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.IsExtensionMethod">
 <summary>
 Returns true if this method is an extension method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.IsExternalMethod">
 <summary>
 Gets a value indicating whether this instance is external method.
 </summary>
 <value>
 <c>true</c> if this instance is external method; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.IsMustOverride">
 <summary>
 Gets a value indicating whether this instance is abstract or not.
 </summary>
 <value>
 <c>true</c> if this instance is abstract; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.IsNotOverridable">
 <summary>
 Gets a value indicating whether this instance is not overridable.
 </summary>
 <value>
 <c>true</c> if this instance is not overridable; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.IsOverloads">
 <summary>
 Gets a value indicating whether this instance is overloads.
 </summary>
 <value>
 <c>true</c> if this instance is overloads; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.IsOverridable">
 <summary>
 Gets a value indicating whether this instance is overridable.
 </summary>
 <value>
 <c>true</c> if this instance is overridable; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.IsOverrides">
 <summary>
 Gets a value indicating whether this instance is overrides.
 </summary>
 <value>
 <c>true</c> if this instance is overrides; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.IsShared">
 <summary>
 Gets a value indicating whether this instance is shared.
 </summary>
 <value>
   <c>true</c> if this instance is shared; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.IsSub">
 <summary>
 Gets a value indicating whether this instance is a sub.
 </summary>
 <value>
   <c>true</c> if this instance is sub; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.IsVararg">
 <summary>
 Gets a value indicating whether this instance is vararg.
 </summary>
 <value>
   <c>true</c> if this instance is vararg; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.Locations">
 <summary>
 A potentially empty collection of locations that correspond to this instance.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.MethodKind">
 <summary>
 Gets what kind of method this is. There are several different kinds of things in the
 VB language that are represented as methods. This property allow distinguishing those things
 without having to decode the name of the method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.Parameters">
 <summary>
 The parameters forming part of this signature.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.ReturnType">
 <summary>
 Gets the return type of the method.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.GetReturnTypeAttributes">
 <summary>
 Returns the list of attributes, if any, associated with the return type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.ReturnTypeCustomModifiers">
 <summary>
 Returns the list of custom modifiers, if any, associated with the returned value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.TypeArguments">
 <summary>
 Returns the type arguments that have been substituted for the type parameters.
 If nothing has been substituted for a given type parameter,
 then the type parameter itself is consider the type argument.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.TypeParameters">
 <summary>
 Get the type parameters on this method. If the method has not generic,
 returns an empty list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.IsImplicitlyDeclared">
 <summary>
 Gets a value indicating whether the symbol was generated by the compiler
 rather than declared explicitly.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol.Name">
 <summary>
 Gets the symbol name. Returns the empty string if unnamed.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedEventDelegateSymbol">
 <summary>
 This class represents a synthesized delegate type derived from an Event declaration
 </summary>
 <remarks>
 <example>
 Class C
   Event Name(a As Integer, b As Integer)
 End Class
 
 defines an event and a delegate type:
 
 Event Name As NamedEventHandler
 Delegate Sub NameEventHandler(a As Integer, b As Integer)
 
 </example>
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedEventDelegateSymbol.ImplicitlyDefinedBy(System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbol}})">
 <summary>
 This property may be called while containing type is still being constructed.
 Therefore it can take membersInProgress context to ensure that returned symbol
 is relevant to the current type construction.
 (there could be several optimistically concurrent sessions)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedEventDelegateSymbol.GenerateDeclarationErrors(System.Threading.CancellationToken)">
 <summary>
 Force all declaration errors to be generated.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedGlobalMethodBase">
 <summary>
 This class represents a base class for compiler generated synthesized method symbols
 that must be emitted in the compiler generated PrivateImplementationDetails class.
 SynthesizedGlobalMethodBase symbols don't have a ContainingType, there are global to
 the containing source module and are Public Shared methods.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedGlobalMethodBase.Name">
 <summary>
 Gets the symbol name. Returns the empty string if unnamed.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedGlobalMethodBase.IsMustOverride">
 <summary>
 Gets a value indicating whether this instance is abstract or not.
 </summary>
 <value>
 <c>true</c> if this instance is abstract; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedGlobalMethodBase.IsNotOverridable">
 <summary>
 Gets a value indicating whether this instance is not overridable.
 </summary>
 <value>
 <c>true</c> if this instance is not overridable; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedGlobalMethodBase.IsOverloads">
 <summary>
 Gets a value indicating whether this instance is overloads.
 </summary>
 <value>
 <c>true</c> if this instance is overloads; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedGlobalMethodBase.IsOverridable">
 <summary>
 Gets a value indicating whether this instance is overridable.
 </summary>
 <value>
 <c>true</c> if this instance is overridable; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedGlobalMethodBase.IsOverrides">
 <summary>
 Gets a value indicating whether this instance is overrides.
 </summary>
 <value>
 <c>true</c> if this instance is overrides; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedGlobalMethodBase.IsShared">
 <summary>
 Gets a value indicating whether this instance is shared.
 </summary>
 <value>
   <c>true</c> if this instance is shared; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedGlobalMethodBase.Locations">
 <summary>
 A potentially empty collection of locations that correspond to this instance.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedGlobalMethodBase.MethodKind">
 <summary>
 Gets what kind of method this is. There are several different kinds of things in the
 VB language that are represented as methods. This property allow distinguishing those things
 without having to decode the name of the method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedGlobalMethodBase.Parameters">
 <summary>
 The parameters forming part of this signature.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedInterfaceImplementationStubSymbol">
 <summary>
 When signature of an implementing method differs (due to presence of custom modifiers)
 from the signature of implemented method, we insert a synthesized explicit interface 
 implementation that delegates to the method declared in source.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMethod">
 <summary>
 Base for synthesized Lambda methods. 
 Just provides a bunch of defaults
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMethod.WithNewContainerAndType(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol)">
 <summary>
 Creates a clone of the local with a new containing symbol and type.
 Note that the new parameter gets no syntaxRef as it is supposed to get 
 all the values it needs from the original parameter.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedOverridingWithEventsProperty">
 <summary>
 This class represents synthetic WithEvents property that overrides
 one in one of the base classes.
 </summary>
 <remarks>
 When derived class contains "Handles" methods that refer to a 
 WithEvents property in a base class, derived class needs to add a 
 synthetic override for the base WithEvent property. 
 We need the override so that we could inject code sequences that 
 remove old handlers and add new handlers when something is assigned 
 to the property.
 <example>
 Public Class Base
     Protected Friend WithEvents w As Base = Me
     Public Event e As System.Action
 
     Sub H1() Handles w.e
     End Sub
 End Class
 
 Public Class Derived
     Inherits Base
 
     Sub H2() Handles w.e
     End Sub
 End Class
 </example>
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol">
 <summary>
 Base (simplified) class for synthesized parameter symbols of methods that have been synthesized. E.g. the parameters of delegate methods
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Int32,System.String)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbol" /> class.
 </summary>
 <param name="container">The containing symbol</param>
 <param name="type">The type of this parameter</param>
 <param name="ordinal">The ordinal number of this parameter</param>
 <param name="name">The name of this parameter</param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol.ContainingSymbol">
 <summary>
 Gets the containing symbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol.CustomModifiers">
 <summary>
 The list of custom modifiers, if any, associated with the parameter. Evaluate this property only if IsModified is true.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol.ExplicitDefaultConstantValue(Microsoft.CodeAnalysis.VisualBasic.SymbolsInProgress{Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol})">
 <summary>
 A compile time constant value that should be supplied as the corresponding argument value by callers that do not explicitly specify an argument value for this parameter.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol.HasExplicitDefaultValue">
 <summary>
 True if the parameter has a default value that should be supplied as the argument value by a caller for which the argument value has not been explicitly specified.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol.IsByRef">
 <summary>
 Gets a value indicating whether this instance is by ref.
 </summary>
 <value>
   <c>true</c> if this instance is by ref; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol.IsOptional">
 <summary>
 True if the argument value must be included in the marshalled arguments passed to a remote callee only if it is different from the default value (if there is one).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol.IsParamArray">
 <summary>
 Gets a value indicating whether this instance is param array.
 </summary>
 <value>
 <c>true</c> if this instance is param array; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol.IsImplicitlyDeclared">
 <summary>
 Gets a value indicating whether the symbol was generated by the compiler
 rather than declared explicitly.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol.Locations">
 <summary>
 A potentially empty collection of locations that correspond to this instance.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol.Ordinal">
 <summary>
 Gets the ordinal.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol.Type">
 <summary>
 Gets the type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol.Name">
 <summary>
 Gets the name.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbol">
 <summary>
 Base class for synthesized parameter symbols of methods that have been synthesized. E.g. the parameters of delegate methods
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbol.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Int32,System.Boolean,System.String)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbol" /> class.
 </summary>
 <param name="container">The containing symbol</param>
 <param name="type">The type of this parameter</param>
 <param name="ordinal">The ordinal number of this parameter</param>
 <param name="isByRef">Whether the parameter is ByRef or not</param>
 <param name="name">The name of this parameter</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbol.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Int32,System.Boolean,System.String,System.Boolean,Microsoft.CodeAnalysis.ConstantValue)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbol" /> class.
 </summary>
 <param name="container">The containing symbol</param>
 <param name="type">The type of this parameter</param>
 <param name="ordinal">The ordinal number of this parameter</param>
 <param name="isByRef">Whether the parameter is ByRef or not</param>
 <param name="name">The name of this parameter</param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbol.IsByRef">
 <summary>
 Gets a value indicating whether this instance is by ref.
 </summary>
 <value>
   <c>true</c> if this instance is by ref; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbol.IsOptional">
 <summary>
 True if the argument value must be included in the marshalled arguments passed to a remote callee only if it is different from the default value (if there is one).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbol.ExplicitDefaultConstantValue(Microsoft.CodeAnalysis.VisualBasic.SymbolsInProgress{Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol})">
 <summary>
 A compile time constant value that should be supplied as the corresponding argument value by callers that do not explicitly specify an argument value for this parameter.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbol.HasExplicitDefaultValue">
 <summary>
 True if the parameter has a default value that should be supplied as the argument value by a caller for which the argument value has not been explicitly specified.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbolWithCustomModifiers.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Int32,System.Boolean,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier},System.UInt16)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbolWithCustomModifiers" /> class.
 </summary>
 <param name="container">The containing symbol</param>
 <param name="type">The type of this parameter</param>
 <param name="ordinal">The ordinal number of this parameter</param>
 <param name="isByRef">Whether the parameter is ByRef or not</param>
 <param name="name">The name of this parameter</param>
 <param name="customModifiers">The custom modifiers of this parameter</param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbolWithCustomModifiers.CustomModifiers">
 <summary>
 The list of custom modifiers, if any, associated with the parameter. Evaluate this property only if IsModified is true.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterWithLocationSymbol">
 <summary>
 Extends SynthesizedParameterSymbol to also accept a location
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedPropertyBase">
 <summary>
 A base class for symbols representing a synthesized property.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedRegularMethodBase">
 <summary>
 This class represents a base class for compiler generated methods
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedRegularMethodBase.Name">
 <summary>
 Gets the symbol name. Returns the empty string if unnamed.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedRegularMethodBase.IsMustOverride">
 <summary>
 Gets a value indicating whether this instance is abstract or not.
 </summary>
 <value>
 <c>true</c> if this instance is abstract; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedRegularMethodBase.IsNotOverridable">
 <summary>
 Gets a value indicating whether this instance is not overridable.
 </summary>
 <value>
 <c>true</c> if this instance is not overridable; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedRegularMethodBase.IsOverloads">
 <summary>
 Gets a value indicating whether this instance is overloads.
 </summary>
 <value>
 <c>true</c> if this instance is overloads; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedRegularMethodBase.IsOverridable">
 <summary>
 Gets a value indicating whether this instance is overridable.
 </summary>
 <value>
 <c>true</c> if this instance is overridable; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedRegularMethodBase.IsOverrides">
 <summary>
 Gets a value indicating whether this instance is overrides.
 </summary>
 <value>
 <c>true</c> if this instance is overrides; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedRegularMethodBase.IsShared">
 <summary>
 Gets a value indicating whether this instance is shared.
 </summary>
 <value>
   <c>true</c> if this instance is shared; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedRegularMethodBase.Locations">
 <summary>
 A potentially empty collection of locations that correspond to this instance.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedRegularMethodBase.MethodKind">
 <summary>
 Gets what kind of method this is. There are several different kinds of things in the
 VB language that are represented as methods. This property allow distinguishing those things
 without having to decode the name of the method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedRegularMethodBase.Parameters">
 <summary>
 The parameters forming part of this signature.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedSimpleConstructorSymbol">
 <summary>
 This class represents a simple implementation of compiler generated constructors
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedSimpleConstructorSymbol.SetParameters(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol})">
 <summary>
 Sets the parameters.
 </summary>
 <param name="parameters">The parameters.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedSimpleMethodSymbol">
 <summary>
 This class represents a base class for compiler generated methods
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedSimpleMethodSymbol.SetParameters(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol})">
 <summary>
 Sets the parameters.
 </summary>
 <param name="parameters">The parameters.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterConstraint">
 <summary>
 A type parameter constraint: a single 'New', 'Class',
 'Structure' constraint or a specific type constraint.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution">
 <summary>
 Immutable. Thread-safe.
 
 Represents a type substitution, with substitutions of types for a set of type parameters.
 Each TypeSubstitution object has three pieces of information:
    - OriginalDefinition of generic symbol the substitution is targeting.
    - An array of pairs that provide a mapping from symbol's type parameters to type arguments.
      identity substitutions are omitted.
    - TypeSubstitution object for containing type to provide mapping for its type
      parameters, if any. 
 
 The identity substitution (for the whole type hierarchy) is represented by Nothing. That said,
 top level parent of non-Nothing instance of TypeSubstitution is guaranteed to be non-identity 
 substitution. The instance may still be an identity substitution just for target generic definition,
 which will be represented by an empty mapping array. 
 
 The chain of TypeSubstitution objects is guaranteed to not skip any type in the containership hierarchy,
 even types with zero arity contained in generic type will have corresponding TypeSubstitution object with
 empty mapping array.
 
 Example:
     Class A(Of T,S)
          Class B
              Class C(Of U)
              End Class
          End Class
     End Class 
 
 TypeSubstitution for A(Of Integer, S).B.C(Of Byte) is C{U->Byte}=>B{}=>A{T->Integer}
 TypeSubstitution for A(Of T, S).B.C(Of Byte) is C{U->Byte}
 TypeSubstitution for A(Of Integer, S).B is B{}=>A{T->Integer}
 TypeSubstitution for A(Of Integer, S).B.C(Of U) is C{}=>B{}=>A{T->Integer}
 
 CONSIDER:
     An array of KeyValuePair(Of TypeParameterSymbol, TypeSymbol)objects is used to represent type 
     parameter substitution mostly due to historical reasons. It might be more convenient and more 
     efficient to use ordinal based array of TypeSymbol objects instead.

 There is a Construct method that can be called on original definition with TypeSubstitution object as
 an argument. The advantage of that method is the ability to substitute type parameters of several types  
 in the containership hierarchy in one call. What type the TypeSubstitution parameter targets makes a 
 difference.
 
 For example:
      C.Construct(C{}=>B{}=>A{T->Integer}) == A(Of Integer, S).B.C(Of U)
      C.Construct(B{}=>A{T->Integer}) == A(Of Integer, S).B.C(Of )
      B.Construct(B{}=>A{T->Integer}) == A(Of Integer, S).B
 
 See comment for IsValidToApplyTo method as well.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution._pairs">
 <summary>
 A map between type parameters of _targetGenericDefinition and corresponding type arguments.
 Represented by an array of Key-Value pairs. Keys are type parameters of _targetGenericDefinition 
 in no particular order. Identity substitutions are omitted. 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution._targetGenericDefinition">
 <summary>
 Definition of a symbol which this instance of TypeSubstitution primarily targets.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution._parent">
 <summary>
 An instance of TypeSubstitution describing substitution for containing type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.PairsIncludingParent">
 <summary>
 Get all the pairs of substitutions, including from the parent substitutions. The substitutions
 are in order from outside-in (parent substitutions before child substitutions).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.ThrowIfSubstitutingToAlphaRenamedTypeParameter">
 <summary>
 Verify TypeSubstitution to make sure it doesn't map any 
 type parameter to an alpha-renamed type parameter.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.GetSubstitutionForGenericDefinition(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Return TypeSubstitution instance that targets particular generic definition.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.GetSubstitutionForGenericDefinitionOrContainers(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Return TypeSubstitution instance that targets particular
 generic definition or one of its containers.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.IsValidToApplyTo(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Does substitution target either genericDefinition or 
 one of its containers?
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.Concat(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Combine two substitutions into one by concatenating. 
 
 They may not directly or indirectly (through Parent) target the same generic definition.
 sub2 is expected to target types lower in the containership hierarchy.
 Either or both can be Nothing. 
 
 targetGenericDefinition specifies target generic definition for the result. 
 If sub2 is not Nothing, it must target targetGenericDefinition.
 If sub2 is Nothing, sub1 will be "extended" with identity substitutions to target 
 targetGenericDefinition.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.Create(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol[],Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeWithModifiers[],System.Boolean)">
 <summary>
 Create a substitution. If the substitution is the identity substitution, Nothing is returned.
 </summary>
 <param name="targetGenericDefinition">Generic definition the result should target.</param>
 <param name="params">
 Type parameter definitions. Duplicates aren't allowed. Type parameters of containing type
 must precede type parameters of a nested type.  
 </param>
 <param name="args">Corresponding type arguments.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.Create(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeWithModifiers},System.Boolean)">
 <summary>
 Create a substitution. If the substitution is the identity substitution, Nothing is returned.
 </summary>
 <param name="targetGenericDefinition">Generic definition the result should target.</param>
 <param name="params">
 Type parameter definitions. Duplicates aren't allowed. Type parameters of containing type
 must precede type parameters of a nested type.  
 </param>
 <param name="args">Corresponding type arguments.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.Concat(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution,Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeWithModifiers}})">
 <summary>
 Private helper to make sure identity substitutions are injected for types between 
 targetGenericDefinition and parent.TargetGenericDefinition.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.CreateForAlphaRename(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol})">
 <summary>
 Create substitution to handle alpha-renaming of type parameters. 
 It maps type parameter definition to corresponding alpha-renamed type parameter.
 </summary>
 <param name="alphaRenamedTypeParameters">Alpha-renamed type parameters.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.CreateAdditionalMethodTypeParameterSubstitution(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeWithModifiers})">
 <summary>
 Create TypeSubstitution that can be used to substitute method's type parameters
 in types involved in method's signature. 
 
 Unlike for other construction methods in this class, targetMethod doesn't have to be 
 original definition, it is allowed to be specialized unconstructed generic method.
 
 An item in typeArguments can be an alpha-renamed type parameter, but it must belong
 to the targetMethod and can only appear at its ordinal position to represent the lack
 of substitution for it.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.AdjustForConstruct(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Adjust substitution for construction.
 This has the following effects:
     1) The passed in additionalSubstitution is used on each type argument.
     2) If any parameters in the given additionalSubstitution are not present in oldConstructSubstitution, they are added.
     3) Parent substitution in oldConstructSubstitution is replaced with adjustedParent. 
 
 oldConstructSubstitution can be cancelled out by additionalSubstitution. In this case, 
 if the adjustedParent is Nothing, Nothing is returned.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.PrivateAdjustForConstruct(Microsoft.CodeAnalysis.ArrayBuilder{System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeWithModifiers}},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 This has the following effects:
     1) The passed in additionalSubstitution is used on each type argument.
     2) If any parameters in the given additionalSubstitution are not present in oldConstructSubstitution, they are added.
 
 Result is placed into pairs. Identity substitutions are omitted.
 
 Returns True if the set of pairs have changed, False otherwise.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution.Create(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution,Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeWithModifiers},System.Boolean)">
 <summary>
 Create substitution for targetGenericDefinition based on its type 
 arguments (matched to type parameters by position) and TypeSubstitution
 for direct or indirect container.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol">
 <summary>
 A TypeSymbol is a base class for all the symbols that represent a type
 in Visual Basic.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.OriginalDefinition">
 <summary>
 Get the original definition of this symbol. If this symbol is derived from another
 symbol by (say) type substitution, this gets the original symbol, as it was defined
 in source or metadata.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.BaseType">
 <summary>
 Gets the BaseType of this type. If the base type could not be determined, then 
 an instance of ErrorType is returned. If this kind of type does not have a base type
 (for example, interfaces), Nothing is returned. Also the special class System.Object
 always has a BaseType of Nothing.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.Interfaces">
 <summary>
 Gets the set of interfaces that this type directly implements. This set does not
 include interfaces that are base interfaces of directly implemented interfaces.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.AllInterfaces">
 <summary>
 The list of all interfaces of which this type is a declared subtype, excluding this type
 itself. This includes all declared base interfaces, all declared base interfaces of base
 types, and all declared base interfaces of those results (recursively).  Each result
 appears exactly once in the list. This list is topologically sorted by the inheritance
 relationship: if interface type A extends interface type B, then A precedes B in the
 list. This is not quite the same as "all interfaces of which this type is a proper
 subtype" because it does not take into account variance: AllInterfaces for
 IEnumerable(Of String) will not include IEnumerable(Of Object).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.MakeAllInterfaces">
 Produce all implemented interfaces in topologically sorted order. We use
 TypeSymbol.Interfaces as the source of edge data, which has had cycles and infinitely
 long dependency cycles removed. Consequently, it is possible (and we do) use the
 simplest version of Tarjan's topological sorting algorithm.
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics">
 <summary>
 Gets the set of interfaces that this type directly implements, plus the base interfaces
 of all such types.
 </summary>
 <remarks>
 CONSIDER: it probably isn't truly necessary to cache this.  If space gets tight, consider
 alternative approaches (recompute every time, cache on the side, only store on some types,
 etc).
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.IsReferenceType">
 <summary>
 Returns true if this type is known to be a reference type. It is never the case
 that <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.IsValueType"/> both return true. However, for an unconstrained
 type parameter, <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.IsValueType"/> will both return false.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.IsValueType">
 <summary>
 Returns true if this type is known to be a value type. It is never the case
 that <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.IsValueType"/> both return true. However, for an unconstrained
 type parameter, <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.IsValueType"/> will both return false.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.IsAnonymousType">
 <summary>
 Is this a symbol for an anonymous type (including delegate).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.TypeKind">
 <summary>
 Gets the kind of this type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.SpecialType">
 <summary>
 Gets corresponding special TypeId of this type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.PrimitiveTypeCode">
 <summary>
 Gets corresponding primitive type code for this type declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.InternalSubstituteTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution)">
 <summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.LookupMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
 <summary>
 Lookup an immediately nested type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
 <param name="emittedTypeName">
 Type name.
 </param>
 <returns>
 Symbol for the type, or MissingMetadataSymbol if the type isn't found.
 </returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.HighestPriorityUseSiteError">
 <summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.FindImplementationForInterfaceMember(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Returns the corresponding symbol in this type or a base type that implements 
 interfaceMember (either implicitly or explicitly), or null if no such symbol 
 exists (which might be either because this type doesn't implement the container 
 of interfaceMember, or this type doesn't supply a member that successfully 
 implements interfaceMember).
 </summary>
 <param name="interfaceMember">
 Must be a non-null interface property, method, or event.
 </param>
 <returns>The implementing member.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.ComputeImplementationForInterfaceMember(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Compute the implementation for an interface member in this type, or Nothing if none.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.IsNotInheritable(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Return true if nothing can inherit or implement this type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.DigThroughArrayType(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Dig through possibly jagged array type to the ultimate element type
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.IsCompatibleWithGenericIEnumerableOfType(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Returns true if <paramref name="type" /> is/inherits from/implements IEnumerable(Of U), and U is/inherits from/implements <paramref name="typeArgument" />
 </summary>
 <param name="type">The type to check compatibility for.</param>
 <param name="typeArgument">The type argument for IEnumerable(Of ...)</param>
 <returns><c>True</c> if type can be assigned to a IEnumerable(Of <para>typeArgument</para>); otherwise <c>False</c>.</returns>
 <remarks>This is not a general purpose helper.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.IsValidTypeForConstField(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Determines whether the given type is valid for a const field.
 VB Spec 9.5: The type of a constant may only be a primitive type or Object
 </summary>
 <param name="fieldType">The type of the field.</param><returns>
   <c>true</c> if type is valid for a const field; otherwise, <c>false</c>.
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.VisitType``1(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Func{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,``0,System.Boolean},``0)">
 <summary>
 Visit the given type and, in the case of compound types, visit all "sub type"
 (such as A in A(), or { A(Of T), T, U } in A(Of T).B(Of U)) invoking 'predicate'
 with the type and 'arg' at each sub type. If the predicate returns true for any type,
 traversal stops and that type is returned from this method. Otherwise if traversal
 completes without the predicate returning true for any type, this method returns null.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.IsValidTypeForAttributeArgument(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 Determines if the type is a valid type for a custom attribute argument
 </summary>
 <param name="type"></param>
 <param name="compilation"></param>
 <returns></returns>
 <remarks>
  The only valid types are 
 1. primitive types except date and decimal, 
 2. object, system.type, public enumerated types
 3. one dimensional arrays of (1) and (2) above
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.MarkCheckedIfNecessary(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol}@)">
 <summary>
 Add this instance to the set of checked types. Returns True
 if this type was added, False if the type was already in the set.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.CheckTypeArguments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol},System.Int32)">
 <summary> Checks for validity of type arguments passed to Construct(...) method </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.TransformToCanonicalFormFor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol},Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType.SpecializedGenericType)">
 <summary>
 Returns Nothing for identity substitution.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.TransformToCanonicalFormFor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol},Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol.SpecializedGenericMethod)">
 <summary>
 Returns Nothing for identity substitution.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.ExpressionTargetDelegate(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 Is this type System.Linq.Expressions.Expression(Of T) for some delegate type T. If so, return the type
 argument, else return nothing.
 The passed-in compilation is used to find the well-known-type System.Linq.Expressions.Expression(Of T).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.DelegateOrExpressionDelegate(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 If the passed in type is a delegate type D, return D.
 If the passed in type is a System.Linq.Expressions.Expression(Of D) for a delegate type D, return D.
 Else return Nothing
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.DelegateOrExpressionDelegate(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Boolean@)">
 <summary>
 If the passed in type is a delegate type D, return D and set wasExpression to False
 If the passed in type is a System.Linq.Expressions.Expression(Of D) for a delegate type D, return D and set wasExpression to True
 Else return Nothing and set wasExpression to False
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.IsExpressionTree(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 If the passed in type is a System.Linq.Expressions.Expression(Of D) for a delegate type D, return True
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.GetAllTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Return all of the type parameters in this type and enclosing types,
 from outer-most to inner-most type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.GetAllTypeParameters(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol})">
 <summary>
 Return all of the type parameters in this type and enclosing types,
 from outer-most to inner-most type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.GetAllTypeArguments(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Return all of the type arguments in this type and enclosing types,
 from outer-most to inner-most type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.GetAllTypeArgumentsWithModifiers(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Return all of the type arguments and their modifiers in this type and enclosing types,
 from outer-most to inner-most type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions.HasNameQualifier(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,System.String,System.StringComparison)">
 <summary>
 Return true if the fully qualified name of the type's containing symbol
 matches the given name. This method avoids string concatenations
 in the common case where the type is a top-level type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeWithModifiers.AsTypeSymbolOnly">
 <summary>
 Extract type under assumption that there should be no custom modifiers.
 The method asserts otherwise.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.UnboundGenericType.Create(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Given a possibly constructed/specialized generic type, create a symbol
 to represent an unbound generic type for its definition.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.UnboundGenericType.GenerateDeclarationErrors(System.Threading.CancellationToken)">
 <summary>
 Force all declaration errors to be generated.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.TopLevelCodeBinder">
 <summary>
 Provides context for binding top-level statements in a script. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.TopLevelCodeBinder.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Create binder for binding the body of a method. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.TypesOfImportedNamespacesMembersBinder">
 <summary>
 Provides lookup in types of imported namespaces, either at file level or project level.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.TypesOfImportedNamespacesMembersBinder.CollectProbableExtensionMethodsInSingleBinder(System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Collect extension methods with the given name that are in scope in this binder.
 The passed in ArrayBuilder must be empty. Extension methods from the same containing type
 must be grouped together. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.UsingBlockBinder">
 <summary>
 Binder used to bind using blocks. 
 It hosts the variables declared in the resource list (if they are declared).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.UsingInfo">
 <summary>
 Holds all information needed to rewrite a bound using block node.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.UsingInfo.PlaceholderInfo">
 <summary>
 A dictionary holding a placeholder, a conversion from placeholder to IDisposable and a condition if placeholder IsNot nothing
 per type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.UsingInfo.UsingStatementSyntax">
 <summary>
 Syntax node for the using block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.UsingInfo.#ctor(Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Roslyn.Utilities.ValueTuple{Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression}})">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.UsingInfo" /> class.
 </summary>
 <param name="usingStatementSyntax">The syntax node for the using block</param>
 <param name="placeholderInfo">A dictionary holding a placeholder, a conversion from placeholder to IDisposable and 
 a condition if placeholder IsNot nothing per type.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.IsInstanceReference(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary> Returns True if the node specified is one of Me/MyClass/MyBase </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.IsPropertyOrXmlPropertyAccess(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Returns True if the expression is a property access expression,
 either directly or wrapped in an XML member access expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.IsPropertySupportingAssignment(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Does this node represent a property with Set accessor and AccessKind not yet bound to Get?
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.IsSupportingAssignment(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Does this node represent a property or latebound access not yet determined to be Get?
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.GetAccessKind(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Get the access kind from property access expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.SetAccessKind(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.PropertyAccessKind)">
 <summary>
 Sets the access kind on the property access expression. To clear the access
 kind, 'newAccessKind' should be Unknown. Otherwise, the current property
 access kind should be Unknown or equal to 'newAccessKind'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.Update(Microsoft.CodeAnalysis.VisualBasic.BoundXmlMemberAccess,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Return a BoundXmlMemberAccess node with
 updated MemberAccess property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.IsIntegerZeroLiteral(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Return true if and only if an expression is a integral literal with a value of zero.
 Non-literal constant value zero does not qualify.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.IsIntegerZeroLiteral(Microsoft.CodeAnalysis.VisualBasic.BoundLiteral)">
 <summary>
 Return true if and only if an expression is a integral literal with a value of zero.
 Non-literal constant value zero does not qualify.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.IsDefaultValueConstant(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Checks if the expression is a default value (0 or Nothing)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.IsTrueConstant(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Checks if the expression is a constant and that constant is False
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.IsFalseConstant(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Checks if the expression is a constant and that constant is True
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.IsNegativeIntegerConstant(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Checks if the expression is a negative integer constant value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.GetIntegerConstantValue(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Return the integer constant value (if any) from a BoundExpression
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.IsNothingLiteral(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Return true if and only if an expression is a semantical Nothing literal, 
 which is defined as follows (the definition is consistent with 
 definition used by Dev10 compiler):
 - A Nothing literal according to the language grammar, or
 - A parenthesized expression, for which IsNothingLiteral returns true, or
 - An expression of type Object with constant value == Nothing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.IsNothingLiteral(Microsoft.CodeAnalysis.VisualBasic.BoundLiteral)">
 <summary>
 Return true if target BoundLiteral represents Nothing literal as defined by the language grammar.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.IsStrictNothingLiteral(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Return true if and only if an expression represents optionally 
 parenthesized Nothing literal as defined by the language grammar. 
 I.e. implicit conversions are Ok, but explicit conversions aren't.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions.TypeArguments(Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup)">
 <summary>
 returns type arguments or Nothing if group does not have type arguments.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.BoundNode.WasCompilerGenerated">
 <summary>
 The node should not be treated as a direct semantical representation of the syntax it is associated with. 
 Some examples: 
 - implicit call for base constructor is associated with the constructor syntax.
 - code in compiler generated constructor is associated with the type declaration.
 
 Nodes marked this way are likely to be skipped by SemanticModel, Sequence Point rewriter, etc.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.BoundNodeExtensions.GetBinderFromLambda(Microsoft.CodeAnalysis.VisualBasic.BoundNode)">
 <summary>
 Get the Binder from a lambda node, or return Nothing if this isn't 
 a lambda node.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.BoundNodeFinder">
 <summary>
 The visitor which searches for a bound node inside a bound subtree
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.BoundNodeFinder._nodeToFind">
 <summary> Note: Nothing if node is found </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.NoOpStatementFlavor">
 <summary>
 NoOpStatementFlavor specifies additional info that NoOp statement may be carrying;
 Such info may be used in rewriting or code gen phases to perform some special actions
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.NoOpStatementFlavor.AwaitYieldPoint">
 <summary> 
 Marks a control yield point for emitted await operator; is processed by codegen; 
 only allowed inside MoveNext methods generated for Async methods
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.NoOpStatementFlavor.AwaitResumePoint">
 <summary> 
 Marks a control resume point for emitted await operator; is processed by codegen; 
 only allowed inside MoveNext methods generated for Async methods
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.PseudoVariableExpressions">
 <summary>
 BoundExpressions to be used for emit. The expressions are assumed
 to be lowered and will not be visited by <see cref="T:Microsoft.CodeAnalysis.VisualBasic.BoundTreeWalker"/>.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator._tryNestingLevel">
 <summary> Keeps track on current nesting level of try statements </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator._currentCatchBlock">
 <summary> Current enclosing Catch block if there is any. </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.EmitAddress(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.AddressKind)">
 <summary>
 Emits address as in &amp; 
 
 May introduce a temp which it will return. (otherwise returns null)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.EmitAddressOfTempClone(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Emits address of a temp.
 Used in cases where taking address directly is not possible 
 (typically because expression does not have a home)
 
 Will introduce a temp which it will return.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.HasHome(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Checks if expression represents directly or indirectly a value with its own home.
 In such cases it is possible to get a reference without loading into a temporary.
 
 This is a CLR concept which is weaker than VB's IsLValue.
 For example all locals are homed even if VB may consider some locals read-only.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.HasHome(Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess)">
 <summary>
 Special HasHome for fields. Fields have homes when they are writable.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.AllowedToTakeRef(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.AddressKind)">
 <summary>
 Checks if it is allowed to take a writable reference to expression according to VB rules.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.AllowedToTakeRef(Microsoft.CodeAnalysis.VisualBasic.BoundLocal,Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.AddressKind)">
 <summary>
 Checks if it is allowed to take a writable reference to expression according to VB rules.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.AllowedToTakeRef(Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess,Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.AddressKind)">
 <summary>
 Can take a reference.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.EmitReceiverRef(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.AddressKind)">
 <summary>
 Emits receiver in a form that allows member accesses ( O or &amp; ). For verifiably
 reference types it is the actual reference. For generic types it is a address of the
 receiver with readonly intent. For the value types it is an address of the receiver.
 
 isAccessConstrained indicates that receiver is a target of a constrained callvirt
 in such case it is unnecessary to box a receiver that is typed to a type parameter
 
 May introduce a temp which it will return. (otherwise returns null)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.EmitInstanceFieldAddress(Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess,Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.AddressKind)">
 <summary>
 May introduce a temp which it will return. (otherwise returns null)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.EmitArrayInitializers(Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization)">
 <summary>
 Entry point to the array initialization.
 Assumes that we have newly created array on the stack.
 
 inits could be an array of values for a single dimensional array
 or an   array (of array)+  of values for a multidimensional case
 
 in either case it is expected that number of leaf values will match number 
 of elements in the array and nesting level should match the rank of the array.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.IndexDesc">
 <summary>
 To handle array initialization of arbitrary rank it is convenient to 
 approach multidimensional initialization as a recursively nested.
 
 ForAll{i, j, k} Init(i, j, k) ===> 
 ForAll{i} ForAll{j, k} Init(i, j, k) ===>
 ForAll{i} ForAll{j} ForAll{k} Init(i, j, k)
 
 This structure is used for capturing initializers of a given index and 
 the index value itself.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.EmitAllElementInitializersRecursive(Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.IndexDesc},System.Boolean)">
 <summary>
 Emits all initializers that match indices on the stack recursively.
 
 Example: 
  if array has [0..2, 0..3, 0..2] shape
  and we have {1, 2} indices on the stack
  initializers for 
              [1, 2, 0]
              [1, 2, 1]
              [1, 2, 2]
 
  will be emitted and the top index will be pushed off the stack 
  as at that point we would be completely done with emitting initializers 
  corresponding to that index.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.InitializerCountRecursive(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},System.Int32@,System.Int32@)">
 <summary>
 Count of all initializers.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.GetRawData(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression})">
 <summary>
 Produces a serialized blob of all constant initializers.
 Non-constant initializers are matched with a zero of corresponding size.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.IsMultidimensionalInitializer(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression})">
 <summary>
 Check if it is a regular collection of expressions or there are nested initializers.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.CanUseCallOnRefTypeReceiver(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Used to decide if we need to emit call or callvirt.
 It basically checks if the receiver expression cannot be null, but it is not 100% precise. 
 There are cases where it really can be null, but we do not care.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.IsMeReceiver(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 checks if receiver is effectively ldarg.0
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.MayUseCallForStructMethod(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 Used to decide if we need to emit 'call' or 'callvirt' for structure method.
 It basically checks if the method overrides any other and method's defining type
 is not a 'special' or 'special-by-ref' type. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.EmitTernaryConditionalExpression(Microsoft.CodeAnalysis.VisualBasic.BoundTernaryConditionalExpression,System.Boolean)">
 <summary>
 Emit code for a ternary conditional operator.
 </summary>
 <remarks>
 if (b, x, y) becomes
     push b
     if pop then goto CONSEQUENCE
     push y
     goto DONE
   CONSEQUENCE:
     push x
   DONE:
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.EmitBinaryConditionalExpression(Microsoft.CodeAnalysis.VisualBasic.BoundBinaryConditionalExpression,System.Boolean)">
 <summary>
 Emit code for a null-coalescing operator.
 </summary>
 <remarks>
 if(x, y) becomes
   push x
   dup x
   if pop isnot null goto LEFT_NOT_NULL
     pop 
     push y
   LEFT_NOT_NULL:
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.EmitVectorElementStore(Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Emit an element store instruction for a single dimensional array.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.ShouldNoteProjectErrors">
 <summary>
 Tells if we should emit [Set/Clear]ProjectErrors when entering/leaving handlers
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.LabelFinder">
 <summary>
 tells if given node contains a label statement that defines given label symbol
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.EmitStringCompareAndBranch(Microsoft.CodeAnalysis.CodeGen.LocalOrParameter,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ConstantValue,System.Object,Microsoft.Cci.IReference)">
 <summary>
 Delegate to emit string compare call and conditional branch based on the compare result.
 </summary>
 <param name="key">Key to compare</param>
 <param name="syntaxNode">Node for diagnostics</param>
 <param name="stringConstant">Case constant to compare the key against</param>
 <param name="targetLabel">Target label to branch to if key = stringConstant</param>
 <param name="stringCompareMethodRef">String equality method</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.GetLocalDebugName(Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.CodeGen.LocalDebugId@)">
 <summary>
 Gets the name And id of the local that are going to be generated into the debug metadata.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.GetLocal(Microsoft.CodeAnalysis.VisualBasic.BoundLocal)">
 <summary>
 Gets already declared and initialized local.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.AllocateTemp(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Allocates a temp without identity.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.FreeTemp(Microsoft.CodeAnalysis.CodeGen.LocalDefinition)">
 <summary>
 Frees a temp without identity.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator.FreeOptTemp(Microsoft.CodeAnalysis.CodeGen.LocalDefinition)">
 <summary>
 Frees an optional temp.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.CodeGen.Optimizer">
 <summary>
 Optimizer performs optimization of the bound tree performed before passing it to a codegen. Generally it may
 include several phases like stack scheduling of local variables, etc...
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.ExprContext">
 <summary>
 context of expression evaluation. 
 it will affect inference of stack behavior
 it will also affect when expressions can be dup-reused
     Example:
         Foo(x, ref x)     x cannot be duped as it is used in different context  
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.Analyzer">
 <summary>
 Analyzes the tree trying to figure which locals may live on stack. It is 
 a fairly delicate process and must be very familiar with how CodeGen works. 
 It is essentially a part of CodeGen.
 
 NOTE: It is always safe to mark a local as not eligible as a stack local 
 so when situation gets complicated we just refuse to schedule and move on.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.Analyzer._empty">
 <summary>
 fake local that represents the eval stack. when we need to ensure that eval
 stack is not blocked by stack Locals, we record an access to empty.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.Analyzer.LhsUsesStackWhenAssignedTo(Microsoft.CodeAnalysis.VisualBasic.BoundNode,Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.ExprContext)">
 <summary>
 here we have a case of indirect assignment:  *t1 = expr;
 normally we would need to push t1 and that will cause spilling of t2
 
 TODO: an interesting case arises in unused x[i]++  and ++x[i] :
       we have trees that look like:

    t1 = &amp;(x[0])
    t2 = *t1
   *t1 = t2 + 1

    t1 = &amp;(x[0])
    t2 = *t1 + 1
   *t1 = t2

  in these cases, we could keep t2 on stack (dev10 does).
  we are dealing with exactly 2 locals and access them in strict order 
  t1, t2, t1, t2  and we are not using t2 after that.
  We may consider detecting exactly these cases and pretend that we do not need 
  to push either t1 or t2 in this case.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.Analyzer.IsIndirectAssignment(Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator)">
 <summary>
 indirect assignment is assignment to a value referenced indirectly
 it may only happen if lhs is a reference (must be a parameter or a local)
       1) lhs is a reference (must be a parameter or a local)
       2) it is not a ref/out assignment where the reference itself would be assigned
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.Analyzer.EnsureOnlyEvalStack">
 <summary>
 Ensures that there are no stack locals. It is done by accessing 
 virtual "empty" local that is at the bottom of all stack locals.
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.LocalDefUseInfo">
 <summary>
 Represents a local and its Def-Use-Use chain
 
 NOTE: stack local reads are destructive to the locals so 
 if the read is not last one, it must be immediately followed by another definition. 
 For the rewriting purposes it is irrelevant if definition was created by a write or 
 a subsequent read. These cases are not ambiguous because when rewriting, definition 
 will match to a single node and  we always know if given node is reading or writing.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.LocalDefUseInfo.StackAtDeclaration">
 <summary>
 stack at variable declaration, may be > 0 in sequences.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.LocalDefUseInfo.localDefs">
 <summary>
 value definitions for this variable
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.LocalDefUseInfo.CannotSchedule">
 <summary>
 once this goes to true we are no longer interested in this variable.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.LocalDefUseSpan">
 <summary>
 Represents a span of a value between definition and use. Start/end positions are 
 specified in terms of global node count as visited by StackOptimizer visitors. 
 (i.e. recursive walk not looking into constants)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.LocalDefUseSpan.ConflictsWith(Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.LocalDefUseSpan)">
 <summary>
 when current And other use spans are regular spans we can have only 2 conflict cases:
 [1, 3) conflicts with [0, 2)
 [1, 3) conflicts with [2, 4)
 
 NOTE: With regular spans, it is not possible for two spans to share an edge point 
 unless they belong to the same local. (because we cannot aceess two real locals at the same time)
 
 specifically:
 [1, 3) does Not conflict with [0, 1)   since such spans would need to belong to the same local
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.LocalDefUseSpan.ConflictsWithDummy(Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.LocalDefUseSpan)">
 <summary>
 Dummy locals represent implicit control flow
 it is not allowed for a regular local span to cross into or 
 be immediately adjacent to a dummy span.
 
 specifically:
 [1, 3) does conflict with [0, 1)   since that would imply a value flowing into or out of a span surrounded by a branch/label
 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler.Rewriter">
 <summary>
 Rewrites the tree to account for destructive nature of stack local reads.
 
 Typically, last read stays as-is and local is destroyed by the read.
 Intermediate reads are rewritten as Dups -
 
       NotLastUse(X_stackLocal) ===> NotLastUse(Dup)
       LastUse(X_stackLocal) ===> LastUse(X_stackLocal)
 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineArguments">
 <summary>
 The CommandLineArguments class provides members to Set and Get Visual Basic compilation and parse options.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineArguments.CompilationOptions">
 <summary>
 Set and Get the Visual Basic compilation options.
 </summary>
 <returns>The currently set Visual Basic compilation options.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineArguments.ParseOptions">
 <summary>
 Set and Get the Visual Basic parse options.
 </summary>
 <returns>The currently set Visual Basic parse options.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineArguments.ParseOptionsCore">
 <summary>
 Gets the core Parse options.
 </summary>
 <returns>The currently set core parse options.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineArguments.CompilationOptionsCore">
 <summary>
 Gets the core compilation options.
 </summary>
 <returns>The currently set core compilation options.</returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser">
 <summary>
 The VisualBasicCommandLineParser class contains members used to perform various Visual Basic command line parsing operations.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.Default">
 <summary>
 Gets the current command line parser.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.ScriptRunner">
 <summary>
 Gets the current interactive command line parser.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.#ctor(System.Boolean)">
 <summary>
 Creates a new command line parser.
 </summary>
 <param name="isScriptRunner">An optional parameter indicating whether to create a interactive command line parser.</param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.RegularFileExtension">
 <summary>
 Gets the standard Visual Basic source file extension
 </summary>
 <returns>A string representing the standard Visual Basic source file extension.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.ScriptFileExtension">
 <summary>
 Gets the standard Visual Basic script file extension.
 </summary>
 <returns>A string representing the standard Visual Basic script file extension.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.Parse(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String)">
 <summary>
 Parses a command line.
 </summary>
 <param name="args">A collection of strings representing the command line arguments.</param>
 <param name="baseDirectory">The base directory used for qualifying file locations.</param>
 <param name="sdkDirectory">The directory to search for mscorlib, or Nothing if not available.</param>
 <param name="additionalReferenceDirectories">A string representing additional reference paths.</param>
 <returns>A CommandLineArguments object representing the parsed command line.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.PublicSymbolsToInternalDefines(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}},System.String)">
 <summary>
 Converts a sequence of definitions provided by a caller (public API) into map 
 of definitions used internally.
 </summary>
 <exception cref="T:System.ArgumentException">Invalid value provided.</exception>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.InternalDefinesToPublicSymbols(System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CConst})">
 <summary>
 Converts ImmutableDictionary of definitions used internally into IReadOnlyDictionary of definitions 
 returned to a caller (of public API)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.ParseConditionalCompilationSymbols(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic}@,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
 <summary>
 Parses Conditional Compilations Symbols.   Given the string of conditional compilation symbols from the project system, parse them and merge them with an IReadOnlyDictionary
 ready to be given to the compilation.
 </summary>
 <param name="symbolList">
 The conditional compilation string. This takes the form of a comma delimited list
 of NAME=Value pairs, where Value may be a quoted string or integer.
 </param>
 <param name="diagnostics">A collection of reported diagnostics during parsing of symbolList, can be empty IEnumerable.</param>
 <param name="symbols">A collection representing existing symbols. Symbols parsed from <paramref name="symbolList"/> will be merged with this dictionary. </param>
 <exception cref="T:System.ArgumentException">Invalid value provided.</exception>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.ParseConditionalCompilationExpression(System.String,System.Int32)">
 <summary>
 NOTE: implicit line continuation will not be handled here and an error will be generated, 
 but explicit one (like ".... _\r\n ....") should work fine
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.ParsePlatform(System.String,System.String,System.Collections.Generic.List{Microsoft.CodeAnalysis.Diagnostic})">
 <summary>
 Parses the given platform option. Legal strings are "anycpu", "x64", "x86", "itanium", "anycpu32bitpreferred", "arm".
 In case an invalid value was passed, anycpu is returned.
 </summary>
 <param name="value">The value for platform.</param>
 <param name="errors">The error bag.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.ParseFileAlignment(System.String,System.String,System.Collections.Generic.List{Microsoft.CodeAnalysis.Diagnostic})">
 <summary>
 Parses the file alignment option.
 In case an invalid value was passed, nothing is returned.
 </summary>
 <param name="name">The name of the option.</param>
 <param name="value">The value for the option.</param>
 <param name="errors">The error bag.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.ParseBaseAddress(System.String,System.String,System.Collections.Generic.List{Microsoft.CodeAnalysis.Diagnostic})">
 <summary>
 Parses the base address option.
 In case an invalid value was passed, nothing is returned.
 </summary>
 <param name="name">The name of the option.</param>
 <param name="value">The value for the option.</param>
 <param name="errors">The error bag.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.ParseWarnings(System.String)">
 <summary>
 Parses the warning option.
 </summary>
 <param name="value">The value for the option.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser.GetCompilationAndModuleNames(System.Collections.Generic.List{Microsoft.CodeAnalysis.Diagnostic},Microsoft.CodeAnalysis.OutputKind,System.Collections.Generic.List{Microsoft.CodeAnalysis.CommandLineSourceFile},System.String,System.String@,System.String@,System.String@)">
 <summary>
 In VB, if the output file name isn't specified explicitly, then it is derived from the name of the
 first input file.
 </summary>
 <remarks>
 http://msdn.microsoft.com/en-us/library/std9609e(v=vs.110)
 Specify the full name and extension of the file to create. If you do not, the .exe file takes 
 its name from the source-code file containing the Sub Main procedure, and the .dll file takes
 its name from the first source-code file.
 
 However, vbc.cpp has: 
 <![CDATA[
   // Calculate the output name and directory
   dwCharCount = GetFullPathName(pszOut ? pszOut : g_strFirstFile, &wszFileName);
 ]]>
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompiler.PrintLogo(System.IO.TextWriter)">
 <summary>
 Print compiler logo
 </summary>
 <param name="consoleOutput"></param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompiler.PrintHelp(System.IO.TextWriter)">
 <summary>
 Print Commandline help message (up to 80 English characters per line)
 </summary>
 <param name="consoleOutput"></param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo">
 <summary>
  Structure containing all semantic information about an Await expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo.#ctor(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.IMethodSymbol)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo" /> structure.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo.GetAwaiterMethod">
 <summary>
 Gets the &quot;GetAwaiter&quot; method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo.GetResultMethod">
 <summary>
 Gets the &quot;GetResult&quot; method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo.IsCompletedProperty">
 <summary>
 Gets the &quot;IsCompleted&quot; property.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.BoundNodeSummary">
 <summary>
 This structure holds the relevant bound node information relating to a particular syntax
 node, used temporarily for GetSemanticInfo and similar APIs. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ClsComplianceChecker">
 <summary>
 Traverses the symbol table checking for CLS compliance.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ClsComplianceChecker.CheckCompliance(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,Microsoft.CodeAnalysis.DiagnosticBag,System.Threading.CancellationToken,Microsoft.CodeAnalysis.SyntaxTree,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan})">
 <summary>
 Traverses the symbol table checking for CLS compliance.
 </summary>
 <param name="compilation">Compilation that owns the symbol table.</param>
 <param name="diagnostics">Will be supplemented with documentation comment diagnostics.</param>
 <param name="cancellationToken">To stop traversing the symbol table early.</param>
 <param name="filterTree">Only report diagnostics from this syntax tree, if non-null.</param>
 <param name="filterSpanWithinTree">If <paramref name="filterTree"/> and <paramref name="filterSpanWithinTree"/> is non-null, report diagnostics within this span in the <paramref name="filterTree"/>.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ClsComplianceChecker.CheckSymbolDistinctness(Microsoft.CodeAnalysis.VisualBasic.Symbol,Roslyn.Utilities.MultiDictionary{System.String,Microsoft.CodeAnalysis.VisualBasic.Symbol}.ValueSet)">
 <remarks>
 NOTE: Dev11 does some pretty weird things here.  First, it ignores arity,
 which seems like a good way to disambiguate symbols (in particular,
 CLS Rule 43 says that the name includes backtick-arity).  Second, it
 does not consider two members with identical names (i.e. not differing
 in case) to collide.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ClsComplianceChecker.GetInheritedCompliance(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 What is the argument to the (first) CLSCompliantAttribute on this symbol, if there is one?
 Consider attributes inherited from base types.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ClsComplianceChecker.GetDeclaredComplianceHelper(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.Location@,System.Boolean@)">
 <summary>
 What is the argument to the (first) CLSCompliantAttribute on this symbol, if there is one?
 Do not consider attributes inherited from base types.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ClsComplianceChecker.GetContainingModuleOrAssembly(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Return the containing module if the output kind is module and the containing assembly otherwise.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ClsComplianceChecker.SignaturesCollide(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <remarks>
 Based on CompilationPass::CLSReduceSignature.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation">
 <summary>
 The Compilation object is an immutable representation of a single invocation of the
 compiler. Although immutable, a Compilation is also on-demand, in that a compilation can be
 created quickly, but will that compiler parts or all of the code in order to respond to
 method or properties. Also, a compilation can produce a new compilation with a small change
 from the current compilation. This is, in many cases, more efficient than creating a new
 compilation from scratch, as the new compilation can share information from the old
 compilation.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.IsInSemanticModelMode">
 <summary>
 For semantic model scenarios we continue processing documentation comment even in presence
 of some errors. Now, we detect semantic model context from '_isForSingleSymbol' flag,
 later we might consider introducing an explicit flag
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.GetDocumentationCommentForSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.DocumentationCommentTriviaSyntax,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.WellKnownTag,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax}})">
 <summary>
 Given a DocumentationCommentTriviaSyntax and the symbol, return the 
 full documentation comment text.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.GetFirstNameAttributeValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax,System.String,Microsoft.CodeAnalysis.VisualBasic.ERRID,Microsoft.CodeAnalysis.VisualBasic.ERRID)">
 <summary>
 Gets the value of the first 'name' attribute on the element, returns Nothing in case 
 the attribute was not found or has an invalid value, reports necessary diagnostics in 
 the latest case
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.GetSymbolName(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Return symbol text name the way Dev11 does it
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.IncludeElementExpander.RewriteMany(System.Xml.Linq.XNode[],System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <remarks>
 Rewrites nodes in <paramref name="nodes"/>, which Is a snapshot of nodes from the original document.
 We're mutating the tree as we rewrite, so it's important to grab a snapshot of the
 nodes that we're going to reparent before we enumerate them.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.WriteDocumentationCommentForMethod(Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol)">
 <returns> True, if the comment was written </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.VisitNamedType(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Generates the documentation comment for the type, writes it into 
 the writer
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.FormatComment(System.String)">
 <summary>
 Given the full text of a documentation comment, strip off the comment 
 punctuation (''') and add appropriate indentations.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.GetIndexOfFirstNonWhitespaceChar(System.String)">
 <summary>
 Given a string, find the index of the first non-whitespace char.
 </summary>
 <param name="str">The string to search</param>
 <returns>The index of the first non-whitespace char in the string</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.GetIndexOfFirstNonWhitespaceChar(System.String,System.Int32,System.Int32)">
 <summary>
 Find the first non-whitespace character in a given substring.
 </summary>
 <param name="str">The string to search</param>
 <param name="start">The start index</param>
 <param name="end">The last index (non-inclusive)</param>
 <returns>The index of the first non-whitespace char after index 
 start in the string up to, but not including the end index</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.TrimmedStringStartsWith(System.String,System.String)">
 <summary>
 Determine if the given string starts with the given prefix if whitespace
 is first trimmed from the beginning.
 </summary>
 <param name="str">The string to search</param>
 <param name="prefix">The prefix</param>
 <returns>true if "str.TrimStart().StartsWith(prefix)"</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.IndexOfNewLine(System.String,System.Int32,System.Int32@)">
 <summary>
 Given a string which may contain newline sequences, get the index of the first newline
 sequence beginning at the given starting index.
 </summary>
 <param name="str">The string to split.</param>
 <param name="start">The starting index within the string.</param>
 <param name="newLineLength">The length of the newline sequence discovered. 0 if the end of the string was reached, otherwise either 1 or 2 chars</param>
 <returns>The index of the start of the first newline sequence following the start index</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.WriteFormattedComment(System.String)">
 <summary>
 Given the full text of a single-line style documentation comment, for each line, strip off
 the comment punctuation (''') and flatten the text.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.GetDescription(System.Xml.XmlException)">
 <remarks>
 WORKAROUND:
 We're taking a dependency on the location and structure of a framework assembly resource.  This is not a robust solution.
 
 Possible alternatives:
 1) Polish our XML parser until it matches MSXML.  We don't want to reinvent the wheel.
 2) Build a map that lets us go from XML string positions back to source positions.  
 This is what the native compiler did, and it was a lot of work.  We'd also still need to modify the message.
 3) Do not report a diagnostic.  This is very unhelpful.
 4) Report a vague diagnostic (i.e. there's a problem somewhere in this doc comment).  This is relatively unhelpful.
 5) Always report the message in English, so that we can pull it apart without needing to mess with resource files.
 This engenders a lot of ill will.
 6) Report the exception message without modification and (optionally) include the text with respect to which the
 position is specified.  This looks amateurish.            
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.WriteDocumentationCommentXml(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,System.String,System.IO.Stream,Microsoft.CodeAnalysis.DiagnosticBag,System.Threading.CancellationToken,Microsoft.CodeAnalysis.SyntaxTree,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan})">
 <summary>
 Traverses the symbol table processing XML documentation comments and optionally writing them to a provided stream.
 </summary>
 <param name="compilation">Compilation that owns the symbol table.</param>
 <param name="assemblyName">Assembly name override, if specified. Otherwise the <see cref="P:Microsoft.CodeAnalysis.ISymbol.Name"/> of the source assembly is used.</param>
 <param name="xmlDocStream">Stream to which XML will be written, if specified.</param>
 <param name="diagnostics">Will be supplemented with documentation comment diagnostics.</param>
 <param name="cancellationToken">To stop traversing the symbol table early.</param>
 <param name="filterTree">Only report diagnostics from this syntax tree, if non-null.</param>
 <param name="filterSpanWithinTree">If <paramref name="filterTree"/> and filterSpanWithinTree is non-null, report diagnostics within this span in the <paramref name="filterTree"/>.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.GetDocumentationCommentXml(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Boolean,System.Globalization.CultureInfo,System.Threading.CancellationToken)">
 <summary>
 Gets the XML that would be written to the documentation comment file for this assembly.
 </summary>
 <param name="symbol">The symbol for which to retrieve documentation comments.</param>
 <param name="processIncludes">True to treat includes as semantically meaningful 
 (pull in contents from other files and bind crefs, etc).</param>
 <param name="cancellationToken">To stop traversing the symbol table early.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.DocumentationCommentWalker">
 <summary>
 Walks a DocumentationCommentTriviaSyntax, binding the semantically meaningful parts 
 to produce diagnostics and to replace source crefs with documentation comment IDs.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.DocumentationCommentWalker.GetSubstitutedText(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.DocumentationCommentTriviaSyntax,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.DocumentationCommentCompiler.WellKnownTag,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax}},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Given a DocumentationCommentTriviaSyntax, return the full text, but with
 documentation comment IDs substituted into crefs.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.s_myTemplateCache">
 <summary>
 most of time all compilation would use same MyTemplate. no reason to create (reparse) one for each compilation
 as long as its parse option is same
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._lazyAssemblySymbol">
 <summary>
 The SourceAssemblySymbol for this compilation. Do not access directly, use Assembly
 property instead. This field is lazily initialized by ReferenceManager,
 ReferenceManager.CacheLockObject must be locked while ReferenceManager "calculates" the
 value and assigns it, several threads must not perform duplicate "calculation"
 simultaneously.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._referenceManager">
 <summary>
 Holds onto data related to reference binding.
 The manager is shared among multiple compilations that we expect to have the same result of reference binding.
 In most cases this can be determined without performing the binding. If the compilation however contains a circular 
 metadata reference (a metadata reference that refers back to the compilation) we need to avoid sharing of the binding results.
 We do so by creating a new reference manager for such compilation. 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._options">
 <summary>
 The options passed to the constructor of the Compilation
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._lazyGlobalNamespace">
 <summary>
 The global namespace symbol. Lazily populated on first access.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._syntaxTrees">
 <summary>
 The syntax trees explicitly given to the compilation at creation, in ordinal order.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._lazyAllSyntaxTrees">
 <summary>
 The syntax trees of this compilation plus all 'hidden' trees 
 added to the compilation by compiler, e.g. Vb Core Runtime.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._rootNamespaces">
 <summary>
 A map between syntax trees and the root declarations in the declaration table.
 Incrementally updated between compilation versions when source changes are made.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._lazyImportInfos">
 <summary>
 Imports appearing in <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>s in this compilation.
 </summary>
 <remarks>
 Unlike in C#, we don't need to use a set because the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile"/> objects
 that record the imports are persisted.
 </remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._lazyClsComplianceDiagnostics">
 <summary>
 Cache the CLS diagnostics for the whole compilation so they aren't computed repeatedly.
 </summary>
 <remarks>
 NOTE: Presently, we do not cache the per-tree diagnostics.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.EmbeddedTreeAndDeclaration">
 <summary>
 A SyntaxTree and the associated RootSingleNamespaceDeclaration for an embedded
 syntax tree in the Compilation. Unlike the entries in m_rootNamespaces, the
 SyntaxTree here is lazy since the tree cannot be evaluated until the references
 have been resolved (as part of binding the source module), and at that point, the
 SyntaxTree may be Nothing if the embedded tree is not needed for the Compilation.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._declarationTable">
 <summary>
 The declaration table that holds onto declarations from source. Incrementally updated
 between compilation versions when source changes are made.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._anonymousTypeManager">
 <summary>
 Manages anonymous types declared in this compilation. Unifies types that are structurally equivalent.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._lazyEmbeddedSymbolManager">
 <summary>
 Manages automatically embedded content.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._lazyMyTemplate">
 <summary>
 MyTemplate automatically embedded from resource in the compiler.
 It doesn't feel like it should be managed by EmbeddedSymbolManager
 because MyTemplate is treated as user code, i.e. can be extended via
 partial declarations, doesn't require "on-demand" metadata generation, etc.
 
 SyntaxTree.Dummy means uninitialized.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._lazyEntryPoint">
 <summary>
 Contains the main method of this assembly, if there is one.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._lazyCompilationUnitCompletedTrees">
 <summary>
 The set of trees for which a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationUnitCompletedEvent"/> has been added to the queue.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._languageVersion">
 <summary>
 The common language version among the trees of the compilation.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.LanguageVersion">
 <summary>
 The language version that was used to parse the syntax trees of this compilation.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.MyTemplate">
 <summary>
 SyntaxTree of MyTemplate for the compilation. Settable for testing purposes only.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.Create(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions)">
 <summary>
 Create a new compilation from scratch.
 </summary>
 <param name="assemblyName">Simple assembly name.</param>
 <param name="syntaxTrees">The syntax trees with the source code for the new compilation.</param>
 <param name="references">The references for the new compilation.</param>
 <param name="options">The compiler options to use.</param>
 <returns>A new compilation.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.CreateScriptCompilation(System.String,Microsoft.CodeAnalysis.SyntaxTree,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions,Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,System.Type,System.Type)">
 <summary> 
 Creates a new compilation that can be used in scripting. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.Clone">
 <summary>
 Create a duplicate of this compilation with different symbol instances
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.WithAssemblyName(System.String)">
 <summary>
 Creates a new compilation with the specified name.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.WithReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
 <summary>
 Creates a new compilation with the specified references.
 </summary>
 <remarks>
 The new <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation"/> will query the given <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/> for the underlying 
 metadata as soon as the are needed. 
 
 The New compilation uses whatever metadata is currently being provided by the <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/>.
 E.g. if the current compilation references a metadata file that has changed since the creation of the compilation
 the New compilation is going to use the updated version, while the current compilation will be using the previous (it doesn't change).
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.WithScriptCompilationInfo(Microsoft.CodeAnalysis.VisualBasic.VisualBasicScriptCompilationInfo)">
 <summary>
 Returns a new compilation with the given compilation set as the previous submission. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.WithEventQueue(Microsoft.CodeAnalysis.Diagnostics.AsyncQueue{Microsoft.CodeAnalysis.Diagnostics.CompilationEvent})">
 <summary>
 Returns a new compilation with a given event queue.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.SyntaxTrees">
 <summary>
 Get a read-only list of the syntax trees that this compilation was created with.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.AllSyntaxTrees">
 <summary>
 Get a read-only list of the syntax trees that this compilation was created with PLUS
 the trees that were automatically added to it, i.e. Vb Core Runtime tree.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.ContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Is the passed in syntax tree in this compilation?
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.IncludeInternalXmlHelper">
 <summary>
 Returns True if the set of references contains those assemblies needed for XML
 literals.
 If those assemblies are included, we should include the InternalXmlHelper
 SyntaxTree in the Compilation so the helper methods are available for binding XML.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.CompareSourceLocations(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Location)">
 <summary>
 Compare two source locations, using their containing trees, and then by Span.First within a tree. 
 Can be used to get a total ordering on declarations, for example.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)">
 <summary>
 Gets the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol"/> or <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol"/> for a metadata reference used to create this compilation.
 </summary>
 <returns><see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol"/> or <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol"/> corresponding to the given reference or Nothing if there is none.</returns>
 <remarks>
 Uses object identity when comparing two references. 
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetMetadataReference(Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol)">
 <summary>
 Gets the <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/> that corresponds to the assembly symbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.EnableEnumArrayBlockInitialization">
 <summary>
 Determine if enum arrays can be initialized using block initialization.
 </summary>
 <returns>True if it's safe to use block initialization for enum arrays.</returns>
 <remarks>
 In NetFx 4.0, block array initializers do not work on all combinations of {32/64 X Debug/Retail} when array elements are enums.
 This is fixed in 4.5 thus enabling block array initialization for a very common case.
 We look for the presence of <see cref="F:System.Runtime.GCLatencyMode.SustainedLowLatency"/> which was introduced in .Net 4.5
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.Assembly">
 <summary>
 Gets the AssemblySymbol that represents the assembly being created.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.SourceModule">
 <summary>
 Get a ModuleSymbol that refers to the module being created by compiling all of the code. By
 getting the GlobalNamespace property of that module, all of the namespace and types defined in source code 
 can be obtained.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GlobalNamespace">
 <summary>
 Gets the merged root namespace that contains all namespaces and types defined in source code or in 
 referenced metadata, merged into a single namespace hierarchy. This namespace hierarchy is how the compiler
 binds types that are referenced in code.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.RootNamespace">
 <summary>
 Get the "root" or default namespace that all source types are declared inside. This may be the 
 global namespace or may be another namespace. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)">
 <summary>
 Given a namespace symbol, returns the corresponding namespace symbol with Compilation extent
 that refers to that namespace in this compilation. Returns Nothing if there is no corresponding 
 namespace. This should not occur if the namespace symbol came from an assembly referenced by this
 compilation. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.MemberImports">
 <summary>
 Returns the list of member imports that apply to all syntax trees in this compilation.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.AliasImports">
 <summary>
 Returns the list of alias imports that apply to all syntax trees in this compilation.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.ClassifyConversion(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
 <summary>
 Determine what kind of conversion, if any, there is between the types 
 "source" and "destination".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.ScriptClass">
 <summary>
 A symbol representing the implicit Script class. This is null if the class is not
 defined in the compilation.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.BindScriptClass">
 <summary>
 Resolves a symbol that represents script container (Script class). 
 Uses the full name of the container class stored in <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.ScriptClassName"/>  to find the symbol.
 </summary> 
 <returns>
 The Script class symbol or null if it is not defined.
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)">
 <summary>
 Get symbol for predefined type from Cor Library referenced by this compilation.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
 <summary>
 Get symbol for predefined type member from Cor Library referenced by this compilation.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetTypeByMetadataName(System.String)">
 <summary>
 Lookup a type within the compilation's assembly and all referenced assemblies
 using its canonical CLR metadata name (names are compared case-sensitively).
 </summary>
 <param name="fullyQualifiedMetadataName">
 </param>
 <returns>
 Symbol for the type or null if type cannot be found or is ambiguous. 
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
<summary> 
 Get a fresh SemanticModel.  Note that each invocation gets a fresh SemanticModel, each of
 which has a cache.  Therefore, one effectively clears the cache by discarding the
 SemanticModel.
</summary> 
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetDiagnostics(System.Threading.CancellationToken)">
 <summary>
 Get all diagnostics for the entire compilation. This includes diagnostics from parsing, declarations, and
 the bodies of methods. Getting all the diagnostics is potentially a length operations, as it requires parsing and
 compiling all the code. The set of diagnostics is not caches, so each call to this method will recompile all
 methods.
 </summary>
 <param name="cancellationToken">Cancellation token to allow cancelling the operation.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetParseDiagnostics(System.Threading.CancellationToken)">
 <summary>
 Get parse diagnostics for the entire compilation. This includes diagnostics from parsing BUT NOT from declarations and
 the bodies of methods or initializers. The set of parse diagnostics is cached, so calling this method a second time
 should be fast.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
 <summary>
 Get declarations diagnostics for the entire compilation. This includes diagnostics from declarations, BUT NOT
 the bodies of methods or initializers. The set of declaration diagnostics is cached, so calling this method a second time
 should be fast.
 </summary>
 <param name="cancellationToken">Cancellation token to allow cancelling the operation.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetMethodBodyDiagnostics(System.Threading.CancellationToken)">
 <summary>
 Get method body diagnostics for the entire compilation. This includes diagnostics only from 
 the bodies of methods and initializers. These diagnostics are NOT cached, so calling this method a second time
 repeats significant work.
 </summary>
 <param name="cancellationToken">Cancellation token to allow cancelling the operation.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetDiagnostics(Microsoft.CodeAnalysis.CompilationStage,System.Boolean,System.Threading.CancellationToken)">
 <summary>
 Get all errors in the compilation, up through the given compilation stage. Note that this may
 require significant work by the compiler, as all source code must be compiled to the given
 level in order to get the errors. Errors on Options should be inspected by the user prior to constructing the compilation.
 </summary>
 <returns>
 Returns all errors. The errors are not sorted in any particular order, and the client
 should sort the errors as desired.
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.ContainsSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
 <summary>
 Return true if there Is a source declaration symbol name that meets given predicate.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
 <summary>
 Return source declaration symbols whose name meets given predicate.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.ReferenceManager">
 <summary>
 ReferenceManager encapsulates functionality to create an underlying SourceAssemblySymbol 
 (with underlying ModuleSymbols) for Compilation and AssemblySymbols for referenced assemblies 
 (with underlying ModuleSymbols) all properly linked together based on reference resolution 
 between them.
 
 ReferenceManager is also responsible for reuse of metadata readers for imported modules and 
 assemblies as well as existing AssemblySymbols for referenced assemblies. In order to do that, 
 it maintains global cache for metadata readers and AssemblySymbols associated with them. 
 The cache uses WeakReferences to refer to the metadata readers and AssemblySymbols to allow 
 memory and resources being reclaimed once they are no longer used. The tricky part about reusing 
 existing AssemblySymbols is to find a set of AssemblySymbols that are created for the referenced 
 assemblies, which (the AssemblySymbols from the set) are linked in a way, consistent with the 
 reference resolution between the referenced assemblies.
 
 When existing Compilation is used as a metadata reference, there are scenarios when its underlying 
 SourceAssemblySymbol cannot be used to provide symbols in context of the new Compilation. Consider 
 classic multi-targeting scenario: compilation C1 references v1 of Lib.dll and compilation C2 
 references C1 and v2 of Lib.dll. In this case, SourceAssemblySymbol for C1 is linked to AssemblySymbol 
 for v1 of Lib.dll. However, given the set of references for C2, the same reference for C1 should be 
 resolved against v2 of Lib.dll. In other words, in context of C2, all types from v1 of Lib.dll 
 leaking through C1 (through method signatures, etc.) must be retargeted to the types from v2 of Lib.dll.
 In this case, ReferenceManager creates a special RetargetingAssemblySymbol for C1, which is responsible 
 for the type retargeting. The RetargetingAssemblySymbols could also be reused for different 
 Compilations, ReferenceManager maintains a cache of RetargetingAssemblySymbols (WeakReferences) for each 
 Compilation.
 
 The only public entry point of this class is CreateSourceAssembly() method.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.ReferenceManager.WeakIdentityPropertiesEquivalent(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
 <summary>
 VB allows two weak assembly references of the same simple name be passed to a compilation 
 as long as their versions are different. It ignores culture.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.ReferenceManager.CreatePEAssemblyForAssemblyMetadata(Microsoft.CodeAnalysis.AssemblyMetadata,Microsoft.CodeAnalysis.MetadataImportOptions,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity}@)">
  <summary>
  Creates a <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAssemblySymbol"/> from specified metadata. 
  </summary>
  <remarks>
  Used by EnC to create symbols for emit baseline. The PE symbols are used by <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Emit.VisualBasicSymbolMatcher"/>.
  
  The assembly references listed in the metadata AssemblyRef table are matched to the resolved references 
  stored on this <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.ReferenceManager"/>. We assume that the dependencies of the baseline metadata are 
  the same as the dependencies of the current compilation. This is not exactly true when the dependencies use 
  time-based versioning pattern, e.g. AssemblyVersion("1.0.*"). In that case we assume only the version
  changed And nothing else.
  
  Each AssemblyRef is matched against the assembly identities using an exact equality comparison modulo version. 
  AssemblyRef with lower version in metadata is matched to a PE assembly symbol with the higher version 
  (provided that the assembly name, culture, PKT And flags are the same) if there is no symbol with the exactly matching version. 
  If there are multiple symbols with higher versions selects the one with the minimal version among them.
  
  Matching to a higher version is necessary to support EnC for projects whose P2P dependencies use time-based versioning pattern. 
  The versions of the dependent projects seen from the IDE will be higher than 
  the one written in the metadata at the time their respective baselines are built.
  
  No other unification or further resolution is performed.
  </remarks>
 <param name="metadata"></param>
 <param name="importOptions"></param>
 <param name="assemblyReferenceIdentityMap">
 A map of the PE assembly symbol identities to the identities of the original metadata AssemblyRefs.
 This map will be used in emit when serializing AssemblyRef table of the delta. For the delta to be compatible with
 the original metadata we need to map the identities of the PE assembly symbols back to the original AssemblyRefs (if different).
 In other words, we pretend that the versions of the dependencies haven't changed.
 </param>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.ReferenceManager.AssemblyDataForFile.CachedSymbols">
 <summary>
 Guarded by <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard"/>.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.ReferenceManager.AssemblyDataForFile._compilationImportOptions">
 <summary>
 Import options of the compilation being built.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.ReferenceManager.IsSourceAssemblySymbolCreated(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 For testing purposes only.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.ReferenceManager.IsReferenceManagerInitialized(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation)">
 <summary>
 For testing purposes only.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._lazyWellKnownTypes">
 <summary>
 An array of cached well known types available for use in this Compilation.
 Lazily filled by GetWellKnownType method.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation._lazyWellKnownTypeMembers">
 <summary>
 Lazy cache of well known members.
 Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.TrySynthesizeAttribute(Microsoft.CodeAnalysis.WellKnownMember,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TypedConstant},System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.WellKnownMember,Microsoft.CodeAnalysis.TypedConstant}})">
 <summary>
 Synthesizes a custom attribute. 
 Returns null if the <paramref name="constructor"/> symbol is missing,
 or any of the members in <paramref name="namedArguments" /> are missing.
 The attribute is synthesized only if present.
 </summary>
 <param name="namedArguments">
 Takes a list of pairs of well-known members and constants. The constants
 will be passed to the field/property referenced by the well-known member.
 If the well-known member does Not exist in the compilation then no attribute
 will be synthesized.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation.GetWellKnownTypeMember(Microsoft.CodeAnalysis.WellKnownMember)">
 <summary>
 Lookup member declaration in well known type used by this Compilation.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo">
 <summary>
  Structure containing all semantic information about a for each statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo.GetEnumeratorMethod">
 <summary>
 Gets the &quot;GetEnumerator&quot; method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo.MoveNextMethod">
 <summary>
 Gets the &quot;MoveNext&quot; method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo.CurrentProperty">
 <summary>
 Gets the &quot;Current&quot; property.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo.DisposeMethod">
 <summary>
 Gets the &quot;Dispose&quot; method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo.ElementType">
 <summary>
 The intermediate type to which the output of the <see cref="P:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo.CurrentProperty"/> is converted
 before being converted to the iteration variable type.
 </summary>
 <remarks>
 As you might hope, for an array, it is the element type of the array.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo.ElementConversion">
 <summary>
 The conversion from the <see cref="P:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo.ElementType"/> to the iteration variable type.
 </summary>
 <remarks>
 May be user-defined.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo.CurrentConversion">
 <summary>
 The conversion from the type of the <see cref="P:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo.CurrentProperty"/> to the <see cref="P:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo.ElementType"/>.
 </summary>
 <remarks>
 Frequently the identity conversion.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo.#ctor(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Conversion,Microsoft.CodeAnalysis.VisualBasic.Conversion)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo" /> structure.
 </summary>
 <param name="getEnumeratorMethod">The GetEnumerator method.</param>
 <param name="moveNextMethod">The MoveNext method.</param>
 <param name="currentProperty">The Current property.</param>
 <param name="disposeMethod">The Dispose method.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LexicalOrderSymbolComparer">
 <summary>
 This is an implementation of a special symbol comparer, which is supposed to be used  for 
 sorting original definition symbols (explicitly or explicitly declared in source  within the same 
 container) in lexical order of their declarations. It will not work on  anything that uses non-source locations. 
 </summary>        
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.MemberResolutionKind">
 <summary>
 Indicates whether the compiler accepted or rejected the method during overload resolution.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.MemberResolutionResult`1">
 <summary>
 Represents the results of overload resolution for a single method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.MemberResolutionResult`1.Member">
 <summary>
 The method or property considered during overload resolution.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.MemberResolutionResult`1.Resolution">
 <summary>
 Indicates why the compiler accepted or rejected the method during overload resolution.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.MemberResolutionResult`1.IsValid">
 <summary>
 Returns true if the compiler accepted this method as the sole correct result of overload resolution.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.MemberResolutionResult`1.IsExpandedParamArrayForm">
 <summary>
 Returns true if the method is considered in its expanded param array form.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.OverloadResolutionResult`1">
 <summary>
 Summarizes the results of an overload resolution analysis. Describes whether overload resolution 
 succeeded, and which method was selected if overload resolution succeeded.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.OverloadResolutionResult`1.Succeeded">
 <summary>
 True if overload resolution successfully selected a single best method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.OverloadResolutionResult`1.ValidResult">
 <summary>
 If overload resolution successfully selected a single best method, returns information
 about that method. Otherwise returns Nothing.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.OverloadResolutionResult`1.BestResult">
 <summary>
 If there was a method that overload resolution considered better than all others,
 returns information about that method. A method may be returned even if that method was
 not considered a successful overload resolution, as long as it was better than any other
 potential method considered.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.OverloadResolutionResult`1.Results">
 <summary>
 Returns information about each method that was considered during overload resolution,
 and what the results of overload resolution were for that method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicPreprocessingSymbolInfo.Symbol">
 <summary>
 The symbol that was referred to by the identifier, if any. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicPreprocessingSymbolInfo.ConstantValue">
 <summary>
 Returns the constant value associated with the symbol, if any.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.CollectionRangeVariableSymbolInfo.ToQueryableCollectionConversion">
 <summary>
 Optional AsQueryable/AsEnumerable/Cast(Of Object) method used 
 to "convert" <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax.Expression"/> to queryable
 collection.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.CollectionRangeVariableSymbolInfo.AsClauseConversion">
 <summary>
 Optional Select method to handle AsClause.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.CollectionRangeVariableSymbolInfo.SelectMany">
 <summary>
 SelectMany method for <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax"/>, which is not the first
 <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax"/> in a <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax"/>, and is not the first 
 <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax"/> in <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax"/>.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.AggregateClauseSymbolInfo.Select1">
 <summary>
 The first of the two optional Select methods associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax"/>.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.AggregateClauseSymbolInfo.Select2">
 <summary>
 The second of the two optional Select methods associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax"/>.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel">
 <summary>
 Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,
 an instance is obtained by a call to Compilation.GetBinding. 
 </summary>
 <remarks>
 <para>An instance of SemanticModel caches local symbols and semantic information. Thus, it
 is much more efficient to use a single instance of SemanticModel when asking multiple
 questions about a syntax tree, because information from the first question may be reused.
 This also means that holding onto an instance of SemanticModel for a long time may keep a
 significant amount of memory from being garbage collected.
 </para>
 <para>
 When an answer is a named symbol that is reachable by traversing from the root of the symbol
 table, (that is, from an AssemblySymbol of the Compilation), that symbol will be returned
 (i.e. the returned value will be reference-equal to one reachable from the root of the
 symbol table). Symbols representing entities without names (e.g. array-of-int) may or may
 not exhibit reference equality. However, some named symbols (such as local variables) are
 not reachable from the root. These symbols are visible as answers to semantic questions.
 When the same SemanticModel object is used, the answers exhibit reference-equality.  
 </para>
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetCollectionRangeVariableSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns information about methods associated with CollectionRangeVariableSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetAggregateClauseSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns information about methods associated with AggregateClauseSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)">
 <summary>
 DistinctClauseSyntax -       Returns Distinct method associated with DistinctClauseSyntax.
 
 WhereClauseSyntax -          Returns Where method associated with WhereClauseSyntax.
 
 PartitionWhileClauseSyntax - Returns TakeWhile/SkipWhile method associated with PartitionWhileClauseSyntax.
 
 PartitionClauseSyntax -      Returns Take/Skip method associated with PartitionClauseSyntax.
 
 GroupByClauseSyntax -        Returns GroupBy method associated with GroupByClauseSyntax.
 
 JoinClauseSyntax -           Returns Join/GroupJoin method associated with JoinClauseSyntax/GroupJoinClauseSyntax.
 
 SelectClauseSyntax -         Returns Select method associated with SelectClauseSyntax, if needed.
 
 FromClauseSyntax -           Returns Select method associated with FromClauseSyntax, which has only one 
                              CollectionRangeVariableSyntax and is the only query clause within 
                              QueryExpressionSyntax. NotNeeded SymbolInfo otherwise. 
                              The method call is injected by the compiler to make sure that query is translated to at 
                              least one method call. 
 
 LetClauseSyntax -            NotNeeded SymbolInfo.
 
 OrderByClauseSyntax -        NotNeeded SymbolInfo.
 
 AggregateClauseSyntax -      Empty SymbolInfo. GetAggregateClauseInfo should be used instead.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns Select method associated with ExpressionRangeVariableSyntax within a LetClauseSyntax, if needed.
 NotNeeded SymbolInfo otherwise.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns aggregate function associated with FunctionAggregationSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns OrderBy/OrderByDescending/ThenBy/ThenByDescending method associated with OrderingSyntax.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.Compilation">
 <summary> 
 The compilation associated with this binding.
 </summary> 
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.Root">
 <summary> 
 The root node of the syntax tree that this binding is based on.
 </summary> 
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetExpressionSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.SymbolInfoOptions,System.Threading.CancellationToken)">
 <summary>
 Gets symbol information about an expression syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetCollectionInitializerAddSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets symbol information about the 'Add' method corresponding to an expression syntax <paramref name="node"/> within collection initializer.
 This is the worker function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called and the <paramref name="node"/> is in the right place in the syntax tree.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetAttributeSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets symbol information about an attribute syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetExpressionTypeInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets type information about an expression syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetAttributeTypeInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets type information about an attribute syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetExpressionConstantValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets constant value information about an expression syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetExpressionMemberGroup(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets member group information about an expression syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetAttributeMemberGroup(Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets member group information about an attribute syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetCrefReferenceSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.SymbolInfoOptions,System.Threading.CancellationToken)">
 <summary>
 Gets symbol information about an cref reference syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns what symbol(s), if any, the given expression syntax bound to in the program.
 
 An AliasSymbol will never be returned by this method. What the alias refers to will be
 returned instead. To get information about aliases, call GetAliasInfo.
 
 If binding the type name C in the expression "new C(...)" the actual constructor bound to
 will be returned (or all constructor if overload resolution failed). This occurs as long as C
 unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple
 types, or C binds to a static class, then type(s) are returned.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax 
 within <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax.Initializer"/>.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns what symbol(s), if any, the given cref reference syntax bound to in the documentation comment.
 
 An AliasSymbol will never be returned by this method. What the alias refers to will be
 returned instead.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSpeculativeSymbolInfo(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
 <summary>
 Binds the expression in the context of the specified location and get semantic
 information such as type, symbols and diagnostics. This method is used to get semantic
 information about an expression that did not actually appear in the source code.
 </summary>
 <param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
 <param name="expression">A syntax node that represents a parsed expression. This syntax
 node need not and typically does not appear in the source code referred to  SemanticModel
 instance.</param>
 <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
 or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
 expression should derive from TypeSyntax.</param>
 <returns>The semantic information for the topmost node of the expression.</returns>
 <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
 appeared by itself somewhere within the scope that encloses "position".</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSpeculativeSymbolInfo(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax)">
 <summary>
 Bind the attribute in the context of the specified location and get semantic information
 such as type, symbols and diagnostics. This method is used to get semantic information about an attribute
 that did not actually appear in the source code.
 </summary>
 <param name="position">A character position used to identify a declaration scope and accessibility. This
 character position must be within the FullSpan of the Root syntax node in this SemanticModel. In order to obtain
 the correct scoping rules for the attribute, position should be the Start position of the Span of the symbol that
 the attribute is being applied to.
 </param>
 <param name="attribute">A syntax node that represents a parsed attribute. This syntax node
 need not and typically does not appear in the source code referred to SemanticModel instance.</param>
 <returns>The semantic information for the topmost node of the attribute.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetTypeInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets type information about an expression.
 </summary>
 <param name="expression">The syntax node to get type information for.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSpeculativeTypeInfo(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
 <summary>
 Binds the expression in the context of the specified location and gets type information.
 This method is used to get type information about an expression that did not actually
 appear in the source code.
 </summary>
 <param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
 <param name="expression">A syntax node that represents a parsed expression. This syntax
 node need not and typically does not appear in the source code referred to by the
 SemanticModel instance.</param>
 <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
 or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
 expression should derive from TypeSyntax.</param>
 <returns>The type information for the topmost node of the expression.</returns>
 <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
 appeared by itself somewhere within the scope that encloses "position".</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetConversion(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
 <summary>
 Gets the conversion that occurred between the expression's type and type implied by the expression's context.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSpeculativeConversion(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
 <summary>
 Gets the conversion that occurred between the expression's type and type implied by the expression's context.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSpeculativeConstantValue(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Binds the expression in the context of the specified location and gets constant value information. 
 This method is used to get information about an expression that did not actually appear in the source code.
 </summary>
 <param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
 <param name="expression">A syntax node that represents a parsed expression. This syntax
 node need not and typically does not appear in the source code referred to by SemanticModel
 instance.</param>
 <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
 appeared by itself somewhere within the scope that encloses "position".</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetAliasInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)">
 <summary>
 If "nameSyntax" resolves to an alias name, return the AliasSymbol corresponding
 to A. Otherwise return null.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSpeculativeAliasInfo(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
 <summary>
 Binds the name in the context of the specified location and sees if it resolves to an
 alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
 </summary>
 <param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
 <param name="nameSyntax">A syntax node that represents a name. This syntax
 node need not and typically does not appear in the source code referred to by the
 SemanticModel instance.</param>
 <param name="bindingOption">Indicates whether to binding the name as a full expression,
 or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
 expression should derive from TypeSyntax.</param>
 <remarks>The passed in name is interpreted as a stand-alone name, as if it
 appeared by itself somewhere within the scope that encloses "position".</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetEnclosingBinder(System.Int32)">
 <summary>
 Gets the binder that encloses the position. See comment on LookupSymbols for how
 positions are interpreted.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.MakeValueIfPossible(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.BoundNode)">
 <summary>
 When doing speculative binding, we don't have any context information about expressions or the
 context that is expected. We try to interpret as a value, but
 only if it doesn't cause additional errors (indicating that it wasn't value to interpret it
 that way). This should get us the most "liberal" interpretation
 for semantic information.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSpeculativelyBoundAttribute(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder@)">
 <summary>
 Bind the given attribute speculatively at the given position, and return back
 the resulting bound node. May return null in some error cases.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetSpeculativelyBoundAttributeSummary(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder@)">
 <summary>
 Bind the given attribute speculatively at the given position, and return back
 the resulting bound node summary. May return null in some error cases.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.AdjustSymbolsForObjectCreation(Microsoft.CodeAnalysis.VisualBasic.BoundNodeSummary,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol}@,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.VisualBasic.LookupResultKind@)">
 <summary>
 In cases where we are binding C in "[C(...)]", the bound nodes return the symbol for the type. However, we've
 decided that we want this case to return the constructor of the type instead (based on the SemanticInfoOptions. This 
 affects only attributes. This method checks for this situation and adjusts the syntax and method group.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)">
 <summary>
 Gets the available named symbols in the context of the specified location And optional container. Only
 symbols that are accessible And visible from the given location are returned.
 </summary>
 <param name="position">The character position for determining the enclosing declaration scope And
 accessibility.</param>
 <param name="container">The container to search for symbols within. If null then the enclosing declaration
 scope around position Is used.</param>
 <param name="name">The name of the symbol to find. If null Is specified then symbols
 with any names are returned.</param>
 <param name="includeReducedExtensionMethods">Consider (reduced) extension methods.</param>
 <returns>A list of symbols that were found. If no symbols were found, an empty list Is returned.</returns>
 <remarks>
 The "position" Is used to determine what variables are visible And accessible. Even if "container" Is
 specified, the "position" location Is significant for determining which members of "containing" are
 accessible. 
 
 Labels are Not considered (see <see cref="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.LookupLabels(System.Int32,System.String)"/>).
 
 Non-reduced extension methods are considered regardless of the value of <paramref name="includeReducedExtensionMethods"/>.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.LookupBaseMembers(System.Int32,System.String)">
 <summary>
 Gets the available base type members in the context of the specified location.  Akin to
 calling <see cref="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.LookupSymbols(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol,System.String,Microsoft.CodeAnalysis.AbstractLookupSymbolsInfo{Microsoft.CodeAnalysis.VisualBasic.Symbol}.IArityEnumerable,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbol})"/> with the container set to the immediate base type of
 the type in which <paramref name="position"/> occurs.  However, the accessibility rules
 are different: protected members of the base type will be visible.
 
 Consider the following example:
 
   Public Class Base
       Protected Sub M()
       End Sub
   End Class
   
   Public Class Derived : Inherits Base
       Sub Test(b as Base)
           b.M() ' Error - cannot access protected member.
           MyBase.M()
       End Sub
   End Class
 
 Protected members of an instance of another type are only accessible if the instance is known
 to be "this" instance (as indicated by the "MyBase" keyword).
 </summary>
 <param name="position">The character position for determining the enclosing declaration scope and
 accessibility.</param>
 <param name="name">The name of the symbol to find. If null is specified then symbols
 with any names are returned.</param>
 <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
 <remarks>
 The "position" is used to determine what variables are visible and accessible.
 
 Non-reduced extension methods are considered, but reduced extension methods are not.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)">
 <summary>
 Gets the available named static member symbols in the context of the specified location And optional container.
 Only members that are accessible And visible from the given location are returned.
 
 Non-reduced extension methods are considered, since they are static methods.
 </summary>
 <param name="position">The character position for determining the enclosing declaration scope And
 accessibility.</param>
 <param name="container">The container to search for symbols within. If null then the enclosing declaration
 scope around position Is used.</param>
 <param name="name">The name of the symbol to find. If null Is specified then symbols
 with any names are returned.</param>
 <returns>A list of symbols that were found. If no symbols were found, an empty list Is returned.</returns>
 <remarks>
 The "position" Is used to determine what variables are visible And accessible. Even if "container" Is
 specified, the "position" location Is significant for determining which members of "containing" are
 accessible. 
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)">
 <summary>
 Gets the available named namespace And type symbols in the context of the specified location And optional container.
 Only members that are accessible And visible from the given location are returned.
 </summary>
 <param name="position">The character position for determining the enclosing declaration scope And
 accessibility.</param>
 <param name="container">The container to search for symbols within. If null then the enclosing declaration
 scope around position Is used.</param>
 <param name="name">The name of the symbol to find. If null Is specified then symbols
 with any names are returned.</param>
 <returns>A list of symbols that were found. If no symbols were found, an empty list Is returned.</returns>
 <remarks>
 The "position" Is used to determine what variables are visible And accessible. Even if "container" Is
 specified, the "position" location Is significant for determining which members of "containing" are
 accessible. 
 
 Does Not return INamespaceOrTypeSymbol, because there could be aliases.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.LookupLabels(System.Int32,System.String)">
 <summary>
 Gets the available named label symbols in the context of the specified location And optional container.
 Only members that are accessible And visible from the given location are returned.
 </summary>
 <param name="position">The character position for determining the enclosing declaration scope And
 accessibility.</param>
 <param name="name">The name of the symbol to find. If null Is specified then symbols
 with any names are returned.</param>
 <returns>A list of symbols that were found. If no symbols were found, an empty list Is returned.</returns>
 <remarks>
 The "position" Is used to determine what variables are visible And accessible. Even if "container" Is
 specified, the "position" location Is significant for determining which members of "containing" are
 accessible. 
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.LookupSymbolsInternal(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol,System.String,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,System.Boolean)">
 <summary>
 Gets the available named symbols in the context of the specified location and optional
 container. Only symbols that are accessible and visible from the given location are
 returned.
 </summary>
 <param name="position">The character position for determining the enclosing declaration
 scope and accessibility.</param>
 <param name="container">The container to search for symbols within. If null then the
 enclosing declaration scope around position is used.</param>
 <param name="name">The name of the symbol to find. If null is specified then symbols
 with any names are returned.</param>
 <param name="options">Additional options that affect the lookup process.</param>
 <param name="useBaseReferenceAccessibility">Ignore 'throughType' in accessibility checking. 
 Used in checking accessibility of symbols accessed via 'MyBase' or 'base'.</param>
 <returns>A list of symbols that were found. If no symbols were found, an empty list is
 returned.</returns>
 <remarks>
 The "position" is used to determine what variables are visible and accessible. Even if
 "container" is specified, the "position" location is significant for determining which
 members of "containing" are accessible. 
 
 Locations are character locations, just as used as the Syntax APIs such as FindToken, or 
 returned from the Span property on tokens and syntax node.
 
 The text of the program is divided into scopes, which nest but don't otherwise
 intersect. When doing an operation such as LookupSymbols, the code first determines the
 smallest scope containing the position, and from there all containing scopes. 
 
 Scopes that span an entire block statement start at the beginning of the first token of 
 the block header, and end immediately before the statement terminator token following
 the end statement of the block. If the end statement of the block is missing, it ends
 immediately before the next token. Examples of these include members and type parameters
 of a type, type parameters of a method, and variables declared in a For statement.
 
 Scopes that span the interior of a block statement start at the statement terminator of 
 the block header statement, and end immediately before the first token of the end
 statement of the block. If the end statement of the block is missing, it ends
 immediately before the next statement. Examples of these include local variables, method
 parameters, and members of a namespace.
 
 Scopes of variables declared in a single-line If statement start at the beginning of the
 "Then" token, and end immediately before the Else token or statement terminator. 
 
 Scopes of variables declared in the Else part of a single-line If start at the beginning
 of the "Else" token, and end immediately before the statement terminator.
 
 Some specialized binding rules are in place for a single statement, like Imports or
 Inherits. These specialized binding rules begin at the start of the first token of the
 statement, and end immediately before the statement terminator of that statement.
 
 In all of the above, the "start" means the start of a token without considering leading
 trivia. In other words, Span.Start, not FullSpan.Start. With the exception of
 documentation comments, all scopes begin at the start of a token, and end immediately
 before the start of a token.
 
 The scope of the default namespace, and all symbols introduced via Imports statements,
 is the entire file.
 
 Positions within a documentation comment that is correctly attached to a symbol take on
 the binding scope of that symbol. 
 </remarks>
 <exception cref="T:System.ArgumentException">Throws an argument exception if the passed lookup options are invalid.</exception>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.AddLookupSymbolsInfo(System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.LookupOptions)">
 <summary>
 Gets the names of the available named symbols in the context of the specified location
 and optional container. Only symbols that are accessible and visible from the given
 location are returned.
 </summary>
 <param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
 <param name="container">The container to search for symbols within. If null then the
 enclosing declaration scope around position is used.</param>
 <param name="options">Additional options that affect the lookup process.</param>
 <remarks>
 The "position" is used to determine what variables are visible and accessible. Even if
 "container" is specified, the "position" location is significant for determining which
 members of "containing" are accessible.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.IsAccessible(System.Int32,Microsoft.CodeAnalysis.ISymbol)">
 <summary>
 Determines if the symbol is accessible from the specified location.
 </summary>
 <param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
 <param name="symbol">The symbol that we are checking to see if it accessible.</param>
 <returns>
 True if "symbol is accessible, false otherwise.</returns>
 <remarks>
 This method only checks accessibility from the point of view of the accessibility
 modifiers on symbol and its containing types. Even if true is returned, the given symbol
 may not be able to be referenced for other reasons, such as name hiding.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.AnalyzeControlFlow(Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)">
 <summary>
 Analyze control-flow within a part of a method body.
 </summary>
 <param name="firstStatement">The first statement to be included in the analysis.</param>
 <param name="lastStatement">The last statement to be included in the analysis.</param>
 <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
 <exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.AnalyzeControlFlow(Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)">
 <summary>
 Analyze control-flow within a part of a method body.
 </summary>
 <param name="statement">The statement to be included in the analysis.</param>
 <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Analyze data-flow within an expression. 
 </summary>
 <param name="expression">The expression within the associated SyntaxTree to analyze.</param>
 <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)">
 <summary>
 Analyze data-flow within a set of contiguous statements.
 </summary>
 <param name="firstStatement">The first statement to be included in the analysis.</param>
 <param name="lastStatement">The last statement to be included in the analysis.</param>
 <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
 <exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)">
 <summary>
 Analyze data-flow within a statement.
 </summary>
 <param name="statement">The statement to be included in the analysis.</param>
 <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.TryGetSpeculativeSemanticModelForMethodBody(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
 <summary>
 Get a SemanticModel object that is associated with a method body that did not appear in this source code.
 Given <paramref name="position"/> must lie within an existing method body of the Root syntax node for this SemanticModel.
 Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
 </summary>
 <param name="position">A character position used to identify a declaration scope and accessibility. This
 character position must be within the FullSpan of the Root syntax node in this SemanticModel and must be
 within the FullSpan of a Method body within the Root syntax node.</param>
 <param name="method">A syntax node that represents a parsed method declaration. This method should not be
 present in the syntax tree associated with this object, but must have identical signature to the method containing
 the given <paramref name="position"/> in this SemanticModel.</param>
 <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
 information associated with syntax nodes within <paramref name="method"/>.</param>
 <returns>Flag indicating whether a speculative semantic model was created.</returns>
 <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="method"/> node is contained any SyntaxTree in the current Compilation.</exception>
 <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="method"/> is null.</exception>
 <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is True.
 Chaining of speculative semantic model is not supported.</exception>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
 <summary>
 Get a SemanticModel object that is associated with a range argument syntax that did not appear in
 this source code. This can be used to get detailed semantic information about sub-parts
 of this node that did not appear in source code. 
 </summary>
 <param name="position">A character position used to identify a declaration scope and accessibility. This
 character position must be within the FullSpan of the Root syntax node in this SemanticModel.
 </param>
 <param name="rangeArgument">A syntax node that represents a parsed RangeArgumentSyntax node. This node should not be
 present in the syntax tree associated with this object.</param>
 <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
 information associated with syntax nodes within <paramref name="rangeArgument"/>.</param>
 <returns>Flag indicating whether a speculative semantic model was created.</returns>
 <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="rangeArgument"/> node is contained any SyntaxTree in the current Compilation.</exception>
 <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="rangeArgument"/> is null.</exception>
 <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is True.
 Chaining of speculative semantic model is not supported.</exception>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
 <summary>
 Get a SemanticModel object that is associated with an executable statement that did not appear in
 this source code. This can be used to get detailed semantic information about sub-parts
 of a statement that did not appear in source code. 
 </summary>
 <param name="position">A character position used to identify a declaration scope and accessibility. This
 character position must be within the FullSpan of the Root syntax node in this SemanticModel.</param>
 <param name="statement">A syntax node that represents a parsed statement. This statement should not be
 present in the syntax tree associated with this object.</param>
 <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
 information associated with syntax nodes within <paramref name="statement"/>.</param>
 <returns>Flag indicating whether a speculative semantic model was created.</returns>
 <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="statement"/> node is contained any SyntaxTree in the current Compilation.</exception>
 <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="statement"/> is null.</exception>
 <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is True.
 Chaining of speculative semantic model is not supported.</exception>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
 <summary>
 Get a SemanticModel object that is associated with an initializer that did not appear in
 this source code. This can be used to get detailed semantic information about sub-parts
 of a field initializer, property initializer or default parameter value that did not appear in source code.
 </summary>
 <param name="position">A character position used to identify a declaration scope and accessibility. This
 character position must be within the FullSpan of the Root syntax node in this SemanticModel.
 </param>
 <param name="initializer">A syntax node that represents a parsed initializer. This initializer should not be
 present in the syntax tree associated with this object.</param>
 <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
 information associated with syntax nodes within <paramref name="initializer"/>.</param>
 <returns>Flag indicating whether a speculative semantic model was created.</returns>
 <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="initializer"/> node is contained any SyntaxTree in the current Compilation.</exception>
 <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="initializer"/> is null.</exception>
 <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is True.
 Chaining of speculative semantic model is not supported.</exception>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
 <summary>
 Get a SemanticModel object that is associated with an attribute that did not appear in
 this source code. This can be used to get detailed semantic information about sub-parts
 of an attribute that did not appear in source code. 
 </summary>
 <param name="position">A character position used to identify a declaration scope and accessibility. This
 character position must be within the FullSpan of the Root syntax node in this SemanticModel.</param>
 <param name="attribute">A syntax node that represents a parsed attribute. This attribute should not be
 present in the syntax tree associated with this object.</param>
 <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
 information associated with syntax nodes within <paramref name="attribute"/>.</param>
 <returns>Flag indicating whether a speculative semantic model was created.</returns>
 <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="attribute"/> node is contained any SyntaxTree in the current Compilation.</exception>
 <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="attribute"/> is null.</exception>
 <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is True.
 Chaining of speculative semantic model is not supported.</exception>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
 <summary>
 Get a SemanticModel object that is associated with a type syntax that did not appear in
 this source code. This can be used to get detailed semantic information about sub-parts
 of a type syntax that did not appear in source code. 
 </summary>
 <param name="position">A character position used to identify a declaration scope and accessibility. This
 character position must be within the FullSpan of the Root syntax node in this SemanticModel.
 </param>
 <param name="type">A syntax node that represents a parsed type syntax. This expression should not be
 present in the syntax tree associated with this object.</param>
 <param name="bindingOption">Indicates whether to bind the expression as a full expression,
 or as a type or namespace.</param>
 <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
 information associated with syntax nodes within <paramref name="type"/>.</param>
 <returns>Flag indicating whether a speculative semantic model was created.</returns>
 <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="type"/> node is contained any SyntaxTree in the current Compilation.</exception>
 <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is True.
 Chaining of speculative semantic model is not supported.</exception>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.ParentModel">
 <summary>
 If this is a speculative semantic model, then returns its parent semantic model.
 Otherwise, returns null.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.ClassifyConversion(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol)">
 <summary>
 Determines what type of conversion, if any, would be used if a given expression was
 converted to a given type.
 </summary>
 <param name="expression">An expression which must occur within the syntax tree
 associated with this object.</param>
 <param name="destination">The type to attempt conversion to.</param>
 <returns>Returns a Conversion object that summarizes whether the conversion was
 possible, and if so, what kind of conversion it was. If no conversion was possible, a
 Conversion object with a false "Exists " property is returned.</returns>
 <remarks>To determine the conversion between two types (instead of an expression and a
 type), use Compilation.ClassifyConversion.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.ClassifyConversion(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol)">
 <summary>
 Determines what type of conversion, if any, would be used if a given expression was
 converted to a given type.
 </summary>
 <param name="position">The character position for determining the enclosing declaration scope and accessibility.</param>
 <param name="expression">An expression to classify. This expression does not need to be
 present in the syntax tree associated with this object.</param>
 <param name="destination">The type to attempt conversion to.</param>
 <returns>Returns a Conversion object that summarizes whether the conversion was
 possible, and if so, what kind of conversion it was. If no conversion was possible, a
 Conversion object with a false "Exists " property is returned.</returns>
 <remarks>To determine the conversion between two types (instead of an expression and a
 type), use Compilation.ClassifyConversion.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an modified identifier that is part of a variable declaration, get the
 corresponding symbol.
 </summary>
 <param name="identifierSyntax">The modified identifier that declares a variable.</param>
 <returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an FieldInitializerSyntax, get the corresponding symbol of anonymous type property.
 </summary>
 <param name="fieldInitializerSyntax">The anonymous object creation field initializer syntax.</param>
 <returns>The symbol that was declared, or Nothing if no such symbol exists or 
 if the field initializer was not part of an anonymous type creation.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an AnonymousObjectCreationExpressionSyntax, get the corresponding symbol of anonymous type.
 </summary>
 <param name="anonymousObjectCreationExpressionSyntax">The anonymous object creation syntax.</param>
 <returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an ExpressionRangeVariableSyntax, get the corresponding symbol.
 </summary>
 <param name="rangeVariableSyntax">The range variable syntax that declares a variable.</param>
 <returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an CollectionRangeVariableSyntax, get the corresponding symbol.
 </summary>
 <param name="rangeVariableSyntax">The range variable syntax that declares a variable.</param>
 <returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an AggregationRangeVariableSyntax, get the corresponding symbol.
 </summary>
 <param name="rangeVariableSyntax">The range variable syntax that declares a variable.</param>
 <returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a label statement, get the corresponding label symbol.
 </summary>
 <param name="declarationSyntax">The label statement.</param>
 <returns>The label symbol, or Nothing if no such symbol exists.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a declarationSyntax that is part of a enum constant declaration, get the
 corresponding symbol.
 </summary>
 <param name="declarationSyntax">The declarationSyntax that declares a variable.</param>
 <returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a type declaration, get the corresponding type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a type.</param>
 <returns>The type symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a type block, get the corresponding type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a type block.</param>
 <returns>The type symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a enum declaration, get the corresponding type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares an enum.</param>
 <returns>The type symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a enum block, get the corresponding type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares an enum block.</param>
 <returns>The type symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a namespace declaration, get the corresponding type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a namespace.</param>
 <returns>The namespace symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a namespace block, get the corresponding type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a namespace block.</param>
 <returns>The namespace symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBaseSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a method, property, or event declaration, get the corresponding symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a method, property, or event.</param>
 <returns>The method, property, or event symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a parameter declaration, get the corresponding parameter symbol.
 </summary>
 <param name="parameter">The syntax node that declares a parameter.</param>
 <returns>The parameter symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a type parameter declaration, get the corresponding type parameter symbol.
 </summary>
 <param name="typeParameter">The syntax node that declares a type parameter.</param>
 <returns>The type parameter symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a delegate statement syntax get the corresponding named type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a delegate.</param>
 <returns>The named type that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a constructor statement syntax get the corresponding method symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a constructor.</param>
 <returns>The method symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a method statement syntax get the corresponding method symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a method.</param>
 <returns>The method symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a method statement syntax get the corresponding method symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a method.</param>
 <returns>The method symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a operator statement syntax get the corresponding method symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares an operator.</param>
 <returns>The method symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a method block syntax get the corresponding method, property or event symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares method, property or event.</param>
 <returns>The method, property or event symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a property statement syntax get the corresponding property symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a property.</param>
 <returns>The property symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an event statement syntax get the corresponding event symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares an event.</param>
 <returns>The event symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a property block syntax get the corresponding property symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares property.</param>
 <returns>The property symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a custom event block syntax get the corresponding event symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares the custom event.</param>
 <returns>The event symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a catch statement syntax get the corresponding local symbol.
 </summary>
 <param name="declarationSyntax">The catch statement syntax node.</param>
 <returns>The local symbol that was declared by the Catch statement or Nothing if statement does not declare a local variable.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a property block syntax get the corresponding property symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares property.</param>
 <returns>The property symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an import clause get the corresponding symbol for the import alias that was introduced.
 </summary>
 <param name="declarationSyntax">The import statement syntax node.</param>
 <returns>The alias symbol that was declared or Nothing if no alias symbol was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbols(Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a field declaration syntax, get the corresponding symbols.
 </summary>
 <param name="declarationSyntax">The syntax node that declares one or more fields.</param>
 <returns>The field symbols that were declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetInvokeSummaryForRaiseEvent(Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax)">
 <summary>
 Gets bound node summary of the underlying invocation in a case of RaiseEvent
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetNamedArgumentSymbolInfoInRaiseEvent(System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax)">
 <summary>
 RaiseEvent situation is very special: 
 1) Unlike other syntaxes that take named arguments, RaiseEvent is a statement. 
 2) RaiseEvent is essentially a wrapper around underlying call to the event rising method.
    Note that while event itself may have named parameters in its syntax, their names could be irrelevant
    For the purpose of fetching named parameters, it is the target of the call that we are interested in.
    
    === Example:
 
 Interface I1
    Event E(qwer As Integer)  
 End Interface
 
 Class cls1 : Implements I1
    Event E3(bar As Integer) Implements I1.E   '  "bar" means nothing here. Only type matters.

    Sub moo()
        RaiseEvent E3(qwer:=123)  ' qwer binds to parameter on I1.EEventhandler.invoke(foo)
    End Sub
End Class
 
 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.SyntaxTree">
 <summary> 
 The SyntaxTree that is bound
 </summary> 
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetForEachStatementInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax)">
 <summary>
 Gets the semantic information of a for each statement.
 </summary>
 <param name="node">The for each syntax node.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetForEachStatementInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax)">
 <summary>
 Gets the semantic information of a for each statement.
 </summary>
 <param name="node">The for block syntax node.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetForEachStatementInfoWorker(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax)">
 <summary>
 Gets the semantic information of a for each statement.
 </summary>
 <param name="node">The for each syntax node.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the semantic information of an Await expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 If the given node is within a preprocessing directive, gets the preprocessing symbol info for it.
 </summary>
 <param name="node">Preprocessing symbol identifier node.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.SymbolInfoOptions">
 <summary>
 Options to control the internal working of GetSemanticInfoWorker. Not currently exposed
 to public clients, but could be if desired.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.SymbolInfoOptions.PreferTypeToConstructors">
 <summary>
 When binding "C" new C(...), return the type C and do not return information about
 which constructor was bound to. Bind "new C(...)" to get information about which constructor
 was chosen.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.SymbolInfoOptions.PreferConstructorsToType">
 <summary>
 When binding "C" new C(...), return the constructor of C that was bound to, if C unambiguously
 binds to a single type with at least one constructor. 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.SymbolInfoOptions.ResolveAliases">
 <summary>
 When binding a name X that was declared with a "using X=OtherTypeOrNamespace", return OtherTypeOrNamespace.
 </summary>            
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.SymbolInfoOptions.PreserveAliases">
 <summary>
 When binding a name X that was declared with a "using X=OtherTypeOrNamespace", return the alias symbol X.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetEnclosingSymbol(System.Int32,System.Threading.CancellationToken)">
 <summary>
 Given a position in the SyntaxTree for this SemanticModel returns the innermost Symbol
 that the position is considered inside of. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.OptionStrict">
 <summary>
 Get the state of Option Strict for the code covered by this semantic model.
 This takes into effect both file-level "Option Strict" statements and the project-level
 defaults.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.OptionInfer">
 <summary>
 Get the state of Option Infer for the code covered by this semantic model.
 This takes into effect both file-level "Option Infer" statements and the project-level
 defaults.
 </summary>
 <value>True if Option Infer On, False if Option Infer Off.</value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.OptionExplicit">
 <summary>
 Get the state of Option Explicit for the code covered by this semantic model.
 This takes into effect both file-level "Option Explicit" statements and the project-level
 defaults.
 </summary>
 <value>True if Option Explicit On, False if Option Explicit Off.</value>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.OptionCompareText">
 <summary>
 Get the state of Option Compare for the code covered by this semantic model.
 This takes into effect both file-level "Option Compare" statements and the project-level
 defaults.
 </summary>
 <value>True if Option Compare Text, False if Option Compare Binary.</value>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SpeculativeSyntaxTreeSemanticModel">
 <summary>
 Allows asking semantic questions about a tree of syntax nodes that did not appear in the original source code.
 Typically, an instance is obtained by a call to SemanticModel.TryGetSpeculativeSemanticModel. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel">
 <summary>
 Allows asking semantic questions about any node in a SyntaxTree within a Compilation.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.Compilation">
 <summary> 
 The compilation associated with this binding.
 </summary> 
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.Root">
 <summary> 
 The root node of the syntax tree that this binding is based on.
 </summary> 
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.SyntaxTree">
 <summary> 
 The SyntaxTree that is bound
 </summary> 
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.IgnoresAccessibility">
 <summary>
 Returns true if this Is a SemanticModel that ignores accessibility rules when answering semantic questions.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
 <summary>
 Get all the errors within the syntax tree associated with this object. Includes errors involving compiling
 method bodies or initializers, in addition to the errors returned by GetDeclarationDiagnostics and parse errors.
 </summary>
 <param name="span">Optional span within the syntax tree for which to get diagnostics.
 If no argument is specified, then diagnostics for the entire tree are returned.</param>
 <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
 <remarks>
 Because this method must semantically analyze all method bodies and initializers to check for diagnostics, it may
 take a significant amount of time. Unlike GetDeclarationDiagnostics, diagnostics for method bodies and
 initializers are not cached, the any semantic information used to obtain the diagnostics is discarded.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetSyntaxDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
 <summary>
 Get all of the syntax errors within the syntax tree associated with this
 object. Does not get errors involving declarations or compiling method bodies or initializers.
 </summary>
 <param name="span">Optional span within the syntax tree for which to get diagnostics.
 If no argument is specified, then diagnostics for the entire tree are returned.</param>
 <param name="cancellationToken">A cancellation token that can be used to cancel the
 process of obtaining the diagnostics.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclarationDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
 <summary>
 Get all the syntax and declaration errors within the syntax tree associated with this object. Does not get
 errors involving compiling method bodies or initializers.
 </summary>
 <param name="span">Optional span within the syntax tree for which to get diagnostics.
 If no argument is specified, then diagnostics for the entire tree are returned.</param>
 <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
 <remarks>The declaration errors for a syntax tree are cached. The first time this method is called, a ll
 declarations are analyzed for diagnostics. Calling this a second time will return the cached diagnostics.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetMethodBodyDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
 <summary>
 Get all the syntax and declaration errors within the syntax tree associated with this object. Does not get
 errors involving compiling method bodies or initializers.
 </summary>
 <param name="span">Optional span within the syntax tree for which to get diagnostics.
 If no argument is specified, then diagnostics for the entire tree are returned.</param>
 <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
 <remarks>The declaration errors for a syntax tree are cached. The first time this method is called, a ll
 declarations are analyzed for diagnostics. Calling this a second time will return the cached diagnostics.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetCrefOrNameAttributeReferenceSymbols(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol}@)">
 <summary>
 Get symbols referenced from 'cref' or 'name' attribute value.
 </summary>
 <param name="node">Node to bind.</param>
 <param name="preserveAlias">True to leave <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol"/>s, False to unwrap them.</param>
 <param name="typeParameters">Out: symbols that would have been in the return value but improperly refer to type parameters.</param>
 <returns>Referenced symbols, less type parameters.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.CheckSymbolLocationsAgainstSyntax(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Checks all symbol locations against the syntax provided and return symbol if any of the locations is 
 inside the syntax span. Returns Nothing otherwise.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a delegate declaration, get the corresponding type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a type.</param>
 <returns>The type symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a type declaration, get the corresponding type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a type.</param>
 <returns>The type symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a enum declaration, get the corresponding type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares an enum.</param>
 <returns>The type symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a namespace declaration, get the corresponding type symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a namespace.</param>
 <returns>The namespace symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBaseSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a method, property, or event declaration, get the corresponding symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a method, property, or event.</param>
 <returns>The method, property, or event symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a parameter declaration, get the corresponding parameter symbol.
 </summary>
 <param name="parameter">The syntax node that declares a parameter.</param>
 <returns>The parameter symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a type parameter declaration, get the corresponding type parameter symbol.
 </summary>
 <param name="typeParameter">The syntax node that declares a type parameter.</param>
 <returns>The type parameter symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a variable declaration, get the corresponding  symbol.
 </summary>
 <param name="declarationSyntax">The syntax node that declares a variable.</param>
 <returns>The symbol that was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an FieldInitializerSyntax, get the corresponding symbol of anonymous type creation.
 </summary>
 <param name="fieldInitializerSyntax">The anonymous object creation field initializer syntax.</param>
 <returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an AnonymousObjectCreationExpressionSyntax, get the corresponding symbol of anonymous type.
 </summary>
 <param name="anonymousObjectCreationExpressionSyntax">The anonymous object creation syntax.</param>
 <returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an ExpressionRangeVariableSyntax, get the corresponding symbol.
 </summary>
 <param name="rangeVariableSyntax">The range variable syntax that declares a variable.</param>
 <returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an CollectionRangeVariableSyntax, get the corresponding symbol.
 </summary>
 <param name="rangeVariableSyntax">The range variable syntax that declares a variable.</param>
 <returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an AggregationRangeVariableSyntax, get the corresponding symbol.
 </summary>
 <param name="rangeVariableSyntax">The range variable syntax that declares a variable.</param>
 <returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax,System.Threading.CancellationToken)">
 <summary>
 Given an import clause get the corresponding symbol for the import alias that was introduced.
 </summary>
 <param name="declarationSyntax">The import statement syntax node.</param>
 <returns>The alias symbol that was declared or Nothing if no alias symbol was declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbols(Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a field declaration syntax, get the corresponding symbols.
 </summary>
 <param name="declarationSyntax">The syntax node that declares one or more fields.</param>
 <returns>The field symbols that were declared.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.ClassifyConversion(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol)">
 <summary>
 Determines what type of conversion, if any, would be used if a given expression was converted to a given
 type.
 </summary>
 <param name="expression">An expression which much occur within the syntax tree associated with this
 object.</param>
 <param name="destination">The type to attempt conversion to.</param>
 <returns>Returns a Conversion object that summarizes whether the conversion was possible, and if so, what
 kind of conversion it was. If no conversion was possible, a Conversion object with a false "Exists "
 property is returned.</returns>
 <remarks>To determine the conversion between two types (instead of an expression and a type), use
 Compilation.ClassifyConversion.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.AnalyzeControlFlow(Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)">
 <summary>
 Analyze control-flow within a part of a method body.
 </summary>
 <param name="firstStatement">The first statement to be included in the analysis.</param>
 <param name="lastStatement">The last statement to be included in the analysis.</param>
 <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
 <exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)">
 <summary>
 The first statement to be included in the analysis.
 </summary>
 <param name="firstStatement">The first statement to be included in the analysis.</param>
 <param name="lastStatement">The last statement to be included in the analysis.</param>
 <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
 <exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Analyze data-flow within an expression. 
 </summary>
 <param name="expression">The expression within the associated SyntaxTree to analyze.</param>
 <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.IsNodeInsideAttributeArguments(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Checks if the node is inside the attribute arguments 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.IsExpressionInValidContext(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Check Expression for being in right context, for example 'For ... Next [x]' 
 is not correct context
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.IsNotUppermostForBlock(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Check ForBlockSyntax for being the uppermost For block. By uppermost 
 For block we mean that if Next clause contains several control variables,
 the uppermost block is the one which includes all the For blocks ending with 
 the same Next clause
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetForEachStatementInfoWorker(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax)">
 <summary>
 Gets the semantic information of a for each statement.
 </summary>
 <param name="node">The for each syntax node.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.CreateFailedRegionAnalysisContext">
 <summary> Used to create a region analysis context 
 with failed flag set to be used in 'failed' scenarios </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState">
 <summary>
 Represents the state of compilation of one particular type.
 This includes, for example, a collection of synthesized methods created during lowering.
 WARNING: Note that the underlying collection classes are not thread-safe and this will 
 need to be revised if emit phase is changed to support multithreading when
 translating a particular type.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState.MethodWithBody">
 <summary> Method's information </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState._synthesizedMethods">
 <summary> Flat array of created methods, non-empty if not-nothing </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState.StateMachineImplementationClass">
 <summary>
 A mapping from (source) iterator or async methods to the compiler-generated classes that implement them.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState._methodWrappers">
 <summary> 
 Map of 'MyBase' or 'MyClass' call wrappers; actually each method symbol will 
 only need one wrapper to call it non-virtually; 
 
 Indeed, if the type have a virtual method M1 overridden, MyBase.M1 will use 
 a wrapper for base type's method and MyClass.M1 a wrapper for this type's method.
 
 And if the type does not override a virtual method M1, both MyBase.M1 
 and MyClass.M1 will use a wrapper for base type's method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState.HasSynthesizedMethods">
 <summary>
 Is there any content in the methods collection.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState.SynthesizedMethods">
 <summary> Method created with their bodies </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState.Free">
 <summary> Free resources </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicTypeInfo.Type">
 <summary>
 The type of the expression represented by the syntax node. For expressions that do not
 have a type, null is returned. If the type could not be determined due to an error, than
 an object derived from ErrorTypeSymbol is returned.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicTypeInfo.ConvertedType">
 <summary>
 The type of the expression after it has undergone an implicit conversion. If the type
 did not undergo an implicit conversion, returns the same as Type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicTypeInfo.ImplicitConversion">
 <summary>
 If the expression underwent an implicit conversion, return information about that
 conversion. Otherwise, returns an identity conversion.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicTypeInfo.GetPossibleGuessForErrorType(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Guess the non-error type that the given type was intended to represent, or return
 the type itself. If a single, non-ambiguous type is a guess-type inside the type symbol, 
 return that; otherwise return the type itself (even if it is an error type).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodCompiler.GetCompileDiagnostics(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol,Microsoft.CodeAnalysis.SyntaxTree,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean,System.Threading.CancellationToken)">
 <summary>
 Completes binding and performs analysis of bound trees for the purpose of obtaining diagnostics.
 
 NOTE: This method does not perform lowering/rewriting/emit. 
       Errors from those stages require complete compile, 
       but generally are not interesting during editing.
 
 NOTE: the bound tree produced by this method are not stored anywhere
       and immediately lost after diagnostics of a particular tree is done.
       
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodCompiler.CompileMethodBodies(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,Microsoft.CodeAnalysis.VisualBasic.Emit.PEModuleBuilder,System.Boolean,System.Boolean,System.Predicate{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.DiagnosticBag,System.Threading.CancellationToken)">
 <summary>
 Compiles given compilation into provided module.
 
 NOTE: it is ok for moduleBeingBuiltOpt to be Nothing. 
       In such case the only results of this method would be diagnostics for complete compile.
 
 NOTE: the bound/lowered trees produced by this method are not stored anywhere and
       immediately lost after obtaining method bodies and diagnostics for a particular
       tree.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodCompiler.DetectAndReportCyclesInConstructorCalls(System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Detects cycles in constructor invocations based on the 'constructor-calls-constructor' 
 map provided in 'constructorCallMap', reports errors if found.
 
 NOTE: 'constructorCallMap' is being mutated by this method
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodCompiler.ReportConstructorCycles(System.Int32,System.Int32,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary> All the constructors in the cycle will be reported </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodCompiler.CompileMethod(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,System.Int32,System.Int32@,System.Int32@,System.Predicate{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState,Microsoft.CodeAnalysis.VisualBasic.Binder.ProcessedFieldOrPropertyInitializers,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.SynthesizedSubmissionFields,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol@)">
 <summary>
 Compiles the method.
 </summary>
 <param name="referencedConstructor">
 If the method being compiled is a constructor, CompileMethod returns in this parameter 
 the symbol of the constructor called from the one being compiled either explicitly or implicitly. 
 For structure constructors calling parameterless constructor returns the synthesized constructor symbol.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodCompiler.CreateSyntheticWithEventOverridesIfNeeded(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.HandledEvent},System.Int32@,System.Int32@,Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.SynthesizedSubmissionFields)">
 <summary> 
 If any of the "Handles" in the list have synthetic WithEvent override
 as a container, then this method will (if not done already) inject 
 property/accessors symbol into the emit module and assign bodies to the accessors.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodCompiler.TryGetMethodCalledInBoundExpressionStatement(Microsoft.CodeAnalysis.VisualBasic.BoundExpressionStatement)">
 <summary> 
 Assuming the statement is a constructor call wrapped in bound expression 
 statement, get the method symbol being called 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SynthesizedMetadataCompiler">
 <summary>
 When compiling in metadata-only mode, <see cref="T:Microsoft.CodeAnalysis.VisualBasic.MethodCompiler"/> is not run. This is problematic because 
 <see cref="T:Microsoft.CodeAnalysis.VisualBasic.MethodCompiler"/> adds synthesized explicit implementations to the list of synthesized definitions. 
 In lieu of running <see cref="T:Microsoft.CodeAnalysis.VisualBasic.MethodCompiler"/>, this class performs a quick 
 traversal of the symbol table and performs processing of synthesized symbols if necessary.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SynthesizedMetadataCompiler.ProcessSynthesizedMembers(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,Microsoft.CodeAnalysis.VisualBasic.Emit.PEModuleBuilder,System.Threading.CancellationToken)">
 <summary>
 Traverse the symbol table and properly add/process synthesized extra metadata if needed.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationReference">
 <summary>
 Represents a reference to another Visual Basic compilation. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationReference.Compilation">
 <summary>
 Returns the referenced <see cref="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationReference.Compilation"/>.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationReference.#ctor(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean)">
 <summary>
 Create a metadata reference to a compilation.
 </summary>
 <param name="compilation">The compilation to reference.</param>
 <param name="embedInteropTypes">Should interop types be embedded in the created assembly?</param>
 <param name="aliases">Namespace aliases for this reference.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDiagnosticFilter">
 <summary>
 Applies Visual Basic-specific modification and filtering of <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDiagnosticFilter.Filter(Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Generic.IDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic})">
 <summary>
 Modifies an input <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> per the given options. For example, the
 severity may be escalated, or the <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> may be filtered out entirely
 (by returning null).
 </summary>
 <param name="diagnostic">The input diagnostic</param>
 <param name="generalDiagnosticOption">How warning diagnostics should be reported</param>
 <param name="specificDiagnosticOptions">How specific diagnostics should be reported</param>
 <returns>A diagnostic updated to reflect the options, or null if it has been filtered out</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SourceDocumentationCommentUtils.GetDocumentationCommentForSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Globalization.CultureInfo,System.Boolean,System.Threading.CancellationToken)">
 <summary>
 Returns documentation comment for a type, field, property, event or method, 
 discards all the diagnostics
 </summary>
 <returns>
 Returns Nothing if there is no documentation comment on the type or 
 there were errors preventing such a comment from being generated,
 XML string otherwise
 </returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Emit.VisualBasicDefinitionMap">
 <summary>
 Matches symbols from an assembly in one compilation to
 the corresponding assembly in another. Assumes that only
 one assembly has changed between the two compilations.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Emit.VisualBasicDefinitionMap.CreateLocalSlotMap(Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.LocalInfo{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol}})">
 <summary>
 Match local declarations to names to generate a map from
 declaration to local slot. The names are indexed by slot And the
 assumption Is that declarations are in the same order as slots.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Emit.GenericMethodInstanceReference">
 <summary>
 Represents a reference to a generic method instantiation, closed over type parameters, 
 e.g. MyNamespace.Class.Method{T}()
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Emit.GenericNamespaceTypeInstanceReference">
 <summary>
 Represents a reference to a generic type instantiation that is not nested.
 e.g. MyNamespace.A{int}
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Emit.GenericNestedTypeInstanceReference">
 <summary>
 Represents a reference to a generic type instantiation that is nested in a non-generic type.
 e.g. A.B{int}
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Emit.GenericTypeInstanceReference">
 <summary>
 Represents a reference to a generic type instantiation.
 Subclasses represent nested and namespace types.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Emit.NoPia.EmbeddedTypesManager)">
 <summary>
 Returns true if the type can be embedded. If the type is defined in a linked (/l-ed)
 assembly, but doesn't meet embeddable type requirements, this function returns
 False and reports appropriate diagnostics.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Emit.PEAssemblyBuilderBase._metadataName">
 <summary>
 This value will override m_SourceModule.MetadataName.
 </summary>
 <remarks>
 This functionality exists for parity with C#, which requires it for
 legacy reasons (see Microsoft.CodeAnalysis.CSharp.Emit.PEAssemblyBuilderBase.metadataName).
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Emit.PEModuleBuilder.AllowOmissionOfConditionalCalls">
 <summary>
 True if conditional calls may be omitted when the required preprocessor symbols are not defined.
 </summary>
 <remarks>
 Only false in debugger scenarios (where calls should never be omitted).
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Emit.PEModuleBuilder.IgnoreAccessibility">
 <summary>
 Ignore accessibility when resolving well-known type
 members, in particular for generic type arguments
 (e.g.: binding to internal types in the EE).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Emit.PEModuleBuilder._addedEmbeddedSymbols">
 <summary> Stores collection of all embedded symbols referenced from IL </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Emit.PEModuleBuilder.ProcessReferencedSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary> Adds a symbol to the collection of referenced embedded symbols </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Emit.SpecializedFieldReference">
 <summary>
 Represents a reference to a field of a generic type instantiation.
 e.g.
 A{int}.Field
 A{int}.B{string}.C.Field
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Emit.SpecializedGenericMethodInstanceReference">
 <summary>
 Represents a generic method of a generic type instantiation, closed over type parameters.
 e.g. 
 A{T}.M{S}()
 A.B{T}.C.M{S}()
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Emit.SpecializedGenericNestedTypeInstanceReference">
 <summary>
 Represents a reference to an instantiation of a generic type nested in an instantiation of another generic type.
 e.g. 
 A{int}.B{string}
 A.B{int}.C.D{string}
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Emit.SpecializedMethodReference">
 <summary>
 Represents a method of a generic type instantiation.
 e.g. 
 A{int}.M()
 A.B{int}.C.M()
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Emit.SpecializedNestedTypeReference">
 <summary>
 Represents a reference to a type nested in an instantiation of a generic type.
 e.g. 
 A{int}.B
 A.B{int}.C.D
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Symbol">
 <summary>
 The base class for all symbols (namespaces, classes, method, parameters, etc.) that are 
 exposed by the compiler.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsDefinitionOrDistinct">
 <summary>
 Return whether the symbol is either the original definition
 or distinct from the original. Intended for use in Debug.Assert
 only since it may include a deep comparison.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.GetCustomAttributesToEmit(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedAttributeData},System.Boolean,System.Boolean)">
 <summary> 
 Returns a list of attributes to emit to CustomAttribute table.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.CheckDefinitionInvariant">
 <summary>
 Checks if this symbol is a definition and its containing module is a SourceModuleSymbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.HaveSameSignature(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 Determine if two methods have the same signature according to section 4.1.1 of the VB language spec.
 The name, number of type parameters, and number and types of the method's non-optional parameters are
 considered. ByRef/Byval, parameter names, returns type, constraints, or optional parameters are not considered.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsSymbolAccessible(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Checks if <paramref name="symbol"/> is accessible from within type <paramref name="within"/>.  
 </summary>
 <param name="symbol">The symbol for the accessibility check.</param>
 <param name="within">The type to use as a context for the check.</param>
 <param name="throughTypeOpt">
 The type of an expression that <paramref name="symbol"/> is accessed off of, if any.
 This is needed to properly check accessibility of protected members.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsSymbolAccessible(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol)">
 <summary>
 Checks if <paramref name="symbol"/> is accessible from within the assembly <paramref name="within"/>', but outside any 
 type. Protected members are deemed inaccessible.
 </summary>
 <param name="symbol">The symbol to check accessibility.</param>
 <param name="within">The assembly to check accessibility within.</param>
 <returns>True if symbol is accessible. False otherwise.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.Name">
 <summary>
 Gets the name of this symbol.
 </summary>
 <returns>Returns the name of this symbol. Symbols without a name return the empty string;
 Nothing is never returned.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.MetadataName">
 <summary>
 Gets the name of a symbol as it appears in metadata. Most of the time, this
 is the same as the Name property, with the following exceptions:
 1) The metadata name of generic types includes the "`1", "`2" etc. suffix that
 indicates the number of type parameters (it does not include, however, names of
 containing types or namespaces).
 2) The metadata name of methods that overload or override methods with the same
 case-insensitive name but different case-sensitive names are adjusted so that
 the overrides and overloads always have the same name in a case-sensitive way.
 
 It should be noted that Visual Basic merges namespace declaration from source
 and/or metadata with different casing into a single namespace symbol. Thus, for
 namespace symbols this property may return incorrect information if multiple declarations
 with different casing were found.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.SetMetadataName(System.String)">
 <summary>
 Set the metadata name for this symbol.
 Called from <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Symbols.OverloadingHelper.SetMetadataNameForAllOverloads(System.String,Microsoft.CodeAnalysis.SymbolKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)"/> for each symbol of the same name in a type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.Kind">
 <summary>
 Gets the kind of this symbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.ContainingSymbol">
 <summary>
 Get the symbol that logically contains this symbol. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.ContainingNamespace">
 <summary>
 Gets the nearest enclosing namespace for this namespace or type. For a nested type,
 returns the namespace that contains its container.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.ContainingType">
 <summary>
 Returns the nearest lexically enclosing type, or Nothing if there is none.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.ContainingNamespaceOrType">
 <summary>
 Returns the containing type or namespace, if this symbol is immediately contained by it.
 Otherwise returns Nothing.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.ContainingAssembly">
 <summary>
 Returns the assembly containing this symbol. If this symbol is shared
 across multiple assemblies, or doesn't belong to an assembly, returns Nothing.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.DeclaringCompilation">
 <summary>
 For a source assembly, the associated compilation.
 For any other assembly, null.
 For a source module, the DeclaringCompilation of the associated source assembly.
 For any other module, null.
 For any other symbol, the DeclaringCompilation of the associated module.
 </summary>
 <remarks>
 We're going through the containing module, rather than the containing assembly,
 because of /addmodule (symbols in such modules should return null).
 
 Remarks, not "ContainingCompilation" because it isn't transitive.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.ContainingModule">
 <summary>
 Returns the module containing this symbol. If this symbol is shared
 across multiple modules, or doesn't belong to a module, returns Nothing.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.OriginalDefinition">
 <summary>
 Get the original definition of this symbol. If this symbol is derived from another
 symbol by (say) type substitution, this gets the original symbol, as it was defined
 in source or metadata.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsDefinition">
 <summary>
 Returns true if this is the original definition of this symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.GetLexicalSortKey">
 <summary>
 <para>
 Get a source location key for sorting. For performance, it's important that this
 be able to be returned from a symbol without doing any additional allocations (even
 if nothing is cached yet.)
 </para>
 <para>
 Only (original) source symbols and namespaces that can be merged
 need override this function if they want to do so for efficiency.
 </para>
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.Locations">
 <summary>
 Gets the locations where this symbol was originally defined, either in source
 or metadata. Some symbols (for example, partial classes) may be defined in more
 than one location.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.DeclaringSyntaxReferences">
 <summary>
 Get the syntax node(s) where this symbol was declared in source. Some symbols (for example,
 partial classes) may be defined in more than one location. This property should return
 one or more syntax nodes only if the symbol was declared in source code and also was
 not implicitly declared (see the IsImplicitlyDeclared property). 
 
 Note that for namespace symbol, the declaring syntax might be declaring a nested namespace.
 For example, the declaring syntax node for N1 in "Namespace N1.N2" is the 
 NamespaceDeclarationSyntax for N1.N2. For the project namespace, the declaring syntax will
 be the CompilationUnitSyntax.
 </summary>
 <returns>
 The syntax node(s) that declared the symbol. If the symbol was declared in metadata
 or was implicitly declared, returns an empty read-only array.
 </returns>
 <remarks>
 To go the opposite direction (from syntax node to symbol), see <see cref="M:Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,System.Threading.CancellationToken)"/>.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.GetDeclaringSyntaxNodeHelper``1(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})">
 <summary> 
 Helper for implementing DeclaringSyntaxNodes for derived classes that store a location but not a  SyntaxNode or SyntaxReference. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.GetDeclaringSyntaxReferenceHelper``1(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})">
 <summary> 
 Helper for implementing DeclaringSyntaxNodes for derived classes that store a location but not a  SyntaxNode or SyntaxReference. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.GetDeclaringSyntaxReferenceHelper(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxReference})">
 <summary> 
 Helper for implementing DeclaringSyntaxNodes for derived classes that store SyntaxReferences. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.DeclaredAccessibility">
 <summary>
 Get this accessibility that was declared on this symbol. For symbols that do
 not have accessibility declared on them, returns NotApplicable.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsShared">
 <summary>
 Returns true if this symbol is "shared"; i.e., declared with the "Shared"
 modifier or implicitly always shared.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsOverridable">
 <summary>
 Returns true if this member is overridable, has an implementation,
 and does not override a base class member; i.e., declared with the "Overridable"
 modifier. Does not return true for members declared as MustOverride or Overrides.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsOverrides">
 <summary>
 Returns true if this symbol was declared to override a base class members; i.e., declared
 with the "Overrides" modifier. Still returns true if the members was declared
 to override something, but (erroneously) no member to override exists.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsMustOverride">
 <summary>
 Returns true if this symbol was declared as requiring an override; i.e., declared
 with the "MustOverride" modifier. Never returns true for types. 
 Also methods, properties and events declared in interface are considered to have MustOverride.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsNotOverridable">
 <summary>
 Returns true if this symbol was declared to override a base class members and was
 also restricted from further overriding; i.e., declared with the "NotOverridable"
 modifier. Never returns true for types.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsImplicitlyDeclared">
 <summary>
 Returns true if this symbol was automatically created by the compiler, and does not
 have an explicit corresponding source code declaration.  
 </summary>
 <remarks>
 This is intended for symbols that are ordinary symbols in the language sense,
 and may be used by code, but that are simply declared implicitly rather than
 with explicit language syntax.
 
 Examples include (this list is not exhaustive):
   the default constructor for a class or struct that is created if one is not provided,
   the BeginInvoke/Invoke/EndInvoke methods for a delegate,
   the generated backing field for an auto property or a field-like event,
   the "this" parameter for non-static methods,
   the "value" parameter for a property setter,
   the parameters on indexer accessor methods (not on the indexer itself),
   methods in anonymous types
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.ObsoleteState">
 <summary>
 True if this symbol has been marked with the Obsolete attribute. 
 This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.ObsoleteAttributeData">
 <summary>
 Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
 This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.ImplicitlyDefinedBy(System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbol}})">
 <summary>
 Returns the symbol that implicitly defined this symbol, or Nothing if this
 symbol was declared explicitly. Examples of implicit symbols are property
 accessors and the backing field for an automatically implemented property.
 
 NOTE: there are scenarios in which ImplicitlyDefinedBy is called while bound members 
       are not yet published. This typically happens if ImplicitlyDefinedBy while binding members.
       In such case, if callee needs to refer to a member of enclosing type it must 
       do that in the context of unpublished members that caller provides 
       (asking encompassing type for members will cause infinite recursion).
 
 NOTE: There could be several threads trying to bind and publish members, only one will succeed.
       Reporting ImplicitlyDefinedBy within the set of members known to the caller guarantees
       that if particular thread succeeds it will not have information that refers to something
       built by another thread and discarded.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.ShadowsExplicitly">
 <summary> 
 Returns true if 'Shadows' is explicitly specified on the declaration if the symbol is from
 source, or in cases of synthesized symbols, if 'Shadows' is specified on the associated
 source symbol. (For instance, ShadowsExplicitly will be set on the backing fields and
 accessors for properties and events based on the value from the property or event.)
 Returns false in all other cases, in particular, for symbols not from source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.CanBeReferencedByName">
 <summary>
 Returns true if this symbol can be referenced by its name in code. Examples of symbols
 that cannot be referenced by name are:
    constructors, operators, 
    accessor methods for properties and events.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.CanBeReferencedByNameIgnoringIllegalCharacters">
 <summary>
 As an optimization, viability checking in the lookup code should use this property instead
 of CanBeReferencedByName.
 </summary>
 <remarks>
 This property exists purely for performance reasons.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsEmbedded">
 <summary>
 Is this a symbol that is generated by the compiler and
 automatically added to the compilation? Note that
 only source symbols may be embedded symbols. 
 
 Namespace symbol is considered to be an embedded symbol
 if at least one of its declarations are embedded symbols.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.EffectiveDefaultMarshallingCharSet">
 <summary>
 <see cref="T:System.Runtime.InteropServices.CharSet"/> effective for this symbol (type or DllImport method).
 Nothing if <see cref="T:System.Runtime.InteropServices.DefaultCharSetAttribute"/> isn't applied on the containing module or it doesn't apply on this symbol.
 </summary>
 <remarks>
 Determined based upon value specified via <see cref="T:System.Runtime.InteropServices.DefaultCharSetAttribute"/> applied on the containing module.
 Symbols that are embedded are not affected by <see cref="T:System.Runtime.InteropServices.DefaultCharSetAttribute"/> (see DevDiv bug #16434).
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.Dangerous_IsFromSomeCompilationIncludingRetargeting">
 <summary>
 Always prefer IsFromCompilation.
 </summary>
 <remarks>
 This property is actually a triple workaround:
 
 1) Unfortunately, when determining overriding/hiding/implementation relationships, we don't
    have the "current" compilation available.  We could, but that would clutter up the API
    without providing much benefit.  As a compromise, we consider all compilations "current".
 
 2) TypeSymbol.Interfaces doesn't roundtrip in the presence of implicit interface implementation.
    In particular, the metadata symbol may declare fewer interfaces than the source symbol so
    that runtime implicit interface implementation will find the right symbol.  Thus, we need to
    know what kind of symbol we are dealing with to be able to interpret the Interfaces property
    properly.  Since a retargeting TypeSymbol will reflect the behavior of the underlying source
    TypeSymbol, we need this property to match as well.  (C# does not have this problem.)
 
 3) The Dev12 VB compiler avoided loading private fields of structs from metadata, even though
    they're supposed to affect definite assignment analysis.  For compatibility
    we therefore ignore these fields when doing DA analysis.  (C# has a similar issue.)
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsLambdaMethod">
 <summary>
 Equivalent to MethodKind = MethodKind.LambdaMethod, but can be called on a symbol directly.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsMyGroupCollectionProperty">
 <summary>
 Is this an auto-generated property of a group class?
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.IsQueryLambdaMethod">
 <summary>
 Is this lambda method a query lambda? 
 If it is, IsLambdaMethod == True as well.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.GetGuidStringDefaultImplementation(System.String@)">
 <summary>
 Returns true and a <see cref="T:System.String"/> from the first <see cref="T:System.Runtime.InteropServices.GuidAttribute"/> on the symbol, 
 the string might be null or an invalid guid representation. False, 
 if there is no <see cref="T:System.Runtime.InteropServices.GuidAttribute"/> with string argument.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.GetDocumentationCommentId">
 <summary>
 Returns the Documentation Comment ID for the symbol, or Nothing if the symbol
 doesn't support documentation comments.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.GetDocumentationCommentXml(System.Globalization.CultureInfo,System.Boolean,System.Threading.CancellationToken)">
 <summary>
 Fetches the documentation comment for this element with a cancellation token.
 </summary>
 <param name="preferredCulture">Optionally, retrieve the comments formatted for a particular culture. No impact on source documentation comments.</param>
 <param name="expandIncludes">Optionally, expand <![CDATA[<include>]]> elements. No impact on non-source documentation comments.</param>
 <param name="cancellationToken">Optionally, allow cancellation of documentation comment retrieval.</param>
 <returns>The XML that would be written to the documentation file for the symbol.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.op_Equality(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Compare two symbol objects to see if they refer to the same symbol. You should always use
 = and &lt;&gt; or the Equals method, to compare two symbols for equality.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.op_Inequality(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Compare two symbol objects to see if they refer to the same symbol. You should always use
 = and &lt;&gt;, or the Equals method, to compare two symbols for equality.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.GenerateDeclarationErrors(System.Threading.CancellationToken)">
 <summary>
 Force all declaration diagnostics to be generated for the symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.GetUseSiteErrorInfo">
 <summary>
 Returns error info for an error, if any, that should be reported at the use site of the symbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.HasUnsupportedMetadata">
 <summary>
 Indicates that this symbol uses metadata that cannot be supported by the language.
 
 Examples include:
    - Pointer types in VB
    - ByRef return type
    - Required custom modifiers
    
 This is distinguished from, for example, references to metadata symbols defined in assemblies that weren't referenced.
 Symbols where this returns true can never be used successfully, and thus should never appear in any IDE feature.
 
 This is set for metadata symbols, as follows:
 Type - if a type is unsupported (e.g., a pointer type, etc.)
 Method - parameter or return type is unsupported
 Field - type is unsupported
 Event - type is unsupported
 Property - type is unsupported
 Parameter - type is unsupported
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.DeriveUseSiteErrorInfoFromType(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Derive error info from a type symbol.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Symbol.HighestPriorityUseSiteError">
 <summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.GetAttributes">
 <summary>
 Gets the attributes on this symbol. Returns an empty ImmutableArray if there are
 no attributes.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.AddSynthesizedAttributes(Microsoft.CodeAnalysis.VisualBasic.ModuleCompilationState,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedAttributeData}@)">
 <summary>
 Build and add synthesized attributes for this symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.AddSynthesizedAttribute(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedAttributeData}@,Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedAttributeData)">
 <summary>
 Convenience helper called by subclasses to add a synthesized attribute to a collection of attributes.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.GetAttributeTarget">
 <summary>
 Returns the appropriate AttributeTarget for a symbol.  This is used to validate attribute usage when
 applying an attribute to a symbol. For any symbol that does not support the application of custom
 attributes 0 is returned.
 </summary>
 <returns>The attribute target flag for this symbol or 0 if none apply.</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.EarlyDecodeWellKnownAttribute(Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.VisualBasic.EarlyWellKnownAttributeBinder,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation}@)">
 <summary>
 Method to early decode applied well-known attribute which can be queried by the binder.
 This method is called during attribute binding after we have bound the attribute types for all attributes,
 but haven't yet bound the attribute arguments/attribute constructor.
 Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol
 when binding the attribute arguments/attribute constructor without causing attribute binding cycle.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.DecodeWellKnownAttribute(Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData,Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation}@)">
 <summary>
 This method is called by the binder when it is finished binding a set of attributes on the symbol so that
 the symbol can extract data from the attribute arguments and potentially perform validation specific to
 some well known attributes.
 </summary>
 <remarks>
 <para>
 Symbol types should override this if they want to handle a specific well-known attribute.
 If the attribute is of a type that the symbol does not wish to handle, it should delegate back to
 this (base) method.
 </para>
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.PostDecodeWellKnownAttributes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax},Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation,Microsoft.CodeAnalysis.WellKnownAttributeData)">
 <summary>
 Called to report attribute related diagnostics after all attributes have been bound and decoded.
 Called even if there are no attributes.
 </summary>
 <remarks>
 This method is called by the binder from <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany{Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax}},Microsoft.CodeAnalysis.CustomAttributesBag{Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData}@,Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation)"/> after it has finished binding attributes on the symbol,
 has executed <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.DecodeWellKnownAttribute(Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData,Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation}@)"/> for attributes applied on the symbol and has stored the decoded data in the
 lazyCustomAttributesBag on the symbol. Bound attributes haven't been stored on the bag yet.
 
 Post-validation for attributes that is dependent on other attributes can be done here.
 
 This method should not have any side effects on the symbol, i.e. it SHOULD NOT change the symbol state.
 </remarks>
 <param name="boundAttributes">Bound attributes.</param>
 <param name="allAttributeSyntaxNodes">Syntax nodes of attributes in order they are specified in source.</param>
 <param name="diagnostics">Diagnostic bag.</param>
 <param name="symbolPart">Specific part of the symbol to which the attributes apply, or <see cref="F:Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation.None"/> if the attributes apply to the symbol itself.</param>
 <param name="decodedData">Decoded well known attribute data.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany{Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax}},Microsoft.CodeAnalysis.CustomAttributesBag{Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData}@,Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation)">
 <summary>
 This method does the following set of operations in the specified order:
 (1) GetAttributesToBind: Merge the given attributeBlockSyntaxList into a single list of attributes to bind.
 (2) GetAttributes: Bind the attributes (attribute type, arguments and constructor).
 (3) DecodeWellKnownAttributes: Decode and validate bound well-known attributes.
 (4) ValidateAttributes: Perform some additional attribute validations, such as
         1) Duplicate attributes,
         2) Attribute usage target validation, etc.
 (5) Store the bound attributes and decoded well-known attribute data in lazyCustomAttributesBag in a thread safe manner.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.EarlyDecodeWellKnownAttributes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Binder},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax},Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData[],Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation)">
 <summary> 
 Method to early decode certain well-known attributes which can be queried by the binder. 
 This method is called during attribute binding after we have bound the attribute types for all attributes, 
 but haven't yet bound the attribute arguments/attribute constructor. 
 Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol 
 when binding the attribute arguments/attribute constructor without causing attribute binding cycle. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.ValidateAttributeUsageAndDecodeWellKnownAttributes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Binder},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData},Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation)">
 <summary> 
 This method validates attribute usage for each bound attribute and calls <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.DecodeWellKnownAttribute(Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData,Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation}@)"/>
 on attributes with valid attribute usage.
 This method is called by the binder when it is finished binding a set of attributes on the symbol so that 
 the symbol can extract data from the attribute arguments and potentially perform validation specific to 
 some well known attributes. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.ValidateAttributeUsage(Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation,Microsoft.CodeAnalysis.DiagnosticBag,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol})">
 <summary>
 Validate attribute usage target and duplicate attributes.
 </summary>
 <param name="attribute">Bound attribute</param>
 <param name="node">Syntax node for attribute specification</param>
 <param name="compilation">Compilation</param>
 <param name="symbolPart">Symbol part to which the attribute has been applied</param>
 <param name="diagnostics">Diagnostics</param>
 <param name="uniqueAttributeTypes">Set of unique attribute types applied to the symbol</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Symbol.ForceCompleteObsoleteAttribute">
 <summary>
 Ensure that attributes are bound and the ObsoleteState of this symbol is known.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.BadSymbolDiagnostic">
 <summary>
 This diagnostic indicates when a symbol is not good for binding against.
 
 Client code can obtain the bad symbol via the BadSymbol property.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.AmbiguousSymbolDiagnostic">
 <summary>
 This diagnostics indicates when a lookup is ambiguous between multiple
 equally good symbols, for example in different imported namespaces, or different
 modules.
 
 Client code can obtain the set of ambiguous symbols via the AmbiguousSymbols property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DiagnosticBagExtensions.Add(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.ERRID,Microsoft.CodeAnalysis.Location)">
 <summary>
 Add a diagnostic to the bag.
 </summary>
 <param name = "diagnostics"></param>
 <param name = "code"></param>
 <param name = "location"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DiagnosticBagExtensions.Add(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.ERRID,Microsoft.CodeAnalysis.Location,System.Object[])">
 <summary>
 Add a diagnostic to the bag.
 </summary>
 <param name = "diagnostics"></param>
 <param name = "code"></param>
 <param name = "location"></param>
 <param name = "args"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.DiagnosticBagExtensions.Add(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo})">
 <summary>
 Appends diagnostics from useSiteDiagnostics into diagnostics and returns True if there were any errors.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDiagnosticFormatter">
 <summary>
 The Diagnostic class allows formatting of Visual Basic diagnostics. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicDiagnosticFormatter.Instance">
 <summary>
 Gets the current DiagnosticFormatter instance.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.CompoundDiagnosticInfo">
 <summary>
 Concatenates messages for a set of DiagnosticInfo.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LocalizableErrorArgument">
 <summary>
 The LocalizableErrorArgument class contains members that allows formatting and serialization of error arguments.
 Message IDs may refer to strings that need to be localized.   This struct makes an IFormattable wrapper around a MessageID
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalizableErrorArgument.ToString">
 <summary>
Creates a string representing the unformatted LocalizableErrorArgument instance.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalizableErrorArgument.ToString_IFormattable(System.String,System.IFormatProvider)">
 <summary>
 Creates a string representing the formatted LocalizableErrorArgument instance.
 </summary>
 <param name="format">A string to use for formatting.</param>
 <param name="formatProvider">An object that supplies culture-specific format information about format.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.GlobalImport">
 <summary>
 Represents a Visual Basic global imports.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.GlobalImport.Clause">
 <summary>
 The import clause (a namespace name, an alias, or an XML namespace alias).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.GlobalImport.Name">
 <summary>
 The import name.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.GlobalImport.Parse(System.String)">
 <summary>
 Parses a specified string to create a GlobalImport instance.
 </summary>
 <param name="importedNames">The string containing the text to be parsed.</param>
 <returns>A GlobalImport instance. </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.GlobalImport.Parse(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic}@)">
 <summary>
 Parses a specified string to create a GlobalImport instance with diagnostics info.
 </summary>
 <param name="importedNames">The string containing the text to be parsed.</param>
 <param name="diagnostics">An ImmutableArray of diagnostics created during parse.</param>
 <returns>A GlobalImport instance.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.GlobalImport.Parse(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Parses a collection of strings representing imports to create collection of GlobalImports.
 </summary>
 <param name="importedNames">The collection of strings to be parsed.</param>
 <returns>A collection of GlobalImports</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.GlobalImport.Parse(System.String[])">
 <summary>
 Parses a parameter array of string arrays representing imports to create a collection of GlobalImports.
 </summary>
 <param name="importedNames">The string arrays to be parsed.</param>
 <returns>A collection of GlobalImports.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.GlobalImport.Parse(System.Collections.Generic.IEnumerable{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic}@)">
 <summary>
 Parses a collection of strings representing imports to create a collection of GlobalImport instance and diagnostics
 </summary>
 <param name="importedNames">A collection of strings to be parsed.</param>
 <param name="diagnostics">A ImmutableArray of diagnostics.</param>
 <returns>A collection of GlobalImports.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.GlobalImport.Equals(System.Object)">
 <summary>
 Determines if the current object is equal to another object.
 </summary>
 <param name="obj">An object to compare with this object</param>
 <returns>A boolean value.  True if the current object is equal to the other parameter; otherwise, False.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.GlobalImport.Equals(Microsoft.CodeAnalysis.VisualBasic.GlobalImport)">
 <summary>
 Determines whether the current object is equal to another object of the same type.
 </summary>
 <param name="other">A GlobalImport object to compare with this object</param>
 <returns>A boolean value.  True if the current object is equal to the other parameter; otherwise, False.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.GlobalImport.GetHashCode">
 <summary>
 Creates a hashcode for this instance.
 </summary>
 <returns>A hashcode representing this instance.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.GlobalImport.op_Equality(Microsoft.CodeAnalysis.VisualBasic.GlobalImport,Microsoft.CodeAnalysis.VisualBasic.GlobalImport)">
 <summary>
 Operator for Equality with GlobalImport Objects.
 </summary>
 <returns>True if the two items are Equal.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.GlobalImport.op_Inequality(Microsoft.CodeAnalysis.VisualBasic.GlobalImport,Microsoft.CodeAnalysis.VisualBasic.GlobalImport)">
 <summary>
 Overloaded Operator for Inequality ith GlobalImport Objects.
 </summary>
 <returns>Returns True if the two items are not Equal.</returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LanguageVersion">
 <summary>
 Supported Visual Basic language versions.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.EmbeddedTreeLocation">
 <summary>
 A program location in source code.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.MyTemplateLocation">
 <summary>
 A program location in MyTemplate code.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VBLocation">
 <summary>
 Represents a VB location in source code or metadata.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.AsyncMethodToClassRewriter.SpillExpressionsWithReceiver(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.SpillBuilder@)">
 <summary>
 Spill an expression list with a receiver (e.g. array access, method call), 
 where at least one of the receiver or the arguments contains an await expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.AsyncMethodToClassRewriter.SpillExpressionList(Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.SpillBuilder@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},System.Boolean)">
 <summary>
 Spill a list of expressions (e.g. the arguments of a method call).
 
 The expressions are processed right-to-left. Once an expression has been found that contains an await
 expression, all subsequent expressions are spilled.
 
 Example:
 
     (1 + 2, await t1, Foo(), await t2, 3 + 4)
 
     becomes:
 
     Spill(
         spill1 = 1 + 2,
         spill2 = await t1,
         spill3 = Foo(),
         (spill1, spill2, spill3, await t2, 3 + 4))
 
 NOTE: Consider nested array initializers:
 
     new int[] {
         { 1, await t1 },
         { 3, await t2 }
     }
 
 If the arguments of the top-level initializer had already been spilled, we would end up trying to spill
 something like this:
 
     new int[] {
         Spill(
             spill1 = 1,
             { spill1, await t1 }),
         Spill(
             spill2 = 3,
             { spill2, await t2 })
     }
 
 The normal rewriting would produce:
 
     Spill(
         spill1 = 1,
         spill3 = { spill1, await t1 },
         spill2 = 3,
         int[] a = new int[] {
             spill3,
             { spill2, await t2 }))
 
 Which is invalid, because spill3 does not have a type.
 
 To solve this problem the expression list spilled descends into nested array initializers.
 
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.AsyncMethodToClassRewriter._method">
 <summary>
 The method being rewritten.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.AsyncMethodToClassRewriter._builder">
 <summary>
 The field of the generated async class used to store the async method builder: an instance of
 AsyncVoidMethodBuilder, AsyncTaskMethodBuilder, or AsyncTaskMethodBuilder(Of T) depending on the
 return type of the async method.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.AsyncMethodToClassRewriter._exprReturnLabel">
 <summary>
 The exprReturnLabel is used to label the return handling code at the end of the async state-machine
 method. Return expressions are rewritten as unconditional branches to exprReturnLabel.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.AsyncMethodToClassRewriter._exitLabel">
 <summary>
 The exitLabel is used to label the final method body return at the end of the async state-machine 
 method. Is used in rewriting of return statements from Await expressions and a couple of other 
 places where the return is not accompanied by return of the value.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.AsyncMethodToClassRewriter._exprRetValue">
 <summary>
 The field of the generated async class used in generic task returning async methods to store the value
 of rewritten return expressions. The return-handling code then uses SetResult on the async method builder
 to make the result available to the caller.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.AsyncMethodToClassRewriter.GenerateMoveNext(Microsoft.CodeAnalysis.VisualBasic.BoundStatement,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 Generate the body for MoveNext()
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.CapturedSymbolOrExpression.Materialize(Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.AsyncMethodToClassRewriter,System.Boolean)">
 <summary>
 Materialize the capture, e.g. return an expression to be used instead of captured symbol
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.CapturedSymbolOrExpression.AddProxyFieldsForStateMachineScope(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol})">
 <summary>
 Add proxy field(s) if any to the array builder provided
 
 Note: is used for binding BoundStateMachineScope with 
       correspondent local/field references
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.CapturedSymbolOrExpression.CreateCaptureInitializationCode(Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.AsyncMethodToClassRewriter,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundExpression})">
 <summary>
 Create assignment expressions initializing for this capture, is only supposed to be
 used for proper handling of reference assignments
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.SpillFieldAllocator">
 <summary>
 Spill field allocator controls allocation and reuse of the set of fields 
 used to spilling expressions; current implementation allows reuse of fields 
 of the same type on high-level statement level
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.Rewrite(Microsoft.CodeAnalysis.VisualBasic.BoundBlock,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.AsyncStateMachine@)">
 <summary>
 Rewrite an async method into a state machine class.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.AsyncMethodKind">
 <summary>
 Specifies a kind of an Async method
 
 None is returned for non-Async methods or methods with wrong return type
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter.GetAsyncMethodKind(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 Returns method's async kind
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ClosureKind.Static">
 <summary>
 The closure doesn't declare any variables. 
 Display class Is a singleton And may be shared with other top-level methods.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ClosureKind.ThisOnly">
 <summary>
 The closure only contains a reference to the containing class instance ("Me").
 We don't emit a display class, lambdas are emitted directly to the containing class as its instance methods.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ClosureKind.General">
  <summary>
  General closure.
  Display class may only contain lambdas defined in the same top-level method.
  </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ExpressionLambdaRewriter">
 <summary>
 Rewrite lambda that are being converted to LINQ expression trees (Expression(Of T))
 </summary>
 <remarks>
 A lot of code is #If False disabled until it can be tested. 
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ExpressionLambdaRewriter.RewriteLambda(Microsoft.CodeAnalysis.VisualBasic.BoundLambda,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution,Microsoft.CodeAnalysis.DiagnosticBag,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.BoundNode},System.Int32)">
 <summary>
 Rewrite a bound lambda into a bound node that will create the corresponding expression tree at run time.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ExpressionLambdaRewriter.ConvertRuntimeHelperToExpressionTree(System.String,Microsoft.CodeAnalysis.VisualBasic.BoundExpression[])">
 <summary>
 Create an Expression Tree Node with the given name and arguments
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ExpressionLambdaRewriter.ConvertRuntimeHelperToExpressionTree(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol},Microsoft.CodeAnalysis.VisualBasic.BoundExpression[])">
 <summary>
 Create an Expression node with the given name, type arguments, and arguments.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ExpressionLambdaRewriter.GetExprFactoryMethodGroup(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol})">
 <summary>
 Gets the method group for a given method name. Returns Nothing if no methods found.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ExpressionLambdaRewriter.MaskShiftCountOperand(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Int32,Microsoft.CodeAnalysis.ConstantValue,System.Boolean)">
 <summary>
 The shift count for a left-shift or right-shift operator needs to be masked according to the type 
 of the left hand side, unless the shift count is an in-range constant. This is similar to what is 
 done in code gen.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ExpressionLambdaRewriter.ReplaceArgWithParameterInUserDefinedConversion(Microsoft.CodeAnalysis.VisualBasic.BoundConversion,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Boolean)">
 <summary>
 Given user defined conversion node replace the operand with the coalesce lambda parameter. 
 
 The input bound conversion node must have the following form:
     --> BoundConversion [UserDefined]
         --> [optional] BoundConversion (OutConversion)
             --> BoundCall [shared method, no receiver, one argument]
 
 The OUTPUT bound conversion node will have the following form:
     --> BoundConversion *updated*
         --> [optional] BoundConversion *updated*
             --> BoundCall [shared method, no receiver, * updated argument *]
                 --> [optional] BoundConversion (parameter from nullable to value)
                     --> *parameter*
 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ExpressionLambdaRewriter.CreateBuiltInConversion(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.ExpressionLambdaRewriter.ConversionSemantics,System.Boolean)">
 <summary>
 Rewrites a built-in conversion. Doesn't handle user-defined conversions or Nothing literals.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ExpressionLambdaRewriter.GetConversionHelperMethod(Microsoft.CodeAnalysis.SpecialType,Microsoft.CodeAnalysis.SpecialType)">
 <summary>
 Get the conversion helper for converting between special types in an expression tree. 
 These are often different than the ones used in regular code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ExpressionLambdaRewriter.GetUnaryOperatorMethodName(Microsoft.CodeAnalysis.VisualBasic.UnaryOperatorKind,System.Boolean)">
 <summary>
 Get the name of the expression tree function for a particular unary operator
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.IteratorRewriter.IteratorMethodToClassRewriter._current">
 <summary>
 The field of the generated iterator class that underlies the Current property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.IteratorRewriter.Rewrite(Microsoft.CodeAnalysis.VisualBasic.BoundBlock,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.IteratorStateMachine@)">
 <summary>
 Rewrite an iterator method into a state machine class.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LambdaCapturedVariable">
 <summary>
 A field of a frame class that represents a variable that has been captured in a lambda.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LambdaFrame">
 <summary>
 A class that represents the set of variables in a scope that have been
 captured by lambdas within that scope.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SynthesizedLambdaCopyConstructor">
 <summary>
 Copy constructor has one parameter of the same type as the enclosing type.
 The purpose is to copy all the lifted values from previous version of the 
 frame if there was any into the new one.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter">
 <summary>
 The rewriter for removing lambda expressions from method bodies and introducing closure classes
 as containers for captured variables along the lines of the example in section 6.5.3 of the
 C# language specification.
 
 The entry point is the public method Rewrite.  It operates as follows:
 
 First, an analysis of the whole method body is performed that determines which variables are
 captured, what their scopes are, and what the nesting relationship is between scopes that
 have captured variables.  The result of this analysis is left in LambdaRewriter.analysis.
 
 Then we make frame, or compiler-generated class, represented by an instance of
 LambdaRewriter.Frame for each scope with captured variables.  The generated frames are kept
 in LambdaRewriter.frames.  Each frame is given a single field for each captured
 variable in the corresponding scope.  These are maintained in LambdaRewriter.proxies.
 
 Finally, we walk and rewrite the input bound tree, keeping track of the following:
 (1) The current set of active frame pointers, in LambdaRewriter.framePointers
 (2) The current method being processed (this changes within a lambda's body), in LambdaRewriter.currentMethod
 (3) The "this" symbol for the current method in LambdaRewriter.currentFrameThis, and
 (4) The symbol that is used to access the innermost frame pointer (it could be a local variable or "this" parameter)
 
 There are a few key transformations done in the rewriting.
 (1) Lambda expressions are turned into delegate creation expressions, and the body of the lambda is
     moved into a new, compiler-generated method of a selected frame class.
 (2) On entry to a scope with captured variables, we create a frame object and store it in a local variable.
 (3) References to captured variables are transformed into references to fields of a frame class.
 
 In addition, the rewriting deposits into the field LambdaRewriter.generatedMethods a (MethodSymbol, BoundStatement)
 pair for each generated method.
 
 LambdaRewriter.Rewrite produces its output in two forms.  First, it returns a new bound statement
 for the caller to use for the body of the original method.  Second, it returns a collection of
 (MethodSymbol, BoundStatement) pairs for additional method that the lambda rewriter produced.
 These additional methods contain the bodies of the lambdas moved into ordinary methods of their
 respective frame classes, and the caller is responsible for processing them just as it does with
 the returned bound node.  For example, the caller will typically perform iterator method and
 asynchronous method transformations, and emit IL instructions into an assembly.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis">
 <summary>
 Perform a first analysis pass in preparation for removing all lambdas from a method body.  The entry point is Analyze.
 The results of analysis are placed in the fields seenLambda, blockParent, variableBlock, captured, and captures.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.seenLambda">
 <summary>
 Set to true of any lambda expressions were seen in the analyzed method body.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.seenBackBranches">
 <summary>
 Set to true if method body contains any back branches (loops).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.blockParent">
 <summary>
 For each statement with captured variables, identifies the nearest enclosing statement with captured variables.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.variableScope">
 <summary>
 For each captured variable, identifies the statement in which it will be moved to a frame class.  This is
 normally the block where the variable is introduced, but method parameters are moved
 to a frame class within the body of the method.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.labelBlock">
 <summary>
 For a given label, the nearest enclosing block that captures variables
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.gotoBlock">
 <summary>
 For a given goto, the nearest enclosing block that captures variables
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.containsLiftingLambda">
 <summary>
 Blocks that contain (recursively) a lambda that is lifting. 
 Such blocks are considered as potentially needing closure initialization when doing jump verification.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.needsParentFrame">
 <summary>
 Blocks that are positioned between a block declaring some lifted variables
 and a block that contains the lambda that lifts said variables.
 If such block itself requires a closure, then it must lift parent frame pointer into the closure
 in addition to whatever else needs to be lifted.
 
 NOTE: This information is computed in addition to the regular analysis of the tree and only needed for rewriting.
 If someone only needs diagnostics or information about captures, this information is not necessary.
 ComputeLambdaScopesAndFrameCaptures needs to be called to compute this.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.lambdaScopes">
 <summary>
 Optimized locations of lambdas. 
 
 Lambda does not need to be placed in a frame that corresponds to its lexical scope if lambda does not reference any local state in that scope.
 It is advantageous to place lambdas higher in the scope tree, ideally in the innermost scope of all scopes that contain variables captured by a given lambda.
 Doing so reduces indirections needed when captured local are accessed. For example locals from the innermost scope can be accessed with no indirection at all.
 
 NOTE: This information is computed in addition to the regular analysis of the tree and only needed for rewriting.
 If someone only needs diagnostics or information about captures, this information is not necessary.
 ComputeLambdaScopesAndFrameCaptures needs to be called to compute this.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.capturedVariables">
 <summary>
 The set of captured variables seen in the method body.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.capturedVariablesByLambda">
 <summary>
 For each lambda in the code, the set of variables that it captures.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.declaredInsideExpressionLambda">
 <summary>
 The set of variables that were declared anywhere inside an expression lambda.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis._inExpressionLambda">
 <summary>
 Set to true while we are analyzing the interior of an expression lambda.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.symbolsCapturedWithoutCopyCtor">
 <summary>
 All symbols that should never be captured with a copy constructor of a closure.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.AnalyzeMethodBody(Microsoft.CodeAnalysis.VisualBasic.BoundBlock,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,System.Collections.Generic.ISet{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Analyzes method body that belongs to the given method symbol.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.ComputeLambdaScopesAndFrameCaptures">
 <summary>
 Create the optimized plan for the location of lambda methods and whether scopes need access to parent scopes
  </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.BlockDepth(Microsoft.CodeAnalysis.VisualBasic.BoundNode)">
 <summary>
 Compute the nesting depth of a given block.
 Topmost block (where method locals and parameters are defined) are at the depth 0.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.RecordCaptureInIntermediateBlocks(Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Once we see a lambda lifting something
 We mark all scopes from the current up to the one that declares lifted symbol as
 containing a lifting lambda.
 This is needed so that we could reject jumps that might jump over frame allocations.
 
 NOTE: because of optimizations lambda _might_ be placed in a frame higher
       than its lexical scope and thus make a jump technically legal.
       However, we explicitly do not consider frame optimizations in this analysis.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.ReferenceVariable(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 This method is called on every variable reference.
 It checks for cases where variable is declared outside of the lambda in which it is being accessed
 If capture is detected, than it marks variable as capturED and all lambdas involved as capturING
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Analysis.MayParticipateInIllegalBranch(Microsoft.CodeAnalysis.VisualBasic.BoundGotoStatement)">
 <summary>
 For performance reason we may not want to check if synthetic gotos are legal.
 Those are the majority, but should not be ever illegal (how user would fix them?).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter._rewrittenNodes">
 <summary> WARNING: used ONLY in DEBUG </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.Rewrite(Microsoft.CodeAnalysis.VisualBasic.BoundBlock,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo},System.Int32@,Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState,System.Collections.Generic.ISet{Microsoft.CodeAnalysis.VisualBasic.Symbol},Microsoft.CodeAnalysis.DiagnosticBag,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.BoundNode})">
 <summary>
 Rewrite the given node to eliminate lambda expressions.  Also returned are the method symbols and their
 bound bodies for the extracted lambda bodies. These would typically be emitted by the caller such as
 MethodBodyCompiler.  See this class' documentation
 for a more thorough explanation of the algorithm and its use by clients.
 </summary>
 <param name="node">The bound node to be rewritten</param>
 <param name="method">The containing method of the node to be rewritten</param>
 <param name="methodOrdinal">Index of the method symbol in its containing type member list.</param>
 <param name="compilationState">The caller's buffer into which we produce additional methods to be emitted by the caller</param>
 <param name="symbolsCapturedWithoutCopyCtor">Set of symbols that should not be captured using a copy constructor</param>
 <param name="diagnostics">The caller's buffer into which we place any diagnostics for problems encountered</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.MakeFrames(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo})">
 <summary>
 Create the frame types.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.FrameOfType(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Produces a bound expression representing a pointer to a frame of a particular frame type.
 </summary>
 <param name="syntax">The syntax to attach to the bound nodes produced</param>
 <param name="frameType">The type of frame to be returned</param>
 <returns>A bound node that computes the pointer to the required frame</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.FramePointer(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Produce a bound expression representing a pointer to a frame of a particular frame class.
 Note that for generic frames, the frameClass parameter is the generic definition, but
 the resulting expression will be constructed with the current type parameters.
 </summary>
 <param name="syntax">The syntax to attach to the bound nodes produced</param>
 <param name="frameClass">The class type of frame to be returned</param>
 <returns>A bound node that computes the pointer to the required frame</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.ConstructFrameType``1(Microsoft.CodeAnalysis.VisualBasic.LambdaFrame,System.Collections.Immutable.ImmutableArray{``0})">
 <summary>
 Constructs a concrete frame type if needed.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.IntroduceFrame(Microsoft.CodeAnalysis.VisualBasic.BoundNode,Microsoft.CodeAnalysis.VisualBasic.LambdaFrame,System.Func{Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol},Microsoft.CodeAnalysis.VisualBasic.BoundNode},Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol)">
 <summary>
 Introduce a frame around the translation of the given node.
 </summary>
 <param name="node">The node whose translation should be translated to contain a frame</param>
 <param name="frame">The frame for the translated node</param>
 <param name="F">A function that computes the translation of the node.  It receives lists of added statements and added symbols</param>
 <returns>The translated statement, as returned from F</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.InitVariableProxy(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundExpression})">
 <summary>
 If parameter (or variable in the EE) is lifted, initialize its proxy.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.RewriteLambdaAsMethod(Microsoft.CodeAnalysis.VisualBasic.SynthesizedLambdaMethod,Microsoft.CodeAnalysis.VisualBasic.BoundLambda)">
 <summary>
 Rewrites lambda body into a body of a method.
 </summary>
 <param name="method">Method symbol for the rewritten lambda body.</param>
 <param name="lambda">Original lambda node.</param>
 <returns>Lambda body rewritten as a body of the given method symbol.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.IsLegalBranch(Microsoft.CodeAnalysis.VisualBasic.BoundNode,Microsoft.CodeAnalysis.VisualBasic.BoundNode)">
 <summary>
 It is illegal to jump into blocks that reference lifted variable
 as that could leave closure frames of the target block uninitialized.
 
 The fact that closure could be created as high as the declaration level of the variable
 and well above goto block (thus making the jump safe) is considered an optional optimization 
 and ignored. 
 For the purpose of this analysis just having lifting lambdas already means 
 that block may require initialization and cannot be jumped into.
 
 Note that when you are jumping into a block you are essentially jumping into ALL blocks
 on the path from LowestCommonAncestor(goto, label) to the actual label block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter.OptimizeMethodCallForDelegateInvoke(Microsoft.CodeAnalysis.VisualBasic.BoundCall,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression})">
 <summary>
 Optimize the case where we create an instance of a delegate and invoke it right away.
 Skip the delegate creation and invoke the method directly. Specifically, we are targeting 
 lambda relaxation scenario that requires a stub, which invokes original lambda by instantiating
 an Anonymous Delegate and calling its Invoke method. That is why this optimization should be done
 after lambdas are rewritten.
 CONSIDER: Should we expand this optimization to all delegate types and all explicitly written code?
           If we decide to do this, we should be careful with extension methods because they have
           special treatment of 'this' parameter. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SynthesizedLambdaMethod">
 <summary>
 A method that results from the translation of a single lambda expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SynthesizedLambdaMethod.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.InstanceTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.ClosureKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CodeGen.DebugId,Microsoft.CodeAnalysis.VisualBasic.BoundLambda,Microsoft.CodeAnalysis.CodeGen.DebugId,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Creates a symbol for a synthesized lambda method
 </summary>
 <param name="containingType">Type that contains lambda method 
 - it is either Frame or enclosing class in a case if we do not lift anything.</param>
 <param name="topLevelMethod">Method that contains lambda expression for which we do the rewrite.</param>
 <param name="lambdaNode">Lambda expression which is represented by this method.</param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PlaceholderReplacement(Microsoft.CodeAnalysis.VisualBasic.BoundValuePlaceholderBase)">
 <summary>
 Returns substitution currently used by the rewriter for a placeholder node.
 Each occurrence of the placeholder node is replaced with the node returned.
 Throws if there is no substitution.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.AddPlaceholderReplacement(Microsoft.CodeAnalysis.VisualBasic.BoundValuePlaceholderBase,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Sets substitution used by the rewriter for a placeholder node.
 Each occurrence of the placeholder node is replaced with the node returned.
 Throws if there is already a substitution.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.UpdatePlaceholderReplacement(Microsoft.CodeAnalysis.VisualBasic.BoundValuePlaceholderBase,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Replaces substitution currently used by the rewriter for a placeholder node with a different substitution.
 Asserts if there isn't already a substitution.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.RemovePlaceholderReplacement(Microsoft.CodeAnalysis.VisualBasic.BoundValuePlaceholderBase)">
 <summary>
 Removes substitution currently used by the rewriter for a placeholder node.
 Asserts if there isn't already a substitution.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PrependWithSequencePoint(Microsoft.CodeAnalysis.VisualBasic.BoundStatement,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan)">
 <summary>
 Adds a sequence point with the specified span before stepping on the statement.
 </summary>
 <remarks>
 If the statement is a block the sequence point will be outside of the scope.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)">
 <summary>
 Gets the special type.
 </summary>
 <param name="specialType">Special Type to get.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.GetSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
 <summary>
 Gets the special type member.
 </summary>
 <param name="specialMember">Member of the special type.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.ReportMissingOrBadRuntimeHelper(Microsoft.CodeAnalysis.VisualBasic.BoundNode,Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Checks for special member and reports diagnostics if the member is Nothing or has UseSiteError.
 Returns True in case diagnostics was actually reported
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.ReportMissingOrBadRuntimeHelper(Microsoft.CodeAnalysis.VisualBasic.BoundNode,Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 Checks for special member and reports diagnostics if the member is Nothing or has UseSiteError.
 Returns True in case diagnostics was actually reported
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.ReportMissingOrBadRuntimeHelper(Microsoft.CodeAnalysis.VisualBasic.BoundNode,Microsoft.CodeAnalysis.WellKnownMember,Microsoft.CodeAnalysis.VisualBasic.Symbol)">
 <summary>
 Checks for well known member and reports diagnostics if the member is Nothing or has UseSiteError.
 Returns True in case diagnostics was actually reported
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.ReportMissingOrBadRuntimeHelper(Microsoft.CodeAnalysis.VisualBasic.BoundNode,Microsoft.CodeAnalysis.WellKnownMember,Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
 <summary>
 Checks for well known member and reports diagnostics if the member is Nothing or has UseSiteError.
 Returns True in case diagnostics was actually reported
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.CacheToLocalIfNotConst(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.SynthesizedLocalKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)">
 <summary>
 If value is const, returns the value unchanged.
 
 In a case if value is not a const, a proxy temp is created and added to "locals"
 In addition to that, code that evaluates and stores the value is added to "expressions"
 The access expression to the proxy temp is returned.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.GenerateSequenceValueSideEffects(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression})">
 <summary>
 Helper method to create a bound sequence to represent the idea:
 "compute this value, and then compute this side effects while discarding results"

 A Bound sequence is generated for the provided expr and side-effects, say {se1, se2, se3}, as follows:

 If expr is of void type:
     BoundSequence { side-effects: { expr, se1, se2, se3 }, valueOpt: Nothing }
 
 ElseIf expr is a constant:
     BoundSequence { side-effects: { se1, se2, se3 }, valueOpt: expr }
 
 Else
     BoundSequence { side-effects: { tmp = expr, se1, se2, se3 }, valueOpt: tmp }
 </summary>
 <remarks>
 NOTE: Supporting cases where side-effects change the value (or to detect such cases)
 NOTE: could be complicated. We do not support this currently and instead require
 NOTE: value expr to be not LValue.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.VisitExpressionNode(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Helper function that visits the given expression and returns a BoundExpression.
 Please use this instead of DirectCast(Visit(expression), BoundExpression)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.RewriteWinRtEvent(Microsoft.CodeAnalysis.VisualBasic.BoundAddRemoveHandlerStatement,Microsoft.CodeAnalysis.VisualBasic.BoundEventAccess,System.Boolean)">
 <summary>
 If we have a WinRT type event, we need to encapsulate the adder call
 (which returns an EventRegistrationToken) with a call to 
 WindowsRuntimeMarshal.AddEventHandler or RemoveEventHandler, but these
 require us to create a new Func representing the adder and another
 Action representing the remover.
 
 The rewritten call looks something like:
 
 WindowsRuntimeMarshal.AddEventHandler(Of TEventHandler)(
            New Func(Of TEventHandler, EventRegistrationToken)([object].add_T), 
            New Action(Of EventRegistrationToken)([object].remove_T), 
            New TEventHandler(Me.OnSuspending))
 
 
 where [object] is a compiler-generated local temp.
 
 For a remover, the call looks like:
 
 WindowsRuntimeMarshal.RemoveEventHandler(Of TEventHandler)(
            New Action(Of EventRegistrationToken)([object].remove_T), 
            New TEventHandler(Me.OnSuspending))
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.VisitAssignmentOperatorSimple(Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator)">
 <summary>
 Make sure GetObjectValue calls are injected.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.GenerateObjectCloneIfNeeded(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Apply GetObjectValue call if needed.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.GenerateObjectCloneIfNeeded(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Apply GetObjectValue call if needed.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.InitWithParameterlessValueTypeConstructor(Microsoft.CodeAnalysis.VisualBasic.BoundConversion,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary> Given bound conversion node and the type the conversion is being done to initializes 
 bound conversion node with the reference to parameterless value type constructor and returns 
 modified bound node.
 In case the constructor is not accessible from current context, or there is no parameterless
 constructor found in the type (which should never happen, because in such cases a synthesized 
 constructor is supposed to be generated)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.VisitFieldOrPropertyInitializer(Microsoft.CodeAnalysis.VisualBasic.BoundFieldOrPropertyInitializer,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Field initializers need to be rewritten multiple times in case of an AsNew declaration with multiple field names because the 
 initializer may contain references to the current field like in the following example:
 Class C1
     Public x, y As New RefType() With {.Field1 = .Field2}
 End Class 
 
 in this example .Field2 references the temp that is created for x and y.
 
 We moved the final rewriting for field initializers to the local 
 rewriters because here we already have the infrastructure to replace placeholders. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.VisitForEachStatement(Microsoft.CodeAnalysis.VisualBasic.BoundForEachStatement)">
 <summary>
 Rewrites a for each statement.
 </summary>
 <param name="node">The node.</param><returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.RewriteForEachArrayOrString(Microsoft.CodeAnalysis.VisualBasic.BoundForEachStatement,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundStatement},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol},System.Boolean,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Rewrites a for each over an one dimensional array or a string.
 
 As an optimization, if c is an array type of rank 1, the form becomes:

     Dim collectionCopy As C = c
     Dim collectionIndex As Integer = 0
     Do While collectionIndex &lt; len(collectionCopy)    ' len(a) represents the LDLEN opcode
         dim controlVariable = DirectCast(collectionCopy(collectionIndex), typeOfControlVariable)
         &lt;loop body&gt;
     continue:
         collectionIndex += 1
     postIncrement:
     Loop

 An iteration over a string becomes
     Dim collectionCopy As String = c
     Dim collectionIndex As Integer = 0
     Dim limit as Integer = s.Length
     Do While collectionIndex &lt; limit
         dim controlVariable = DirectCast(collectionCopy.Chars(collectionIndex), typeOfControlVariable)
         &lt;loop body&gt;
     continue:
         collectionIndex += 1
     postIncrement:
     Loop
 </summary>
 <param name="node">The node.</param>
 <param name="statements">The statements.</param>
 <param name="locals">The locals.</param>
 <param name="isArray">if set to <c>true</c> [is array].</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.CreateLocalAndAssignment(Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundLocal@,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol},Microsoft.CodeAnalysis.SynthesizedLocalKind)">
 <summary>
 Creates a local and assigns it the given bound expression.
 </summary>
 <param name="syntaxNode">The syntax node.</param>
 <param name="initExpression">The initialization expression.</param>
 <param name="boundLocal">The bound local.</param>
 <param name="locals">The locals.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.CreateIndexIncrement(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundLocal)">
 <summary>
 Creates the index increment statement.
 </summary>
 <param name="syntaxNode">The syntax node.</param>
 <param name="boundIndex">The bound index expression (bound local).</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.CreateLoweredWhileStatements(Microsoft.CodeAnalysis.VisualBasic.BoundForEachStatement,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundLocal,Microsoft.CodeAnalysis.VisualBasic.BoundStatement,Microsoft.CodeAnalysis.VisualBasic.BoundStatement,System.Boolean)">
 <summary>
 Creates the while statement for the for each rewrite
 </summary>
 <param name="limit">The limit to check the index against.</param>
 <param name="index">The index.</param>
 <param name="currentAssignment">The assignment statement of the current value.</param>
 <param name="incrementAssignment">The increment statement.</param>
 <param name="forEachStatement">The bound for each node.</param>
 <returns>The lowered statement list for the while statement.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.RewriteForEachIEnumerable(Microsoft.CodeAnalysis.VisualBasic.BoundForEachStatement,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundStatement},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol})">
 <summary>
 Rewrite a for each that uses IEnumerable. It's basic form is:

     Dim e As E = c.GetEnumerator()
     Do While e.MoveNext()
        controlVariable = e.Current
        &lt;loop body&gt;
     Loop

 To support disposable enumerators, the compiler will generate code to dispose the
 enumerator after loop termination.  Only when E implements IDisposable can this be done.
 The one exception to this rule is when E is specifically IEnumerator, in which case
 the compiler will generate code to dynamically query the enumerator to determine
 if it implements IDisposable.

 If E is IEnumerator the loop becomes:

     Dim e As IEnumerator = c.GetEnumerator()
     Try
         Do While e.MoveNext()
            dim controlVariable = e.Current
            &lt;loop body&gt;
         Loop
     Finally
         If TryCast(e, IDisposable) IsNot Nothing then
             CType(e, IDisposable).Dispose()
         End If
     End Try

 If E is known at compile time to implement IDisposable the loop becomes:

     Dim e As E = c.GetEnumerator()
     Try
         Do While e.MoveNext()
            dim controlVariable = e.Current
            &lt;loop body&gt;
         Loop
     Finally
         If Not e Is Nothing Then
             CType(e, IDisposable).Dispose()
         End If
     End Try

 The exception to these forms is the existence of On Error in which case the Try/Finally
 block will be eliminated (instead the body of the Finally will immediately follow
 the end of the loop).
 </summary>
 <param name="node"></param>
 <param name="statements"></param>
 <param name="locals"></param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.GenerateDisposeCallForForeachAndUsing(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundLocal,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Depending on whether the bound local's type is, implements or inherits IDisposable for sure, or might implement it,
 this function returns the statements to call Dispose on the bound local.
 
 If it's known to implement IDisposable, the generated code looks like this for reference types:
     If e IsNot Nothing Then
       CType(e, IDisposable).Dispose()
     End If
 or
 e.Dispose()
 for value types (including type parameters with a value constraint).
 Otherwise it looks like the following
     If TryCast(e, IDisposable) IsNot Nothing then
       CType(e, IDisposable).Dispose()
     End If
 </summary>
 <remarks>This method is used by the for each rewriter and the using rewriter. The latter should only call 
 this method with both IsOrInheritsFromOrImplementsIDisposable and needToDispose set to true, as using is not
 pattern based and must implement IDisposable.
 </remarks>
 <param name="syntaxNode">The syntax node.</param>
 <param name="rewrittenBoundLocal">The bound local.</param>
 <param name="rewrittenCondition">The condition used in the if statement around the dispose call</param>
 <param name="IsOrInheritsFromOrImplementsIDisposable">A flag indicating whether the bound local's type is,
 inherits or implements IDisposable or not.</param>
 <param name="rewrittenDisposeConversion">Conversion from the local type to IDisposable</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.LocalVariableSubstituter">
 <summary>
 Internal helper class to replace local symbols in bound locals of a given bound tree.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.VisitForToStatement(Microsoft.CodeAnalysis.VisualBasic.BoundForToStatement)">
 <summary>
 Rewrites ForTo loop.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.NegateIfStepNegative(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Negates the value if step is negative
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.RewriteForLoopCondition(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundForToUserDefinedOperators,Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLocal)">
 <summary>
 Given the control variable, limit and step, produce the loop condition.
 The principle is simple - 
       if step is negative (stepping "Up") then it is "control >= limit"
       otherwise it is "control &lt;= limit"
 
 It gets more complicated when step is not a constant or not a numeric or 
 involves overloaded comparison/IsTrue operators
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.TryGetSpecialMember``1(``0@,Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Attempt to retrieve the specified special member, reporting a use-site diagnostic if the member is not found.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.RewriteLocalDeclarationAsInitializer(Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclaration,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedStaticLocalBackingField,Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedStaticLocalBackingField},System.Boolean)">
 <summary>
 Replaces local declaration with its initializer
 Also marks resulting statement with seq point that matches original declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.ProcessNullableOperand(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol}@,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundExpression}@,System.Boolean)">
 <summary>
 Splits nullable operand into a hasValueExpression and an expression that represents underlying value (returned).
 
 Underlying value can be called after calling hasValueExpr without duplicated side-effects.
 Note that hasValueExpr is guaranteed to have NO SIDE-EFFECTS, while result value is 
 expected to be called exactly ONCE. That is the normal pattern in operator lifting.
 
 All necessary temps and side-effecting initializations are appended to temps and inits
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.CaptureNullableIfNeeded(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLocal@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression@,System.Boolean)">
 <summary>
 Returns a NOT-SIDE-EFFECTING expression that represents results of the operand
 If such transformation requires a temp, the temp and its initializing expression
 are returned in temp/init
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.NullableValueOrDefault(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Returns expression that -
 a) evaluates the operand if needed
 b) produces it's ValueOrDefault.
 The helper is familiar with wrapping expressions and will go directly after the value 
 skipping wrap/unwrap steps.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.NullableHasValue(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Evaluates expr and calls HasValue on it.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.NullableNull(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Checks that candidate Null expression is a simple expression that produces Null of the desired type
 (not a conversion or anything like that) and returns it.
 Otherwise creates "New T?()" expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.HasNoValue(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 returns true when expression has NO SIDE-EFFECTS and is known to produce nullable NULL
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.HasValue(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Returns true when expression is known to produce nullable NOT-NULL
 NOTE: unlike HasNoValue case, HasValue expressions may have side-effects.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.MakeBinaryExpression(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Helper to generate binary expressions.
 Performs some trivial constant folding.
 TODO: Perhaps belong to a different file
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.MakeBooleanBinaryExpression(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Simpler helper for binary expressions.
 When operand are boolean, the result type is same as operand's and is never checked 
 so do not need to pass that in.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.MakeSequence(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Takes two expressions and makes sequence.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.MakeSequence(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Takes two expressions and makes sequence.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.MakeTernaryConditionalExpression(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Takes two expressions and makes sequence.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.GetSideeffects(Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Returns an expression that can be used instead of the original one when
 we want to run the expression for side-effects only (i.e. we intend to ignore result).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.RewriteCollectionInitializerExpression(Microsoft.CodeAnalysis.VisualBasic.BoundCollectionInitializerExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Rewrites a CollectionInitializerExpression to a list of Add calls and returns the temporary.
 E.g. the following code:
     Dim x As New CollectionType(param1) From {1, {2, 3}, {4, {5, 6, 7}}}
 gets rewritten to 
     Dim temp as CollectionType 
     temp = new CollectionType(param1)
     temp.Add(1)
     temp.Add(2, 3)
     temp.Add(4, {5, 6, 7})
     x = temp
 where the last assignment is not part of this rewriting, because the BoundCollectionInitializerExpression
 only represents the object creation expression with the initialization.
 </summary>
 <param name="node">The BoundCollectionInitializerExpression that should be rewritten.</param>
 <returns>A bound sequence for the object creation expression containing the invocation expressions.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.RewriteObjectInitializerExpression(Microsoft.CodeAnalysis.VisualBasic.BoundObjectInitializerExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Rewrites a ObjectInitializerExpression to either a statement list (in case the there is no temporary used) or a bound
 sequence expression (in case there is a temporary used). The information whether to use a temporary or not is 
 stored in the bound object member initializer node itself.
 
 E.g. the following code:
     Dim x = New RefTypeName(param1) With {.FieldName1 = 23, .FieldName2 = .FieldName3, .FieldName4 = x.FieldName1}
 gets rewritten to 
     Dim temp as RefTypeName 
     temp = new RefTypeName(param1)
     temp.FieldName1 = 23
     temp.FieldName2 = temp.FieldName3
     temp.FieldName4 = x.FieldName1
     x = temp
 where the last assignment is not part of this rewriting, because the BoundObjectInitializerExpression
 only represents the object creation expression with the initialization.
 
 In a case where no temporary is used the following code:
     Dim x As New ValueTypeName(param1) With {.FieldName1 = 23, .FieldName2 = .FieldName3, .FieldName4 = x.FieldName1}
 gets rewritten to 
     x = new ValueTypeName(param1)
     x.FieldName1 = 23
     x.FieldName2 = x.FieldName3
     x.FieldName4 = x.FieldName1
 </summary>
 <param name="node">The BoundObjectInitializerExpression that should be rewritten.</param>
 <returns>A bound sequence for the object creation expression containing the invocation expressions, or a 
 bound statement list if no temporary should be used.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.RewriteReturnStatement(Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement)">
 <summary>
 Rewrites Return as a GoTo is needed (if not the last statement in a method)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.FlattenConcatArg(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundExpression})">
 <summary>
 digs into known concat operators and unwraps their arguments
 otherwise returns the expression as-is
 
 Generally we only need to recognize same node patterns that we create as a result of concatenation rewrite.
 We could recognize some other nodes and unwrap to arguments 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.TryFoldTwoConcatOperands(Microsoft.CodeAnalysis.VisualBasic.SyntheticBoundNodeFactory,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 folds two concat operands into one expression if possible
 otherwise returns null
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.TryFoldTwoConcatConsts(Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.ConstantValue)">
 <summary>
 folds two concat constants into one if possible
 otherwise returns null.
 It is generally always possible to concat constants, unless resulting string would be too large.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.RewriteStringConcatenationOneExpr(Microsoft.CodeAnalysis.VisualBasic.SyntheticBoundNodeFactory,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Strangely enough there is such a thing as unary concatenation and it must be rewritten.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.HasSideEffects(Microsoft.CodeAnalysis.VisualBasic.BoundStatement)">
 <summary>
 Is there any code to execute in the given statement that could have side-effects,
 such as throwing an exception? This implementation is conservative, in the sense
 that it may return true when the statement actually may have no side effects.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.VisitUsingStatement(Microsoft.CodeAnalysis.VisualBasic.BoundUsingStatement)">
 <summary>
 A using statement of the form:
      using Expression
          list_of_statements
      end using

 will be rewritten into:

      temp = Expression
      Try
          list_of_statements
      Finally
          If Temp IsNot Nothing Then
              CType(temp, IDisposable).Dispose()
          End If
      End Try

 when the resource is a using locally declared variable no temporary is generated but the variable is read-only
 A using statement of the form:
      Using v As New MyDispose()
          list_of_statements
      End Using

 is rewritten to:
 
      Dim v As New MyDispose()
      Try
         list_of_statements
      Finally
          If v IsNot Nothing Then
              CType(v, IDisposable).Dispose()
          End If
      End Try

 A using with multiple variable resources are equivalent to a nested using statement.
 So a using statement of the form:
      Using v1 As New MyDispose(), v2 As myDispose = New MyDispose()
          list_of_statements
      end using

 is rewritten to:
      Dim v1 As New MyDispose
      Try
          Dim v2 As MyDispose = new MyDispose()
          Try
              list_of_statements
          Finally
              If v2 IsNot Nothing Then
                  CType(v2, IDisposable).Dispose()
              End If
          End Try
      Finally
          If v1 IsNot Nothing Then
              CType(v1, IDisposable).Dispose()
          End If
      end try
</summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.RewriteSingleUsingToTryFinally(Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Roslyn.Utilities.ValueTuple{Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression}@,Microsoft.CodeAnalysis.VisualBasic.BoundBlock)">
 <summary>
 Creates a TryFinally Statement for the given resource.
 
 This method creates the following for the arguments:
      &lt;localSymbol&gt; = &lt;initializationExpression&gt;
      Try
         &lt;currentBody&gt;
      Finally
          If &lt;disposeCondition&gt; Then
              &lt;disposeConversion&gt;.Dispose()
          End If
      End Try
 
 Note: this is used for both kinds of using statements (resource locals and resource expressions).
 
 </summary>
 <returns>The new bound block containing the assignment of the initialization and the try/finally statement with
 the passed body.</returns>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter._valueTypesCleanUpCache">
 <summary>
 Cache of value types which were already calculated by LocalOrFieldNeedsToBeCleanedUp 
 in this lowering, serves as an optimization 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.CreateTempLocal(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundExpression})">
 <summary>
 Create a temp local of the given type and initial value.
 The resulting local is treated as an rvalue, and the
 initialization assignment is added to 'sideEffects'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.CreateCompilerGeneratedArray(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression})">
 <summary>
 Create a BoundExpression representing an array creation initialized with the given items.
 If there are zero items, the result is a BoundLiteral Nothing, otherwise, a BoundArrayCreation.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1">
 <summary> 
 A bound node rewriter that rewrites types properly (which in some cases the automatically-generated). 
 This is used in the lambda rewriter, the iterator rewriter, and the async rewriter.
 </summary>    
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1.SynthesizedWrapperMethod">
 <summary>
 A method that wraps the call to a method through MyBase/MyClass receiver.
 </summary>
 <remarks>
 <example>
 Class A
     Protected Overridable Sub F(a As Integer)
     End Sub
 End Class
 
 Class B
     Inherits A
 
     Public Sub M()
         Dim b As Integer = 1
         Dim f As System.Action = Sub() MyBase.F(b)
     End Sub
 End Class
 </example>
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1.SynthesizedWrapperMethod.#ctor(Microsoft.CodeAnalysis.VisualBasic.Symbols.InstanceTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,System.String,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Creates a symbol for a method that wraps the call to a method through MyBase/MyClass receiver.
 </summary>
 <param name="containingType">Type that contains wrapper method.</param>
 <param name="methodToWrap">Method to wrap</param>
 <param name="wrapperName">Wrapper method name</param>
 <param name="syntax">Syntax node.</param>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1.Proxies">
 <summary>
 For each captured variable, the corresponding field of its frame
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1.LocalMap">
 <summary>
 A mapping from every local variable to its replacement local variable. Local variables 
 are replaced when their types change due to being inside of a lambda within a generic method.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1.ParameterMap">
 <summary>
 A mapping from every parameter to its replacement parameter. Local variables 
 are replaced when their types change due to being inside of a lambda.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1.TypeMap">
 <summary>
 The mapping of type parameters for the current lambda body
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1.CurrentMethod">
 <summary>
 The method (e.g. lambda) which is currently being rewritten. If we are 
 rewriting a lambda, currentMethod is the new generated method.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1.CompilationState">
 <summary>
 A not-null collection of synthesized methods generated for the current source type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1.PreserveOriginalLocals">
 <summary>
 During rewriting, we ignore locals that have already been rewritten to a proxy (a field on a closure class).
 However, in the EE, we need to preserve the original slots for all locals (slots for any new locals must be
 appended after the originals).  The <see cref="F:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1.PreserveOriginalLocals"/> field is intended to suppress any
 rewriter logic that would result in original locals being omitted.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1.VisitMethodSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 Rewrites method.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1.VisitPropertySymbol(Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol)">
 <summary>
 Rewrites property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1.VisitFieldSymbol(Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol)">
 <summary>
 Rewrites field.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.StateMachineFieldSymbol">
 <summary>
 Represents a synthesized state machine helper field.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1">
 <summary>
 </summary>
 <typeparam name="TProxy">
 Type used by State Machine rewriter to represent symbol proxy. Lambda rewriter as 
 well as iterator rewriter use simplified form of proxy as they only capture 
 locals as r-values in fields, async rewriter uses a different structure as a proxy
 because it has to capture l-values on stack as well
 </typeparam>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter.StateField">
 <summary>
 The "state" of the state machine that is the translation of the iterator method.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter.CachedState">
 <summary>
 Cached "state" of the state machine within the MoveNext method.  We work with a copy of
 the state to avoid shared mutable state between threads.  (Two threads can be executing
 in a Task's MoveNext method because an awaited task may complete after the awaiter has
 tested whether the subtask is complete but before the awaiter has returned)
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter.Dispatches">
 <summary>
 For each distinct label, the set of states that need to be dispatched to that label.
 Note that there is a dispatch occurring at every try-finally statement, so this
 variable takes on a new set of values inside each try block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter.FinalizerStateMap">
 <summary>
 A mapping from each state of the state machine to the new state that will be used to execute
 finally blocks in case the state machine is disposed.  The Dispose method computes the new 
 state and then runs MoveNext.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter._hasFinalizerState">
 <summary>
 A try block might have no state (transitions) within it, in which case it does not need
 to have a state to represent finalization.  This flag tells us whether the current try
 block that we are within has a finalizer state.  Initially true as we have the (trivial)
 finalizer state of -1 at the top level.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter._currentFinalizerState">
 <summary>
 If hasFinalizerState is true, this is the state for finalization from anywhere in this try block.
 Initially set to -1, representing the no-op finalization required at the top level.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter._hoistedVariables">
 <summary>
 The set of local variables and parameters that were hoisted and need a proxy.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter.ResumeLabelName">
 <summary>
 Implementation-specific name for labels to mark state machine resume points.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter.GenerateReturn(System.Boolean)">
 <summary>
 Generate return statements from the state machine method body.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter.MakeStateMachineScope(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol},Microsoft.CodeAnalysis.VisualBasic.BoundStatement)">
 <remarks>
 Must remain in sync with <see cref="M:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter.TryUnwrapBoundStateMachineScope(Microsoft.CodeAnalysis.VisualBasic.BoundStatement@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol}@)"/>.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter.TryUnwrapBoundStateMachineScope(Microsoft.CodeAnalysis.VisualBasic.BoundStatement@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol}@)">
 <remarks>
 Must remain in sync with <see cref="M:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter.MakeStateMachineScope(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol},Microsoft.CodeAnalysis.VisualBasic.BoundStatement)"/>.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.StateMachineMethodToClassRewriter.VisitTryStatement(Microsoft.CodeAnalysis.VisualBasic.BoundTryStatement)">
 <summary>
 The try statement is the most complex part of the state machine transformation.
 Since the CLR will not allow a 'goto' into the scope of a try statement, we must
 generate the dispatch to the state's label stepwise.  That is done by translating
 the try statements from the inside to the outside.  Within a try statement, we
 start with an empty dispatch table (representing the mapping from state numbers
 to labels).  During translation of the try statement's body, the dispatch table
 will be filled in with the data necessary to dispatch once we're inside the try
 block.  We generate that at the head of the translated try statement.  Then, we
 copy all of the states from that table into the table for the enclosing construct,
 but associate them with a label just before the translated try block.  That way
 the enclosing construct will generate the code necessary to get control into the
 try block for all of those states.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.PreserveInitialParameterValues">
 <summary>
 True if the initial values of locals in the rewritten method need to be preserved. (e.g. enumerable iterator methods)
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.TypeMap">
 <summary>
 Type substitution if applicable or Nothing
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.GenerateControlFields">
 <summary>
 Add fields to the state machine class that control the state machine.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.InitializeStateMachine(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.BoundStatement},Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol)">
 <summary>
 Initialize the state machine class.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.GenerateStateMachineCreation(Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Generate implementation-specific state machine initialization for the kickoff method body.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.GenerateMethodImplementations">
 <summary>
 Generate implementation-specific state machine member method implementations.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1.EnsureAllSymbolsAndSignature">
 <summary>
 If any required special/well-known type/member is not found or has use-site errors
 we should not continue with transformation because it may have unwanted consequences;
 e.g. we do return Nothing if well-known member symbol is not found. This method should 
 check all required symbols and return False if any of them are missing or have use-site errors.
 We will also return True if signature is definitely bad - contains parameters that are ByRef or have error types
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SynthesizedStateMachineMethod">
 <summary>
 This class represents a type symbol for compiler generated implementation methods,
 the method being implemented is passed as a parameter and is used to build
 implementation method's parameters, return value type, etc...
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SynthesizedStateMachineMoveNextMethod">
 <summary>
 Represents a state machine MoveNext method.
 Handles special behavior around inheriting some attributes from the original async/iterator method.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SynthesizedStateMachineDebuggerNonUserCodeMethod">
 <summary>
 Represents a state machine method other than a MoveNext method.
 All such methods are considered non-user code. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SynthesizedStateMachineProperty">
 <summary>
 This class represents a symbol for the compiler generated property that owns implemented getter (like IEnumerable.Current),
 The getter method being implemented is passed as a parameter and is used to build
 implementation property around it with appropriate parameters, return value type, etc...
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SynthesizedSubmissionFields">
 <summary>
 Tracks synthesized fields that are needed in a submission being compiled.
 </summary>
 <remarks>
 For every other submission referenced by this submission we add a field, so that we can access members of the target submission.
 A field is also needed for the host object, if provided.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SyntheticBoundNodeFactory">
 <summary> 
 A helper class for synthesizing quantities of code. 
 </summary>    
 <remarks>
 Code if the #If False out is code ported from C# that isn't currently used, and
 hence has no code coverage. It may or may not work correctly, but should be a useful
 starting point.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntheticBoundNodeFactory.AssignmentExpression(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression)">
 <summary>
 Assignment expressions in lowered form should always have suppressObjectClone = True
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntheticBoundNodeFactory.CheckSwitchSections(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundCaseBlock})">
 <summary> Check for (and assert that there are no) duplicate case labels in the switch. </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.UseTwiceRewriter.UseTwice(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLocal})">
 <summary>
 Given an expression that produces some result and 
 has some observable evaluation side effects, return two expressions:
   1) First - produces the same result with the same observable side effects,
   2) Second - produces the same result, but without observable side effects, whenever possible.
 
 This is used for compound assignment, method call ByRef parameter copy back, etc.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.WithExpressionRewriter.Result.Expression">
 <summary> Expression to be used instead of With statement expression placeholder </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.WithExpressionRewriter.Result.Locals">
 <summary> Locals being used </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.WithExpressionRewriter.Result.Initializers">
 <summary> Locals initialization expressions </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.WithExpressionRewriter.AnalyzeWithExpression(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Boolean)">
 <summary>
 Given an expression specified for With statement produces:
   1) Expression - an expression to be used instead of expression placeholder
   2) Locals - a set of locals used to capture parts of Expression
   3) Initializers - initializers for Locals
 
 To be used in With statement only!
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.OptionStrict">
 <summary>
 Represents the state of Option Strict checking.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Off">
 <summary>
 Option Strict is Off. No Option Strict checks are in effect.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Custom">
 <summary>
 The Option Strict checks generate warnings. (Note that other
 compile options may hide these warnings, or turn them into errors.)
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.OptionStrict.On">
 <summary>
 Option Strict is On. All Option Strict checks are in effect and produce errors.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.OptionsValidator">
 <summary>
 This class is used to validate the compiler options.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OptionsValidator.ParseImports(System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Parse the project level imports, adding errors to the errorBag as necessary
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OptionsValidator.IsValidNamespaceName(System.String)">
 <summary>
 Validate and parse the root namespace. If the root namespace string is a valid namespace name, the parsed
 version is returned. Otherwise Nothing is returned.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OptionsValidator.IsValidRootNamespaceComponent(System.String,System.Int32,System.Int32,System.Boolean)">
 <summary>
 Check if a string is a valid component of the root namespace. We use the usual
 VB identifier rules, but don't check for keywords (this is the same as previous versions).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BlockContext.SingleStatementOrDefault">
 <summary>
 Returns the statement if there is exactly one in the body,
 otherwise returns Nothing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BlockContext.OptionalBody">
 <summary>
 Return an empty body if the body is a single, zero-width EmptyStatement,
 otherwise returns the entire body.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ParseGetType">
 <summary>
 Parse GetType, 
 GetTypeExpression -> GetType OpenParenthesis GetTypeTypeName CloseParenthesis 
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ParseNameOf">
 <summary>
 Parse NameOf, 
 NameOfExpression -> NameOf OpenParenthesis Name CloseParenthesis 
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ParseTypeOf">
 <summary>
 Parse TypeOf ... Is ... or TypeOf ... IsNot ...
 TypeOfExpression -> "TypeOf" Expression "Is|IsNot" LineTerminator? TypeName
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.TransitionFromXmlToVB``1(``0)">
 <summary>
 Transition from scanning XML to scanning VB. As a result,
 any single line trivia is consumed and appended to the token
 which is assumed to be the token at the transition point.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ParseCast">
 <summary>
 ParseCast parses CType, DirectCast, TryCast.
 CCCastExpression ->   DirectCast ( CCExpression , TypeName ) 
                     | TryCast ( CCExpression , TypeName ) 
                     | CType ( CCExpression , TypeName ) 
                     { | CastTarget ( CCExpression ) }
 </summary>
 <returns>Cast</returns>
 <remarks>Dev10 ParseCType does not parse exact grammar in the spec, since dev10 accepts Expression whereas the grammar uses CCExpression.
 This function only does not parse CastTarget ( ... ), it is parsed in ParseTerm
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.GetLastNZWToken(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 gets the last token that has nonzero FullWidth. 
 NOTE: this helper will not descend into structured trivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.GetLastToken(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 gets the last token regardless if it has zero FullWidth or not 
 NOTE: this helper will not descend into structured trivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.AdjustTriviaForMissingTokens``1(``0)">
 <summary>
 Adjust the trivia on a node so that missing tokens are always before newline and colon trivia.
 Because new lines and colons are eagerly attached as trivia, missing tokens can end up incorrectly after the new line.
 This method moves the trailing non-whitespace trivia from the last token to the last zero with token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.AdjustTriviaForMissingTokensCore``1(``0)">
 <summary>
 Slow part of AdjustTriviaForMissingTokensCore where we actually do the work when we need to.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ParseCollectionInitializer">
 <summary>
  Parses a CollectionInitializer 
         CollectionInitializer -> "{" CollectionInitializerList "}"
         CollectionInitializerList ->  CollectionElement {"," CollectionElement}*
         CollectionElement -> Expression | CollectionInitializer
 </summary>
 <returns>CollectionInitializerSyntax</returns>
 <remarks>In the grammar ArrayLiteralExpression is a rename of CollectionInitializer</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ParseObjectInitializerList(System.Boolean,System.Boolean)">
 <summary>
 Parses
 "With "{" FieldInitializerList "}"
 FieldInitializerList -> FieldInitializer {"," FieldInitializer}*
 FieldInitializer -> {Key? "." IdentifierOrKeyword "="}? Expression
 
  e.g.
  Dim x as new Customer With {.Id = 1, .Name = "A"}
 </summary>
 <returns>ObjectMemberInitializer</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ParseObjectCollectionInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
   Parses an ObjectCollectionInitializer
         ObjectCollectionInitializer -> "from" CollectionInitializer
 
 </summary>
 <returns>ObjectCollectionInitializer</returns>
 <remarks>In Dev10 this was called ParseInitializerList.  It also took several boolean parameters.  
  These were always set as 
       AllowExpressionInitializers = true
       AllowAssignmentInitializers = false
       AnonymousTypeInitializer = false
       RequireAtleastOneInitializer = false
 
  While the grammar uses the nonterminal CollectionInitializer is modeled as an
  AnonymousArrayCreationExpression which has the identical syntax "{" Expression {"," Expression }* "}"
 </remarks>
 
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ParseAssignmentInitializer(System.Boolean)">
 <summary>
 Parses a FieldInitializer
 
 FieldInitializer -> ("key"? "." IdentifierOrKeyword "=")? Expression
 </summary>
 <param name="anonymousTypeInitializer">If true then allow the keyword "key" to prefix the field initializer</param>
 <returns></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ParseTypeName(System.Boolean,System.Boolean,System.Boolean@)">
 <summary>
 Parse and return a TypeName.  Assumes the CurrentToken is on the name.
 </summary>
 <param name="allowEmptyGenericArguments">Controls generic argument parsing</param>
 <param name="allowedEmptyGenericArguments">Controls generic argument parsing</param>
 <returns>TypeName</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ParseParameter(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax})">
 <summary>
     Parameter -> Attributes? ParameterModifiers* ParameterIdentifier ("as" TypeName)? ("=" ConstantExpression)?
 </summary>
 <param name="attributes"></param>
 <param name="modifiers"></param>
 <returns></returns>
 <remarks>>This replaces both ParseParameter and ParseOptionalParameter in Dev10</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ParseCustomEventDefinition(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax})">
 <summary>
 Parse a CustomEventMemberDeclaration
 </summary>
 <param name="attributes"></param>
 <param name="modifiers"></param>
 <returns></returns>
 <remarks>This code used to be in ParseEventDefinition.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.PeekToken(System.Int32)">
 <summary>
 Peeks in a stream of VB tokens.
 Note that the first token will be picked according to _allowLeadingMultilineTrivia
 The rest will be picked as regular VB as scanner does not always know what to do with
 line terminators and we assume that multiple token lookahead makes sense inside a single statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.GetNextToken(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState)">
 <summary>
 Consumes current token and gets the next one with desired state.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.GetNextSyntaxNode">
 <summary>
 Consumes current node and gets next one. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.AssertLanguageFeature(Microsoft.CodeAnalysis.VisualBasic.ERRID)">
 <summary>
 returns true if feature is available
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.CheckFeatureAvailability``1(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Feature,``0)">
 <summary>
 Check to see if the given <paramref name="feature"/> is available with the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.LanguageVersion"/>
 of the parser.  If it is not available a diagnostic will be added to the returned value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ReportUnrecognizedStatementError(Microsoft.CodeAnalysis.VisualBasic.ERRID,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax},System.Boolean,System.Boolean)">
 <summary>
 Create a bad statement.  Report an error only if the statement doesn't have one already
 </summary>
 <param name="ErrorId"></param>
 <param name="attributes"></param>
 <param name="modifiers"></param>
 <param name="createMissingIdentifier">If set to true a new missing identifier will be created and added to the incomplete member.</param>
 <param name="forceErrorOnFirstToken">If set to true the error will be attached to the first skipped token of the incomplete member.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ResyncAndConsumeStatementTerminator">
 <summary>
 Resyncs to next statement terminator. Used in Preprocessor
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.TryEatNewLine(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState)">
 <summary>
 If the current token is a newline statement terminator, then consume the token.
 </summary>
 <returns>True if the statement terminator was consumed</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.ParseStringLiteral">
 <summary>
 Parses StringLiteral
 </summary>
 <returns>LiteralNode</returns>
 <remarks>If the current Token is not StringLiteral then returns LiteralNode with missing token.</remarks>  
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.VerifyExpectedToken``1(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,``0@,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState)">
 <summary>
 Check that the current token is the expected kind, the current node is consumed and optionally a new line
 after the token.
 </summary>
 <param name="kind">The expected node kind.</param>
 <returns>A token of the expected kind.  This node may be an empty token with an error attached to it</returns>
 <remarks>Since nodes are immutable, the only way to create nodes with errors attached is to create a node without an error,
 then add an error with this method to create another node.</remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.TriviaChecker">
 <summary>
 Checks if the resulting Cref or Name attribute value has valid trivia
 Note, this may be applicable not only to regular trivia, but also to syntax 
 nodes added to trivia when the parser was recovering from errors
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser.IsAsciiColonTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Checks if the given <paramref name="node"/> is a colon trivia whose string representation is the COLON (U+003A) character from ASCII range
 (specifically excluding cases when it is the FULLWIDTH COLON (U+FF1A) character).
 See also: http://fileformat.info/info/unicode/char/FF1A
 </summary>
 <param name="node">A VB syntax node to check.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CConst">
 <summary>
 Base class of a compile time constant.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CConst`1">
 <summary>
 Represents a compile time constant.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender._nodeStack">
 <summary>
 Candidate nodes that may be reused.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender._change">
 <summary>
 The text changes combined into a single region.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender._affectedRange">
 <summary>
 The range from which we cannot reuse nodes.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender._currentNode">
 <summary>
 Current node. Not necessarily reusable or even a NonTerminal.
 Can be null if we are out of nodes.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender._currentPreprocessorState">
 <summary>
 preprocessor state before _currentNode
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender._nextPreprocessorStateGetter">
 <summary>
 preprocessor state getter after _currentNode
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender.ExpandToNearestStatements(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan)">
 <summary>
 Expand the span in the tree to encompass the
 nearest statements that the span overlaps.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender.NearestStatementThatContainsPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.Text.TextSpan)">
 <remarks>
 Not guaranteed to return the span of a StatementSyntax.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender.ExpandByLookAheadAndBehind(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan)">
 <summary>
 Expand the span in the tree by the maximum number
 of tokens required for look ahead and the maximum
 number of characters for look behind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender.TryPopNode">
 <summary>
 Moving to the next node on the stack.
 returns false if we are out of nodes.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender.TryCrumbleOnce">
 <summary>
 Crumbles current node onto the stack and pops one node into current.
 Returns false if current node cannot be crumbled.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender.ShouldCrumble(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Certain syntax node kinds should not be crumbled since
 re-using individual child nodes may complicate parsing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender.GetCurrentNode(System.Int32)">
 <summary>
 Advances to given position if needed (note: no way back)
 Gets a nonterminal that can be used for incremental.
 May return Nothing if such node is not available.
 Typically it is _currentNode.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender.GetCurrentSyntaxNode">
 <summary>
 Returns current candidate for reuse if there is one.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender.CanReuseNode(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Checks if node is reusable.
 The reasons for it not be usable are typically that it intersects affected range.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner">
 <summary>
 Creates red tokens for a stream of text
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.ProcessDirective(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DirectiveTriviaSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxListBuilder)">
 <summary>
 Entry point to directive processing for Scanner.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.ApplyDirectives(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.PreprocessorState,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Gets an initial preprocessor state and applies all directives from a given node.
 Entry point for blender
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.AccumulatorState">
 <summary>
 The possible states that the mini scanning can be in.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner._sb">
 <summary>
 DO NOT USE DIRECTLY.
 USE GetScratch()
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.GetDisabledTextAt(Microsoft.CodeAnalysis.Text.TextSpan)">
 <summary>
 Gets a chunk of text as a DisabledCode node.
 </summary>
 <param name="span">The range of text.</param>
 <returns>The DisabledCode node.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.ScanNewlineAsStatementTerminator(System.Char,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Accept a CR/LF pair or either in isolation as a newline.
 Make it a statement separator
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.ScanNewlineAsTrivia(System.Char)">
 <summary>
 Accept a CR/LF pair or either in isolation as a newline.
 Make it a whitespace
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.ScanMultilineTrivia">
 <summary>
 Consumes all trivia until a nontrivia char is found
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.TryScanSinglePieceOfMultilineTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxListBuilder)">
 <summary>
 Scans a single piece of trivia
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.ScanSingleLineTrivia">
 <summary>
 Scan trivia on one LOGICAL line
 Will check for whitespace, comment, EoL, implicit line break
 EoL may be consumed as whitespace only as a part of line continuation ( _ )
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.IsBlankLine(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxListBuilder)">
 <summary>
 Return True if the builder is a (possibly empty) list of
 WhitespaceTrivia followed by an EndOfLineTrivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.IsColonAndNotColonEquals(System.Char,System.Int32)">
 <summary>
 Return True if the character is a colon, and not part of ":=".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.IsIdentifier(System.String)">
 <remarks>
 Not intended for use in Expression Compiler scenarios.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.TryIdentifierAsContextualKeyword(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax@)">
 <summary>
 Try to convert an Identifier to a Keyword.  Called by the parser when it wants to force
 an identifier to be a keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.Page">
 <summary>
 page represents a cached array of chars.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.Page._pageStart">
 <summary>
 where page maps in the stream. Used to validate pages
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.Page._arr">
 <summary>
 page's buffer
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner._curPage">
 <summary>
 current page we are reading.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.GetPage(System.Int32)">
 <summary>
 gets a page for the position.
 will initialize it if we have cache miss
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.ScanSurrogatePair(System.Char,System.Int32)">
 <summary>
 0 - not a surrogate, 2 - is valid surrogate 
 1 is an error
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.TryCrumbleOnce">
 <summary>
 Crumbles currently available node (if available) into its components.
 The leftmost child becomes the current node.
 If operation is not possible (node has no children, there is no node), then returns false.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.GetCurrentSyntaxNode">
 <summary>
 Gets current reusable syntax node.
 If node is returned its start will be aligned with the start of current token. 
 NOTE: Line offset may not match start of current token because of lookahead. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.MoveToNextSyntaxNode">
 <summary>
 Indicates that previously returned node has been consumed
 and scanner needs to advance by the size of the node.
 
 NOTE: the advancement is done relative to the start of the current token.
 Line offset may not match start of current token because of lookahead. 
 
 This operation will discard lookahead tokens and reset preprocessor state 
 to the state of current token. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.MoveToNextSyntaxNodeInTrivia">
 <summary>
 Indicates that previously returned node has been consumed
 and scanner needs to advance by the size of the node.
 
 NOTE: the advancement is done relative to the _lineBufferOffset.
 Line offset will likely not match start of current token because this operation
 is done while constructing the content of current token.
 
 NOTE: This operation assumes that there is no tokens read ahead.
 
 NOTE: This operation does not change preprocessor state. 
 The assumption is that it is responsibility of the node consumer to update preprocessor
 state if needed when using nodes that change preprocessor state.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.PeekToken(System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState)">
 <summary>
 note that state is applied only to the token #1
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner._endOfXmlInsteadOfLastDocCommentLineBreak">
 <remarks>See description in TryScanXmlDocComment(...)</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.ForceScanningXmlDocMode">
 <summary>
 This method is only to be used for parsing Cref and Name attributes as stand-alone entities
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner.ScanXmlTriviaInXmlDoc(System.Char,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxListBuilder{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Returns False if trivia ends line.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.VB">
 <summary>
 Scan VB tokens
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.VBAllowLeadingMultilineTrivia">
 <summary>
 Scan VB tokens but consume multiline trivia before token. Done at the start of a new statement except after line if.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.Misc">
 <summary>
 Scan tokens in Xml misc state, these are tokens between document declaration and the root element
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.DocType">
 <summary>
 Scan tokens inside of &lt;!DOCTYPE ... &gt;
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.Element">
 <summary>
 Scan tokens inside of &lt; ... &gt;
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.EndElement">
 <summary>
 Scan tokens inside of &lt;/ ...&gt;
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.SingleQuotedString">
 <summary>
 Scan a single quoted string
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.SmartSingleQuotedString">
 <summary>
 Scan a single quoted string RIGHT_SINGLE_QUOTATION_MARK
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.QuotedString">
 <summary>
 Scan a quoted string
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.SmartQuotedString">
 <summary>
 Scan a quoted string RIGHT_DOUBLE_QUOTATION_MARK
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.UnQuotedString">
 <summary>
 Scan a string that is missing quotes (error recovery)
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.Content">
 <summary>
 Scan text between markup
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.CData">
 <summary>
 Scan text inside of &lt;![CDATA[ ... ]]&gt;
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.StartProcessingInstruction">
 <summary>
 Scan first text inside f &lt;? ... ?&gt;, the first text can have leading trivia
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.ProcessingInstruction">
 <summary>
 Scan remaining text inside of &lt;? ... ?&gt;
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.Comment">
 <summary>
 Scan text inside of &lt;!-- ... --&gt;
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.InterpolatedStringPunctuation">
 <summary>
 Scan punctuation in an interpolated string.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.InterpolatedStringContent">
 <summary>
 Scan interpolated string text content.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState.InterpolatedStringFormatString">
 <summary>
 Scan interpolated string format string text content (no newlines).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ComplexIdentifierSyntax.PossibleKeywordKind">
 <summary>
 Contextual Nodekind
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ComplexIdentifierSyntax.IsBracketed">
 <summary>
 If true, the identifier was enclosed in brackets, such as "[End]".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ComplexIdentifierSyntax.IdentifierText">
 <summary>
 The text of the identifier, not including the brackets or type character.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ComplexIdentifierSyntax.TypeCharacter">
 <summary>
 The type character suffix, if present. Returns TypeCharacter.None if no type
 character was present. The only allowed values are None, Integer, Long,
 Decimal, Single, Double, and String.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DocumentationCommentTriviaSyntax">
 <summary>
 Represents a documentation comment e.g. ''' &lt;Summary&gt; appearing in
 source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DocumentationCommentTriviaSyntax.Content">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax">
 <summary>
 Represents an identifier token. This might include brackets around the name,
 and a type character.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax.PossibleKeywordKind">
 <summary>
 Contextual Nodekind
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax.IsBracketed">
 <summary>
 If true, the identifier was enclosed in brackets, such as "[End]".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax.IdentifierText">
 <summary>
 The text of the identifier, not including the brackets or type character.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax.TypeCharacter">
 <summary>
 The type character suffix, if present. Returns TypeCharacter.None if no type
 character was present. The only allowed values are None, Integer, Long,
 Decimal, Single, Double, and String.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
 <summary>
 Gets the separator at the given index in this list.
 </summary>
 <param name="index">The index.</param><returns></returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleIdentifierSyntax.PossibleKeywordKind">
 <summary>
 Contextual Nodekind
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleIdentifierSyntax.IsBracketed">
 <summary>
 If true, the identifier was enclosed in brackets, such as "[End]".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleIdentifierSyntax.IdentifierText">
 <summary>
 The text of the identifier, not including the brackets or type character.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleIdentifierSyntax.TypeCharacter">
 <summary>
 The type character suffix, if present. Returns TypeCharacter.None if no type
 character was present. The only allowed values are None, Integer, Long,
 Decimal, Single, Double, and String.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StructuredTriviaSyntax">
 <summary>
 Abstract class that represent structured trivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Identifier(System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Create an identifier node without brackets or type character.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Identifier(System.String,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,System.Boolean,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Create an identifier node with brackets or type character.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Identifier(System.String)">
 <summary>
 Create an identifier node without brackets or type character or trivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MissingIdentifier">
 <summary>
 Create a missing identifier.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MissingIdentifier(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Create a missing contextual keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MissingKeyword(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Create a missing keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MissingPunctuation(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Create a missing punctuation mark.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MissingStringLiteral">
 <summary>
 Create a missing string literal.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MissingCharacterLiteralToken">
 <summary>
 Create a missing character literal.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MissingIntegerLiteralToken">
 <summary>
 Create a missing integer literal.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MissingToken(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Creates a copy of a token.
 <para name="err"></para>
 <para name="trivia"></para>
 </summary>
 <returns>The new token</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndOfFileToken(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxTrivia)">
 <summary>
 Create an end-of-text token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndOfFileToken">
 <summary>
 Create an end-of-text token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EmptyStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
 <param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndUsingStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndWithStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndSelectStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndStructureStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndEnumStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndInterfaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndClassStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndModuleStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndNamespaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndSubStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndFunctionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndGetStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndSetStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndPropertyStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndOperatorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndEventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndAddHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndRemoveHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndRaiseEventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndTryStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndSyncLockStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndBlockStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 EndBlockStatementSyntax. One of EndIfStatement, EndUsingStatement,
 EndWithStatement, EndSelectStatement, EndStructureStatement, EndEnumStatement,
 EndInterfaceStatement, EndClassStatement, EndModuleStatement,
 EndNamespaceStatement, EndSubStatement, EndFunctionStatement, EndGetStatement,
 EndSetStatement, EndPropertyStatement, EndOperatorStatement, EndEventStatement,
 EndAddHandlerStatement, EndRemoveHandlerStatement, EndRaiseEventStatement,
 EndWhileStatement, EndTryStatement, EndSyncLockStatement.
 </param>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CompilationUnit(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an entire source file of VB code.
 </summary>
 <param name="options">
 Represents the list of Option statements at the beginning of a source file.
 </param>
 <param name="imports">
 Represents the list of Imports statements at the beginning of a source file.
 </param>
 <param name="attributes">
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </param>
 <param name="members">
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </param>
 <param name="endOfFileToken">
 Represents the end of the source file. This token may have trivia (whitespace,
 comments, ...) attached to it.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.OptionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
 <param name="optionKeyword">
 The "Option" keyword.
 </param>
 <param name="nameKeyword">
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </param>
 <param name="valueKeyword">
 The keyword that identifiers the value being set for the option: On, Off, Text
 or Binary.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ImportsStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportsClauseSyntax})">
 <summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
 <param name="importsKeyword">
 The "Imports" keyword.
 </param>
 <param name="importsClauses">
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SimpleImportsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportAliasClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameSyntax)">
 <summary>
 Represents the clause of an Imports statement that imports all members of a
 type or namespace or aliases a type or namespace.
 </summary>
 <param name="alias">
 An optional alias for the namespace or type being imported.
 </param>
 <param name="name">
 The namespace or type being imported.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ImportAliasClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an alias identifier followed by an "=" token in an Imports clause.
 </summary>
 <param name="identifier">
 The identifier being introduced.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlNamespaceImportsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlAttributeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Defines a XML namespace for XML expressions.
 </summary>
 <param name="xmlNamespace">
 Identifies the XML namespace alias and URI.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NamespaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamespaceStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
 <param name="namespaceStatement">
 The statement that begins the NamespaceBlock.
 </param>
 <param name="members">
 The declarations contained in the namespace statement.
 </param>
 <param name="endNamespaceStatement">
 The End Namespace statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NamespaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameSyntax)">
 <summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
 <param name="namespaceKeyword">
 The "Namespace" keyword.
 </param>
 <param name="name">
 A (possibly dotted) name denoting the namespace being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ModuleBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModuleStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
 <param name="moduleStatement">
 The "Module" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
 <param name="endModuleStatement">
 The "End Module" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.StructureBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StructureStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
 <param name="structureStatement">
 The "Structure" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
 <param name="endStructureStatement">
 The "End Structure" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.InterfaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterfaceStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
 <param name="interfaceStatement">
 The "Interface" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
 <param name="endInterfaceStatement">
 The "End Interface" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ClassBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ClassStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
 <param name="classStatement">
 The "Class" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
 <param name="endClassStatement">
 The "End Class" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EnumBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
 <param name="enumStatement">
 The statement that begins the type or module.
 </param>
 <param name="members">
 The declarations contained in the enumeration.
 </param>
 <param name="endEnumStatement">
 The End XXX statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.InheritsStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax})">
 <summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
 <param name="inheritsKeyword">
 The "Inherits" keyword.
 </param>
 <param name="types">
 A list of the types being inherited.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ImplementsStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax})">
 <summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
 <param name="implementsKeyword">
 The "Implements" keyword.
 </param>
 <param name="types">
 A list of the types being implemented.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ModuleStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="moduleKeyword">
 The "Module" keyword.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.StructureStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="structureKeyword">
 The "Structure" keyword.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.InterfaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="interfaceKeyword">
 The "Interface" keyword.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ClassStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="classKeyword">
 The "Class" keyword.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EnumStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AsClauseSyntax)">
 <summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="enumKeyword">
 The "Enum" keyword.
 </param>
 <param name="identifier">
 The name of the enum being declared.
 </param>
 <param name="underlyingType">
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TypeParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the type parameter list in a declaration.
 </summary>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="ofKeyword">
 The "Of" keyword.
 </param>
 <param name="parameters">
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TypeParameter(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax)">
 <summary>
 Represents a type parameter on a generic type declaration.
 </summary>
 <param name="varianceKeyword">
 Represents the "In" or "Out" variance keyword on a type parameter, if present.
 If no variance modifier was present, Nothing is returned.
 </param>
 <param name="identifier">
 The name of the type parameter
 </param>
 <param name="typeParameterConstraintClause">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TypeParameterSingleConstraintClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstraintSyntax)">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
 <param name="asKeyword">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
 <param name="constraint">
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TypeParameterMultipleConstraintClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstraintSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
 <param name="asKeyword">
 The "As" keyword.
 </param>
 <param name="openBraceToken">
 The "{" token.
 </param>
 <param name="constraints">
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </param>
 <param name="closeBraceToken">
 The "}" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NewConstraint(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
 <param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ClassConstraint(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
 <param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.StructureConstraint(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
 <param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SpecialConstraint(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 SpecialConstraintSyntax. One of NewConstraint, ClassConstraint,
 StructureConstraint.
 </param>
 <param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TypeConstraint(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax)">
 <summary>
 Represents a type parameter constraint that is a type.
 </summary>
 <param name="type">
 The type describing the constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EnumMemberDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EqualsValueSyntax)">
 <summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
 <param name="initializer">
 An optional value for the enum member.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SubBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 The "End Sub" or "End Function" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.FunctionBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 The "End Sub" or "End Function" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MethodBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of MethodBlockSyntax.
 One of SubBlock, FunctionBlock.
 </param>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 The "End Sub" or "End Function" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ConstructorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SubNewStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a constructor block declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subNewStatement">
 The "Sub New" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endSubStatement">
 The "End Sub" statement that ends the block declaration.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.OperatorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OperatorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an Operator block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="operatorStatement">
 The "Operator" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endOperatorStatement">
 The "End Operator" statement that ends the block declaration.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.GetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AddHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.RemoveHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.RaiseEventAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AccessorBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of AccessorBlockSyntax.
 One of GetAccessorBlock, SetAccessorBlock, AddHandlerAccessorBlock,
 RemoveHandlerAccessorBlock, RaiseEventAccessorBlock.
 </param>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.PropertyBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
 <param name="propertyStatement">
 The property declaration that begins the block.
 </param>
 <param name="accessors">
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </param>
 <param name="endPropertyStatement">
 The End Property statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EventBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
 <param name="eventStatement">
 The event declaration that begins the block.
 </param>
 <param name="accessors">
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </param>
 <param name="endEventStatement">
 The End Event statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the parameter list in a method declaration.
 </summary>
 <param name="openParenToken">
 The "(" token that introduces the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="parameters">
 The list of parameters. If no parameter list was present, Nothing is returned.
 </param>
 <param name="closeParenToken">
 The ")" token that concludes the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SubStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this method declaration.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.FunctionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this method declaration.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MethodStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MethodStatementSyntax. One of SubStatement, FunctionStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this method declaration.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SubNewStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subKeyword">
 The "Sub" keyword.
 </param>
 <param name="newKeyword">
 The "New" keyword in the constructor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DeclareSubStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="declareKeyword">
 The "Declare" keyword.
 </param>
 <param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libKeyword">
 The "Lib" keyword.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
 <param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
 <param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DeclareFunctionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="declareKeyword">
 The "Declare" keyword.
 </param>
 <param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libKeyword">
 The "Lib" keyword.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
 <param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
 <param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DeclareStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="declareKeyword">
 The "Declare" keyword.
 </param>
 <param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libKeyword">
 The "Lib" keyword.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
 <param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
 <param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DelegateSubStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DelegateFunctionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DelegateStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DelegateStatementSyntax. One of DelegateSubStatement,
 DelegateFunctionStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax)">
 <summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="customKeyword">
 The optional Custom keyword for custom event declarations.
 </param>
 <param name="eventKeyword">
 The "Event" keyword that introduces this event declaration.
 </param>
 <param name="identifier">
 The name of the event being declared.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.OperatorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="operatorKeyword">
 The "Operator" keyword that introduces this operator declaration.
 </param>
 <param name="operatorToken">
 The operator being defined.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.PropertyStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EqualsValueSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax)">
 <summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="propertyKeyword">
 The "Property" keyword that introduces this property declaration.
 </param>
 <param name="identifier">
 The name of the property being declared.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="initializer">
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.GetAccessorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SetAccessorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AddHandlerAccessorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.RemoveHandlerAccessorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.RaiseEventAccessorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AccessorStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AccessorStatementSyntax. One of GetAccessorStatement, SetAccessorStatement,
 AddHandlerAccessorStatement, RemoveHandlerAccessorStatement,
 RaiseEventAccessorStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ImplementsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.QualifiedNameSyntax})">
 <summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
 <param name="implementsKeyword">
 The "Implements" keyword.
 </param>
 <param name="interfaceMembers">
 The list of interface members being implemented.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.HandlesClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseItemSyntax})">
 <summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
 <param name="handlesKeyword">
 The "Handles" keyword.
 </param>
 <param name="events">
 The list of event members being handled.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.KeywordEventContainer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents event container specified through special keywords "Me", "MyBase" or
 "MyClass"..
 </summary>
 <param name="keyword">
 The container of the event. This can be one of the special keywords: "Me",
 "MyBase" or "MyClass".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.WithEventsEventContainer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax)">
 <summary>
 Represents event container that refers to a WithEvents member.
 </summary>
 <param name="identifier">
 The container of the event. It is a simple identifier that refers to a
 WithEvents member of the containing type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.WithEventsPropertyEventContainer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithEventsEventContainerSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax)">
 <summary>
 Represents event container that refers to a WithEvents member's property.
 </summary>
 <param name="withEventsContainer">
 The container of the event.
 </param>
 <param name="dotToken">
 The "." token.
 </param>
 <param name="property">
 The provider of the event. It is a property of a WithEvents member of the
 containing type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.HandlesClauseItem(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventContainerSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax)">
 <summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
 <param name="eventContainer">
 The container of the event. This can either be a simple identifier (identifying
 a members of the containing type) or one of the special keywords "Me", "MyBase"
 or "MyClass".
 </param>
 <param name="dotToken">
 The "." token.
 </param>
 <param name="eventMember">
 The event being handled. This must be a simple identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IncompleteMember(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax)">
 <summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="missingIdentifier">
 The missing identifier token for this incomplete member. Should only be used to
 have a location for error reporting.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.FieldDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableDeclaratorSyntax})">
 <summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.VariableDeclarator(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EqualsValueSyntax)">
 <summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
 <param name="names">
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type, and possibly includes "New",
 "With" or "From". If no As clause was present, Nothing is returned.
 </param>
 <param name="initializer">
 If present, an "= initial-value" clause describing the initial value of the
 variable or the value of the constant.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SimpleAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax)">
 <summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
 <param name="asKeyword">
 The "As" keyword.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="type">
 The type-name part of the As clause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AsNewClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NewExpressionSyntax)">
 <summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
 <param name="asKeyword">
 The "As" keyword.
 </param>
 <param name="newExpression">
 The New expression
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ObjectMemberInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FieldInitializerSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
 <param name="withKeyword">
 The "With" keyword.
 </param>
 <param name="openBraceToken">
 The "{" token.
 </param>
 <param name="initializers">
 The comma-separated list of field initializers.
 </param>
 <param name="closeBraceToken">
 The "}" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ObjectCollectionInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionInitializerSyntax)">
 <summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
 <param name="fromKeyword">
 The "From" keyword.
 </param>
 <param name="initializer">
 The initializer including the braces.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.InferredFieldInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
 <param name="keyKeyword">
 The optional "Key" keyword.
 </param>
 <param name="expression">
 The value being assigned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NamedFieldInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
 <param name="keyKeyword">
 The optional "Key" keyword.
 </param>
 <param name="dotToken">
 The "." token.
 </param>
 <param name="name">
 The name of the field being initialized.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
 <param name="expression">
 The value being assigned to the field.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EqualsValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an "= initializer" clause in a declaration for a variable, parameter
 or automatic property.
 </summary>
 <param name="equalsToken">
 The "=" token.
 </param>
 <param name="value">
 The expression used as the initial value.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Parameter(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EqualsValueSyntax)">
 <summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this parameter. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
 modify this parameter.
 </param>
 <param name="identifier">
 The name of the parameter, including any "?" or "()" modifiers.
 </param>
 <param name="asClause">
 If present, the "As type-name" clause describing the type of the parameter. If
 no As clause is present, Nothing is returned.
 </param>
 <param name="default">
 If present, an initializer with the default value of the parameter. If no
 default value is present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ModifiedIdentifier(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
 <param name="identifier">
 The identifier that names the item being declared.
 </param>
 <param name="nullable">
 The "?" token that indicates a nullable type.
 </param>
 <param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
 <param name="arrayRankSpecifiers">
 A list of array modifiers for the type. If no array modifiers were present, an
 empty list is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ArrayRankSpecifier(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="commaTokens">
 The comma tokens in the array type. There is one less comma than the rank.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AttributeList(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
 <param name="lessThanToken">
 The "&lt;" token.
 </param>
 <param name="attributes">
 A comma separated list of attribute declarations in this attribute list.
 </param>
 <param name="greaterThanToken">
 The "&gt;" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Attribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeTargetSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax)">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
 <param name="target">
 Optional attribute target. Assembly|Module :
 </param>
 <param name="name">
 The name of the attribute.
 </param>
 <param name="argumentList">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AttributeTarget(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
 <param name="attributeModifier">
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </param>
 <param name="colonToken">
 The ":" token, if an attribute modifier is present. If no attribute modifier is
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AttributesStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
 <param name="attributeLists">
 The list of attribute lists.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExpressionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represent an expression in a statement context. This may only be a invocation
 or await expression in standard code but may be any expression in VB
 Interactive code.
 </summary>
 <param name="expression">
 The expression.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.PrintStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represent a "? expression" "Print" statement in VB Interactive code.
 </summary>
 <param name="questionToken">
 "?" token.
 </param>
 <param name="expression">
 The expression whose value is being output.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.WhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
 <param name="whileStatement">
 The While statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the While...End While. This might be an empty list.
 </param>
 <param name="endWhileStatement">
 The End While statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.UsingBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UsingStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
 <param name="usingStatement">
 The UsingStatement that begins the Using...End Using block.
 </param>
 <param name="statements">
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </param>
 <param name="endUsingStatement">
 The End Using statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SyncLockBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyncLockStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statement.
 </summary>
 <param name="syncLockStatement">
 The SyncLock statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </param>
 <param name="endSyncLockStatement">
 The End SyncLock statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.WithBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
 <param name="withStatement">
 The WithStatement that begins the With...End With block.
 </param>
 <param name="statements">
 The statements contained in the With...End With block. This might be an empty
 list.
 </param>
 <param name="endWithStatement">
 The End With statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LocalDeclarationStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableDeclaratorSyntax})">
 <summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
 <param name="modifiers">
 The modifier token (Static, Dim or Const) that introduces this local variable
 declaration.
 </param>
 <param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LabelStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a label statement.
 </summary>
 <param name="labelToken">
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </param>
 <param name="colonToken">
 The ":" token of the label statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.GoToStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents a "GoTo" statement.
 </summary>
 <param name="goToKeyword">
 The "GoTo" keyword.
 </param>
 <param name="label">
 The name of the label. If the label is a line number, wraps an IntegerLiteral
 that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IdentifierLabel(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NumericLabel(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NextLabel(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Label(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LabelSyntax. One of
 IdentifierLabel, NumericLabel, NextLabel.
 </param>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.StopStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
 <param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
 <param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.StopOrEndStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 StopOrEndStatementSyntax. One of StopStatement, EndStatement.
 </param>
 <param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExitDoStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExitForStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExitSubStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExitFunctionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExitOperatorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExitPropertyStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExitTryStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExitSelectStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExitWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExitStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of ExitStatementSyntax.
 One of ExitDoStatement, ExitForStatement, ExitSubStatement,
 ExitFunctionStatement, ExitOperatorStatement, ExitPropertyStatement,
 ExitTryStatement, ExitSelectStatement, ExitWhileStatement.
 </param>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ContinueWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
 <param name="continueKeyword">
 The "Continue" keyword.
 </param>
 <param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ContinueDoStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
 <param name="continueKeyword">
 The "Continue" keyword.
 </param>
 <param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ContinueForStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
 <param name="continueKeyword">
 The "Continue" keyword.
 </param>
 <param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ContinueStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 ContinueStatementSyntax. One of ContinueWhileStatement, ContinueDoStatement,
 ContinueForStatement.
 </param>
 <param name="continueKeyword">
 The "Continue" keyword.
 </param>
 <param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ReturnStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Return" statement.
 </summary>
 <param name="returnKeyword">
 The "Return" keyword.
 </param>
 <param name="expression">
 The expression being returned, if present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SingleLineIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineElseClauseSyntax)">
 <summary>
 Represents a single-line "If ... Then ... Else ..." statement.
 </summary>
 <param name="ifKeyword">
 The "If" keyword.
 </param>
 <param name="condition">
 The condition expression to be evaluated.
 </param>
 <param name="thenKeyword">
 The "Then" keyword.
 </param>
 <param name="statements">
 A list of statements to be executed if the condition expression evaluates as
 true. Multiple statements must be separated by colons.
 </param>
 <param name="elseClause">
 An "Else" clause to be executed if the condition expression evaluates as false.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SingleLineElseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents the "Else ..." clause of a single-line "If" statement.
 </summary>
 <param name="elseKeyword">
 The "Else" keyword.
 </param>
 <param name="statements">
 A list of statements to be executed. Multiple statements must be separated by
 colons.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MultiLineIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IfStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseBlockSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line "If ... Then ... ElseIf ... Then ... Else ... End If"
 block.
 </summary>
 <param name="ifStatement">
 The "If" statement that begins the "If" block.
 </param>
 <param name="statements">
 A list of statements to be executed if the condition expression evaluates as
 true.
 </param>
 <param name="elseIfBlocks">
 A list of "ElseIf" blocks to be evaluated, in order, if the condition
 expression of the "If" statement evaluates as false.
 </param>
 <param name="elseBlock">
 An "Else" block to be executed if the condition expression of the "If"
 statement and all "ElseIf" blocks evaluate as false.
 </param>
 <param name="endIfStatement">
 Then "End If" statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the "If ... Then" statement that begins a multi-line "If" block.
 </summary>
 <param name="ifKeyword">
 The "If" keyword.
 </param>
 <param name="condition">
 The condition expression to be evaluated.
 </param>
 <param name="thenKeyword">
 The "Then" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElseIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseIfStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents an "ElseIf ... Then ..." block.
 </summary>
 <param name="elseIfStatement">
 The "ElseIf ... Then" statement the begins the "ElseIf" block.
 </param>
 <param name="statements">
 A list of statements to be executed if the condition expression of the "ElseIf"
 statement evaluates as true.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElseIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the "ElseIf ... Then" statement that begins an "ElseIf" block.
 </summary>
 <param name="elseIfKeyword">
 The "ElseIf" keyword.
 </param>
 <param name="condition">
 The condition expression to be evaluated.
 </param>
 <param name="thenKeyword">
 The "Then" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents an "Else ..." block.
 </summary>
 <param name="elseStatement">
 The "Else" statement that begins the "Else" block.
 </param>
 <param name="statements">
 A list of statements to be executed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the "Else" statement that begins an "Else" block.
 </summary>
 <param name="elseKeyword">
 The "Else" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TryBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FinallyBlockSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a "Try ... Catch ... Finally ... End Try" block.
 </summary>
 <param name="tryStatement">
 The "Try" statement that begins the "Try" block.
 </param>
 <param name="statements">
 A list of statements to be executed.
 </param>
 <param name="catchBlocks">
 A list of "Catch" blocks which may be executed if an exception is thrown while
 executing the statements in the "Try" block.
 </param>
 <param name="finallyBlock">
 A "Finally" block to be executed before execution leaves the "Try" block.
 </param>
 <param name="endTryStatement">
 The "End Try" statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TryStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the "Try" statement that begins a "Try" block.
 </summary>
 <param name="tryKeyword">
 The "Try" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CatchBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents a "Catch ..." block.
 </summary>
 <param name="catchStatement">
 The "Catch" statement that begins the "Catch" block.
 </param>
 <param name="statements">
 A list of statements to be executed if an exception is caught by the "Catch"
 block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CatchStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchFilterClauseSyntax)">
 <summary>
 Represents the "Catch ... When ..." statement that begins a "Catch" block.
 </summary>
 <param name="catchKeyword">
 The "Catch" keyword.
 </param>
 <param name="identifierName">
 An identifier declaring a new variable or naming an existing variable to store
 the exception caught by the "Catch" statement.
 </param>
 <param name="asClause">
 A simple "As" clause specifying the type of exception to catch.
 </param>
 <param name="whenClause">
 A "When" clause to filter exceptions before catching.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CatchFilterClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents the "When ..." clause of a "Catch" statement.
 </summary>
 <param name="whenKeyword">
 The "When" keyword.
 </param>
 <param name="filter">
 The filter expression to be evaluated.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.FinallyBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FinallyStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents a "Finally ..." block of a "Try" block.
 </summary>
 <param name="finallyStatement">
 The "Finally" statement that begins the "Finally" block.
 </param>
 <param name="statements">
 A list of statements to be executed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.FinallyStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the "Finally" statement that begins a "Finally" block.
 </summary>
 <param name="finallyKeyword">
 The "Finally" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ErrorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents the "Error" statement.
 </summary>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="errorNumber">
 The expression that represents the error number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.OnErrorGoToZeroStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="goToKeyword">
 The "GoTo" keyword
 </param>
 <param name="minus">
 An optional minus for On Error Goto -1
 </param>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.OnErrorGoToMinusOneStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="goToKeyword">
 The "GoTo" keyword
 </param>
 <param name="minus">
 An optional minus for On Error Goto -1
 </param>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.OnErrorGoToLabelStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="goToKeyword">
 The "GoTo" keyword
 </param>
 <param name="minus">
 An optional minus for On Error Goto -1
 </param>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.OnErrorGoToStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 OnErrorGoToStatementSyntax. One of OnErrorGoToZeroStatement,
 OnErrorGoToMinusOneStatement, OnErrorGoToLabelStatement.
 </param>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="goToKeyword">
 The "GoTo" keyword
 </param>
 <param name="minus">
 An optional minus for On Error Goto -1
 </param>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.OnErrorResumeNextStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an OnError Resume Next statement.
 </summary>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="resumeKeyword">
 The "Resume" keyword.
 </param>
 <param name="nextKeyword">
 The "Next"
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ResumeStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="resumeKeyword">
 The "Resume" keyword.
 </param>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ResumeLabelStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="resumeKeyword">
 The "Resume" keyword.
 </param>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ResumeNextStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="resumeKeyword">
 The "Resume" keyword.
 </param>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SelectBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
 <param name="selectStatement">
 The Select Case statement that begins the block.
 </param>
 <param name="caseBlocks">
 A list of the contained Case blocks.
 </param>
 <param name="endSelectStatement">
 The End Select statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SelectStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
 <param name="selectKeyword">
 The "Select" keyword.
 </param>
 <param name="caseKeyword">
 The "Case" keyword, if present.
 </param>
 <param name="expression">
 The value that branching is based on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CaseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
 <param name="caseStatement">
 The statement that begins the case block.
 </param>
 <param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CaseElseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
 <param name="caseStatement">
 The statement that begins the case block.
 </param>
 <param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CaseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseClauseSyntax})">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
 <param name="caseKeyword">
 The "Case" keyword
 </param>
 <param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CaseElseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseClauseSyntax})">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
 <param name="caseKeyword">
 The "Case" keyword
 </param>
 <param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElseCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 The "Else" part in a Case Else statement.
 </summary>
 <param name="elseKeyword">
 The "Else" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SimpleCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a single value in a Case.
 </summary>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.RangeCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a range "expression To expression" in a Case.
 </summary>
 <param name="lowerBound">
 The lower bound of the range.
 </param>
 <param name="toKeyword">
 The "To" keyword
 </param>
 <param name="upperBound">
 The upper bound of the range.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CaseEqualsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CaseNotEqualsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CaseLessThanClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CaseLessThanOrEqualClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CaseGreaterThanOrEqualClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CaseGreaterThanClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.RelationalCaseClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 RelationalCaseClauseSyntax. One of CaseEqualsClause, CaseNotEqualsClause,
 CaseLessThanClause, CaseLessThanOrEqualClause, CaseGreaterThanOrEqualClause,
 CaseGreaterThanClause.
 </param>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SyncLockStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
 <param name="syncLockKeyword">
 The "SyncLock" keyword.
 </param>
 <param name="expression">
 The expression being synchronized on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SimpleDoLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DoWhileLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DoUntilLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DoLoopWhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DoLoopUntilBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DoLoopBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of DoLoopBlockSyntax.
 One of SimpleDoLoopBlock, DoWhileLoopBlock, DoUntilLoopBlock, DoLoopWhileBlock,
 DoLoopUntilBlock.
 </param>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SimpleDoStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="doKeyword">
 The "Do" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DoWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="doKeyword">
 The "Do" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DoUntilStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="doKeyword">
 The "Do" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DoStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of DoStatementSyntax.
 One of SimpleDoStatement, DoWhileStatement, DoUntilStatement.
 </param>
 <param name="doKeyword">
 The "Do" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SimpleLoopStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="loopKeyword">
 The "Loop" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LoopWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="loopKeyword">
 The "Loop" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LoopUntilStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="loopKeyword">
 The "Loop" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LoopStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LoopStatementSyntax.
 One of SimpleLoopStatement, LoopWhileStatement, LoopUntilStatement.
 </param>
 <param name="loopKeyword">
 The "Loop" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.WhileClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
 <param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
 <param name="condition">
 The boolean expression after the While or Until.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.UntilClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
 <param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
 <param name="condition">
 The boolean expression after the While or Until.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.WhileOrUntilClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 WhileOrUntilClauseSyntax. One of WhileClause, UntilClause.
 </param>
 <param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
 <param name="condition">
 The boolean expression after the While or Until.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.WhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
 <param name="whileKeyword">
 The "While" keyword.
 </param>
 <param name="condition">
 The boolean expression that controls the While loop.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ForBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NextStatementSyntax)">
 <summary>
 Represents a For block, including the introducing statement, the body and the
 "Next" (which can be omitted if a containing For has a Next with multiple
 variables).
 </summary>
 <param name="forStatement">
 The For statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
 <param name="nextStatement">
 The Next statement that ends the block. If two For or For Each statements are
 ended by a single Next statement, the inner For will not have a Next statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ForEachBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForEachStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NextStatementSyntax)">
 <summary>
 Represents a For Each block, including the introducing statement, the body and
 the "Next" (which can be omitted if a containing For has a Next with multiple
 variables).
 </summary>
 <param name="forEachStatement">
 The For Each statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
 <param name="nextStatement">
 The Next statement that ends the block. If two For or For Each statements are
 ended by a single Next statement, the inner For will not have a Next statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ForStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStepClauseSyntax)">
 <summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
 <param name="forKeyword">
 The "For" keyword.
 </param>
 <param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
 <param name="fromValue">
 The expression denoting the initial value of the iteration.
 </param>
 <param name="toKeyword">
 The "To" keyword.
 </param>
 <param name="toValue">
 The expression denoting the final value of the iteration.
 </param>
 <param name="stepClause">
 The optional Step clause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ForStepClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 The Step clause in a For Statement.
 </summary>
 <param name="stepKeyword">
 The "Step" keyword.
 </param>
 <param name="stepValue">
 The expression denoting the step increment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ForEachStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
 <param name="forKeyword">
 The "For" keyword.
 </param>
 <param name="eachKeyword">
 The "Each" keyword.
 </param>
 <param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
 <param name="inKeyword">
 The "In" keyword.
 </param>
 <param name="expression">
 The expression denoting the collection to iterate over.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NextStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax})">
 <summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
 <param name="nextKeyword">
 The "Next" keyword.
 </param>
 <param name="controlVariables">
 The variables in the Next statement, if present
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.UsingStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableDeclaratorSyntax})">
 <summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
 <param name="usingKeyword">
 The "Using" keyword.
 </param>
 <param name="expression">
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </param>
 <param name="variables">
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ThrowStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a Throw statement.
 </summary>
 <param name="throwKeyword">
 The "Throw" keyword
 </param>
 <param name="expression">
 The expression denoting the value being thrown.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SimpleAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MidAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AddAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SubtractAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MultiplyAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DivideAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IntegerDivideAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExponentiateAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LeftShiftAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.RightShiftAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ConcatenateAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AssignmentStatementSyntax. One of SimpleAssignmentStatement,
 MidAssignmentStatement, AddAssignmentStatement, SubtractAssignmentStatement,
 MultiplyAssignmentStatement, DivideAssignmentStatement,
 IntegerDivideAssignmentStatement, ExponentiateAssignmentStatement,
 LeftShiftAssignmentStatement, RightShiftAssignmentStatement,
 ConcatenateAssignmentStatement.
 </param>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MidExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax)">
 <summary>
 Represents a left-hand side of a MidAssignment statement.
 </summary>
 <param name="mid">
 The "Mid" possibly followed by a type character.
 </param>
 <param name="argumentList">
 The argument list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CallStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
 <param name="callKeyword">
 The "Call" keyword.
 </param>
 <param name="invocation">
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AddHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
 <param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
 <param name="eventExpression">
 The event being accessed.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.RemoveHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
 <param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
 <param name="eventExpression">
 The event being accessed.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AddRemoveHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AddRemoveHandlerStatementSyntax. One of AddHandlerStatement,
 RemoveHandlerStatement.
 </param>
 <param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
 <param name="eventExpression">
 The event being accessed.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.RaiseEventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax)">
 <summary>
 Represent a RaiseEvent statement.
 </summary>
 <param name="raiseEventKeyword">
 The "RaiseEvent" keyword
 </param>
 <param name="name">
 The name of the event being raised.
 </param>
 <param name="argumentList">
 The argument list, if present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.WithStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
 <param name="withKeyword">
 The "With" keyword.
 </param>
 <param name="expression">
 The expression that is the operand of the With statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ReDimStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RedimClauseSyntax})">
 <summary>
 Represents a ReDim statement.
 </summary>
 <param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
 <param name="preserveKeyword">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
 <param name="clauses">
 The list of ReDim clauses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ReDimPreserveStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RedimClauseSyntax})">
 <summary>
 Represents a ReDim statement.
 </summary>
 <param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
 <param name="preserveKeyword">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
 <param name="clauses">
 The list of ReDim clauses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.RedimClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax)">
 <summary>
 Represents a ReDim statement clause.
 </summary>
 <param name="expression">
 The target of the ReDim statement.
 </param>
 <param name="arrayBounds">
 The ArraySizeInitializationModifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EraseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax})">
 <summary>
 Represents an "Erase" statement.
 </summary>
 <param name="eraseKeyword">
 The "Erase" keyword.
 </param>
 <param name="expressions">
 A list of expressions denoting the arrays to erase.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CharacterLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TrueLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.FalseLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NumericLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DateLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.StringLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NothingLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LiteralExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 LiteralExpressionSyntax. One of CharacterLiteralExpression,
 TrueLiteralExpression, FalseLiteralExpression, NumericLiteralExpression,
 DateLiteralExpression, StringLiteralExpression, NothingLiteralExpression.
 </param>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ParenthesizedExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a parenthesized expression.
 </summary>
 <param name="openParenToken">
 The "(" token
 </param>
 <param name="expression">
 The expression inside the parentheses.
 </param>
 <param name="closeParenToken">
 The ")" token
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Identifies the special instance "Me"
 </summary>
 <param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MyBaseExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Identifies the special instance "MyBase"
 </summary>
 <param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MyClassExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Identifies the special instance "MyClass"
 </summary>
 <param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.GetTypeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a GetType expression.
 </summary>
 <param name="getTypeKeyword">
 The "GetType" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="type">
 The type to get the Type object for. This can be an open generic type.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TypeOfIsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax)">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
 <param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
 <param name="expression">
 The expression being tested.
 </param>
 <param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
 <param name="type">
 The name of the type being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TypeOfIsNotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax)">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
 <param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
 <param name="expression">
 The expression being tested.
 </param>
 <param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
 <param name="type">
 The name of the type being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TypeOfExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax)">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 TypeOfExpressionSyntax. One of TypeOfIsExpression, TypeOfIsNotExpression.
 </param>
 <param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
 <param name="expression">
 The expression being tested.
 </param>
 <param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
 <param name="type">
 The name of the type being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.GetXmlNamespaceExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlPrefixNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a GetXmlNamespace expression.
 </summary>
 <param name="getXmlNamespaceKeyword">
 The "GetXmlNamespace" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="name">
 The Xml namespace name being referenced.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SimpleMemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
 <param name="operatorToken">
 The "." or "!" token.
 </param>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DictionaryAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
 <param name="operatorToken">
 The "." or "!" token.
 </param>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MemberAccessExpressionSyntax. One of SimpleMemberAccessExpression,
 DictionaryAccessExpression.
 </param>
 <param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
 <param name="operatorToken">
 The "." or "!" token.
 </param>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlElementAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token1">
 The initial dot "." part of the separator.
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="token3">
 The third "." in a "..." separator.
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlDescendantAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token1">
 The initial dot "." part of the separator.
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="token3">
 The third "." in a "..." separator.
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlAttributeAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token1">
 The initial dot "." part of the separator.
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="token3">
 The third "." in a "..." separator.
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlMemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
 XmlDescendantAccessExpression, XmlAttributeAccessExpression.
 </param>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token1">
 The initial dot "." part of the separator.
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="token3">
 The third "." in a "..." separator.
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.InvocationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax)">
 <summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
 <param name="expression">
 The target of the call or index expression.
 </param>
 <param name="argumentList">
 The argument list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ObjectCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectCreationInitializerSyntax)">
 <summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
 <param name="newKeyword">
 The "New" keyword.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="type">
 The type of the object being initialized.
 </param>
 <param name="argumentList">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
 <param name="initializer">
 An optional From or With clause to initialize the new object.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectMemberInitializerSyntax)">
 <summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
 <param name="newKeyword">
 The "New" keyword.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="initializer">
 The With clause to initialize the new object.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ArrayCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionInitializerSyntax)">
 <summary>
 Represents an expression that creates a new array.
 </summary>
 <param name="newKeyword">
 The "New" keyword.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="type">
 The element type of the array being created.
 </param>
 <param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
 <param name="rankSpecifiers">
 A list of array modifiers such as "()" or "(,)". If no array modifiers were
 present, an empty list is returned.
 </param>
 <param name="initializer">
 The initializer including the braces.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CollectionInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
 <param name="openBraceToken">
 The "{" token.
 </param>
 <param name="initializers">
 The list of initializers between the braces.
 </param>
 <param name="closeBraceToken">
 The "}" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CTypeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="expression">
 The expression being cast.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="type">
 The type the expression is being cast to.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DirectCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="expression">
 The expression being cast.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="type">
 The type the expression is being cast to.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TryCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="expression">
 The expression being cast.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="type">
 The type the expression is being cast to.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.PredefinedCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
 <param name="keyword">
 The keyword that was used in the cast operation.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="expression">
 The expression being cast.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AddExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SubtractExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MultiplyExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DivideExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IntegerDivideExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExponentiateExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LeftShiftExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.RightShiftExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ConcatenateExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ModuloExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EqualsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NotEqualsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LessThanExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LessThanOrEqualExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.GreaterThanOrEqualExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.GreaterThanExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IsNotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LikeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.OrExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExclusiveOrExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AndExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.OrElseExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AndAlsoExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.BinaryExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 BinaryExpressionSyntax. One of AddExpression, SubtractExpression,
 MultiplyExpression, DivideExpression, IntegerDivideExpression,
 ExponentiateExpression, LeftShiftExpression, RightShiftExpression,
 ConcatenateExpression, ModuloExpression, EqualsExpression, NotEqualsExpression,
 LessThanExpression, LessThanOrEqualExpression, GreaterThanOrEqualExpression,
 GreaterThanExpression, IsExpression, IsNotExpression, LikeExpression,
 OrExpression, ExclusiveOrExpression, AndExpression, OrElseExpression,
 AndAlsoExpression.
 </param>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.UnaryPlusExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.UnaryMinusExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AddressOfExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.UnaryExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 UnaryExpressionSyntax. One of UnaryPlusExpression, UnaryMinusExpression,
 NotExpression, AddressOfExpression.
 </param>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.BinaryConditionalExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
 <param name="ifKeyword">
 The "If" keyword
 </param>
 <param name="openParenToken">
 The "(" token
 </param>
 <param name="firstExpression">
 The first expression inside the parentheses.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="secondExpression">
 The second expression inside the parentheses.
 </param>
 <param name="closeParenToken">
 The ")" token
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TernaryConditionalExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
 <param name="ifKeyword">
 The "If" keyword
 </param>
 <param name="openParenToken">
 The "(" token
 </param>
 <param name="condition">
 The first expression inside the parentheses.
 </param>
 <param name="firstCommaToken">
 The "," token.
 </param>
 <param name="whenTrue">
 The second expression inside the parentheses.
 </param>
 <param name="secondCommaToken">
 The "," token.
 </param>
 <param name="whenFalse">
 The second expression inside the parentheses.
 </param>
 <param name="closeParenToken">
 The ")" token
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SingleLineFunctionLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents a single line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SingleLineSubLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents a single line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SingleLineLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents a single line lambda expression.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 SingleLineLambdaExpressionSyntax. One of SingleLineFunctionLambdaExpression,
 SingleLineSubLambdaExpression.
 </param>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MultiLineFunctionLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MultiLineSubLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.MultiLineLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MultiLineLambdaExpressionSyntax. One of MultiLineFunctionLambdaExpression,
 MultiLineSubLambdaExpression.
 </param>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SubLambdaHeader(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 Represents the header part of a lambda expression
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this lambda expression.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.FunctionLambdaHeader(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 Represents the header part of a lambda expression
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this lambda expression.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LambdaHeader(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 Represents the header part of a lambda expression
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LambdaHeaderSyntax.
 One of SubLambdaHeader, FunctionLambdaHeader.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this lambda expression.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ArgumentList(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a parenthesized argument list.
 </summary>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="arguments">
 The list of arguments. This may be empty. Omitted argument are represented by
 an OmittedArgumentSyntax node.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.OmittedArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
 <param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SimpleArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameColonEqualsSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an argument that is just an optional argument name and an
 expression.
 </summary>
 <param name="nameColonEquals">
 The optional name and ":=" prefix of a named argument.
 </param>
 <param name="expression">
 The expression that is the argument.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NameColonEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an identifier name followed by a ":=" token in a named argument.
 </summary>
 <param name="name">
 The name used to identify the named argument.
 </param>
 <param name="colonEqualsToken">
 The ":=" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.RangeArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
 <param name="lowerBound">
 The lower bound of the range. This is typically the integer constant zero.
 </param>
 <param name="toKeyword">
 The "To" keyword.
 </param>
 <param name="upperBound">
 The upper bound of the range.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.QueryExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
 <param name="clauses">
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CollectionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
 <param name="identifier">
 The name of the range variable being defined.
 </param>
 <param name="asClause">
 Describes the type of the variable being defined.
 </param>
 <param name="inKeyword">
 The "In" keyword.
 </param>
 <param name="expression">
 The expression that serves as the source of items for the range variable.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExpressionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableNameEqualsSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
 <param name="nameEquals">
 The optional name and type of the expression range variable. If omitted, the
 name of the expression range variable is inferred from the expression.
 </param>
 <param name="expression">
 The expression used to initialize the expression variable.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AggregationRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableNameEqualsSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationSyntax)">
 <summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
 <param name="nameEquals">
 The optional name and type of the expression range variable. If omitted, the
 name of the expression range variable is inferred from the aggregation
 expression.
 </param>
 <param name="aggregation">
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.VariableNameEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the name and optional type of an expression range variable.
 </summary>
 <param name="identifier">
 The name of the variable being defined.
 </param>
 <param name="asClause">
 Describes the type of the variable being defined.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.FunctionAggregation(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
 <param name="functionName">
 The name of the aggregation function.
 </param>
 <param name="openParenToken">
 The "(" token if present.
 </param>
 <param name="argument">
 The argument to the aggregation function.
 </param>
 <param name="closeParenToken">
 The ")" token, if present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.GroupAggregation(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
 <param name="groupKeyword">
 The "Group" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.FromClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax})">
 <summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
 <param name="fromKeyword">
 The "From" keyword.
 </param>
 <param name="variables">
 The list of collection variables declared by this From operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LetClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionRangeVariableSyntax})">
 <summary>
 Represents a "Let" query operator.
 </summary>
 <param name="letKeyword">
 The "Let" keyword.
 </param>
 <param name="variables">
 The list of expression range variable being defined by the Let operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AggregateClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents an Aggregate query operator.
 </summary>
 <param name="aggregateKeyword">
 The "Aggregate" keyword.
 </param>
 <param name="variables">
 The list of collection range variables declared by this Aggregate operator.
 </param>
 <param name="additionalQueryOperators">
 A list of additional query operators. It may be empty.
 </param>
 <param name="intoKeyword">
 The "Into" keyword.
 </param>
 <param name="aggregationVariables">
 The list of new variables being defined by the aggregation.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DistinctClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the "Distinct" query operator.
 </summary>
 <param name="distinctKeyword">
 The "Distinct" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.WhereClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Where" query operator.
 </summary>
 <param name="whereKeyword">
 The "Where" keyword.
 </param>
 <param name="condition">
 The boolean expression used for filtering.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SkipWhileClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="whileKeyword">
 The "While" keyword.
 </param>
 <param name="condition">
 The boolean expression used for partitioning.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TakeWhileClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="whileKeyword">
 The "While" keyword.
 </param>
 <param name="condition">
 The boolean expression used for partitioning.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.PartitionWhileClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 PartitionWhileClauseSyntax. One of SkipWhileClause, TakeWhileClause.
 </param>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="whileKeyword">
 The "While" keyword.
 </param>
 <param name="condition">
 The boolean expression used for partitioning.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SkipClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TakeClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.PartitionClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 PartitionClauseSyntax. One of SkipClause, TakeClause.
 </param>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.GroupByClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionRangeVariableSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionRangeVariableSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents the "Group By" query operator.
 </summary>
 <param name="groupKeyword">
 The "Group" keyword.
 </param>
 <param name="items">
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </param>
 <param name="byKeyword">
 The "By" keyword.
 </param>
 <param name="keys">
 The key values being used for grouping.
 </param>
 <param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.JoinCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
 <param name="left">
 The left expression in the Join condition.
 </param>
 <param name="equalsKeyword">
 The "Equals" keyword.
 </param>
 <param name="right">
 The right expression in the Join condition.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SimpleJoinClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinConditionSyntax})">
 <summary>
 Represents a Join query operator.
 </summary>
 <param name="joinKeyword">
 The "Join" keyword.
 </param>
 <param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
 <param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
 <param name="onKeyword">
 The "On" keyword.
 </param>
 <param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.GroupJoinClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinConditionSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents the "Group Join" query operator.
 </summary>
 <param name="groupKeyword">
 The "Group" keyword.
 </param>
 <param name="joinKeyword">
 The "Join" keyword.
 </param>
 <param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
 <param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
 <param name="onKeyword">
 The "On" keyword.
 </param>
 <param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
 <param name="intoKeyword">
 The "Into" keyword.
 </param>
 <param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.OrderByClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OrderingSyntax})">
 <summary>
 Represents the "Order By" query operator.
 </summary>
 <param name="orderKeyword">
 The "Order" keyword
 </param>
 <param name="byKeyword">
 The "By" keyword.
 </param>
 <param name="orderings">
 The list of OrderExpression's to sort by.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AscendingOrdering(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
 <param name="expression">
 The expression to sort by.
 </param>
 <param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DescendingOrdering(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
 <param name="expression">
 The expression to sort by.
 </param>
 <param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Ordering(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of OrderingSyntax. One
 of AscendingOrdering, DescendingOrdering.
 </param>
 <param name="expression">
 The expression to sort by.
 </param>
 <param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SelectClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionRangeVariableSyntax})">
 <summary>
 Represents the "Select" query operator.
 </summary>
 <param name="selectKeyword">
 The "Select" keyword.
 </param>
 <param name="variables">
 The list of expression range variables being defined by the Select query
 operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlDocument(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents an XML Document literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlDeclarationOption(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlStringSyntax)">
 <summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlElementStartTagSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlElementEndTagSyntax)">
 <summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlText(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents Xml text.
 </summary>
 <param name="textTokens">
 A list of all the text tokens in the Xml text. This list always contains at
 least one token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlElementStartTag(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlElementEndTag(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlEmptyElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax)">
 <summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlString(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlPrefixName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameTokenSyntax)">
 <summary>
 Represents an XML name of the form 'name' appearing in GetXmlNamespace().
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlPrefixSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameTokenSyntax)">
 <summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlBracketedName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
 of an XML literal or member access expression or an XML namespace import
 clause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlPrefix(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlComment(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an XML comment of the form &lt;!-- Comment --&gt; appearing in an
 XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlProcessingInstruction(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
 XMLProcessingValue ?&gt;'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlCDataSection(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlEmbeddedExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
 obj.Name =%&gt;&lt;/name&gt;'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ArrayType(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
 <param name="elementType">
 The type of the elements of the array.
 </param>
 <param name="rankSpecifiers">
 Represents the list of "()" or "(,,)" modifiers on the array type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NullableType(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
 <param name="elementType">
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </param>
 <param name="questionMarkToken">
 The "?" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.PredefinedType(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
 <param name="keyword">
 The keyword that was used to describe the built-in type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IdentifierName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax)">
 <summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
 <param name="identifier">
 The identifier in the name.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.GenericName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeArgumentListSyntax)">
 <summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
 <param name="identifier">
 The identifier in the name.
 </param>
 <param name="typeArgumentList">
 The generic argument list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.QualifiedName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleNameSyntax)">
 <summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
 <param name="left">
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </param>
 <param name="dotToken">
 The "." token that separates the names.
 </param>
 <param name="right">
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.GlobalName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a name in the global namespace.
 </summary>
 <param name="globalKeyword">
 The "Global" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.TypeArgumentList(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="ofKeyword">
 The "Of" keyword.
 </param>
 <param name="arguments">
 A list of all the type arguments.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CrefReference(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefSignatureSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 Syntax node class that represents a value of 'cref' attribute inside
 documentation comment trivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CrefSignature(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefSignaturePartSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a parenthesized list of argument types for a signature inside
 CrefReferenceSyntax syntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.YieldStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represent a Yield statement.
 </summary>
 <param name="yieldKeyword">
 The "Yield" keyword.
 </param>
 <param name="expression">
 The expression whose value is being yielded.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.AwaitExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an Await expression.
 </summary>
 <param name="awaitKeyword">
 The "Await" keyword.
 </param>
 <param name="expression">
 The expression being awaited.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlNameToken(System.String,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlTextLiteralToken(System.String,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlEntityLiteralToken(System.String,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DocumentationCommentLineBreakToken(System.String,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlTextToken(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,System.String,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of XmlTextTokenSyntax.
 One of XmlTextLiteralToken, XmlEntityLiteralToken,
 DocumentationCommentLineBreakToken.
 </param>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.InterpolatedStringTextToken(System.String,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents literal character data in interpolated string expression.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DecimalLiteralToken(System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter,System.Decimal,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents a Decimal literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DateLiteralToken(System.String,System.DateTime,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents an Date literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.StringLiteralToken(System.String,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents an string literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CharacterLiteralToken(System.String,System.Char,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents an string literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SkippedTokensTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
 <param name="tokens">
 The list of tokens that were skipped by the parser.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DocumentationCommentTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents a documentation comment e.g. ''' &lt;Summary&gt; appearing in
 source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlCrefAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefReferenceSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or
 &lt;seealso&gt; documentation comment tag). For example, the M in &lt;see
 cref="M" /&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlNameAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 A param or type param symbol referenced by a name attribute (e.g. in a
 &lt;param&gt; or &lt;typeparam&gt; documentation comment tag). For example, the
 M in &lt;param name="M" /&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ConditionalAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 ExpressionSyntax node representing the object conditionally accessed.
 </summary>
 <param name="expression">
 The expression on the left-hand-side of the "?".
 </param>
 <param name="questionMarkToken">
 "?" token.
 </param>
 <param name="whenNotNull">
 ExpressionSyntax node representing the access expression to be executed when
 the object is not null."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.NameOfExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a NameOf expression.
 </summary>
 <param name="nameOfKeyword">
 The "NameOf" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="argument">
 The argument.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.InterpolatedStringExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an interpolated string expression.
 </summary>
 <param name="dollarSignDoubleQuoteToken">
 The opening '$"', '$“', or '$”' token.
 </param>
 <param name="contents">
 The contents of the interpolated string.
 </param>
 <param name="doubleQuoteToken">
 The closing '"', '”', or '“' token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.InterpolatedStringText(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringTextTokenSyntax)">
 <summary>
 Represents literal text content in an interpolated string.
 </summary>
 <param name="textToken">
 The text token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Interpolation(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationAlignmentClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationFormatClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an interpolation of an expression in an interpolated string
 expression e.g. '{expression[,alignment][:formatString]}'.
 </summary>
 <param name="openBraceToken">
 The opening curly brace '{' token.
 </param>
 <param name="expression">
 The expression whose formatted value should be embedded in the resultant
 string.
 </param>
 <param name="alignmentClause">
 Optional. The alignment clause ',alignment' of the embedded expression.
 </param>
 <param name="formatClause">
 Optional. The format string clause ':formatString' of the embedded expression.
 </param>
 <param name="closeBraceToken">
 The closing curly brace '}' token of the embedded expression.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.InterpolationAlignmentClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an alignment clause ',alignment' of an interpolated string embedded
 expression.
 </summary>
 <param name="commaToken">
 The comma ',' token.
 </param>
 <param name="value">
 An expression representing the alignment of the interpolated expression.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.InterpolationFormatClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringTextTokenSyntax)">
 <summary>
 Represents a format string clause ':formatString' of an interpolated string
 embedded expression.
 </summary>
 <param name="colonToken">
 The ':' token.
 </param>
 <param name="formatStringToken">
 The format string.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.WhitespaceTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndOfLineTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ColonTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CommentTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LineContinuationTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DocumentationCommentExteriorTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DisabledTextTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.SyntaxTrivia(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of SyntaxTrivia. One of
 WhitespaceTrivia, EndOfLineTrivia, ColonTrivia, CommentTrivia,
 LineContinuationTrivia, DocumentationCommentExteriorTrivia, DisabledTextTrivia.
 </param>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ConstDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
 <param name="constKeyword">
 The "Const" keyword.
 </param>
 <param name="name">
 The name of the pre-processing constant being defined.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
 <param name="value">
 An expression representing the value of the pre-processing constant being
 defined.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IfDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElseIfDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElseDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndIfDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.RegionDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax)">
 <summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
 <param name="regionKeyword">
 The "Region" keyword.
 </param>
 <param name="name">
 The label of the code region being defined.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndRegionDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an #End Region directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
 <param name="endKeyword">
 The "End" keyword.
 </param>
 <param name="regionKeyword">
 The "Region" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExternalSourceDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IntegerLiteralTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndExternalSourceDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ExternalChecksumDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EnableWarningDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax})">
 <summary>
 Represents #Enable Warning pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DisableWarningDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax})">
 <summary>
 Represents #Disable Warning pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ReferenceDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax)">
 <summary>
 Represents an #r directive appearing in scripts.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.BadDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList.WithLotsOfChildren.FindSlotIndexContainingOffset(System.Int32)">
 <summary>
 Find the slot that contains the given offset.
 </summary>
 <param name="offset">The target offset. Must be between 0 and <see cref="P:Microsoft.CodeAnalysis.GreenNode.FullWidth"/>.</param>
 <returns>The slot index of the slot containing the given offset.</returns>
 <remarks>
 This implementation uses a binary search to find the first slot that contains
 the given offset.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CharacterLiteralTokenSyntax">
 <summary>
 Represents an string literal token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CharacterLiteralTokenSyntax.Value">
 <summary>
 The value of the character, after removing the quotation marks.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DateLiteralTokenSyntax">
 <summary>
 Represents an Date literal token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DateLiteralTokenSyntax.Value">
 <summary>
 The value of the token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DecimalLiteralTokenSyntax">
 <summary>
 Represents a Decimal literal token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DecimalLiteralTokenSyntax.TypeSuffix">
 <summary>
 The type suffix or type character that was on the literal, if any. If no suffix
 was present, TypeCharacter.None is returned.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DecimalLiteralTokenSyntax.Value">
 <summary>
 The value of the token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax">
 <summary>
 Represents an string literal token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax.Value">
 <summary>
 The value of the string, after removing the quotation marks and combining
 doubled quotation marks.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IntegerLiteralTokenSyntax`1.Value">
 <summary>
 The value of the token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IntegerLiteralTokenSyntax">
 <summary>
 Represents an integer literal token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IntegerLiteralTokenSyntax.Base">
 <summary>
 Whether the token was specified in base 10, 16, or 8.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IntegerLiteralTokenSyntax.TypeSuffix">
 <summary>
 The type suffix or type character that was on the literal, if any. If no suffix
 was present, TypeCharacter.None is returned.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FloatingLiteralTokenSyntax`1">
 <summary>
 Represents an floating literal token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FloatingLiteralTokenSyntax`1.Value">
 <summary>
 The value of the token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FloatingLiteralTokenSyntax">
 <summary>
 Represents an floating literal token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FloatingLiteralTokenSyntax.TypeSuffix">
 <summary>
 The type suffix or type character that was on the literal, if any. If no suffix
 was present, TypeCharacter.None is returned.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode">
 <summary>
 The base class for all nodes in the VB syntax tree.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode.SetFactoryContext(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ISyntaxFactoryContext)">
 <summary>
 Should only be called during construction.
 </summary>
 <remarks>
 This should probably be an extra constructor parameter, but we don't need more constructor overloads.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode.WriteTo(System.IO.TextWriter)">
 <summary>
 Append the full text of this node including children and trivia to the given stringbuilder.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode.WriteToOrFlatten(System.IO.TextWriter,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.GreenNode})">
 <summary>
 NOTE: the method should write OR push children, but never do both
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode.CollectConstituentTokensAndDiagnostics(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxListBuilder{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken},System.Collections.Generic.IList{Microsoft.CodeAnalysis.DiagnosticInfo})">
 <summary>
 Add all the tokens in this node and children to the build token list builder. While doing this, add any
 diagnostics not on tokens to the given diagnostic info list.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode.ToString">
 <summary>
 Returns the string representation of this node, not including its leading and trailing trivia.
 </summary>
 <returns>The string representation of this node, not including its leading and trailing trivia.</returns>
 <remarks>The length of the returned string is always the same as Span.Length</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode.ToFullString">
 <summary>
 Returns full string representation of this node including its leading and trailing trivia.
 </summary>
 <returns>The full string representation of this node including its leading and trailing trivia.</returns>
 <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode.AddError(Microsoft.CodeAnalysis.DiagnosticInfo)">
 <summary>
 Add an error to the given node, creating a new node that is the same except it has no parent,
 and has the given error attached to it. The error span is the entire span of this node.
 </summary>
 <param name="err">The error to attach to this node</param>
 <returns>A new node, with no parent, that has this error added to it.</returns>
 <remarks>Since nodes are immutable, the only way to create nodes with errors attached is to create a node without an error,
 then add an error with this method to create another node.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode.GetSyntaxErrors">
 <summary>
 Get all syntax errors associated with this node, or any child nodes, grand-child nodes, etc. The errors
 are not in order.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GreenStats">
 <summary>
 Provides caching functionality for green nonterminals with up to 3 children.
 Example:
     When constructing a node with given kind, flags, child1 and child2, we can look up 
     in the cache whether we already have a node that contains same kind, flags, 
     child1 and child2 and use that.
     
     For the purpose of children comparison, reference equality is used as a much cheaper 
     alternative to the structural/recursive equality. This implies that in order to de-duplicate
     a node to a cache node, the children of two nodes must be already de-duplicated.     
     When adding a node to the cache we verify that cache does contain node's children,
     since otherwise there is no reason for the node to be used.
     Tokens/nulls are for this purpose considered deduplicated. Indeed most of the tokens
     are deduplicated via quick-scanner caching, so we just assume they all are.
     
     As a result of above, "fat" nodes with 4 or more children or their recursive parents
     will never be in the cache. This naturally limits the typical single cache item to be 
     a relatively simple expression. We do not want the cache to be completely unbounded 
     on the item size. 
     While it still may be possible to store a gigantic nested binary expression, 
     it should be a rare occurrence.
     
     We only consider "normal" nodes to be cacheable. 
     Nodes with diagnostics/annotations/directives/skipped, etc... have more complicated identity 
     and are not likely to be repetitive.
     
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxNodeExtensions.GetLengthOfCommonEnd(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Return the length of the common ending between the two
 sets of trivia. The valid trivia (following skipped tokens)
 of one must be contained in the valid trivia of the other. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxNodeExtensions.GetIndexOfEndOfTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Return the index within the trivia of what would be considered trailing
 single-line trivia by the Scanner. This behavior must match ScanSingleLineTrivia.
 In short, search walks backwards and stops at the second terminator
 (colon or EOL) from the end, ignoring EOLs preceded by line continuations.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentSyntax">
 <summary>
 Base class for the possible kinds of arguments that can appear in an argument
 list.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken">
 <summary>
 Represents a single syntactic token in a VB program. A token is a keyword,
 punctuator, literal, identifier or XML token. The type of keyword or punctuator
 can be determined from the Kind property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken.CollectConstituentTokensAndDiagnostics(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxListBuilder{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken},System.Collections.Generic.IList{Microsoft.CodeAnalysis.DiagnosticInfo})">
 <summary>
 Add this token to the token list builder.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken.IsKeyword">
 <summary>
 Helper to check whether the token is a keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken.IsBinaryOperator">
 <summary>
 Helpers to check whether the token is a binary operator
 </summary>
 <returns>True if it is a binary operator</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken.IsEndOfLine">
 <summary>
 Check whether the token is a statement terminator
 </summary>
 <returns>True if it is statement terminator</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken.IsEndOfParse">
 <summary>
 Check whether token is end of text
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken.AddLeadingTrivia``1(``0,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Create a new token with the trivia prepended to the existing preceding trivia
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken.AddTrailingTrivia``1(``0,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Create a new token with the trivia appended to the existing following trivia
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlTextTokenSyntax">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlTextTokenSyntax.Value">
 <summary>
 The text of the attribute or pcdata after normalization.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringTextTokenSyntax">
 <summary>
 Represents literal character data in interpolated string expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringTextTokenSyntax.Value">
 <summary>
 The text.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxTrivia">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBlockBaseSyntax">
 <summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBlockBaseSyntax.Begin">
 <summary>
 The statement that begins the block declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBlockBaseSyntax.End">
 <summary>
 The statement that ends the block declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBlockBaseSyntax.Statements">
 <summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorBlockSyntax">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorBlockSyntax.AccessorStatement">
 <summary>
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorBlockSyntax.EndAccessorStatement">
 <summary>
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstructorBlockSyntax">
 <summary>
 Represents a constructor block declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstructorBlockSyntax.SubNewStatement">
 <summary>
 The "Sub New" statement that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstructorBlockSyntax.EndSubStatement">
 <summary>
 The "End Sub" statement that ends the block declaration.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBlockSyntax">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBlockSyntax.SubOrFunctionStatement">
 <summary>
 The "Sub" or "Function" statement that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBlockSyntax.EndSubOrFunctionStatement">
 <summary>
 The "End Sub" or "End Function" statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OperatorBlockSyntax">
 <summary>
 Represents an Operator block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OperatorBlockSyntax.OperatorStatement">
 <summary>
 The "Operator" statement that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OperatorBlockSyntax.EndOperatorStatement">
 <summary>
 The "End Operator" statement that ends the block declaration.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeBlockSyntax">
 <summary>
 Represents a declaration of a Class, Interface, Structure, Module, its contents
 and the End statement that ends it.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeBlockSyntax.BlockStatement">
 <summary>
 The statement that begins the block declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeBlockSyntax.EndBlockStatement">
 <summary>
 The statement that ends the block declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeBlockSyntax.Inherits">
 <summary>
 A list of the Inherits declarations for the type.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeBlockSyntax.Implements">
 <summary>
 A list of the Implements declarations for the type.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeBlockSyntax.Members">
 <summary>
 The declarations contained in the type or module.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ClassBlockSyntax">
 <summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ClassBlockSyntax.ClassStatement">
 <summary>
 The "Class" statement that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ClassBlockSyntax.EndClassStatement">
 <summary>
 The "End Class" statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StructureBlockSyntax">
 <summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StructureBlockSyntax.StructureStatement">
 <summary>
 The "Structure" statement that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StructureBlockSyntax.EndStructureStatement">
 <summary>
 The "End Structure" statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterfaceBlockSyntax">
 <summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterfaceBlockSyntax.InterfaceStatement">
 <summary>
 The "Interface" statement that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterfaceBlockSyntax.EndInterfaceStatement">
 <summary>
 The "End Interface" statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModuleBlockSyntax">
 <summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModuleBlockSyntax.ModuleStatement">
 <summary>
 The "Module" statement that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModuleBlockSyntax.EndModuleStatement">
 <summary>
 The "End Module" statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StatementSyntax">
 <summary>
 The base class for all nodes that represent statements. This includes both
 declaration statements, such as class declarations as well as executable
 statements.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExecutableStatementSyntax">
 <summary>
 The base class for all nodes that represent executable statements.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclarationStatementSyntax">
 <summary>
 The base class for all nodes that represent statements that declare options,
 imports, members, etc.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EmptyStatementSyntax">
 <summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EmptyStatementSyntax.Empty">
 <summary>
 An empty token because all non terminals must have a token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax.EndKeyword">
 <summary>
 The "End" keyword
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax.BlockKeyword">
 <summary>
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CompilationUnitSyntax">
 <summary>
 Represents an entire source file of VB code.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CompilationUnitSyntax.Options">
 <summary>
 Represents the list of Option statements at the beginning of a source file.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CompilationUnitSyntax.Imports">
 <summary>
 Represents the list of Imports statements at the beginning of a source file.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CompilationUnitSyntax.Attributes">
 <summary>
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CompilationUnitSyntax.Members">
 <summary>
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CompilationUnitSyntax.EndOfFileToken">
 <summary>
 Represents the end of the source file. This token may have trivia (whitespace,
 comments, ...) attached to it.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OptionStatementSyntax">
 <summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OptionStatementSyntax.OptionKeyword">
 <summary>
 The "Option" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OptionStatementSyntax.NameKeyword">
 <summary>
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OptionStatementSyntax.ValueKeyword">
 <summary>
 The keyword that identifiers the value being set for the option: On, Off, Text
 or Binary.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportsStatementSyntax">
 <summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportsStatementSyntax.ImportsKeyword">
 <summary>
 The "Imports" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportsStatementSyntax.ImportsClauses">
 <summary>
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportsClauseSyntax">
 <summary>
 The base class for the possible clauses of an Imports statement.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleImportsClauseSyntax">
 <summary>
 Represents the clause of an Imports statement that imports all members of a
 type or namespace or aliases a type or namespace.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleImportsClauseSyntax.Alias">
 <summary>
 An optional alias for the namespace or type being imported.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleImportsClauseSyntax.Name">
 <summary>
 The namespace or type being imported.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportAliasClauseSyntax">
 <summary>
 Represents an alias identifier followed by an "=" token in an Imports clause.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportAliasClauseSyntax.Identifier">
 <summary>
 The identifier being introduced.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportAliasClauseSyntax.EqualsToken">
 <summary>
 The "=" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNamespaceImportsClauseSyntax">
 <summary>
 Defines a XML namespace for XML expressions.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNamespaceImportsClauseSyntax.XmlNamespace">
 <summary>
 Identifies the XML namespace alias and URI.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamespaceBlockSyntax">
 <summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamespaceBlockSyntax.NamespaceStatement">
 <summary>
 The statement that begins the NamespaceBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamespaceBlockSyntax.Members">
 <summary>
 The declarations contained in the namespace statement.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamespaceBlockSyntax.EndNamespaceStatement">
 <summary>
 The End Namespace statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamespaceStatementSyntax">
 <summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamespaceStatementSyntax.NamespaceKeyword">
 <summary>
 The "Namespace" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamespaceStatementSyntax.Name">
 <summary>
 A (possibly dotted) name denoting the namespace being declared.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumBlockSyntax">
 <summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumBlockSyntax.EnumStatement">
 <summary>
 The statement that begins the type or module.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumBlockSyntax.Members">
 <summary>
 The declarations contained in the enumeration.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumBlockSyntax.EndEnumStatement">
 <summary>
 The End XXX statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InheritsOrImplementsStatementSyntax">
 <summary>
 Represents an Inherits or Implements statement in a Class, Structure or
 Interface.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InheritsStatementSyntax">
 <summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InheritsStatementSyntax.InheritsKeyword">
 <summary>
 The "Inherits" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InheritsStatementSyntax.Types">
 <summary>
 A list of the types being inherited.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsStatementSyntax">
 <summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsStatementSyntax.ImplementsKeyword">
 <summary>
 The "Implements" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsStatementSyntax.Types">
 <summary>
 A list of the types being implemented.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeStatementSyntax">
 <summary>
 Abstract class for the beginning statement of a Module, Class, Interface or
 Structure declaration. This node always appears as the Begin of a TypeBlock
 with Kind=ModuleDeclarationBlock, ClassDeclarationBlock,
 InterfaceDeclarationBlock or StructureDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeStatementSyntax.Identifier">
 <summary>
 The name of the type being declared.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeStatementSyntax.TypeParameterList">
 <summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModuleStatementSyntax">
 <summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModuleStatementSyntax.ModuleKeyword">
 <summary>
 The "Module" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StructureStatementSyntax">
 <summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StructureStatementSyntax.StructureKeyword">
 <summary>
 The "Structure" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterfaceStatementSyntax">
 <summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterfaceStatementSyntax.InterfaceKeyword">
 <summary>
 The "Interface" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ClassStatementSyntax">
 <summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ClassStatementSyntax.ClassKeyword">
 <summary>
 The "Class" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumStatementSyntax">
 <summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumStatementSyntax.EnumKeyword">
 <summary>
 The "Enum" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumStatementSyntax.Identifier">
 <summary>
 The name of the enum being declared.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumStatementSyntax.UnderlyingType">
 <summary>
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax">
 <summary>
 Represents the type parameter list in a declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax.OfKeyword">
 <summary>
 The "Of" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax.Parameters">
 <summary>
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterSyntax">
 <summary>
 Represents a type parameter on a generic type declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterSyntax.VarianceKeyword">
 <summary>
 Represents the "In" or "Out" variance keyword on a type parameter, if present.
 If no variance modifier was present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterSyntax.Identifier">
 <summary>
 The name of the type parameter
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterSyntax.TypeParameterConstraintClause">
 <summary>
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax">
 <summary>
 An abstract node class that is the parent of classes that describe type
 parameter constraint clauses.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterSingleConstraintClauseSyntax">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterSingleConstraintClauseSyntax.AsKeyword">
 <summary>
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterSingleConstraintClauseSyntax.Constraint">
 <summary>
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax.AsKeyword">
 <summary>
 The "As" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax.OpenBraceToken">
 <summary>
 The "{" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax.Constraints">
 <summary>
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax.CloseBraceToken">
 <summary>
 The "}" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstraintSyntax">
 <summary>
 An abstract node class that is the parent of classes that describe type
 parameter constraints.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SpecialConstraintSyntax">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SpecialConstraintSyntax.ConstraintKeyword">
 <summary>
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeConstraintSyntax">
 <summary>
 Represents a type parameter constraint that is a type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeConstraintSyntax.Type">
 <summary>
 The type describing the constraint.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumMemberDeclarationSyntax">
 <summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumMemberDeclarationSyntax.AttributeLists">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumMemberDeclarationSyntax.Initializer">
 <summary>
 An optional value for the enum member.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyBlockSyntax">
 <summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyBlockSyntax.PropertyStatement">
 <summary>
 The property declaration that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyBlockSyntax.Accessors">
 <summary>
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyBlockSyntax.EndPropertyStatement">
 <summary>
 The End Property statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventBlockSyntax">
 <summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventBlockSyntax.EventStatement">
 <summary>
 The event declaration that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventBlockSyntax.Accessors">
 <summary>
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventBlockSyntax.EndEventStatement">
 <summary>
 The End Event statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBaseSyntax">
 <summary>
 An abstract node class that is the parent for declarations that are
 "method-like"; i.e., that have a parameter list and return type. This includes
 methods, constructors, properties, events, operators, declares, delegates,
 property accessors and custom event accessors.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBaseSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBaseSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBaseSyntax.ParameterList">
 <summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax">
 <summary>
 Represents the parameter list in a method declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax.OpenParenToken">
 <summary>
 The "(" token that introduces the parameter list. If no parameter list was
 present, Nothing is returned.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax.Parameters">
 <summary>
 The list of parameters. If no parameter list was present, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax.CloseParenToken">
 <summary>
 The ")" token that concludes the parameter list. If no parameter list was
 present, Nothing is returned.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax.SubOrFunctionKeyword">
 <summary>
 The "Sub" or "Function" keyword that introduces this method declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax.Identifier">
 <summary>
 The name of the method being declared.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax.TypeParameterList">
 <summary>
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax.HandlesClause">
 <summary>
 If present, a Handles clause indicated the events that this method handles.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax.ImplementsClause">
 <summary>
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SubNewStatementSyntax">
 <summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SubNewStatementSyntax.SubKeyword">
 <summary>
 The "Sub" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SubNewStatementSyntax.NewKeyword">
 <summary>
 The "New" keyword in the constructor declaration.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclareStatementSyntax">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclareStatementSyntax.DeclareKeyword">
 <summary>
 The "Declare" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclareStatementSyntax.CharsetKeyword">
 <summary>
 If present, the keyword that defines the string translation semantics of the
 external method.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclareStatementSyntax.SubOrFunctionKeyword">
 <summary>
 The "Sub" or "Function" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclareStatementSyntax.Identifier">
 <summary>
 The name of the method being declared.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclareStatementSyntax.LibKeyword">
 <summary>
 The "Lib" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclareStatementSyntax.LibraryName">
 <summary>
 The string literal with the library name.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclareStatementSyntax.AliasKeyword">
 <summary>
 If present, the "Alias" keyword. If not present, returns Nothing.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclareStatementSyntax.AliasName">
 <summary>
 The string literal with the alias. If not present, returns Nothing.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclareStatementSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DelegateStatementSyntax">
 <summary>
 A statement that declares a delegate type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DelegateStatementSyntax.DelegateKeyword">
 <summary>
 The "Delegate" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DelegateStatementSyntax.SubOrFunctionKeyword">
 <summary>
 The "Sub" or "Function" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DelegateStatementSyntax.Identifier">
 <summary>
 The name of the delegate being declared.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DelegateStatementSyntax.TypeParameterList">
 <summary>
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DelegateStatementSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventStatementSyntax">
 <summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventStatementSyntax.CustomKeyword">
 <summary>
 The optional Custom keyword for custom event declarations.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventStatementSyntax.EventKeyword">
 <summary>
 The "Event" keyword that introduces this event declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventStatementSyntax.Identifier">
 <summary>
 The name of the event being declared.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventStatementSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventStatementSyntax.ImplementsClause">
 <summary>
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OperatorStatementSyntax">
 <summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OperatorStatementSyntax.OperatorKeyword">
 <summary>
 The "Operator" keyword that introduces this operator declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OperatorStatementSyntax.OperatorToken">
 <summary>
 The operator being defined.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OperatorStatementSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyStatementSyntax">
 <summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyStatementSyntax.PropertyKeyword">
 <summary>
 The "Property" keyword that introduces this property declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyStatementSyntax.Identifier">
 <summary>
 The name of the property being declared.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyStatementSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyStatementSyntax.Initializer">
 <summary>
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyStatementSyntax.ImplementsClause">
 <summary>
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax.AccessorKeyword">
 <summary>
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax">
 <summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax.ImplementsKeyword">
 <summary>
 The "Implements" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax.InterfaceMembers">
 <summary>
 The list of interface members being implemented.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseSyntax">
 <summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseSyntax.HandlesKeyword">
 <summary>
 The "Handles" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseSyntax.Events">
 <summary>
 The list of event members being handled.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventContainerSyntax">
 <summary>
 Represents container of an event in a Handles clause item.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordEventContainerSyntax">
 <summary>
 Represents event container specified through special keywords "Me", "MyBase" or
 "MyClass"..
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordEventContainerSyntax.Keyword">
 <summary>
 The container of the event. This can be one of the special keywords: "Me",
 "MyBase" or "MyClass".
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithEventsEventContainerSyntax">
 <summary>
 Represents event container that refers to a WithEvents member.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithEventsEventContainerSyntax.Identifier">
 <summary>
 The container of the event. It is a simple identifier that refers to a
 WithEvents member of the containing type.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithEventsPropertyEventContainerSyntax">
 <summary>
 Represents event container that refers to a WithEvents member's property.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithEventsPropertyEventContainerSyntax.WithEventsContainer">
 <summary>
 The container of the event.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithEventsPropertyEventContainerSyntax.DotToken">
 <summary>
 The "." token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithEventsPropertyEventContainerSyntax.Property">
 <summary>
 The provider of the event. It is a property of a WithEvents member of the
 containing type.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseItemSyntax">
 <summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseItemSyntax.EventContainer">
 <summary>
 The container of the event. This can either be a simple identifier (identifying
 a members of the containing type) or one of the special keywords "Me", "MyBase"
 or "MyClass".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseItemSyntax.DotToken">
 <summary>
 The "." token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseItemSyntax.EventMember">
 <summary>
 The event being handled. This must be a simple identifier.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IncompleteMemberSyntax">
 <summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IncompleteMemberSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IncompleteMemberSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IncompleteMemberSyntax.MissingIdentifier">
 <summary>
 The missing identifier token for this incomplete member. Should only be used to
 have a location for error reporting.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FieldDeclarationSyntax">
 <summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FieldDeclarationSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FieldDeclarationSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FieldDeclarationSyntax.Declarators">
 <summary>
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableDeclaratorSyntax">
 <summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableDeclaratorSyntax.Names">
 <summary>
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableDeclaratorSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type, and possibly includes "New",
 "With" or "From". If no As clause was present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableDeclaratorSyntax.Initializer">
 <summary>
 If present, an "= initial-value" clause describing the initial value of the
 variable or the value of the constant.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AsClauseSyntax">
 <summary>
 Abstract node class that represents the different kinds of "As {type-name}"
 clauses in a declaration: simple "As" clauses and "As New" clauses. The type
 has optional attributes associated with it, although attributes are not
 permitted in all possible places where this node occurs.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AsClauseSyntax.AsKeyword">
 <summary>
 The "As" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax">
 <summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax.Type">
 <summary>
 The type-name part of the As clause.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AsNewClauseSyntax">
 <summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AsNewClauseSyntax.NewExpression">
 <summary>
 The New expression
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectCreationInitializerSyntax">
 <summary>
 An abstract node class that represents a "With" or "From" clause used to
 initializer an new object.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectMemberInitializerSyntax">
 <summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectMemberInitializerSyntax.WithKeyword">
 <summary>
 The "With" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectMemberInitializerSyntax.OpenBraceToken">
 <summary>
 The "{" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectMemberInitializerSyntax.Initializers">
 <summary>
 The comma-separated list of field initializers.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectMemberInitializerSyntax.CloseBraceToken">
 <summary>
 The "}" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectCollectionInitializerSyntax">
 <summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectCollectionInitializerSyntax.FromKeyword">
 <summary>
 The "From" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectCollectionInitializerSyntax.Initializer">
 <summary>
 The initializer including the braces.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FieldInitializerSyntax">
 <summary>
 Abstract class that represent a single field initializer used in a "With {...}"
 field initializer list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FieldInitializerSyntax.KeyKeyword">
 <summary>
 The optional "Key" keyword.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InferredFieldInitializerSyntax">
 <summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InferredFieldInitializerSyntax.Expression">
 <summary>
 The value being assigned.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamedFieldInitializerSyntax">
 <summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamedFieldInitializerSyntax.DotToken">
 <summary>
 The "." token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamedFieldInitializerSyntax.Name">
 <summary>
 The name of the field being initialized.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamedFieldInitializerSyntax.EqualsToken">
 <summary>
 The "=" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamedFieldInitializerSyntax.Expression">
 <summary>
 The value being assigned to the field.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EqualsValueSyntax">
 <summary>
 Represents an "= initializer" clause in a declaration for a variable, parameter
 or automatic property.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EqualsValueSyntax.EqualsToken">
 <summary>
 The "=" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EqualsValueSyntax.Value">
 <summary>
 The expression used as the initial value.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterSyntax">
 <summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this parameter. If no attributes were
 specified, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterSyntax.Modifiers">
 <summary>
 A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
 modify this parameter.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterSyntax.Identifier">
 <summary>
 The name of the parameter, including any "?" or "()" modifiers.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterSyntax.AsClause">
 <summary>
 If present, the "As type-name" clause describing the type of the parameter. If
 no As clause is present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterSyntax.Default">
 <summary>
 If present, an initializer with the default value of the parameter. If no
 default value is present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax">
 <summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax.Identifier">
 <summary>
 The identifier that names the item being declared.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax.Nullable">
 <summary>
 The "?" token that indicates a nullable type.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax.ArrayBounds">
 <summary>
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax.ArrayRankSpecifiers">
 <summary>
 A list of array modifiers for the type. If no array modifiers were present, an
 empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayRankSpecifierSyntax">
 <summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayRankSpecifierSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayRankSpecifierSyntax.CommaTokens">
 <summary>
 The comma tokens in the array type. There is one less comma than the rank.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayRankSpecifierSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeListSyntax">
 <summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeListSyntax.LessThanToken">
 <summary>
 The "&lt;" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeListSyntax.Attributes">
 <summary>
 A comma separated list of attribute declarations in this attribute list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeListSyntax.GreaterThanToken">
 <summary>
 The "&gt;" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeSyntax">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeSyntax.Target">
 <summary>
 Optional attribute target. Assembly|Module :
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeSyntax.Name">
 <summary>
 The name of the attribute.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeSyntax.ArgumentList">
 <summary>
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeTargetSyntax">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeTargetSyntax.AttributeModifier">
 <summary>
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeTargetSyntax.ColonToken">
 <summary>
 The ":" token, if an attribute modifier is present. If no attribute modifier is
 present, Nothing is returned.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributesStatementSyntax">
 <summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributesStatementSyntax.AttributeLists">
 <summary>
 The list of attribute lists.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionStatementSyntax">
 <summary>
 Represent an expression in a statement context. This may only be a invocation
 or await expression in standard code but may be any expression in VB
 Interactive code.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionStatementSyntax.Expression">
 <summary>
 The expression.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PrintStatementSyntax">
 <summary>
 Represent a "? expression" "Print" statement in VB Interactive code.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PrintStatementSyntax.QuestionToken">
 <summary>
 "?" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PrintStatementSyntax.Expression">
 <summary>
 The expression whose value is being output.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileBlockSyntax">
 <summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileBlockSyntax.WhileStatement">
 <summary>
 The While statement that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileBlockSyntax.Statements">
 <summary>
 The statements contained in the While...End While. This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileBlockSyntax.EndWhileStatement">
 <summary>
 The End While statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UsingBlockSyntax">
 <summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UsingBlockSyntax.UsingStatement">
 <summary>
 The UsingStatement that begins the Using...End Using block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UsingBlockSyntax.Statements">
 <summary>
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UsingBlockSyntax.EndUsingStatement">
 <summary>
 The End Using statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyncLockBlockSyntax">
 <summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyncLockBlockSyntax.SyncLockStatement">
 <summary>
 The SyncLock statement that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyncLockBlockSyntax.Statements">
 <summary>
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyncLockBlockSyntax.EndSyncLockStatement">
 <summary>
 The End SyncLock statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithBlockSyntax">
 <summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithBlockSyntax.WithStatement">
 <summary>
 The WithStatement that begins the With...End With block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithBlockSyntax.Statements">
 <summary>
 The statements contained in the With...End With block. This might be an empty
 list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithBlockSyntax.EndWithStatement">
 <summary>
 The End With statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LocalDeclarationStatementSyntax">
 <summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LocalDeclarationStatementSyntax.Modifiers">
 <summary>
 The modifier token (Static, Dim or Const) that introduces this local variable
 declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LocalDeclarationStatementSyntax.Declarators">
 <summary>
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelStatementSyntax">
 <summary>
 Represents a label statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelStatementSyntax.LabelToken">
 <summary>
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelStatementSyntax.ColonToken">
 <summary>
 The ":" token of the label statement.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GoToStatementSyntax">
 <summary>
 Represents a "GoTo" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GoToStatementSyntax.GoToKeyword">
 <summary>
 The "GoTo" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GoToStatementSyntax.Label">
 <summary>
 The name of the label. If the label is a line number, wraps an IntegerLiteral
 that is the line number, otherwise, wraps an Identifier.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax.LabelToken">
 <summary>
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StopOrEndStatementSyntax">
 <summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StopOrEndStatementSyntax.StopOrEndKeyword">
 <summary>
 The "Stop" or "End" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExitStatementSyntax">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExitStatementSyntax.ExitKeyword">
 <summary>
 The "Exit" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExitStatementSyntax.BlockKeyword">
 <summary>
 The keyword describing the block to exit.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContinueStatementSyntax">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContinueStatementSyntax.ContinueKeyword">
 <summary>
 The "Continue" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContinueStatementSyntax.BlockKeyword">
 <summary>
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ReturnStatementSyntax">
 <summary>
 Represents a "Return" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ReturnStatementSyntax.ReturnKeyword">
 <summary>
 The "Return" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ReturnStatementSyntax.Expression">
 <summary>
 The expression being returned, if present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineIfStatementSyntax">
 <summary>
 Represents a single-line "If ... Then ... Else ..." statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineIfStatementSyntax.IfKeyword">
 <summary>
 The "If" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineIfStatementSyntax.Condition">
 <summary>
 The condition expression to be evaluated.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineIfStatementSyntax.ThenKeyword">
 <summary>
 The "Then" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineIfStatementSyntax.Statements">
 <summary>
 A list of statements to be executed if the condition expression evaluates as
 true. Multiple statements must be separated by colons.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineIfStatementSyntax.ElseClause">
 <summary>
 An "Else" clause to be executed if the condition expression evaluates as false.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineElseClauseSyntax">
 <summary>
 Represents the "Else ..." clause of a single-line "If" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineElseClauseSyntax.ElseKeyword">
 <summary>
 The "Else" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineElseClauseSyntax.Statements">
 <summary>
 A list of statements to be executed. Multiple statements must be separated by
 colons.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MultiLineIfBlockSyntax">
 <summary>
 Represents a multi-line "If ... Then ... ElseIf ... Then ... Else ... End If"
 block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MultiLineIfBlockSyntax.IfStatement">
 <summary>
 The "If" statement that begins the "If" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MultiLineIfBlockSyntax.Statements">
 <summary>
 A list of statements to be executed if the condition expression evaluates as
 true.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MultiLineIfBlockSyntax.ElseIfBlocks">
 <summary>
 A list of "ElseIf" blocks to be evaluated, in order, if the condition
 expression of the "If" statement evaluates as false.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MultiLineIfBlockSyntax.ElseBlock">
 <summary>
 An "Else" block to be executed if the condition expression of the "If"
 statement and all "ElseIf" blocks evaluate as false.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MultiLineIfBlockSyntax.EndIfStatement">
 <summary>
 Then "End If" statement.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IfStatementSyntax">
 <summary>
 Represents the "If ... Then" statement that begins a multi-line "If" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IfStatementSyntax.IfKeyword">
 <summary>
 The "If" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IfStatementSyntax.Condition">
 <summary>
 The condition expression to be evaluated.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IfStatementSyntax.ThenKeyword">
 <summary>
 The "Then" keyword.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseIfBlockSyntax">
 <summary>
 Represents an "ElseIf ... Then ..." block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseIfBlockSyntax.ElseIfStatement">
 <summary>
 The "ElseIf ... Then" statement the begins the "ElseIf" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseIfBlockSyntax.Statements">
 <summary>
 A list of statements to be executed if the condition expression of the "ElseIf"
 statement evaluates as true.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseIfStatementSyntax">
 <summary>
 Represents the "ElseIf ... Then" statement that begins an "ElseIf" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseIfStatementSyntax.ElseIfKeyword">
 <summary>
 The "ElseIf" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseIfStatementSyntax.Condition">
 <summary>
 The condition expression to be evaluated.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseIfStatementSyntax.ThenKeyword">
 <summary>
 The "Then" keyword.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseBlockSyntax">
 <summary>
 Represents an "Else ..." block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseBlockSyntax.ElseStatement">
 <summary>
 The "Else" statement that begins the "Else" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseBlockSyntax.Statements">
 <summary>
 A list of statements to be executed.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseStatementSyntax">
 <summary>
 Represents the "Else" statement that begins an "Else" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseStatementSyntax.ElseKeyword">
 <summary>
 The "Else" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryBlockSyntax">
 <summary>
 Represents a "Try ... Catch ... Finally ... End Try" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryBlockSyntax.TryStatement">
 <summary>
 The "Try" statement that begins the "Try" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryBlockSyntax.Statements">
 <summary>
 A list of statements to be executed.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryBlockSyntax.CatchBlocks">
 <summary>
 A list of "Catch" blocks which may be executed if an exception is thrown while
 executing the statements in the "Try" block.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryBlockSyntax.FinallyBlock">
 <summary>
 A "Finally" block to be executed before execution leaves the "Try" block.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryBlockSyntax.EndTryStatement">
 <summary>
 The "End Try" statement.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryStatementSyntax">
 <summary>
 Represents the "Try" statement that begins a "Try" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryStatementSyntax.TryKeyword">
 <summary>
 The "Try" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchBlockSyntax">
 <summary>
 Represents a "Catch ..." block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchBlockSyntax.CatchStatement">
 <summary>
 The "Catch" statement that begins the "Catch" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchBlockSyntax.Statements">
 <summary>
 A list of statements to be executed if an exception is caught by the "Catch"
 block.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchStatementSyntax">
 <summary>
 Represents the "Catch ... When ..." statement that begins a "Catch" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchStatementSyntax.CatchKeyword">
 <summary>
 The "Catch" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchStatementSyntax.IdentifierName">
 <summary>
 An identifier declaring a new variable or naming an existing variable to store
 the exception caught by the "Catch" statement.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchStatementSyntax.AsClause">
 <summary>
 A simple "As" clause specifying the type of exception to catch.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchStatementSyntax.WhenClause">
 <summary>
 A "When" clause to filter exceptions before catching.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchFilterClauseSyntax">
 <summary>
 Represents the "When ..." clause of a "Catch" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchFilterClauseSyntax.WhenKeyword">
 <summary>
 The "When" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchFilterClauseSyntax.Filter">
 <summary>
 The filter expression to be evaluated.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FinallyBlockSyntax">
 <summary>
 Represents a "Finally ..." block of a "Try" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FinallyBlockSyntax.FinallyStatement">
 <summary>
 The "Finally" statement that begins the "Finally" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FinallyBlockSyntax.Statements">
 <summary>
 A list of statements to be executed.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FinallyStatementSyntax">
 <summary>
 Represents the "Finally" statement that begins a "Finally" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FinallyStatementSyntax.FinallyKeyword">
 <summary>
 The "Finally" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ErrorStatementSyntax">
 <summary>
 Represents the "Error" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ErrorStatementSyntax.ErrorKeyword">
 <summary>
 The "Error" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ErrorStatementSyntax.ErrorNumber">
 <summary>
 The expression that represents the error number.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OnErrorGoToStatementSyntax">
 <summary>
 Represents an OnError Goto statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OnErrorGoToStatementSyntax.OnKeyword">
 <summary>
 The "On" keyword
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OnErrorGoToStatementSyntax.ErrorKeyword">
 <summary>
 The "Error" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OnErrorGoToStatementSyntax.GoToKeyword">
 <summary>
 The "GoTo" keyword
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OnErrorGoToStatementSyntax.Minus">
 <summary>
 An optional minus for On Error Goto -1
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OnErrorGoToStatementSyntax.Label">
 <summary>
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OnErrorResumeNextStatementSyntax">
 <summary>
 Represents an OnError Resume Next statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OnErrorResumeNextStatementSyntax.OnKeyword">
 <summary>
 The "On" keyword
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OnErrorResumeNextStatementSyntax.ErrorKeyword">
 <summary>
 The "Error" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OnErrorResumeNextStatementSyntax.ResumeKeyword">
 <summary>
 The "Resume" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OnErrorResumeNextStatementSyntax.NextKeyword">
 <summary>
 The "Next"
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ResumeStatementSyntax">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ResumeStatementSyntax.ResumeKeyword">
 <summary>
 The "Resume" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ResumeStatementSyntax.Label">
 <summary>
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectBlockSyntax">
 <summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectBlockSyntax.SelectStatement">
 <summary>
 The Select Case statement that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectBlockSyntax.CaseBlocks">
 <summary>
 A list of the contained Case blocks.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectBlockSyntax.EndSelectStatement">
 <summary>
 The End Select statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectStatementSyntax">
 <summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectStatementSyntax.SelectKeyword">
 <summary>
 The "Select" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectStatementSyntax.CaseKeyword">
 <summary>
 The "Case" keyword, if present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectStatementSyntax.Expression">
 <summary>
 The value that branching is based on.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseBlockSyntax">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseBlockSyntax.CaseStatement">
 <summary>
 The statement that begins the case block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseBlockSyntax.Statements">
 <summary>
 The statements contained in the case block. This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseStatementSyntax">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseStatementSyntax.CaseKeyword">
 <summary>
 The "Case" keyword
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseStatementSyntax.Cases">
 <summary>
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseClauseSyntax">
 <summary>
 Represents a single clause in a case statement. An abstract node that is the
 parent of different kinds of Case clauses.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseCaseClauseSyntax">
 <summary>
 The "Else" part in a Case Else statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseCaseClauseSyntax.ElseKeyword">
 <summary>
 The "Else" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleCaseClauseSyntax">
 <summary>
 Represents a single value in a Case.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleCaseClauseSyntax.Value">
 <summary>
 The expression that denotes the value being tested against.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RangeCaseClauseSyntax">
 <summary>
 Represents a range "expression To expression" in a Case.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RangeCaseClauseSyntax.LowerBound">
 <summary>
 The lower bound of the range.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RangeCaseClauseSyntax.ToKeyword">
 <summary>
 The "To" keyword
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RangeCaseClauseSyntax.UpperBound">
 <summary>
 The upper bound of the range.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RelationalCaseClauseSyntax">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RelationalCaseClauseSyntax.IsKeyword">
 <summary>
 The "Is" keyword, if present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RelationalCaseClauseSyntax.OperatorToken">
 <summary>
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RelationalCaseClauseSyntax.Value">
 <summary>
 The expression that denotes the value being tested against.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyncLockStatementSyntax">
 <summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyncLockStatementSyntax.SyncLockKeyword">
 <summary>
 The "SyncLock" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyncLockStatementSyntax.Expression">
 <summary>
 The expression being synchronized on.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoLoopBlockSyntax">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoLoopBlockSyntax.DoStatement">
 <summary>
 The Do statement that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoLoopBlockSyntax.Statements">
 <summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoLoopBlockSyntax.LoopStatement">
 <summary>
 The Loop statement that ends the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax.DoKeyword">
 <summary>
 The "Do" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax.WhileOrUntilClause">
 <summary>
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax.LoopKeyword">
 <summary>
 The "Loop" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax.WhileOrUntilClause">
 <summary>
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax">
 <summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax.WhileOrUntilKeyword">
 <summary>
 The "While" or "Until" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax.Condition">
 <summary>
 The boolean expression after the While or Until.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileStatementSyntax">
 <summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileStatementSyntax.WhileKeyword">
 <summary>
 The "While" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileStatementSyntax.Condition">
 <summary>
 The boolean expression that controls the While loop.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForOrForEachBlockSyntax">
 <summary>
 Represents a For or For Each block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForOrForEachBlockSyntax.Statements">
 <summary>
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForOrForEachBlockSyntax.NextStatement">
 <summary>
 The Next statement that ends the block. If two For or For Each statements are
 ended by a single Next statement, the inner For will not have a Next statement.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForBlockSyntax">
 <summary>
 Represents a For block, including the introducing statement, the body and the
 "Next" (which can be omitted if a containing For has a Next with multiple
 variables).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForBlockSyntax.ForStatement">
 <summary>
 The For statement that begins the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForEachBlockSyntax">
 <summary>
 Represents a For Each block, including the introducing statement, the body and
 the "Next" (which can be omitted if a containing For has a Next with multiple
 variables).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForEachBlockSyntax.ForEachStatement">
 <summary>
 The For Each statement that begins the block.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForOrForEachStatementSyntax">
 <summary>
 Represents a For or For Each statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForOrForEachStatementSyntax.ForKeyword">
 <summary>
 The "For" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForOrForEachStatementSyntax.ControlVariable">
 <summary>
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStatementSyntax">
 <summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStatementSyntax.EqualsToken">
 <summary>
 The "=" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStatementSyntax.FromValue">
 <summary>
 The expression denoting the initial value of the iteration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStatementSyntax.ToKeyword">
 <summary>
 The "To" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStatementSyntax.ToValue">
 <summary>
 The expression denoting the final value of the iteration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStatementSyntax.StepClause">
 <summary>
 The optional Step clause.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStepClauseSyntax">
 <summary>
 The Step clause in a For Statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStepClauseSyntax.StepKeyword">
 <summary>
 The "Step" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStepClauseSyntax.StepValue">
 <summary>
 The expression denoting the step increment.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForEachStatementSyntax">
 <summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForEachStatementSyntax.EachKeyword">
 <summary>
 The "Each" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForEachStatementSyntax.InKeyword">
 <summary>
 The "In" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForEachStatementSyntax.Expression">
 <summary>
 The expression denoting the collection to iterate over.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NextStatementSyntax">
 <summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NextStatementSyntax.NextKeyword">
 <summary>
 The "Next" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NextStatementSyntax.ControlVariables">
 <summary>
 The variables in the Next statement, if present
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UsingStatementSyntax">
 <summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UsingStatementSyntax.UsingKeyword">
 <summary>
 The "Using" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UsingStatementSyntax.Expression">
 <summary>
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UsingStatementSyntax.Variables">
 <summary>
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ThrowStatementSyntax">
 <summary>
 Represents a Throw statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ThrowStatementSyntax.ThrowKeyword">
 <summary>
 The "Throw" keyword
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ThrowStatementSyntax.Expression">
 <summary>
 The expression denoting the value being thrown.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AssignmentStatementSyntax">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AssignmentStatementSyntax.Left">
 <summary>
 The target (left hand side) of the assignment.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AssignmentStatementSyntax.OperatorToken">
 <summary>
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AssignmentStatementSyntax.Right">
 <summary>
 The source (right hand side) of the assignment.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MidExpressionSyntax">
 <summary>
 Represents a left-hand side of a MidAssignment statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MidExpressionSyntax.Mid">
 <summary>
 The "Mid" possibly followed by a type character.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MidExpressionSyntax.ArgumentList">
 <summary>
 The argument list.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CallStatementSyntax">
 <summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CallStatementSyntax.CallKeyword">
 <summary>
 The "Call" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CallStatementSyntax.Invocation">
 <summary>
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AddRemoveHandlerStatementSyntax">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AddRemoveHandlerStatementSyntax.AddHandlerOrRemoveHandlerKeyword">
 <summary>
 The "AddHandler" or "RemoveHandler" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AddRemoveHandlerStatementSyntax.EventExpression">
 <summary>
 The event being accessed.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AddRemoveHandlerStatementSyntax.CommaToken">
 <summary>
 The "," token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AddRemoveHandlerStatementSyntax.DelegateExpression">
 <summary>
 The delegate being added or removed.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RaiseEventStatementSyntax">
 <summary>
 Represent a RaiseEvent statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RaiseEventStatementSyntax.RaiseEventKeyword">
 <summary>
 The "RaiseEvent" keyword
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RaiseEventStatementSyntax.Name">
 <summary>
 The name of the event being raised.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RaiseEventStatementSyntax.ArgumentList">
 <summary>
 The argument list, if present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithStatementSyntax">
 <summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithStatementSyntax.WithKeyword">
 <summary>
 The "With" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithStatementSyntax.Expression">
 <summary>
 The expression that is the operand of the With statement.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ReDimStatementSyntax">
 <summary>
 Represents a ReDim statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ReDimStatementSyntax.ReDimKeyword">
 <summary>
 The "ReDim" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ReDimStatementSyntax.PreserveKeyword">
 <summary>
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ReDimStatementSyntax.Clauses">
 <summary>
 The list of ReDim clauses.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RedimClauseSyntax">
 <summary>
 Represents a ReDim statement clause.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RedimClauseSyntax.Expression">
 <summary>
 The target of the ReDim statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RedimClauseSyntax.ArrayBounds">
 <summary>
 The ArraySizeInitializationModifier.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EraseStatementSyntax">
 <summary>
 Represents an "Erase" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EraseStatementSyntax.EraseKeyword">
 <summary>
 The "Erase" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EraseStatementSyntax.Expressions">
 <summary>
 A list of expressions denoting the arrays to erase.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax">
 <summary>
 An abstract base class for all node classes that define expressions.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax.Token">
 <summary>
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParenthesizedExpressionSyntax">
 <summary>
 Represents a parenthesized expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParenthesizedExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParenthesizedExpressionSyntax.Expression">
 <summary>
 The expression inside the parentheses.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParenthesizedExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InstanceExpressionSyntax">
 <summary>
 Identifies one of the special instances "Me", "MyClass" or "MyBase". The Kind
 property identifies which.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InstanceExpressionSyntax.Keyword">
 <summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MeExpressionSyntax">
 <summary>
 Identifies the special instance "Me"
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MyBaseExpressionSyntax">
 <summary>
 Identifies the special instance "MyBase"
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MyClassExpressionSyntax">
 <summary>
 Identifies the special instance "MyClass"
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GetTypeExpressionSyntax">
 <summary>
 Represents a GetType expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GetTypeExpressionSyntax.GetTypeKeyword">
 <summary>
 The "GetType" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GetTypeExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GetTypeExpressionSyntax.Type">
 <summary>
 The type to get the Type object for. This can be an open generic type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GetTypeExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeOfExpressionSyntax">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeOfExpressionSyntax.TypeOfKeyword">
 <summary>
 The "TypeOf" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeOfExpressionSyntax.Expression">
 <summary>
 The expression being tested.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeOfExpressionSyntax.OperatorToken">
 <summary>
 The "Is" or "IsNot" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeOfExpressionSyntax.Type">
 <summary>
 The name of the type being tested against.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GetXmlNamespaceExpressionSyntax">
 <summary>
 Represents a GetXmlNamespace expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GetXmlNamespaceExpressionSyntax.GetXmlNamespaceKeyword">
 <summary>
 The "GetXmlNamespace" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GetXmlNamespaceExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GetXmlNamespaceExpressionSyntax.Name">
 <summary>
 The Xml namespace name being referenced.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GetXmlNamespaceExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MemberAccessExpressionSyntax">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MemberAccessExpressionSyntax.Expression">
 <summary>
 The expression on the left-hand-side of the "." or "!" token.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MemberAccessExpressionSyntax.OperatorToken">
 <summary>
 The "." or "!" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MemberAccessExpressionSyntax.Name">
 <summary>
 The identifier after the "." or "!" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlMemberAccessExpressionSyntax">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlMemberAccessExpressionSyntax.Base">
 <summary>
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlMemberAccessExpressionSyntax.Token1">
 <summary>
 The initial dot "." part of the separator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlMemberAccessExpressionSyntax.Token2">
 <summary>
 The "@" part of .@ or the second "." of "...".
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlMemberAccessExpressionSyntax.Token3">
 <summary>
 The third "." in a "..." separator.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlMemberAccessExpressionSyntax.Name">
 <summary>
 The identifier after the ".", ".@" or "..."
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InvocationExpressionSyntax">
 <summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InvocationExpressionSyntax.Expression">
 <summary>
 The target of the call or index expression.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InvocationExpressionSyntax.ArgumentList">
 <summary>
 The argument list.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NewExpressionSyntax">
 <summary>
 Base class for object, array and anonymous object creation expressions
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NewExpressionSyntax.NewKeyword">
 <summary>
 The "New" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NewExpressionSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectCreationExpressionSyntax">
 <summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectCreationExpressionSyntax.Type">
 <summary>
 The type of the object being initialized.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectCreationExpressionSyntax.ArgumentList">
 <summary>
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectCreationExpressionSyntax.Initializer">
 <summary>
 An optional From or With clause to initialize the new object.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax">
 <summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax.Initializer">
 <summary>
 The With clause to initialize the new object.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayCreationExpressionSyntax">
 <summary>
 Represents an expression that creates a new array.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayCreationExpressionSyntax.Type">
 <summary>
 The element type of the array being created.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayCreationExpressionSyntax.ArrayBounds">
 <summary>
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayCreationExpressionSyntax.RankSpecifiers">
 <summary>
 A list of array modifiers such as "()" or "(,)". If no array modifiers were
 present, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayCreationExpressionSyntax.Initializer">
 <summary>
 The initializer including the braces.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionInitializerSyntax">
 <summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionInitializerSyntax.OpenBraceToken">
 <summary>
 The "{" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionInitializerSyntax.Initializers">
 <summary>
 The list of initializers between the braces.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionInitializerSyntax.CloseBraceToken">
 <summary>
 The "}" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CastExpressionSyntax">
 <summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CastExpressionSyntax.Keyword">
 <summary>
 The "CType", "DirectCast" or "TryCast" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CastExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CastExpressionSyntax.Expression">
 <summary>
 The expression being cast.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CastExpressionSyntax.CommaToken">
 <summary>
 The "," token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CastExpressionSyntax.Type">
 <summary>
 The type the expression is being cast to.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CastExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PredefinedCastExpressionSyntax">
 <summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PredefinedCastExpressionSyntax.Keyword">
 <summary>
 The keyword that was used in the cast operation.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PredefinedCastExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PredefinedCastExpressionSyntax.Expression">
 <summary>
 The expression being cast.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PredefinedCastExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BinaryExpressionSyntax">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BinaryExpressionSyntax.Left">
 <summary>
 The left operand.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BinaryExpressionSyntax.Right">
 <summary>
 The right operand.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UnaryExpressionSyntax">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UnaryExpressionSyntax.OperatorToken">
 <summary>
 The token that is the operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UnaryExpressionSyntax.Operand">
 <summary>
 The expression being operated on.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BinaryConditionalExpressionSyntax">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BinaryConditionalExpressionSyntax.IfKeyword">
 <summary>
 The "If" keyword
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BinaryConditionalExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BinaryConditionalExpressionSyntax.FirstExpression">
 <summary>
 The first expression inside the parentheses.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BinaryConditionalExpressionSyntax.CommaToken">
 <summary>
 The "," token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BinaryConditionalExpressionSyntax.SecondExpression">
 <summary>
 The second expression inside the parentheses.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BinaryConditionalExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TernaryConditionalExpressionSyntax">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TernaryConditionalExpressionSyntax.IfKeyword">
 <summary>
 The "If" keyword
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TernaryConditionalExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TernaryConditionalExpressionSyntax.Condition">
 <summary>
 The first expression inside the parentheses.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TernaryConditionalExpressionSyntax.FirstCommaToken">
 <summary>
 The "," token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TernaryConditionalExpressionSyntax.WhenTrue">
 <summary>
 The second expression inside the parentheses.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TernaryConditionalExpressionSyntax.SecondCommaToken">
 <summary>
 The "," token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TernaryConditionalExpressionSyntax.WhenFalse">
 <summary>
 The second expression inside the parentheses.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TernaryConditionalExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaExpressionSyntax">
 <summary>
 Represents a lambda expression, either single line or multi-line.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaExpressionSyntax.SubOrFunctionHeader">
 <summary>
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineLambdaExpressionSyntax">
 <summary>
 Represents a single line lambda expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineLambdaExpressionSyntax.Body">
 <summary>
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MultiLineLambdaExpressionSyntax">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MultiLineLambdaExpressionSyntax.Statements">
 <summary>
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MultiLineLambdaExpressionSyntax.EndSubOrFunctionStatement">
 <summary>
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax">
 <summary>
 Represents the header part of a lambda expression
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax.SubOrFunctionKeyword">
 <summary>
 The "Sub" or "Function" keyword that introduces this lambda expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax">
 <summary>
 Represents a parenthesized argument list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax.Arguments">
 <summary>
 The list of arguments. This may be empty. Omitted argument are represented by
 an OmittedArgumentSyntax node.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OmittedArgumentSyntax">
 <summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OmittedArgumentSyntax.Empty">
 <summary>
 An empty token because all non terminals must have a token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleArgumentSyntax">
 <summary>
 Represents an argument that is just an optional argument name and an
 expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleArgumentSyntax.NameColonEquals">
 <summary>
 The optional name and ":=" prefix of a named argument.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleArgumentSyntax.Expression">
 <summary>
 The expression that is the argument.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameColonEqualsSyntax">
 <summary>
 Represents an identifier name followed by a ":=" token in a named argument.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameColonEqualsSyntax.Name">
 <summary>
 The name used to identify the named argument.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameColonEqualsSyntax.ColonEqualsToken">
 <summary>
 The ":=" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RangeArgumentSyntax">
 <summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RangeArgumentSyntax.LowerBound">
 <summary>
 The lower bound of the range. This is typically the integer constant zero.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RangeArgumentSyntax.ToKeyword">
 <summary>
 The "To" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RangeArgumentSyntax.UpperBound">
 <summary>
 The upper bound of the range.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.QueryExpressionSyntax">
 <summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.QueryExpressionSyntax.Clauses">
 <summary>
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.QueryClauseSyntax">
 <summary>
 This is a base class for all query operators.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax">
 <summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax.Identifier">
 <summary>
 The name of the range variable being defined.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax.AsClause">
 <summary>
 Describes the type of the variable being defined.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax.InKeyword">
 <summary>
 The "In" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax.Expression">
 <summary>
 The expression that serves as the source of items for the range variable.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionRangeVariableSyntax">
 <summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionRangeVariableSyntax.NameEquals">
 <summary>
 The optional name and type of the expression range variable. If omitted, the
 name of the expression range variable is inferred from the expression.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionRangeVariableSyntax.Expression">
 <summary>
 The expression used to initialize the expression variable.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationRangeVariableSyntax">
 <summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationRangeVariableSyntax.NameEquals">
 <summary>
 The optional name and type of the expression range variable. If omitted, the
 name of the expression range variable is inferred from the aggregation
 expression.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationRangeVariableSyntax.Aggregation">
 <summary>
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableNameEqualsSyntax">
 <summary>
 Represents the name and optional type of an expression range variable.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableNameEqualsSyntax.Identifier">
 <summary>
 The name of the variable being defined.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableNameEqualsSyntax.AsClause">
 <summary>
 Describes the type of the variable being defined.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableNameEqualsSyntax.EqualsToken">
 <summary>
 The "=" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationSyntax">
 <summary>
 Represents aggregation in aggregation range variable declaration of a Group By,
 Group Join or Aggregate query operator.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FunctionAggregationSyntax">
 <summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FunctionAggregationSyntax.FunctionName">
 <summary>
 The name of the aggregation function.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FunctionAggregationSyntax.OpenParenToken">
 <summary>
 The "(" token if present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FunctionAggregationSyntax.Argument">
 <summary>
 The argument to the aggregation function.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FunctionAggregationSyntax.CloseParenToken">
 <summary>
 The ")" token, if present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupAggregationSyntax">
 <summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupAggregationSyntax.GroupKeyword">
 <summary>
 The "Group" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FromClauseSyntax">
 <summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FromClauseSyntax.FromKeyword">
 <summary>
 The "From" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FromClauseSyntax.Variables">
 <summary>
 The list of collection variables declared by this From operator.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LetClauseSyntax">
 <summary>
 Represents a "Let" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LetClauseSyntax.LetKeyword">
 <summary>
 The "Let" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LetClauseSyntax.Variables">
 <summary>
 The list of expression range variable being defined by the Let operator.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregateClauseSyntax">
 <summary>
 Represents an Aggregate query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregateClauseSyntax.AggregateKeyword">
 <summary>
 The "Aggregate" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregateClauseSyntax.Variables">
 <summary>
 The list of collection range variables declared by this Aggregate operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregateClauseSyntax.AdditionalQueryOperators">
 <summary>
 A list of additional query operators. It may be empty.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregateClauseSyntax.IntoKeyword">
 <summary>
 The "Into" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregateClauseSyntax.AggregationVariables">
 <summary>
 The list of new variables being defined by the aggregation.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DistinctClauseSyntax">
 <summary>
 Represents the "Distinct" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DistinctClauseSyntax.DistinctKeyword">
 <summary>
 The "Distinct" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhereClauseSyntax">
 <summary>
 Represents a "Where" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhereClauseSyntax.WhereKeyword">
 <summary>
 The "Where" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhereClauseSyntax.Condition">
 <summary>
 The boolean expression used for filtering.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PartitionWhileClauseSyntax">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PartitionWhileClauseSyntax.SkipOrTakeKeyword">
 <summary>
 The "Skip" or "Take" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PartitionWhileClauseSyntax.WhileKeyword">
 <summary>
 The "While" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PartitionWhileClauseSyntax.Condition">
 <summary>
 The boolean expression used for partitioning.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PartitionClauseSyntax">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PartitionClauseSyntax.SkipOrTakeKeyword">
 <summary>
 The "Skip" or "Take" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PartitionClauseSyntax.Count">
 <summary>
 Represents the expression with the number of items to take or skip.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupByClauseSyntax">
 <summary>
 Represents the "Group By" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupByClauseSyntax.GroupKeyword">
 <summary>
 The "Group" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupByClauseSyntax.Items">
 <summary>
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupByClauseSyntax.ByKeyword">
 <summary>
 The "By" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupByClauseSyntax.Keys">
 <summary>
 The key values being used for grouping.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupByClauseSyntax.AggregationVariables">
 <summary>
 The list of new variables that calculate aggregations.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinClauseSyntax">
 <summary>
 Represents a Join or a Group Join query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinClauseSyntax.JoinKeyword">
 <summary>
 The "Join" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinClauseSyntax.JoinedVariables">
 <summary>
 Defines the collection range variables being joined to.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinClauseSyntax.AdditionalJoins">
 <summary>
 An additional Join or Group Join query operator.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinClauseSyntax.OnKeyword">
 <summary>
 The "On" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinClauseSyntax.JoinConditions">
 <summary>
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinConditionSyntax">
 <summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinConditionSyntax.Left">
 <summary>
 The left expression in the Join condition.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinConditionSyntax.EqualsKeyword">
 <summary>
 The "Equals" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinConditionSyntax.Right">
 <summary>
 The right expression in the Join condition.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleJoinClauseSyntax">
 <summary>
 Represents a Join query operator.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupJoinClauseSyntax">
 <summary>
 Represents the "Group Join" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupJoinClauseSyntax.GroupKeyword">
 <summary>
 The "Group" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupJoinClauseSyntax.IntoKeyword">
 <summary>
 The "Into" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupJoinClauseSyntax.AggregationVariables">
 <summary>
 The list of new variables that calculate aggregations.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OrderByClauseSyntax">
 <summary>
 Represents the "Order By" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OrderByClauseSyntax.OrderKeyword">
 <summary>
 The "Order" keyword
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OrderByClauseSyntax.ByKeyword">
 <summary>
 The "By" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OrderByClauseSyntax.Orderings">
 <summary>
 The list of OrderExpression's to sort by.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OrderingSyntax">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OrderingSyntax.Expression">
 <summary>
 The expression to sort by.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OrderingSyntax.AscendingOrDescendingKeyword">
 <summary>
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectClauseSyntax">
 <summary>
 Represents the "Select" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectClauseSyntax.SelectKeyword">
 <summary>
 The "Select" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectClauseSyntax.Variables">
 <summary>
 The list of expression range variables being defined by the Select query
 operator.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax">
 <summary>
 This is the base class for all XML expression syntax nodes (XmlDocument and
 XmlElement).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDocumentSyntax">
 <summary>
 Represents an XML Document literal expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDocumentSyntax.PrecedingMisc">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDocumentSyntax.FollowingMisc">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationSyntax">
 <summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationSyntax.Encoding">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationSyntax.Standalone">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationOptionSyntax">
 <summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlElementSyntax">
 <summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlElementSyntax.Content">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlTextSyntax">
 <summary>
 Represents Xml text.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlTextSyntax.TextTokens">
 <summary>
 A list of all the text tokens in the Xml text. This list always contains at
 least one token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlElementStartTagSyntax">
 <summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlElementStartTagSyntax.Attributes">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlElementEndTagSyntax">
 <summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlElementEndTagSyntax.Name">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlEmptyElementSyntax">
 <summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlEmptyElementSyntax.Attributes">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlAttributeSyntax">
 <summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BaseXmlAttributeSyntax">
 <summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlStringSyntax">
 <summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlStringSyntax.TextTokens">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlPrefixNameSyntax">
 <summary>
 Represents an XML name of the form 'name' appearing in GetXmlNamespace().
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameSyntax">
 <summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameSyntax.Prefix">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlBracketedNameSyntax">
 <summary>
 Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
 of an XML literal or member access expression or an XML namespace import
 clause.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlPrefixSyntax">
 <summary>
 Represents an XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlCommentSyntax">
 <summary>
 Represents an XML comment of the form &lt;!-- Comment --&gt; appearing in an
 XML literal expression.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlProcessingInstructionSyntax">
 <summary>
 Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
 XMLProcessingValue ?&gt;'.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlCDataSectionSyntax">
 <summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlEmbeddedExpressionSyntax">
 <summary>
 Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
 obj.Name =%&gt;&lt;/name&gt;'.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax">
 <summary>
 Abstract node class that represents the textual description of a type, possibly
 include generic type arguments, qualified names, array specifiers, nullable
 specifier and the like.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayTypeSyntax">
 <summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayTypeSyntax.ElementType">
 <summary>
 The type of the elements of the array.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayTypeSyntax.RankSpecifiers">
 <summary>
 Represents the list of "()" or "(,,)" modifiers on the array type.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NullableTypeSyntax">
 <summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NullableTypeSyntax.ElementType">
 <summary>
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NullableTypeSyntax.QuestionMarkToken">
 <summary>
 The "?" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PredefinedTypeSyntax">
 <summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PredefinedTypeSyntax.Keyword">
 <summary>
 The keyword that was used to describe the built-in type.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameSyntax">
 <summary>
 Abstract node class that represents a name, possibly include generic arguments
 and qualified names.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleNameSyntax">
 <summary>
 Abstract node class that represents a name, possibly include generic arguments.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleNameSyntax.Identifier">
 <summary>
 The identifier in the name.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax">
 <summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GenericNameSyntax">
 <summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GenericNameSyntax.TypeArgumentList">
 <summary>
 The generic argument list.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.QualifiedNameSyntax">
 <summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.QualifiedNameSyntax.Left">
 <summary>
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.QualifiedNameSyntax.DotToken">
 <summary>
 The "." token that separates the names.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.QualifiedNameSyntax.Right">
 <summary>
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GlobalNameSyntax">
 <summary>
 Represents a name in the global namespace.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GlobalNameSyntax.GlobalKeyword">
 <summary>
 The "Global" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeArgumentListSyntax">
 <summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeArgumentListSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeArgumentListSyntax.OfKeyword">
 <summary>
 The "Of" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeArgumentListSyntax.Arguments">
 <summary>
 A list of all the type arguments.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeArgumentListSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefReferenceSyntax">
 <summary>
 Syntax node class that represents a value of 'cref' attribute inside
 documentation comment trivia.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefReferenceSyntax.Signature">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefReferenceSyntax.AsClause">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefSignatureSyntax">
 <summary>
 Represents a parenthesized list of argument types for a signature inside
 CrefReferenceSyntax syntax.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefSignaturePartSyntax.Modifier">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefSignaturePartSyntax.Type">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.YieldStatementSyntax">
 <summary>
 Represent a Yield statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.YieldStatementSyntax.YieldKeyword">
 <summary>
 The "Yield" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.YieldStatementSyntax.Expression">
 <summary>
 The expression whose value is being yielded.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AwaitExpressionSyntax">
 <summary>
 Represents an Await expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AwaitExpressionSyntax.AwaitKeyword">
 <summary>
 The "Await" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AwaitExpressionSyntax.Expression">
 <summary>
 The expression being awaited.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameTokenSyntax">
 <summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SkippedTokensTriviaSyntax">
 <summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SkippedTokensTriviaSyntax.Tokens">
 <summary>
 The list of tokens that were skipped by the parser.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlCrefAttributeSyntax">
 <summary>
 A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or
 &lt;seealso&gt; documentation comment tag). For example, the M in &lt;see
 cref="M" /&gt;.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameAttributeSyntax">
 <summary>
 A param or type param symbol referenced by a name attribute (e.g. in a
 &lt;param&gt; or &lt;typeparam&gt; documentation comment tag). For example, the
 M in &lt;param name="M" /&gt;.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax">
 <summary>
 ExpressionSyntax node representing the object conditionally accessed.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax.Expression">
 <summary>
 The expression on the left-hand-side of the "?".
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax.QuestionMarkToken">
 <summary>
 "?" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax.WhenNotNull">
 <summary>
 ExpressionSyntax node representing the access expression to be executed when
 the object is not null."
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameOfExpressionSyntax">
 <summary>
 Represents a NameOf expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameOfExpressionSyntax.NameOfKeyword">
 <summary>
 The "NameOf" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameOfExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameOfExpressionSyntax.Argument">
 <summary>
 The argument.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameOfExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax">
 <summary>
 Represents an interpolated string expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax.DollarSignDoubleQuoteToken">
 <summary>
 The opening '$"', '$“', or '$”' token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax.Contents">
 <summary>
 The contents of the interpolated string.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax.DoubleQuoteToken">
 <summary>
 The closing '"', '”', or '“' token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringContentSyntax">
 <summary>
 Represents either text content or an interpolation.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringTextSyntax">
 <summary>
 Represents literal text content in an interpolated string.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringTextSyntax.TextToken">
 <summary>
 The text token.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationSyntax">
 <summary>
 Represents an interpolation of an expression in an interpolated string
 expression e.g. '{expression[,alignment][:formatString]}'.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationSyntax.OpenBraceToken">
 <summary>
 The opening curly brace '{' token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationSyntax.Expression">
 <summary>
 The expression whose formatted value should be embedded in the resultant
 string.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationSyntax.AlignmentClause">
 <summary>
 Optional. The alignment clause ',alignment' of the embedded expression.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationSyntax.FormatClause">
 <summary>
 Optional. The format string clause ':formatString' of the embedded expression.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationSyntax.CloseBraceToken">
 <summary>
 The closing curly brace '}' token of the embedded expression.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationAlignmentClauseSyntax">
 <summary>
 Represents an alignment clause ',alignment' of an interpolated string embedded
 expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationAlignmentClauseSyntax.CommaToken">
 <summary>
 The comma ',' token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationAlignmentClauseSyntax.Value">
 <summary>
 An expression representing the alignment of the interpolated expression.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationFormatClauseSyntax">
 <summary>
 Represents a format string clause ':formatString' of an interpolated string
 embedded expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationFormatClauseSyntax.ColonToken">
 <summary>
 The ':' token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationFormatClauseSyntax.FormatStringToken">
 <summary>
 The format string.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DirectiveTriviaSyntax">
 <summary>
 Represents a pre-processing directive (such as #If, #Const or #Region)
 appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstDirectiveTriviaSyntax">
 <summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstDirectiveTriviaSyntax.ConstKeyword">
 <summary>
 The "Const" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstDirectiveTriviaSyntax.Name">
 <summary>
 The name of the pre-processing constant being defined.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstDirectiveTriviaSyntax.EqualsToken">
 <summary>
 The "=" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstDirectiveTriviaSyntax.Value">
 <summary>
 An expression representing the value of the pre-processing constant being
 defined.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IfDirectiveTriviaSyntax">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IfDirectiveTriviaSyntax.ElseKeyword">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IfDirectiveTriviaSyntax.ThenKeyword">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseDirectiveTriviaSyntax">
 <summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndIfDirectiveTriviaSyntax">
 <summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RegionDirectiveTriviaSyntax">
 <summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RegionDirectiveTriviaSyntax.RegionKeyword">
 <summary>
 The "Region" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RegionDirectiveTriviaSyntax.Name">
 <summary>
 The label of the code region being defined.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndRegionDirectiveTriviaSyntax">
 <summary>
 Represents an #End Region directive appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndRegionDirectiveTriviaSyntax.EndKeyword">
 <summary>
 The "End" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndRegionDirectiveTriviaSyntax.RegionKeyword">
 <summary>
 The "Region" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExternalSourceDirectiveTriviaSyntax">
 <summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndExternalSourceDirectiveTriviaSyntax">
 <summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExternalChecksumDirectiveTriviaSyntax">
 <summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnableWarningDirectiveTriviaSyntax">
 <summary>
 Represents #Enable Warning pre-processing directive appearing in source.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DisableWarningDirectiveTriviaSyntax">
 <summary>
 Represents #Disable Warning pre-processing directive appearing in source.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ReferenceDirectiveTriviaSyntax">
 <summary>
 Represents an #r directive appearing in scripts.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BadDirectiveTriviaSyntax">
 <summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EmptyStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
 <param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndUsingStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndWithStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndSelectStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndStructureStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndEnumStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndInterfaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndClassStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndModuleStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndNamespaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndSubStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndFunctionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndGetStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndSetStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndPropertyStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndOperatorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndEventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndAddHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndRemoveHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndRaiseEventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndTryStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndSyncLockStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndBlockStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 EndBlockStatementSyntax. One of EndIfStatement, EndUsingStatement,
 EndWithStatement, EndSelectStatement, EndStructureStatement, EndEnumStatement,
 EndInterfaceStatement, EndClassStatement, EndModuleStatement,
 EndNamespaceStatement, EndSubStatement, EndFunctionStatement, EndGetStatement,
 EndSetStatement, EndPropertyStatement, EndOperatorStatement, EndEventStatement,
 EndAddHandlerStatement, EndRemoveHandlerStatement, EndRaiseEventStatement,
 EndWhileStatement, EndTryStatement, EndSyncLockStatement.
 </param>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CompilationUnit(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an entire source file of VB code.
 </summary>
 <param name="options">
 Represents the list of Option statements at the beginning of a source file.
 </param>
 <param name="imports">
 Represents the list of Imports statements at the beginning of a source file.
 </param>
 <param name="attributes">
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </param>
 <param name="members">
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </param>
 <param name="endOfFileToken">
 Represents the end of the source file. This token may have trivia (whitespace,
 comments, ...) attached to it.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.OptionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
 <param name="optionKeyword">
 The "Option" keyword.
 </param>
 <param name="nameKeyword">
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </param>
 <param name="valueKeyword">
 The keyword that identifiers the value being set for the option: On, Off, Text
 or Binary.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ImportsStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportsClauseSyntax})">
 <summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
 <param name="importsKeyword">
 The "Imports" keyword.
 </param>
 <param name="importsClauses">
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SimpleImportsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportAliasClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameSyntax)">
 <summary>
 Represents the clause of an Imports statement that imports all members of a
 type or namespace or aliases a type or namespace.
 </summary>
 <param name="alias">
 An optional alias for the namespace or type being imported.
 </param>
 <param name="name">
 The namespace or type being imported.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ImportAliasClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an alias identifier followed by an "=" token in an Imports clause.
 </summary>
 <param name="identifier">
 The identifier being introduced.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlNamespaceImportsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlAttributeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Defines a XML namespace for XML expressions.
 </summary>
 <param name="xmlNamespace">
 Identifies the XML namespace alias and URI.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NamespaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamespaceStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
 <param name="namespaceStatement">
 The statement that begins the NamespaceBlock.
 </param>
 <param name="members">
 The declarations contained in the namespace statement.
 </param>
 <param name="endNamespaceStatement">
 The End Namespace statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NamespaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameSyntax)">
 <summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
 <param name="namespaceKeyword">
 The "Namespace" keyword.
 </param>
 <param name="name">
 A (possibly dotted) name denoting the namespace being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ModuleBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModuleStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
 <param name="moduleStatement">
 The "Module" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
 <param name="endModuleStatement">
 The "End Module" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.StructureBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StructureStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
 <param name="structureStatement">
 The "Structure" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
 <param name="endStructureStatement">
 The "End Structure" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.InterfaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterfaceStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
 <param name="interfaceStatement">
 The "Interface" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
 <param name="endInterfaceStatement">
 The "End Interface" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ClassBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ClassStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
 <param name="classStatement">
 The "Class" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
 <param name="endClassStatement">
 The "End Class" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EnumBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
 <param name="enumStatement">
 The statement that begins the type or module.
 </param>
 <param name="members">
 The declarations contained in the enumeration.
 </param>
 <param name="endEnumStatement">
 The End XXX statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.InheritsStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax})">
 <summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
 <param name="inheritsKeyword">
 The "Inherits" keyword.
 </param>
 <param name="types">
 A list of the types being inherited.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ImplementsStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax})">
 <summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
 <param name="implementsKeyword">
 The "Implements" keyword.
 </param>
 <param name="types">
 A list of the types being implemented.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ModuleStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="moduleKeyword">
 The "Module" keyword.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.StructureStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="structureKeyword">
 The "Structure" keyword.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.InterfaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="interfaceKeyword">
 The "Interface" keyword.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ClassStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="classKeyword">
 The "Class" keyword.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EnumStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AsClauseSyntax)">
 <summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="enumKeyword">
 The "Enum" keyword.
 </param>
 <param name="identifier">
 The name of the enum being declared.
 </param>
 <param name="underlyingType">
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TypeParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the type parameter list in a declaration.
 </summary>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="ofKeyword">
 The "Of" keyword.
 </param>
 <param name="parameters">
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TypeParameter(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax)">
 <summary>
 Represents a type parameter on a generic type declaration.
 </summary>
 <param name="varianceKeyword">
 Represents the "In" or "Out" variance keyword on a type parameter, if present.
 If no variance modifier was present, Nothing is returned.
 </param>
 <param name="identifier">
 The name of the type parameter
 </param>
 <param name="typeParameterConstraintClause">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TypeParameterSingleConstraintClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstraintSyntax)">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
 <param name="asKeyword">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
 <param name="constraint">
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TypeParameterMultipleConstraintClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstraintSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
 <param name="asKeyword">
 The "As" keyword.
 </param>
 <param name="openBraceToken">
 The "{" token.
 </param>
 <param name="constraints">
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </param>
 <param name="closeBraceToken">
 The "}" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NewConstraint(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
 <param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ClassConstraint(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
 <param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.StructureConstraint(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
 <param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SpecialConstraint(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 SpecialConstraintSyntax. One of NewConstraint, ClassConstraint,
 StructureConstraint.
 </param>
 <param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TypeConstraint(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax)">
 <summary>
 Represents a type parameter constraint that is a type.
 </summary>
 <param name="type">
 The type describing the constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EnumMemberDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EqualsValueSyntax)">
 <summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
 <param name="initializer">
 An optional value for the enum member.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SubBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 The "End Sub" or "End Function" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.FunctionBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 The "End Sub" or "End Function" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MethodBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of MethodBlockSyntax.
 One of SubBlock, FunctionBlock.
 </param>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 The "End Sub" or "End Function" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ConstructorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SubNewStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a constructor block declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subNewStatement">
 The "Sub New" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endSubStatement">
 The "End Sub" statement that ends the block declaration.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.OperatorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OperatorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an Operator block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="operatorStatement">
 The "Operator" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endOperatorStatement">
 The "End Operator" statement that ends the block declaration.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.GetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AddHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.RemoveHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.RaiseEventAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AccessorBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of AccessorBlockSyntax.
 One of GetAccessorBlock, SetAccessorBlock, AddHandlerAccessorBlock,
 RemoveHandlerAccessorBlock, RaiseEventAccessorBlock.
 </param>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.PropertyBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
 <param name="propertyStatement">
 The property declaration that begins the block.
 </param>
 <param name="accessors">
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </param>
 <param name="endPropertyStatement">
 The End Property statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EventBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
 <param name="eventStatement">
 The event declaration that begins the block.
 </param>
 <param name="accessors">
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </param>
 <param name="endEventStatement">
 The End Event statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the parameter list in a method declaration.
 </summary>
 <param name="openParenToken">
 The "(" token that introduces the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="parameters">
 The list of parameters. If no parameter list was present, Nothing is returned.
 </param>
 <param name="closeParenToken">
 The ")" token that concludes the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SubStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this method declaration.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.FunctionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this method declaration.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MethodStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MethodStatementSyntax. One of SubStatement, FunctionStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this method declaration.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SubNewStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subKeyword">
 The "Sub" keyword.
 </param>
 <param name="newKeyword">
 The "New" keyword in the constructor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DeclareSubStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="declareKeyword">
 The "Declare" keyword.
 </param>
 <param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libKeyword">
 The "Lib" keyword.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
 <param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
 <param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DeclareFunctionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="declareKeyword">
 The "Declare" keyword.
 </param>
 <param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libKeyword">
 The "Lib" keyword.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
 <param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
 <param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DeclareStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="declareKeyword">
 The "Declare" keyword.
 </param>
 <param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libKeyword">
 The "Lib" keyword.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
 <param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
 <param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DelegateSubStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DelegateFunctionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DelegateStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DelegateStatementSyntax. One of DelegateSubStatement,
 DelegateFunctionStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax)">
 <summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="customKeyword">
 The optional Custom keyword for custom event declarations.
 </param>
 <param name="eventKeyword">
 The "Event" keyword that introduces this event declaration.
 </param>
 <param name="identifier">
 The name of the event being declared.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.OperatorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="operatorKeyword">
 The "Operator" keyword that introduces this operator declaration.
 </param>
 <param name="operatorToken">
 The operator being defined.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.PropertyStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EqualsValueSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax)">
 <summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="propertyKeyword">
 The "Property" keyword that introduces this property declaration.
 </param>
 <param name="identifier">
 The name of the property being declared.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="initializer">
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.GetAccessorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SetAccessorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AddHandlerAccessorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.RemoveHandlerAccessorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.RaiseEventAccessorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AccessorStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AccessorStatementSyntax. One of GetAccessorStatement, SetAccessorStatement,
 AddHandlerAccessorStatement, RemoveHandlerAccessorStatement,
 RaiseEventAccessorStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ImplementsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.QualifiedNameSyntax})">
 <summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
 <param name="implementsKeyword">
 The "Implements" keyword.
 </param>
 <param name="interfaceMembers">
 The list of interface members being implemented.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.HandlesClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseItemSyntax})">
 <summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
 <param name="handlesKeyword">
 The "Handles" keyword.
 </param>
 <param name="events">
 The list of event members being handled.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.KeywordEventContainer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents event container specified through special keywords "Me", "MyBase" or
 "MyClass"..
 </summary>
 <param name="keyword">
 The container of the event. This can be one of the special keywords: "Me",
 "MyBase" or "MyClass".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.WithEventsEventContainer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax)">
 <summary>
 Represents event container that refers to a WithEvents member.
 </summary>
 <param name="identifier">
 The container of the event. It is a simple identifier that refers to a
 WithEvents member of the containing type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.WithEventsPropertyEventContainer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithEventsEventContainerSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax)">
 <summary>
 Represents event container that refers to a WithEvents member's property.
 </summary>
 <param name="withEventsContainer">
 The container of the event.
 </param>
 <param name="dotToken">
 The "." token.
 </param>
 <param name="property">
 The provider of the event. It is a property of a WithEvents member of the
 containing type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.HandlesClauseItem(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventContainerSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax)">
 <summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
 <param name="eventContainer">
 The container of the event. This can either be a simple identifier (identifying
 a members of the containing type) or one of the special keywords "Me", "MyBase"
 or "MyClass".
 </param>
 <param name="dotToken">
 The "." token.
 </param>
 <param name="eventMember">
 The event being handled. This must be a simple identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.IncompleteMember(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax)">
 <summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="missingIdentifier">
 The missing identifier token for this incomplete member. Should only be used to
 have a location for error reporting.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.FieldDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableDeclaratorSyntax})">
 <summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.VariableDeclarator(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EqualsValueSyntax)">
 <summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
 <param name="names">
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type, and possibly includes "New",
 "With" or "From". If no As clause was present, Nothing is returned.
 </param>
 <param name="initializer">
 If present, an "= initial-value" clause describing the initial value of the
 variable or the value of the constant.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SimpleAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax)">
 <summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
 <param name="asKeyword">
 The "As" keyword.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="type">
 The type-name part of the As clause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AsNewClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NewExpressionSyntax)">
 <summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
 <param name="asKeyword">
 The "As" keyword.
 </param>
 <param name="newExpression">
 The New expression
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ObjectMemberInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FieldInitializerSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
 <param name="withKeyword">
 The "With" keyword.
 </param>
 <param name="openBraceToken">
 The "{" token.
 </param>
 <param name="initializers">
 The comma-separated list of field initializers.
 </param>
 <param name="closeBraceToken">
 The "}" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ObjectCollectionInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionInitializerSyntax)">
 <summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
 <param name="fromKeyword">
 The "From" keyword.
 </param>
 <param name="initializer">
 The initializer including the braces.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.InferredFieldInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
 <param name="keyKeyword">
 The optional "Key" keyword.
 </param>
 <param name="expression">
 The value being assigned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NamedFieldInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
 <param name="keyKeyword">
 The optional "Key" keyword.
 </param>
 <param name="dotToken">
 The "." token.
 </param>
 <param name="name">
 The name of the field being initialized.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
 <param name="expression">
 The value being assigned to the field.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EqualsValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an "= initializer" clause in a declaration for a variable, parameter
 or automatic property.
 </summary>
 <param name="equalsToken">
 The "=" token.
 </param>
 <param name="value">
 The expression used as the initial value.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.Parameter(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EqualsValueSyntax)">
 <summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this parameter. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
 modify this parameter.
 </param>
 <param name="identifier">
 The name of the parameter, including any "?" or "()" modifiers.
 </param>
 <param name="asClause">
 If present, the "As type-name" clause describing the type of the parameter. If
 no As clause is present, Nothing is returned.
 </param>
 <param name="default">
 If present, an initializer with the default value of the parameter. If no
 default value is present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ModifiedIdentifier(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
 <param name="identifier">
 The identifier that names the item being declared.
 </param>
 <param name="nullable">
 The "?" token that indicates a nullable type.
 </param>
 <param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
 <param name="arrayRankSpecifiers">
 A list of array modifiers for the type. If no array modifiers were present, an
 empty list is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ArrayRankSpecifier(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="commaTokens">
 The comma tokens in the array type. There is one less comma than the rank.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AttributeList(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
 <param name="lessThanToken">
 The "&lt;" token.
 </param>
 <param name="attributes">
 A comma separated list of attribute declarations in this attribute list.
 </param>
 <param name="greaterThanToken">
 The "&gt;" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.Attribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeTargetSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax)">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
 <param name="target">
 Optional attribute target. Assembly|Module :
 </param>
 <param name="name">
 The name of the attribute.
 </param>
 <param name="argumentList">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AttributeTarget(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
 <param name="attributeModifier">
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </param>
 <param name="colonToken">
 The ":" token, if an attribute modifier is present. If no attribute modifier is
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AttributesStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
 <param name="attributeLists">
 The list of attribute lists.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExpressionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represent an expression in a statement context. This may only be a invocation
 or await expression in standard code but may be any expression in VB
 Interactive code.
 </summary>
 <param name="expression">
 The expression.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.PrintStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represent a "? expression" "Print" statement in VB Interactive code.
 </summary>
 <param name="questionToken">
 "?" token.
 </param>
 <param name="expression">
 The expression whose value is being output.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.WhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
 <param name="whileStatement">
 The While statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the While...End While. This might be an empty list.
 </param>
 <param name="endWhileStatement">
 The End While statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.UsingBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UsingStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
 <param name="usingStatement">
 The UsingStatement that begins the Using...End Using block.
 </param>
 <param name="statements">
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </param>
 <param name="endUsingStatement">
 The End Using statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SyncLockBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyncLockStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statement.
 </summary>
 <param name="syncLockStatement">
 The SyncLock statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </param>
 <param name="endSyncLockStatement">
 The End SyncLock statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.WithBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
 <param name="withStatement">
 The WithStatement that begins the With...End With block.
 </param>
 <param name="statements">
 The statements contained in the With...End With block. This might be an empty
 list.
 </param>
 <param name="endWithStatement">
 The End With statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LocalDeclarationStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableDeclaratorSyntax})">
 <summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
 <param name="modifiers">
 The modifier token (Static, Dim or Const) that introduces this local variable
 declaration.
 </param>
 <param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LabelStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a label statement.
 </summary>
 <param name="labelToken">
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </param>
 <param name="colonToken">
 The ":" token of the label statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.GoToStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents a "GoTo" statement.
 </summary>
 <param name="goToKeyword">
 The "GoTo" keyword.
 </param>
 <param name="label">
 The name of the label. If the label is a line number, wraps an IntegerLiteral
 that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.IdentifierLabel(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NumericLabel(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NextLabel(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.Label(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LabelSyntax. One of
 IdentifierLabel, NumericLabel, NextLabel.
 </param>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.StopStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
 <param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
 <param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.StopOrEndStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 StopOrEndStatementSyntax. One of StopStatement, EndStatement.
 </param>
 <param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExitDoStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExitForStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExitSubStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExitFunctionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExitOperatorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExitPropertyStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExitTryStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExitSelectStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExitWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExitStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of ExitStatementSyntax.
 One of ExitDoStatement, ExitForStatement, ExitSubStatement,
 ExitFunctionStatement, ExitOperatorStatement, ExitPropertyStatement,
 ExitTryStatement, ExitSelectStatement, ExitWhileStatement.
 </param>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ContinueWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
 <param name="continueKeyword">
 The "Continue" keyword.
 </param>
 <param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ContinueDoStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
 <param name="continueKeyword">
 The "Continue" keyword.
 </param>
 <param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ContinueForStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
 <param name="continueKeyword">
 The "Continue" keyword.
 </param>
 <param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ContinueStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 ContinueStatementSyntax. One of ContinueWhileStatement, ContinueDoStatement,
 ContinueForStatement.
 </param>
 <param name="continueKeyword">
 The "Continue" keyword.
 </param>
 <param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ReturnStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Return" statement.
 </summary>
 <param name="returnKeyword">
 The "Return" keyword.
 </param>
 <param name="expression">
 The expression being returned, if present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SingleLineIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineElseClauseSyntax)">
 <summary>
 Represents a single-line "If ... Then ... Else ..." statement.
 </summary>
 <param name="ifKeyword">
 The "If" keyword.
 </param>
 <param name="condition">
 The condition expression to be evaluated.
 </param>
 <param name="thenKeyword">
 The "Then" keyword.
 </param>
 <param name="statements">
 A list of statements to be executed if the condition expression evaluates as
 true. Multiple statements must be separated by colons.
 </param>
 <param name="elseClause">
 An "Else" clause to be executed if the condition expression evaluates as false.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SingleLineElseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents the "Else ..." clause of a single-line "If" statement.
 </summary>
 <param name="elseKeyword">
 The "Else" keyword.
 </param>
 <param name="statements">
 A list of statements to be executed. Multiple statements must be separated by
 colons.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MultiLineIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IfStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseBlockSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line "If ... Then ... ElseIf ... Then ... Else ... End If"
 block.
 </summary>
 <param name="ifStatement">
 The "If" statement that begins the "If" block.
 </param>
 <param name="statements">
 A list of statements to be executed if the condition expression evaluates as
 true.
 </param>
 <param name="elseIfBlocks">
 A list of "ElseIf" blocks to be evaluated, in order, if the condition
 expression of the "If" statement evaluates as false.
 </param>
 <param name="elseBlock">
 An "Else" block to be executed if the condition expression of the "If"
 statement and all "ElseIf" blocks evaluate as false.
 </param>
 <param name="endIfStatement">
 Then "End If" statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.IfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the "If ... Then" statement that begins a multi-line "If" block.
 </summary>
 <param name="ifKeyword">
 The "If" keyword.
 </param>
 <param name="condition">
 The condition expression to be evaluated.
 </param>
 <param name="thenKeyword">
 The "Then" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ElseIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseIfStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents an "ElseIf ... Then ..." block.
 </summary>
 <param name="elseIfStatement">
 The "ElseIf ... Then" statement the begins the "ElseIf" block.
 </param>
 <param name="statements">
 A list of statements to be executed if the condition expression of the "ElseIf"
 statement evaluates as true.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ElseIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the "ElseIf ... Then" statement that begins an "ElseIf" block.
 </summary>
 <param name="elseIfKeyword">
 The "ElseIf" keyword.
 </param>
 <param name="condition">
 The condition expression to be evaluated.
 </param>
 <param name="thenKeyword">
 The "Then" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ElseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents an "Else ..." block.
 </summary>
 <param name="elseStatement">
 The "Else" statement that begins the "Else" block.
 </param>
 <param name="statements">
 A list of statements to be executed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ElseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the "Else" statement that begins an "Else" block.
 </summary>
 <param name="elseKeyword">
 The "Else" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TryBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FinallyBlockSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a "Try ... Catch ... Finally ... End Try" block.
 </summary>
 <param name="tryStatement">
 The "Try" statement that begins the "Try" block.
 </param>
 <param name="statements">
 A list of statements to be executed.
 </param>
 <param name="catchBlocks">
 A list of "Catch" blocks which may be executed if an exception is thrown while
 executing the statements in the "Try" block.
 </param>
 <param name="finallyBlock">
 A "Finally" block to be executed before execution leaves the "Try" block.
 </param>
 <param name="endTryStatement">
 The "End Try" statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TryStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the "Try" statement that begins a "Try" block.
 </summary>
 <param name="tryKeyword">
 The "Try" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CatchBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents a "Catch ..." block.
 </summary>
 <param name="catchStatement">
 The "Catch" statement that begins the "Catch" block.
 </param>
 <param name="statements">
 A list of statements to be executed if an exception is caught by the "Catch"
 block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CatchStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchFilterClauseSyntax)">
 <summary>
 Represents the "Catch ... When ..." statement that begins a "Catch" block.
 </summary>
 <param name="catchKeyword">
 The "Catch" keyword.
 </param>
 <param name="identifierName">
 An identifier declaring a new variable or naming an existing variable to store
 the exception caught by the "Catch" statement.
 </param>
 <param name="asClause">
 A simple "As" clause specifying the type of exception to catch.
 </param>
 <param name="whenClause">
 A "When" clause to filter exceptions before catching.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CatchFilterClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents the "When ..." clause of a "Catch" statement.
 </summary>
 <param name="whenKeyword">
 The "When" keyword.
 </param>
 <param name="filter">
 The filter expression to be evaluated.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.FinallyBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FinallyStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents a "Finally ..." block of a "Try" block.
 </summary>
 <param name="finallyStatement">
 The "Finally" statement that begins the "Finally" block.
 </param>
 <param name="statements">
 A list of statements to be executed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.FinallyStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the "Finally" statement that begins a "Finally" block.
 </summary>
 <param name="finallyKeyword">
 The "Finally" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ErrorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents the "Error" statement.
 </summary>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="errorNumber">
 The expression that represents the error number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.OnErrorGoToZeroStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="goToKeyword">
 The "GoTo" keyword
 </param>
 <param name="minus">
 An optional minus for On Error Goto -1
 </param>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.OnErrorGoToMinusOneStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="goToKeyword">
 The "GoTo" keyword
 </param>
 <param name="minus">
 An optional minus for On Error Goto -1
 </param>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.OnErrorGoToLabelStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="goToKeyword">
 The "GoTo" keyword
 </param>
 <param name="minus">
 An optional minus for On Error Goto -1
 </param>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.OnErrorGoToStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 OnErrorGoToStatementSyntax. One of OnErrorGoToZeroStatement,
 OnErrorGoToMinusOneStatement, OnErrorGoToLabelStatement.
 </param>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="goToKeyword">
 The "GoTo" keyword
 </param>
 <param name="minus">
 An optional minus for On Error Goto -1
 </param>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.OnErrorResumeNextStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an OnError Resume Next statement.
 </summary>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="resumeKeyword">
 The "Resume" keyword.
 </param>
 <param name="nextKeyword">
 The "Next"
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ResumeStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="resumeKeyword">
 The "Resume" keyword.
 </param>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ResumeLabelStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="resumeKeyword">
 The "Resume" keyword.
 </param>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ResumeNextStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="resumeKeyword">
 The "Resume" keyword.
 </param>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SelectBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
 <param name="selectStatement">
 The Select Case statement that begins the block.
 </param>
 <param name="caseBlocks">
 A list of the contained Case blocks.
 </param>
 <param name="endSelectStatement">
 The End Select statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SelectStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
 <param name="selectKeyword">
 The "Select" keyword.
 </param>
 <param name="caseKeyword">
 The "Case" keyword, if present.
 </param>
 <param name="expression">
 The value that branching is based on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CaseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
 <param name="caseStatement">
 The statement that begins the case block.
 </param>
 <param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CaseElseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
 <param name="caseStatement">
 The statement that begins the case block.
 </param>
 <param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CaseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseClauseSyntax})">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
 <param name="caseKeyword">
 The "Case" keyword
 </param>
 <param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CaseElseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseClauseSyntax})">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
 <param name="caseKeyword">
 The "Case" keyword
 </param>
 <param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ElseCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 The "Else" part in a Case Else statement.
 </summary>
 <param name="elseKeyword">
 The "Else" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SimpleCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a single value in a Case.
 </summary>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.RangeCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a range "expression To expression" in a Case.
 </summary>
 <param name="lowerBound">
 The lower bound of the range.
 </param>
 <param name="toKeyword">
 The "To" keyword
 </param>
 <param name="upperBound">
 The upper bound of the range.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CaseEqualsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CaseNotEqualsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CaseLessThanClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CaseLessThanOrEqualClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CaseGreaterThanOrEqualClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CaseGreaterThanClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.RelationalCaseClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 RelationalCaseClauseSyntax. One of CaseEqualsClause, CaseNotEqualsClause,
 CaseLessThanClause, CaseLessThanOrEqualClause, CaseGreaterThanOrEqualClause,
 CaseGreaterThanClause.
 </param>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SyncLockStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
 <param name="syncLockKeyword">
 The "SyncLock" keyword.
 </param>
 <param name="expression">
 The expression being synchronized on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SimpleDoLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DoWhileLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DoUntilLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DoLoopWhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DoLoopUntilBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DoLoopBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of DoLoopBlockSyntax.
 One of SimpleDoLoopBlock, DoWhileLoopBlock, DoUntilLoopBlock, DoLoopWhileBlock,
 DoLoopUntilBlock.
 </param>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SimpleDoStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="doKeyword">
 The "Do" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DoWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="doKeyword">
 The "Do" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DoUntilStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="doKeyword">
 The "Do" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DoStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of DoStatementSyntax.
 One of SimpleDoStatement, DoWhileStatement, DoUntilStatement.
 </param>
 <param name="doKeyword">
 The "Do" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SimpleLoopStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="loopKeyword">
 The "Loop" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LoopWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="loopKeyword">
 The "Loop" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LoopUntilStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="loopKeyword">
 The "Loop" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LoopStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LoopStatementSyntax.
 One of SimpleLoopStatement, LoopWhileStatement, LoopUntilStatement.
 </param>
 <param name="loopKeyword">
 The "Loop" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.WhileClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
 <param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
 <param name="condition">
 The boolean expression after the While or Until.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.UntilClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
 <param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
 <param name="condition">
 The boolean expression after the While or Until.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.WhileOrUntilClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 WhileOrUntilClauseSyntax. One of WhileClause, UntilClause.
 </param>
 <param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
 <param name="condition">
 The boolean expression after the While or Until.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.WhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
 <param name="whileKeyword">
 The "While" keyword.
 </param>
 <param name="condition">
 The boolean expression that controls the While loop.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ForBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NextStatementSyntax)">
 <summary>
 Represents a For block, including the introducing statement, the body and the
 "Next" (which can be omitted if a containing For has a Next with multiple
 variables).
 </summary>
 <param name="forStatement">
 The For statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
 <param name="nextStatement">
 The Next statement that ends the block. If two For or For Each statements are
 ended by a single Next statement, the inner For will not have a Next statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ForEachBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForEachStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NextStatementSyntax)">
 <summary>
 Represents a For Each block, including the introducing statement, the body and
 the "Next" (which can be omitted if a containing For has a Next with multiple
 variables).
 </summary>
 <param name="forEachStatement">
 The For Each statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
 <param name="nextStatement">
 The Next statement that ends the block. If two For or For Each statements are
 ended by a single Next statement, the inner For will not have a Next statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ForStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStepClauseSyntax)">
 <summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
 <param name="forKeyword">
 The "For" keyword.
 </param>
 <param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
 <param name="fromValue">
 The expression denoting the initial value of the iteration.
 </param>
 <param name="toKeyword">
 The "To" keyword.
 </param>
 <param name="toValue">
 The expression denoting the final value of the iteration.
 </param>
 <param name="stepClause">
 The optional Step clause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ForStepClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 The Step clause in a For Statement.
 </summary>
 <param name="stepKeyword">
 The "Step" keyword.
 </param>
 <param name="stepValue">
 The expression denoting the step increment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ForEachStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
 <param name="forKeyword">
 The "For" keyword.
 </param>
 <param name="eachKeyword">
 The "Each" keyword.
 </param>
 <param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
 <param name="inKeyword">
 The "In" keyword.
 </param>
 <param name="expression">
 The expression denoting the collection to iterate over.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NextStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax})">
 <summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
 <param name="nextKeyword">
 The "Next" keyword.
 </param>
 <param name="controlVariables">
 The variables in the Next statement, if present
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.UsingStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableDeclaratorSyntax})">
 <summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
 <param name="usingKeyword">
 The "Using" keyword.
 </param>
 <param name="expression">
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </param>
 <param name="variables">
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ThrowStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a Throw statement.
 </summary>
 <param name="throwKeyword">
 The "Throw" keyword
 </param>
 <param name="expression">
 The expression denoting the value being thrown.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SimpleAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MidAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AddAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SubtractAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MultiplyAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DivideAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.IntegerDivideAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExponentiateAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LeftShiftAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.RightShiftAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ConcatenateAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AssignmentStatementSyntax. One of SimpleAssignmentStatement,
 MidAssignmentStatement, AddAssignmentStatement, SubtractAssignmentStatement,
 MultiplyAssignmentStatement, DivideAssignmentStatement,
 IntegerDivideAssignmentStatement, ExponentiateAssignmentStatement,
 LeftShiftAssignmentStatement, RightShiftAssignmentStatement,
 ConcatenateAssignmentStatement.
 </param>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MidExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax)">
 <summary>
 Represents a left-hand side of a MidAssignment statement.
 </summary>
 <param name="mid">
 The "Mid" possibly followed by a type character.
 </param>
 <param name="argumentList">
 The argument list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CallStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
 <param name="callKeyword">
 The "Call" keyword.
 </param>
 <param name="invocation">
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AddHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
 <param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
 <param name="eventExpression">
 The event being accessed.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.RemoveHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
 <param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
 <param name="eventExpression">
 The event being accessed.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AddRemoveHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AddRemoveHandlerStatementSyntax. One of AddHandlerStatement,
 RemoveHandlerStatement.
 </param>
 <param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
 <param name="eventExpression">
 The event being accessed.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.RaiseEventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax)">
 <summary>
 Represent a RaiseEvent statement.
 </summary>
 <param name="raiseEventKeyword">
 The "RaiseEvent" keyword
 </param>
 <param name="name">
 The name of the event being raised.
 </param>
 <param name="argumentList">
 The argument list, if present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.WithStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
 <param name="withKeyword">
 The "With" keyword.
 </param>
 <param name="expression">
 The expression that is the operand of the With statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ReDimStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RedimClauseSyntax})">
 <summary>
 Represents a ReDim statement.
 </summary>
 <param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
 <param name="preserveKeyword">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
 <param name="clauses">
 The list of ReDim clauses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ReDimPreserveStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RedimClauseSyntax})">
 <summary>
 Represents a ReDim statement.
 </summary>
 <param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
 <param name="preserveKeyword">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
 <param name="clauses">
 The list of ReDim clauses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.RedimClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax)">
 <summary>
 Represents a ReDim statement clause.
 </summary>
 <param name="expression">
 The target of the ReDim statement.
 </param>
 <param name="arrayBounds">
 The ArraySizeInitializationModifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EraseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax})">
 <summary>
 Represents an "Erase" statement.
 </summary>
 <param name="eraseKeyword">
 The "Erase" keyword.
 </param>
 <param name="expressions">
 A list of expressions denoting the arrays to erase.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CharacterLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TrueLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.FalseLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NumericLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DateLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.StringLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NothingLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LiteralExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 LiteralExpressionSyntax. One of CharacterLiteralExpression,
 TrueLiteralExpression, FalseLiteralExpression, NumericLiteralExpression,
 DateLiteralExpression, StringLiteralExpression, NothingLiteralExpression.
 </param>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ParenthesizedExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a parenthesized expression.
 </summary>
 <param name="openParenToken">
 The "(" token
 </param>
 <param name="expression">
 The expression inside the parentheses.
 </param>
 <param name="closeParenToken">
 The ")" token
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Identifies the special instance "Me"
 </summary>
 <param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MyBaseExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Identifies the special instance "MyBase"
 </summary>
 <param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MyClassExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Identifies the special instance "MyClass"
 </summary>
 <param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.GetTypeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a GetType expression.
 </summary>
 <param name="getTypeKeyword">
 The "GetType" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="type">
 The type to get the Type object for. This can be an open generic type.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TypeOfIsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax)">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
 <param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
 <param name="expression">
 The expression being tested.
 </param>
 <param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
 <param name="type">
 The name of the type being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TypeOfIsNotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax)">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
 <param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
 <param name="expression">
 The expression being tested.
 </param>
 <param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
 <param name="type">
 The name of the type being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TypeOfExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax)">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 TypeOfExpressionSyntax. One of TypeOfIsExpression, TypeOfIsNotExpression.
 </param>
 <param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
 <param name="expression">
 The expression being tested.
 </param>
 <param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
 <param name="type">
 The name of the type being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.GetXmlNamespaceExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlPrefixNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a GetXmlNamespace expression.
 </summary>
 <param name="getXmlNamespaceKeyword">
 The "GetXmlNamespace" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="name">
 The Xml namespace name being referenced.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SimpleMemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
 <param name="operatorToken">
 The "." or "!" token.
 </param>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DictionaryAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
 <param name="operatorToken">
 The "." or "!" token.
 </param>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MemberAccessExpressionSyntax. One of SimpleMemberAccessExpression,
 DictionaryAccessExpression.
 </param>
 <param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
 <param name="operatorToken">
 The "." or "!" token.
 </param>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlElementAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token1">
 The initial dot "." part of the separator.
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="token3">
 The third "." in a "..." separator.
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlDescendantAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token1">
 The initial dot "." part of the separator.
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="token3">
 The third "." in a "..." separator.
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlAttributeAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token1">
 The initial dot "." part of the separator.
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="token3">
 The third "." in a "..." separator.
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlMemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
 XmlDescendantAccessExpression, XmlAttributeAccessExpression.
 </param>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token1">
 The initial dot "." part of the separator.
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="token3">
 The third "." in a "..." separator.
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.InvocationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax)">
 <summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
 <param name="expression">
 The target of the call or index expression.
 </param>
 <param name="argumentList">
 The argument list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ObjectCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectCreationInitializerSyntax)">
 <summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
 <param name="newKeyword">
 The "New" keyword.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="type">
 The type of the object being initialized.
 </param>
 <param name="argumentList">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
 <param name="initializer">
 An optional From or With clause to initialize the new object.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectMemberInitializerSyntax)">
 <summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
 <param name="newKeyword">
 The "New" keyword.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="initializer">
 The With clause to initialize the new object.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ArrayCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionInitializerSyntax)">
 <summary>
 Represents an expression that creates a new array.
 </summary>
 <param name="newKeyword">
 The "New" keyword.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="type">
 The element type of the array being created.
 </param>
 <param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
 <param name="rankSpecifiers">
 A list of array modifiers such as "()" or "(,)". If no array modifiers were
 present, an empty list is returned.
 </param>
 <param name="initializer">
 The initializer including the braces.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CollectionInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
 <param name="openBraceToken">
 The "{" token.
 </param>
 <param name="initializers">
 The list of initializers between the braces.
 </param>
 <param name="closeBraceToken">
 The "}" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CTypeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="expression">
 The expression being cast.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="type">
 The type the expression is being cast to.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DirectCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="expression">
 The expression being cast.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="type">
 The type the expression is being cast to.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TryCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="expression">
 The expression being cast.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="type">
 The type the expression is being cast to.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.PredefinedCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
 <param name="keyword">
 The keyword that was used in the cast operation.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="expression">
 The expression being cast.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AddExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SubtractExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MultiplyExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DivideExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.IntegerDivideExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExponentiateExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LeftShiftExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.RightShiftExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ConcatenateExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ModuloExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EqualsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NotEqualsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LessThanExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LessThanOrEqualExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.GreaterThanOrEqualExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.GreaterThanExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.IsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.IsNotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LikeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.OrExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExclusiveOrExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AndExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.OrElseExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AndAlsoExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.BinaryExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 BinaryExpressionSyntax. One of AddExpression, SubtractExpression,
 MultiplyExpression, DivideExpression, IntegerDivideExpression,
 ExponentiateExpression, LeftShiftExpression, RightShiftExpression,
 ConcatenateExpression, ModuloExpression, EqualsExpression, NotEqualsExpression,
 LessThanExpression, LessThanOrEqualExpression, GreaterThanOrEqualExpression,
 GreaterThanExpression, IsExpression, IsNotExpression, LikeExpression,
 OrExpression, ExclusiveOrExpression, AndExpression, OrElseExpression,
 AndAlsoExpression.
 </param>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.UnaryPlusExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.UnaryMinusExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AddressOfExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.UnaryExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 UnaryExpressionSyntax. One of UnaryPlusExpression, UnaryMinusExpression,
 NotExpression, AddressOfExpression.
 </param>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.BinaryConditionalExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
 <param name="ifKeyword">
 The "If" keyword
 </param>
 <param name="openParenToken">
 The "(" token
 </param>
 <param name="firstExpression">
 The first expression inside the parentheses.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="secondExpression">
 The second expression inside the parentheses.
 </param>
 <param name="closeParenToken">
 The ")" token
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TernaryConditionalExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
 <param name="ifKeyword">
 The "If" keyword
 </param>
 <param name="openParenToken">
 The "(" token
 </param>
 <param name="condition">
 The first expression inside the parentheses.
 </param>
 <param name="firstCommaToken">
 The "," token.
 </param>
 <param name="whenTrue">
 The second expression inside the parentheses.
 </param>
 <param name="secondCommaToken">
 The "," token.
 </param>
 <param name="whenFalse">
 The second expression inside the parentheses.
 </param>
 <param name="closeParenToken">
 The ")" token
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SingleLineFunctionLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents a single line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SingleLineSubLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents a single line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SingleLineLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents a single line lambda expression.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 SingleLineLambdaExpressionSyntax. One of SingleLineFunctionLambdaExpression,
 SingleLineSubLambdaExpression.
 </param>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MultiLineFunctionLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MultiLineSubLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.MultiLineLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MultiLineLambdaExpressionSyntax. One of MultiLineFunctionLambdaExpression,
 MultiLineSubLambdaExpression.
 </param>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SubLambdaHeader(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 Represents the header part of a lambda expression
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this lambda expression.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.FunctionLambdaHeader(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 Represents the header part of a lambda expression
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this lambda expression.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LambdaHeader(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 Represents the header part of a lambda expression
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LambdaHeaderSyntax.
 One of SubLambdaHeader, FunctionLambdaHeader.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this lambda expression.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ArgumentList(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a parenthesized argument list.
 </summary>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="arguments">
 The list of arguments. This may be empty. Omitted argument are represented by
 an OmittedArgumentSyntax node.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.OmittedArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
 <param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SimpleArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameColonEqualsSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an argument that is just an optional argument name and an
 expression.
 </summary>
 <param name="nameColonEquals">
 The optional name and ":=" prefix of a named argument.
 </param>
 <param name="expression">
 The expression that is the argument.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NameColonEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an identifier name followed by a ":=" token in a named argument.
 </summary>
 <param name="name">
 The name used to identify the named argument.
 </param>
 <param name="colonEqualsToken">
 The ":=" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.RangeArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
 <param name="lowerBound">
 The lower bound of the range. This is typically the integer constant zero.
 </param>
 <param name="toKeyword">
 The "To" keyword.
 </param>
 <param name="upperBound">
 The upper bound of the range.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.QueryExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
 <param name="clauses">
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CollectionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
 <param name="identifier">
 The name of the range variable being defined.
 </param>
 <param name="asClause">
 Describes the type of the variable being defined.
 </param>
 <param name="inKeyword">
 The "In" keyword.
 </param>
 <param name="expression">
 The expression that serves as the source of items for the range variable.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExpressionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableNameEqualsSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
 <param name="nameEquals">
 The optional name and type of the expression range variable. If omitted, the
 name of the expression range variable is inferred from the expression.
 </param>
 <param name="expression">
 The expression used to initialize the expression variable.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AggregationRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableNameEqualsSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationSyntax)">
 <summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
 <param name="nameEquals">
 The optional name and type of the expression range variable. If omitted, the
 name of the expression range variable is inferred from the aggregation
 expression.
 </param>
 <param name="aggregation">
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.VariableNameEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the name and optional type of an expression range variable.
 </summary>
 <param name="identifier">
 The name of the variable being defined.
 </param>
 <param name="asClause">
 Describes the type of the variable being defined.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.FunctionAggregation(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
 <param name="functionName">
 The name of the aggregation function.
 </param>
 <param name="openParenToken">
 The "(" token if present.
 </param>
 <param name="argument">
 The argument to the aggregation function.
 </param>
 <param name="closeParenToken">
 The ")" token, if present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.GroupAggregation(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
 <param name="groupKeyword">
 The "Group" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.FromClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax})">
 <summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
 <param name="fromKeyword">
 The "From" keyword.
 </param>
 <param name="variables">
 The list of collection variables declared by this From operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LetClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionRangeVariableSyntax})">
 <summary>
 Represents a "Let" query operator.
 </summary>
 <param name="letKeyword">
 The "Let" keyword.
 </param>
 <param name="variables">
 The list of expression range variable being defined by the Let operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AggregateClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents an Aggregate query operator.
 </summary>
 <param name="aggregateKeyword">
 The "Aggregate" keyword.
 </param>
 <param name="variables">
 The list of collection range variables declared by this Aggregate operator.
 </param>
 <param name="additionalQueryOperators">
 A list of additional query operators. It may be empty.
 </param>
 <param name="intoKeyword">
 The "Into" keyword.
 </param>
 <param name="aggregationVariables">
 The list of new variables being defined by the aggregation.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DistinctClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the "Distinct" query operator.
 </summary>
 <param name="distinctKeyword">
 The "Distinct" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.WhereClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Where" query operator.
 </summary>
 <param name="whereKeyword">
 The "Where" keyword.
 </param>
 <param name="condition">
 The boolean expression used for filtering.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SkipWhileClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="whileKeyword">
 The "While" keyword.
 </param>
 <param name="condition">
 The boolean expression used for partitioning.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TakeWhileClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="whileKeyword">
 The "While" keyword.
 </param>
 <param name="condition">
 The boolean expression used for partitioning.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.PartitionWhileClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 PartitionWhileClauseSyntax. One of SkipWhileClause, TakeWhileClause.
 </param>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="whileKeyword">
 The "While" keyword.
 </param>
 <param name="condition">
 The boolean expression used for partitioning.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SkipClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TakeClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.PartitionClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 PartitionClauseSyntax. One of SkipClause, TakeClause.
 </param>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.GroupByClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionRangeVariableSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionRangeVariableSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents the "Group By" query operator.
 </summary>
 <param name="groupKeyword">
 The "Group" keyword.
 </param>
 <param name="items">
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </param>
 <param name="byKeyword">
 The "By" keyword.
 </param>
 <param name="keys">
 The key values being used for grouping.
 </param>
 <param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.JoinCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
 <param name="left">
 The left expression in the Join condition.
 </param>
 <param name="equalsKeyword">
 The "Equals" keyword.
 </param>
 <param name="right">
 The right expression in the Join condition.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SimpleJoinClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinConditionSyntax})">
 <summary>
 Represents a Join query operator.
 </summary>
 <param name="joinKeyword">
 The "Join" keyword.
 </param>
 <param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
 <param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
 <param name="onKeyword">
 The "On" keyword.
 </param>
 <param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.GroupJoinClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinConditionSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents the "Group Join" query operator.
 </summary>
 <param name="groupKeyword">
 The "Group" keyword.
 </param>
 <param name="joinKeyword">
 The "Join" keyword.
 </param>
 <param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
 <param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
 <param name="onKeyword">
 The "On" keyword.
 </param>
 <param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
 <param name="intoKeyword">
 The "Into" keyword.
 </param>
 <param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.OrderByClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OrderingSyntax})">
 <summary>
 Represents the "Order By" query operator.
 </summary>
 <param name="orderKeyword">
 The "Order" keyword
 </param>
 <param name="byKeyword">
 The "By" keyword.
 </param>
 <param name="orderings">
 The list of OrderExpression's to sort by.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AscendingOrdering(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
 <param name="expression">
 The expression to sort by.
 </param>
 <param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DescendingOrdering(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
 <param name="expression">
 The expression to sort by.
 </param>
 <param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.Ordering(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of OrderingSyntax. One
 of AscendingOrdering, DescendingOrdering.
 </param>
 <param name="expression">
 The expression to sort by.
 </param>
 <param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SelectClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionRangeVariableSyntax})">
 <summary>
 Represents the "Select" query operator.
 </summary>
 <param name="selectKeyword">
 The "Select" keyword.
 </param>
 <param name="variables">
 The list of expression range variables being defined by the Select query
 operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlDocument(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents an XML Document literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlDeclarationOption(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlStringSyntax)">
 <summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlElementStartTagSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlElementEndTagSyntax)">
 <summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlText(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents Xml text.
 </summary>
 <param name="textTokens">
 A list of all the text tokens in the Xml text. This list always contains at
 least one token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlElementStartTag(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlElementEndTag(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlEmptyElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax)">
 <summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlString(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlPrefixName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameTokenSyntax)">
 <summary>
 Represents an XML name of the form 'name' appearing in GetXmlNamespace().
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlPrefixSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameTokenSyntax)">
 <summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlBracketedName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
 of an XML literal or member access expression or an XML namespace import
 clause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlPrefix(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlComment(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an XML comment of the form &lt;!-- Comment --&gt; appearing in an
 XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlProcessingInstruction(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
 XMLProcessingValue ?&gt;'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlCDataSection(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlEmbeddedExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
 obj.Name =%&gt;&lt;/name&gt;'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ArrayType(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
 <param name="elementType">
 The type of the elements of the array.
 </param>
 <param name="rankSpecifiers">
 Represents the list of "()" or "(,,)" modifiers on the array type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NullableType(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
 <param name="elementType">
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </param>
 <param name="questionMarkToken">
 The "?" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.PredefinedType(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
 <param name="keyword">
 The keyword that was used to describe the built-in type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.IdentifierName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax)">
 <summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
 <param name="identifier">
 The identifier in the name.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.GenericName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeArgumentListSyntax)">
 <summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
 <param name="identifier">
 The identifier in the name.
 </param>
 <param name="typeArgumentList">
 The generic argument list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.QualifiedName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleNameSyntax)">
 <summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
 <param name="left">
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </param>
 <param name="dotToken">
 The "." token that separates the names.
 </param>
 <param name="right">
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.GlobalName(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents a name in the global namespace.
 </summary>
 <param name="globalKeyword">
 The "Global" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.TypeArgumentList(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="ofKeyword">
 The "Of" keyword.
 </param>
 <param name="arguments">
 A list of all the type arguments.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CrefReference(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefSignatureSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax)">
 <summary>
 Syntax node class that represents a value of 'cref' attribute inside
 documentation comment trivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CrefSignature(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefSignaturePartSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a parenthesized list of argument types for a signature inside
 CrefReferenceSyntax syntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.YieldStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represent a Yield statement.
 </summary>
 <param name="yieldKeyword">
 The "Yield" keyword.
 </param>
 <param name="expression">
 The expression whose value is being yielded.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.AwaitExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an Await expression.
 </summary>
 <param name="awaitKeyword">
 The "Await" keyword.
 </param>
 <param name="expression">
 The expression being awaited.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlNameToken(System.String,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlTextLiteralToken(System.String,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlEntityLiteralToken(System.String,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DocumentationCommentLineBreakToken(System.String,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlTextToken(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,System.String,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of XmlTextTokenSyntax.
 One of XmlTextLiteralToken, XmlEntityLiteralToken,
 DocumentationCommentLineBreakToken.
 </param>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.InterpolatedStringTextToken(System.String,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents literal character data in interpolated string expression.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DecimalLiteralToken(System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter,System.Decimal,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents a Decimal literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DateLiteralToken(System.String,System.DateTime,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents an Date literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.StringLiteralToken(System.String,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents an string literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CharacterLiteralToken(System.String,System.Char,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode)">
 <summary>
 Represents an string literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SkippedTokensTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
 <param name="tokens">
 The list of tokens that were skipped by the parser.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DocumentationCommentTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode})">
 <summary>
 Represents a documentation comment e.g. ''' &lt;Summary&gt; appearing in
 source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlCrefAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefReferenceSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or
 &lt;seealso&gt; documentation comment tag). For example, the M in &lt;see
 cref="M" /&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.XmlNameAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 A param or type param symbol referenced by a name attribute (e.g. in a
 &lt;param&gt; or &lt;typeparam&gt; documentation comment tag). For example, the
 M in &lt;param name="M" /&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ConditionalAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 ExpressionSyntax node representing the object conditionally accessed.
 </summary>
 <param name="expression">
 The expression on the left-hand-side of the "?".
 </param>
 <param name="questionMarkToken">
 "?" token.
 </param>
 <param name="whenNotNull">
 ExpressionSyntax node representing the access expression to be executed when
 the object is not null."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.NameOfExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents a NameOf expression.
 </summary>
 <param name="nameOfKeyword">
 The "NameOf" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="argument">
 The argument.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.InterpolatedStringExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an interpolated string expression.
 </summary>
 <param name="dollarSignDoubleQuoteToken">
 The opening '$"', '$“', or '$”' token.
 </param>
 <param name="contents">
 The contents of the interpolated string.
 </param>
 <param name="doubleQuoteToken">
 The closing '"', '”', or '“' token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.InterpolatedStringText(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringTextTokenSyntax)">
 <summary>
 Represents literal text content in an interpolated string.
 </summary>
 <param name="textToken">
 The text token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.Interpolation(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationAlignmentClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationFormatClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an interpolation of an expression in an interpolated string
 expression e.g. '{expression[,alignment][:formatString]}'.
 </summary>
 <param name="openBraceToken">
 The opening curly brace '{' token.
 </param>
 <param name="expression">
 The expression whose formatted value should be embedded in the resultant
 string.
 </param>
 <param name="alignmentClause">
 Optional. The alignment clause ',alignment' of the embedded expression.
 </param>
 <param name="formatClause">
 Optional. The format string clause ':formatString' of the embedded expression.
 </param>
 <param name="closeBraceToken">
 The closing curly brace '}' token of the embedded expression.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.InterpolationAlignmentClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents an alignment clause ',alignment' of an interpolated string embedded
 expression.
 </summary>
 <param name="commaToken">
 The comma ',' token.
 </param>
 <param name="value">
 An expression representing the alignment of the interpolated expression.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.InterpolationFormatClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringTextTokenSyntax)">
 <summary>
 Represents a format string clause ':formatString' of an interpolated string
 embedded expression.
 </summary>
 <param name="colonToken">
 The ':' token.
 </param>
 <param name="formatStringToken">
 The format string.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.WhitespaceTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndOfLineTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ColonTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.CommentTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.LineContinuationTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DocumentationCommentExteriorTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DisabledTextTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.SyntaxTrivia(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of SyntaxTrivia. One of
 WhitespaceTrivia, EndOfLineTrivia, ColonTrivia, CommentTrivia,
 LineContinuationTrivia, DocumentationCommentExteriorTrivia, DisabledTextTrivia.
 </param>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ConstDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax)">
 <summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
 <param name="constKeyword">
 The "Const" keyword.
 </param>
 <param name="name">
 The name of the pre-processing constant being defined.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
 <param name="value">
 An expression representing the value of the pre-processing constant being
 defined.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.IfDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ElseIfDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ElseDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndIfDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.RegionDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax)">
 <summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
 <param name="regionKeyword">
 The "Region" keyword.
 </param>
 <param name="name">
 The label of the code region being defined.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndRegionDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an #End Region directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
 <param name="endKeyword">
 The "End" keyword.
 </param>
 <param name="regionKeyword">
 The "Region" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExternalSourceDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IntegerLiteralTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EndExternalSourceDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax)">
 <summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ExternalChecksumDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.EnableWarningDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax})">
 <summary>
 Represents #Enable Warning pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.DisableWarningDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax})">
 <summary>
 Represents #Disable Warning pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.ReferenceDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax)">
 <summary>
 Represents an #r directive appearing in scripts.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory.BadDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax)">
 <summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax">
 <summary>
 Base class for the possible kinds of arguments that can appear in an argument
 list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax.IsNamed">
 <summary>
 Gets a value indicating whether this argument is a named argument.
 </summary>
 <returns>True if this argument is a named argument; otherwise false.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax.IsOmitted">
 <summary>
 Gets a value indicating whether this argument is an omitted argument.
 </summary>
 <returns>True if this argument is an omitted argument; otherwise false.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax.GetExpression">
 <summary>
 Gets the expression of this argument, if any.
 </summary>
 <returns>The expression of this argument if it is a simple argument; otherwise null.</returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax">
 <summary>
 Represents an argument that is just an optional argument name and an
 expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax.NameColonEquals">
 <summary>
 The optional name and ":=" prefix of a named argument.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax.WithNameColonEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax)">
 <summary>
 Returns a copy of this with the NameColonEquals property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax.Expression">
 <summary>
 The expression that is the argument.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="nameColonEquals">
 The value for the NameColonEquals property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.OmittedArgumentSyntax">
 <summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OmittedArgumentSyntax.Empty">
 <summary>
 An empty token because all non terminals must have a token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OmittedArgumentSyntax.WithEmpty(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Empty property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OmittedArgumentSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="empty">
 The value for the Empty property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax">
 <summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax.LowerBound">
 <summary>
 The lower bound of the range. This is typically the integer constant zero.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax.WithLowerBound(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the LowerBound property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax.ToKeyword">
 <summary>
 The "To" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax.WithToKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ToKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax.UpperBound">
 <summary>
 The upper bound of the range.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax.WithUpperBound(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the UpperBound property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="lowerBound">
 The value for the LowerBound property.
 </param>
 <param name="toKeyword">
 The value for the ToKeyword property.
 </param>
 <param name="upperBound">
 The value for the UpperBound property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax">
 <summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax.Rank">
 <summary>
 Returns the ranks of this array rank specifier.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax.CommaTokens">
 <summary>
 The comma tokens in the array type. There is one less comma than the rank.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax.WithCommaTokens(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the CommaTokens property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="commaTokens">
 The value for the CommaTokens property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax.CaseStatement">
 <summary>
 The statement that begins the case block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax.WithCaseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax)">
 <summary>
 Returns a copy of this with the CaseStatement property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax.Statements">
 <summary>
 The statements contained in the case block. This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="caseStatement">
 The value for the CaseStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax">
 <summary>
 Represents an entire source file of VB code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax.GetReferenceDirectives">
 <summary> 
 Returns #r directives specified in the compilation. 
 </summary>       
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax.Options">
 <summary>
 Represents the list of Option statements at the beginning of a source file.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax.WithOptions(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax})">
 <summary>
 Returns a copy of this with the Options property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax.Imports">
 <summary>
 Represents the list of Imports statements at the beginning of a source file.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax.WithImports(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax})">
 <summary>
 Returns a copy of this with the [Imports] property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax.Attributes">
 <summary>
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax.WithAttributes(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax})">
 <summary>
 Returns a copy of this with the Attributes property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax.Members">
 <summary>
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax.WithMembers(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Members property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax.EndOfFileToken">
 <summary>
 Represents the end of the source file. This token may have trivia (whitespace,
 comments, ...) attached to it.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax.WithEndOfFileToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EndOfFileToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="options">
 The value for the Options property.
 </param>
 <param name="imports">
 The value for the Imports property.
 </param>
 <param name="attributes">
 The value for the Attributes property.
 </param>
 <param name="members">
 The value for the Members property.
 </param>
 <param name="endOfFileToken">
 The value for the EndOfFileToken property.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefOperatorReferenceSyntax.WithOperatorKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OperatorKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefOperatorReferenceSyntax.WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OperatorToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefOperatorReferenceSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="operatorKeyword">
 The value for the OperatorKeyword property.
 </param>
 <param name="operatorToken">
 The value for the OperatorToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax">
 <summary>
 Represents a pre-processing directive (such as #If, #Const or #Region)
 appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax">
 <summary>
 Represents a For or For Each block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax.ForOrForEachStatement">
 <summary>
 The For or For Each statement that begins the block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax.Statements">
 <summary>
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax.NextStatement">
 <summary>
 The Next statement that ends the block. If two For or For Each statements are
 ended by a single Next statement, the inner For will not have a Next statement.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForBlockSyntax">
 <summary>
 Represents a For block, including the introducing statement, the body and the
 "Next" (which can be omitted if a containing For has a Next with multiple
 variables).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForBlockSyntax.ForStatement">
 <summary>
 The For statement that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForBlockSyntax.WithForStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax)">
 <summary>
 Returns a copy of this with the ForStatement property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForBlockSyntax.Statements">
 <summary>
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForBlockSyntax.NextStatement">
 <summary>
 The Next statement that ends the block. If two For or For Each statements are
 ended by a single Next statement, the inner For will not have a Next statement.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForBlockSyntax.WithNextStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax)">
 <summary>
 Returns a copy of this with the NextStatement property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="forStatement">
 The value for the ForStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="nextStatement">
 The value for the NextStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax">
 <summary>
 Represents a For Each block, including the introducing statement, the body and
 the "Next" (which can be omitted if a containing For has a Next with multiple
 variables).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax.ForEachStatement">
 <summary>
 The For Each statement that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax.WithForEachStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax)">
 <summary>
 Returns a copy of this with the ForEachStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax.Statements">
 <summary>
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax.NextStatement">
 <summary>
 The Next statement that ends the block. If two For or For Each statements are
 ended by a single Next statement, the inner For will not have a Next statement.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax.WithNextStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax)">
 <summary>
 Returns a copy of this with the NextStatement property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="forEachStatement">
 The value for the ForEachStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="nextStatement">
 The value for the NextStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBaseSyntax">
 <summary>
 An abstract node class that is the parent for declarations that are
 "method-like"; i.e., that have a parameter list and return type. This includes
 methods, constructors, properties, events, operators, declares, delegates,
 property accessors and custom event accessors.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBaseSyntax.DeclarationKeyword">
 <summary>
 Returns the keyword indicating the kind of declaration being made: "Sub", "Function", "Event", "Property", etc. Does not return either the "Declare" or "Delegate" keywords.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBaseSyntax.WithDeclarationKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBaseSyntax"/> with the <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBaseSyntax.DeclarationKeyword"/> property changed to the
 specified value. Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBaseSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBaseSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBaseSyntax.ParameterList">
 <summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.SubOrFunctionKeyword">
 <summary>
 The "Sub" or "Function" keyword that introduces this method declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.WithSubOrFunctionKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the SubOrFunctionKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.Identifier">
 <summary>
 The name of the method being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.TypeParameterList">
 <summary>
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.WithTypeParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Returns a copy of this with the TypeParameterList property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.ParameterList">
 <summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.WithParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Returns a copy of this with the ParameterList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.WithAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the AsClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.HandlesClause">
 <summary>
 If present, a Handles clause indicated the events that this method handles.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.WithHandlesClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax)">
 <summary>
 Returns a copy of this with the HandlesClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.ImplementsClause">
 <summary>
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.WithImplementsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 Returns a copy of this with the ImplementsClause property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The value for the SubOrFunctionKeyword property.
 </param>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="typeParameterList">
 The value for the TypeParameterList property.
 </param>
 <param name="parameterList">
 The value for the ParameterList property.
 </param>
 <param name="asClause">
 The value for the AsClause property.
 </param>
 <param name="handlesClause">
 The value for the HandlesClause property.
 </param>
 <param name="implementsClause">
 The value for the ImplementsClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax">
 <summary>
 A statement that declares a delegate type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.DelegateKeyword">
 <summary>
 The "Delegate" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.WithDelegateKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the DelegateKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.SubOrFunctionKeyword">
 <summary>
 The "Sub" or "Function" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.WithSubOrFunctionKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the SubOrFunctionKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.Identifier">
 <summary>
 The name of the delegate being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.TypeParameterList">
 <summary>
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.WithTypeParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Returns a copy of this with the TypeParameterList property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.ParameterList">
 <summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.WithParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Returns a copy of this with the ParameterList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.WithAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the AsClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="delegateKeyword">
 The value for the DelegateKeyword property.
 </param>
 <param name="subOrFunctionKeyword">
 The value for the SubOrFunctionKeyword property.
 </param>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="typeParameterList">
 The value for the TypeParameterList property.
 </param>
 <param name="parameterList">
 The value for the ParameterList property.
 </param>
 <param name="asClause">
 The value for the AsClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.DeclareKeyword">
 <summary>
 The "Declare" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.WithDeclareKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the DeclareKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.CharsetKeyword">
 <summary>
 If present, the keyword that defines the string translation semantics of the
 external method.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.WithCharsetKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CharsetKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.SubOrFunctionKeyword">
 <summary>
 The "Sub" or "Function" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.WithSubOrFunctionKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the SubOrFunctionKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.Identifier">
 <summary>
 The name of the method being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.LibKeyword">
 <summary>
 The "Lib" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.WithLibKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LibKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.LibraryName">
 <summary>
 The string literal with the library name.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.WithLibraryName(Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax)">
 <summary>
 Returns a copy of this with the LibraryName property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.AliasKeyword">
 <summary>
 If present, the "Alias" keyword. If not present, returns Nothing.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.WithAliasKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the AliasKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.AliasName">
 <summary>
 The string literal with the alias. If not present, returns Nothing.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.WithAliasName(Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax)">
 <summary>
 Returns a copy of this with the AliasName property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.ParameterList">
 <summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.WithParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Returns a copy of this with the ParameterList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.WithAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the AsClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="declareKeyword">
 The value for the DeclareKeyword property.
 </param>
 <param name="charsetKeyword">
 The value for the CharsetKeyword property.
 </param>
 <param name="subOrFunctionKeyword">
 The value for the SubOrFunctionKeyword property.
 </param>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="libKeyword">
 The value for the LibKeyword property.
 </param>
 <param name="libraryName">
 The value for the LibraryName property.
 </param>
 <param name="aliasKeyword">
 The value for the AliasKeyword property.
 </param>
 <param name="aliasName">
 The value for the AliasName property.
 </param>
 <param name="parameterList">
 The value for the ParameterList property.
 </param>
 <param name="asClause">
 The value for the AsClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax">
 <summary>
 Represents the header part of a lambda expression
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax.SubOrFunctionKeyword">
 <summary>
 The "Sub" or "Function" keyword that introduces this lambda expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax.WithSubOrFunctionKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the SubOrFunctionKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax.ParameterList">
 <summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax.WithParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Returns a copy of this with the ParameterList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax.WithAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the AsClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The value for the SubOrFunctionKeyword property.
 </param>
 <param name="parameterList">
 The value for the ParameterList property.
 </param>
 <param name="asClause">
 The value for the AsClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax">
 <summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax.SubKeyword">
 <summary>
 The "Sub" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax.WithSubKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the SubKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax.NewKeyword">
 <summary>
 The "New" keyword in the constructor declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax.WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the NewKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax.ParameterList">
 <summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax.WithParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Returns a copy of this with the ParameterList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="subKeyword">
 The value for the SubKeyword property.
 </param>
 <param name="newKeyword">
 The value for the NewKeyword property.
 </param>
 <param name="parameterList">
 The value for the ParameterList property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax">
 <summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.CustomKeyword">
 <summary>
 The optional Custom keyword for custom event declarations.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.WithCustomKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CustomKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.EventKeyword">
 <summary>
 The "Event" keyword that introduces this event declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.WithEventKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EventKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.Identifier">
 <summary>
 The name of the event being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.ParameterList">
 <summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.WithParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Returns a copy of this with the ParameterList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.WithAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the AsClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.ImplementsClause">
 <summary>
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.WithImplementsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 Returns a copy of this with the ImplementsClause property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="customKeyword">
 The value for the CustomKeyword property.
 </param>
 <param name="eventKeyword">
 The value for the EventKeyword property.
 </param>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="parameterList">
 The value for the ParameterList property.
 </param>
 <param name="asClause">
 The value for the AsClause property.
 </param>
 <param name="implementsClause">
 The value for the ImplementsClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax">
 <summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.PropertyKeyword">
 <summary>
 The "Property" keyword that introduces this property declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.WithPropertyKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the PropertyKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.Identifier">
 <summary>
 The name of the property being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.ParameterList">
 <summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.WithParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Returns a copy of this with the ParameterList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.WithAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)">
 <summary>
 Returns a copy of this with the AsClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.Initializer">
 <summary>
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.WithInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax)">
 <summary>
 Returns a copy of this with the Initializer property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.ImplementsClause">
 <summary>
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.WithImplementsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 Returns a copy of this with the ImplementsClause property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="propertyKeyword">
 The value for the PropertyKeyword property.
 </param>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="parameterList">
 The value for the ParameterList property.
 </param>
 <param name="asClause">
 The value for the AsClause property.
 </param>
 <param name="initializer">
 The value for the Initializer property.
 </param>
 <param name="implementsClause">
 The value for the ImplementsClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax">
 <summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax.OperatorKeyword">
 <summary>
 The "Operator" keyword that introduces this operator declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax.WithOperatorKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OperatorKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax.OperatorToken">
 <summary>
 The operator being defined.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax.WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OperatorToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax.ParameterList">
 <summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax.WithParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Returns a copy of this with the ParameterList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax.WithAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the AsClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="operatorKeyword">
 The value for the OperatorKeyword property.
 </param>
 <param name="operatorToken">
 The value for the OperatorToken property.
 </param>
 <param name="parameterList">
 The value for the ParameterList property.
 </param>
 <param name="asClause">
 The value for the AsClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax.AccessorKeyword">
 <summary>
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax.WithAccessorKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the AccessorKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax.ParameterList">
 <summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax.WithParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Returns a copy of this with the ParameterList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The value for the AccessorKeyword property.
 </param>
 <param name="parameterList">
 The value for the ParameterList property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax">
 <summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax.BlockStatement">
 <summary>
 The statement that begins the block declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax.EndBlockStatement">
 <summary>
 The statement that ends the block declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax.WithBlockStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBaseSyntax)">
 <summary>
 Returns a copy of this <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax"/> with the <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax.BlockStatement"/> property changed to the
 specified value. Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax.WithEndBlockStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax"/> with the <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax.EndBlockStatement"/> property changed to the
 specified value. Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax.Statements">
 <summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax.AccessorStatement">
 <summary>
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax.WithAccessorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax)">
 <summary>
 Returns a copy of this with the AccessorStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax.Statements">
 <summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax.EndAccessorStatement">
 <summary>
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax.WithEndAccessorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndAccessorStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="accessorStatement">
 The value for the AccessorStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="endAccessorStatement">
 The value for the EndAccessorStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax">
 <summary>
 Represents a constructor block declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax.SubNewStatement">
 <summary>
 The "Sub New" statement that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax.WithSubNewStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax)">
 <summary>
 Returns a copy of this with the SubNewStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax.Statements">
 <summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax.EndSubStatement">
 <summary>
 The "End Sub" statement that ends the block declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax.WithEndSubStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndSubStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="subNewStatement">
 The value for the SubNewStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="endSubStatement">
 The value for the EndSubStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax.SubOrFunctionStatement">
 <summary>
 The "Sub" or "Function" statement that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax.WithSubOrFunctionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax)">
 <summary>
 Returns a copy of this with the SubOrFunctionStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax.Statements">
 <summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax.EndSubOrFunctionStatement">
 <summary>
 The "End Sub" or "End Function" statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax.WithEndSubOrFunctionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndSubOrFunctionStatement property changed to
 the specified value. Returns this instance if the specified value is the same
 as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="subOrFunctionStatement">
 The value for the SubOrFunctionStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="endSubOrFunctionStatement">
 The value for the EndSubOrFunctionStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax">
 <summary>
 Represents an Operator block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax.OperatorStatement">
 <summary>
 The "Operator" statement that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax.WithOperatorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax)">
 <summary>
 Returns a copy of this with the OperatorStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax.Statements">
 <summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax.EndOperatorStatement">
 <summary>
 The "End Operator" statement that ends the block declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax.WithEndOperatorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndOperatorStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="operatorStatement">
 The value for the OperatorStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="endOperatorStatement">
 The value for the EndOperatorStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax.SubOrFunctionHeader">
 <summary>
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax.WithSubOrFunctionHeader(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax)">
 <summary>
 Returns a copy of this with the SubOrFunctionHeader property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax.Statements">
 <summary>
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax.EndSubOrFunctionStatement">
 <summary>
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax.WithEndSubOrFunctionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndSubOrFunctionStatement property changed to
 the specified value. Returns this instance if the specified value is the same
 as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="subOrFunctionHeader">
 The value for the SubOrFunctionHeader property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="endSubOrFunctionStatement">
 The value for the EndSubOrFunctionStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax">
 <summary>
 Abstract node class that represents a name, possibly include generic arguments
 and qualified names.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax">
 <summary>
 Represents a single line lambda expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax.Statements">
 <summary>
 Single line subs only have a single statement.  However, when binding it is convenient to have a statement list.  For example,
 dim statements are not valid in a single line lambda.  However, it is nice to be able to provide semantic info about the local.
 The only way to create locals is to have a statement list. This method is friend because the statement list should not be part
 of the public api.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax.SubOrFunctionHeader">
 <summary>
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax.WithSubOrFunctionHeader(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax)">
 <summary>
 Returns a copy of this with the SubOrFunctionHeader property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax.Body">
 <summary>
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax.WithBody(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Returns a copy of this with the Body property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="subOrFunctionHeader">
 The value for the SubOrFunctionHeader property.
 </param>
 <param name="body">
 The value for the Body property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax">
 <summary>
 Represents a lambda expression, either single line or multi-line.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax.SubOrFunctionHeader">
 <summary>
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SkippedTokensTriviaSyntax">
 <summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SkippedTokensTriviaSyntax.Tokens">
 <summary>
 The list of tokens that were skipped by the parser.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SkippedTokensTriviaSyntax.WithTokens(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Tokens property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SkippedTokensTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="tokens">
 The value for the Tokens property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructuredTriviaSyntax">
 <summary>
 Abstract class that represent structured trivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxNormalizer.#ctor(Microsoft.CodeAnalysis.Text.TextSpan,System.String,System.String,System.Boolean,System.Boolean)">
 <summary>
 Creates a syntax trivia normalizing visitor
 </summary>
 <param name="indentWhitespace">The whitespace to indent with</param>
 <param name="eolWhitespace">The whitespace to use for end of line</param>
 <param name="useElasticTrivia">Whether to use elastic trivia or not</param>
 <param name="useDefaultCasing">Whether to rewrite keywords in default casing or not</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxNormalizer.GetIndentationDepth">
 <summary>
 indentation depth is the declaration depth for statements within the block. for start/end statements
 of these blocks (e.g. the if statement), it is a level less
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxNormalizer.VisitCompilationUnit(Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax)">
 <summary>
 We each element of option, imports and attributes on a separate line, where the last element of this the list if 
 followed by an empty line:
 Option Strict On
 
 Imports System
 Imports Foo
 
 [...]
 
 Namespace
 [...]
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxNormalizer.VisitNamespaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax)">
 <summary>
 Add an empty line after the begin, except the first member is a nested namespace.
 Separate each member of a namespace with an empty line. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxNormalizer.VisitTypeBlockSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax)">
 <summary>
 We want to display type blocks (Modules, Classes, Structures and Interfaces) like follows
 Class Foo
   implements IBar1, IBar2
   implements IBar3
   inherits Bar1
 
   Public Sub Boo()
   End Sub
 End Class
 
 or
 
 Class Foo
 
   Public Sub Boo()
   End Sub
 End Class
 
 Basically it's an empty line between implements and inherits and between each member. If there are no
 inherits or implements, add an empty line before the first member.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxNormalizer.VisitEnumBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax)">
 <summary>
 Each statement and the begin will be displayed on a separate line. No empty lines.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.DocumentationCommentTriviaSyntax">
 <summary>
 Represents a documentation comment e.g. ''' &lt;Summary&gt; appearing in
 source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DocumentationCommentTriviaSyntax.Content">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DocumentationCommentTriviaSyntax.WithContent(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Returns a copy of this with the Content property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DocumentationCommentTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="content">
 The value for the Content property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax">
 <summary>
 Represents a declaration of a Class, Interface, Structure, Module, its contents
 and the End statement that ends it.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax.BlockStatement">
 <summary>
 The statement that begins the block declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax.EndBlockStatement">
 <summary>
 The statement that ends the block declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax.WithBlockStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax)">
 <summary>
 Returns a copy of this <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax"/> with the <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax.BlockStatement"/> property changed to the
 specified value. Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax.WithEndBlockStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax"/> with the <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax.EndBlockStatement"/> property changed to the
 specified value. Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax.Inherits">
 <summary>
 A list of the Inherits declarations for the type.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax.Implements">
 <summary>
 A list of the Implements declarations for the type.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax.Members">
 <summary>
 The declarations contained in the type or module.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax">
 <summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax.ClassStatement">
 <summary>
 The "Class" statement that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax.WithClassStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax)">
 <summary>
 Returns a copy of this with the ClassStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax.Inherits">
 <summary>
 A list of the Inherits declarations for the type.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax.WithInherits(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax})">
 <summary>
 Returns a copy of this with the [Inherits] property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax.Implements">
 <summary>
 A list of the Implements declarations for the type.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax.WithImplements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax})">
 <summary>
 Returns a copy of this with the [Implements] property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax.Members">
 <summary>
 The declarations contained in the type or module.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax.WithMembers(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Members property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax.EndClassStatement">
 <summary>
 The "End Class" statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax.WithEndClassStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndClassStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="classStatement">
 The value for the ClassStatement property.
 </param>
 <param name="inherits">
 The value for the Inherits property.
 </param>
 <param name="implements">
 The value for the Implements property.
 </param>
 <param name="members">
 The value for the Members property.
 </param>
 <param name="endClassStatement">
 The value for the EndClassStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax">
 <summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax.StructureStatement">
 <summary>
 The "Structure" statement that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax.WithStructureStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax)">
 <summary>
 Returns a copy of this with the StructureStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax.Inherits">
 <summary>
 A list of the Inherits declarations for the type.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax.WithInherits(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax})">
 <summary>
 Returns a copy of this with the [Inherits] property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax.Implements">
 <summary>
 A list of the Implements declarations for the type.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax.WithImplements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax})">
 <summary>
 Returns a copy of this with the [Implements] property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax.Members">
 <summary>
 The declarations contained in the type or module.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax.WithMembers(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Members property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax.EndStructureStatement">
 <summary>
 The "End Structure" statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax.WithEndStructureStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndStructureStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="structureStatement">
 The value for the StructureStatement property.
 </param>
 <param name="inherits">
 The value for the Inherits property.
 </param>
 <param name="implements">
 The value for the Implements property.
 </param>
 <param name="members">
 The value for the Members property.
 </param>
 <param name="endStructureStatement">
 The value for the EndStructureStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax">
 <summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax.InterfaceStatement">
 <summary>
 The "Interface" statement that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax.WithInterfaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax)">
 <summary>
 Returns a copy of this with the InterfaceStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax.Inherits">
 <summary>
 A list of the Inherits declarations for the type.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax.WithInherits(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax})">
 <summary>
 Returns a copy of this with the [Inherits] property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax.Implements">
 <summary>
 A list of the Implements declarations for the type.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax.WithImplements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax})">
 <summary>
 Returns a copy of this with the [Implements] property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax.Members">
 <summary>
 The declarations contained in the type or module.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax.WithMembers(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Members property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax.EndInterfaceStatement">
 <summary>
 The "End Interface" statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax.WithEndInterfaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndInterfaceStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="interfaceStatement">
 The value for the InterfaceStatement property.
 </param>
 <param name="inherits">
 The value for the Inherits property.
 </param>
 <param name="implements">
 The value for the Implements property.
 </param>
 <param name="members">
 The value for the Members property.
 </param>
 <param name="endInterfaceStatement">
 The value for the EndInterfaceStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax">
 <summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax.ModuleStatement">
 <summary>
 The "Module" statement that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax.WithModuleStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax)">
 <summary>
 Returns a copy of this with the ModuleStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax.Inherits">
 <summary>
 A list of the Inherits declarations for the type.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax.WithInherits(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax})">
 <summary>
 Returns a copy of this with the [Inherits] property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax.Implements">
 <summary>
 A list of the Implements declarations for the type.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax.WithImplements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax})">
 <summary>
 Returns a copy of this with the [Implements] property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax.Members">
 <summary>
 The declarations contained in the type or module.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax.WithMembers(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Members property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax.EndModuleStatement">
 <summary>
 The "End Module" statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax.WithEndModuleStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndModuleStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="moduleStatement">
 The value for the ModuleStatement property.
 </param>
 <param name="inherits">
 The value for the Inherits property.
 </param>
 <param name="implements">
 The value for the Implements property.
 </param>
 <param name="members">
 The value for the Members property.
 </param>
 <param name="endModuleStatement">
 The value for the EndModuleStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax">
 <summary>
 Abstract class for the beginning statement of a Module, Class, Interface or
 Structure declaration. This node always appears as the Begin of a TypeBlock
 with Kind=ModuleDeclarationBlock, ClassDeclarationBlock,
 InterfaceDeclarationBlock or StructureDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax.DeclarationKeyword">
 <summary>
 Returns the keyword indicating the kind of declaration being made: "Class", "Structure", "Module", "Interface", etc.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax.WithDeclarationKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax"/> with the <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax.DeclarationKeyword"/> property changed to the
 specified value. Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax.Identifier">
 <summary>
 The name of the type being declared.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax.TypeParameterList">
 <summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax">
 <summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax.ModuleKeyword">
 <summary>
 The "Module" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax.WithModuleKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ModuleKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax.Identifier">
 <summary>
 The name of the type being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax.TypeParameterList">
 <summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax.WithTypeParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Returns a copy of this with the TypeParameterList property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="moduleKeyword">
 The value for the ModuleKeyword property.
 </param>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="typeParameterList">
 The value for the TypeParameterList property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax">
 <summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax.StructureKeyword">
 <summary>
 The "Structure" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax.WithStructureKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the StructureKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax.Identifier">
 <summary>
 The name of the type being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax.TypeParameterList">
 <summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax.WithTypeParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Returns a copy of this with the TypeParameterList property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="structureKeyword">
 The value for the StructureKeyword property.
 </param>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="typeParameterList">
 The value for the TypeParameterList property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax">
 <summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax.ClassKeyword">
 <summary>
 The "Class" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax.WithClassKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ClassKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax.Identifier">
 <summary>
 The name of the type being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax.TypeParameterList">
 <summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax.WithTypeParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Returns a copy of this with the TypeParameterList property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="classKeyword">
 The value for the ClassKeyword property.
 </param>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="typeParameterList">
 The value for the TypeParameterList property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax">
 <summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax.InterfaceKeyword">
 <summary>
 The "Interface" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax.WithInterfaceKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the InterfaceKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax.Identifier">
 <summary>
 The name of the type being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax.TypeParameterList">
 <summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax.WithTypeParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Returns a copy of this with the TypeParameterList property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="interfaceKeyword">
 The value for the InterfaceKeyword property.
 </param>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="typeParameterList">
 The value for the TypeParameterList property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.VisualBasicLineDirectiveMap">
 <summary>
 Adds VB specific parts to the line directive map
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter">
 <summary>
 Represents one of the type characters or literal suffixes of VB. Used to
 describe a) the type character suffixes that can be placed on identifiers, and
 b) the suffixes that can be placed on integer literals.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.Integer">
 <summary>
 The "%" type character."
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.Long">
 <summary>
 The "&amp;" type character."
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.Decimal">
 <summary>
 The "@" type character."
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.Single">
 <summary>
 The "!" type character."
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.Double">
 <summary>
 The "#" type character."
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.String">
 <summary>
 The "$" type character."
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.ShortLiteral">
 <summary>
 The "S" literal suffix denoting "Short"
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.UShortLiteral">
 <summary>
 The "US" literal suffix denoting "UShort"
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.IntegerLiteral">
 <summary>
 The "I" literal suffix denoting "Integer"
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.UIntegerLiteral">
 <summary>
 The "UI" literal suffix denoting "UInteger"
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.LongLiteral">
 <summary>
 The "L" literal suffix denoting "Long"
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.ULongLiteral">
 <summary>
 The "UL" literal suffix denoting "ULong"
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.SingleLiteral">
 <summary>
 The "F" literal suffix denoting "Single"
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.DoubleLiteral">
 <summary>
 The "R" literal suffix denoting "Double"
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.DecimalLiteral">
 <summary>
 The "D" literal suffix denoting "Decimal"
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralBase">
 <summary>
 The three possible number bases that a literal can be written in.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax">
 <summary>
 The base class for all nodes that represent statements. This includes both
 declaration statements, such as class declarations as well as executable
 statements.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax">
 <summary>
 The base class for all nodes that represent executable statements.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclarationStatementSyntax">
 <summary>
 The base class for all nodes that represent statements that declare options,
 imports, members, etc.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EmptyStatementSyntax">
 <summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EmptyStatementSyntax.Empty">
 <summary>
 An empty token because all non terminals must have a token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EmptyStatementSyntax.WithEmpty(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Empty property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EmptyStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="empty">
 The value for the Empty property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax.EndKeyword">
 <summary>
 The "End" keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax.WithEndKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EndKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax.BlockKeyword">
 <summary>
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax.WithBlockKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the BlockKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="endKeyword">
 The value for the EndKeyword property.
 </param>
 <param name="blockKeyword">
 The value for the BlockKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax">
 <summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax.OptionKeyword">
 <summary>
 The "Option" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax.WithOptionKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OptionKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax.NameKeyword">
 <summary>
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax.WithNameKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the NameKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax.ValueKeyword">
 <summary>
 The keyword that identifiers the value being set for the option: On, Off, Text
 or Binary.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax.WithValueKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ValueKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="optionKeyword">
 The value for the OptionKeyword property.
 </param>
 <param name="nameKeyword">
 The value for the NameKeyword property.
 </param>
 <param name="valueKeyword">
 The value for the ValueKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax">
 <summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax.ImportsKeyword">
 <summary>
 The "Imports" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax.WithImportsKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ImportsKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax.ImportsClauses">
 <summary>
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax.WithImportsClauses(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsClauseSyntax})">
 <summary>
 Returns a copy of this with the ImportsClauses property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsClauseSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="importsKeyword">
 The value for the ImportsKeyword property.
 </param>
 <param name="importsClauses">
 The value for the ImportsClauses property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsClauseSyntax">
 <summary>
 The base class for the possible clauses of an Imports statement.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax">
 <summary>
 Represents the clause of an Imports statement that imports all members of a
 type or namespace or aliases a type or namespace.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax.Alias">
 <summary>
 An optional alias for the namespace or type being imported.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax.WithAlias(Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax)">
 <summary>
 Returns a copy of this with the [Alias] property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax.Name">
 <summary>
 The namespace or type being imported.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="alias">
 The value for the Alias property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax">
 <summary>
 Represents an alias identifier followed by an "=" token in an Imports clause.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax.Identifier">
 <summary>
 The identifier being introduced.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax.EqualsToken">
 <summary>
 The "=" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax.WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EqualsToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="equalsToken">
 The value for the EqualsToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax">
 <summary>
 Defines a XML namespace for XML expressions.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax.WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LessThanToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax.XmlNamespace">
 <summary>
 Identifies the XML namespace alias and URI.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax.WithXmlNamespace(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax)">
 <summary>
 Returns a copy of this with the XmlNamespace property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax.WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the GreaterThanToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="lessThanToken">
 The value for the LessThanToken property.
 </param>
 <param name="xmlNamespace">
 The value for the XmlNamespace property.
 </param>
 <param name="greaterThanToken">
 The value for the GreaterThanToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax">
 <summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax.NamespaceStatement">
 <summary>
 The statement that begins the NamespaceBlock.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax.WithNamespaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax)">
 <summary>
 Returns a copy of this with the NamespaceStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax.Members">
 <summary>
 The declarations contained in the namespace statement.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax.WithMembers(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Members property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax.EndNamespaceStatement">
 <summary>
 The End Namespace statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax.WithEndNamespaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndNamespaceStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="namespaceStatement">
 The value for the NamespaceStatement property.
 </param>
 <param name="members">
 The value for the Members property.
 </param>
 <param name="endNamespaceStatement">
 The value for the EndNamespaceStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax">
 <summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax.NamespaceKeyword">
 <summary>
 The "Namespace" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax.WithNamespaceKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the NamespaceKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax.Name">
 <summary>
 A (possibly dotted) name denoting the namespace being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="namespaceKeyword">
 The value for the NamespaceKeyword property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax">
 <summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax.EnumStatement">
 <summary>
 The statement that begins the type or module.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax.WithEnumStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax)">
 <summary>
 Returns a copy of this with the EnumStatement property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax.Members">
 <summary>
 The declarations contained in the enumeration.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax.WithMembers(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Members property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax.EndEnumStatement">
 <summary>
 The End XXX statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax.WithEndEnumStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndEnumStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="enumStatement">
 The value for the EnumStatement property.
 </param>
 <param name="members">
 The value for the Members property.
 </param>
 <param name="endEnumStatement">
 The value for the EndEnumStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsOrImplementsStatementSyntax">
 <summary>
 Represents an Inherits or Implements statement in a Class, Structure or
 Interface.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax">
 <summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax.InheritsKeyword">
 <summary>
 The "Inherits" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax.WithInheritsKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the InheritsKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax.Types">
 <summary>
 A list of the types being inherited.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax.WithTypes(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax})">
 <summary>
 Returns a copy of this with the Types property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="inheritsKeyword">
 The value for the InheritsKeyword property.
 </param>
 <param name="types">
 The value for the Types property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax">
 <summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax.ImplementsKeyword">
 <summary>
 The "Implements" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax.WithImplementsKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ImplementsKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax.Types">
 <summary>
 A list of the types being implemented.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax.WithTypes(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax})">
 <summary>
 Returns a copy of this with the Types property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="implementsKeyword">
 The value for the ImplementsKeyword property.
 </param>
 <param name="types">
 The value for the Types property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax">
 <summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax.EnumKeyword">
 <summary>
 The "Enum" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax.WithEnumKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EnumKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax.Identifier">
 <summary>
 The name of the enum being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax.UnderlyingType">
 <summary>
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax.WithUnderlyingType(Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)">
 <summary>
 Returns a copy of this with the UnderlyingType property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="enumKeyword">
 The value for the EnumKeyword property.
 </param>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="underlyingType">
 The value for the UnderlyingType property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax">
 <summary>
 Represents the type parameter list in a declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax.OfKeyword">
 <summary>
 The "Of" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax.WithOfKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OfKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax.Parameters">
 <summary>
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax.WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax})">
 <summary>
 Returns a copy of this with the Parameters property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="ofKeyword">
 The value for the OfKeyword property.
 </param>
 <param name="parameters">
 The value for the Parameters property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax">
 <summary>
 Represents a type parameter on a generic type declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax.VarianceKeyword">
 <summary>
 Represents the "In" or "Out" variance keyword on a type parameter, if present.
 If no variance modifier was present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax.WithVarianceKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the VarianceKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax.Identifier">
 <summary>
 The name of the type parameter
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax.TypeParameterConstraintClause">
 <summary>
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax.WithTypeParameterConstraintClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterConstraintClauseSyntax)">
 <summary>
 Returns a copy of this with the TypeParameterConstraintClause property changed
 to the specified value. Returns this instance if the specified value is the
 same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterConstraintClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="varianceKeyword">
 The value for the VarianceKeyword property.
 </param>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="typeParameterConstraintClause">
 The value for the TypeParameterConstraintClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterConstraintClauseSyntax">
 <summary>
 An abstract node class that is the parent of classes that describe type
 parameter constraint clauses.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSingleConstraintClauseSyntax">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSingleConstraintClauseSyntax.AsKeyword">
 <summary>
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSingleConstraintClauseSyntax.WithAsKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the AsKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSingleConstraintClauseSyntax.Constraint">
 <summary>
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSingleConstraintClauseSyntax.WithConstraint(Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax)">
 <summary>
 Returns a copy of this with the Constraint property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSingleConstraintClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="asKeyword">
 The value for the AsKeyword property.
 </param>
 <param name="constraint">
 The value for the Constraint property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax.AsKeyword">
 <summary>
 The "As" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax.WithAsKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the AsKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax.OpenBraceToken">
 <summary>
 The "{" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax.WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenBraceToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax.Constraints">
 <summary>
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax.WithConstraints(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax})">
 <summary>
 Returns a copy of this with the Constraints property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax.CloseBraceToken">
 <summary>
 The "}" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax.WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseBraceToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="asKeyword">
 The value for the AsKeyword property.
 </param>
 <param name="openBraceToken">
 The value for the OpenBraceToken property.
 </param>
 <param name="constraints">
 The value for the Constraints property.
 </param>
 <param name="closeBraceToken">
 The value for the CloseBraceToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax">
 <summary>
 An abstract node class that is the parent of classes that describe type
 parameter constraints.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax.ConstraintKeyword">
 <summary>
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax.WithConstraintKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ConstraintKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="constraintKeyword">
 The value for the ConstraintKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeConstraintSyntax">
 <summary>
 Represents a type parameter constraint that is a type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeConstraintSyntax.Type">
 <summary>
 The type describing the constraint.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeConstraintSyntax.WithType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the Type property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeConstraintSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="type">
 The value for the Type property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax">
 <summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax.AttributeLists">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax.Initializer">
 <summary>
 An optional value for the enum member.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax.WithInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax)">
 <summary>
 Returns a copy of this with the Initializer property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="initializer">
 The value for the Initializer property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax">
 <summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax.PropertyStatement">
 <summary>
 The property declaration that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax.WithPropertyStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax)">
 <summary>
 Returns a copy of this with the PropertyStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax.Accessors">
 <summary>
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax.WithAccessors(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax})">
 <summary>
 Returns a copy of this with the Accessors property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax.EndPropertyStatement">
 <summary>
 The End Property statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax.WithEndPropertyStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndPropertyStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="propertyStatement">
 The value for the PropertyStatement property.
 </param>
 <param name="accessors">
 The value for the Accessors property.
 </param>
 <param name="endPropertyStatement">
 The value for the EndPropertyStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax">
 <summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax.EventStatement">
 <summary>
 The event declaration that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax.WithEventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax)">
 <summary>
 Returns a copy of this with the EventStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax.Accessors">
 <summary>
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax.WithAccessors(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax})">
 <summary>
 Returns a copy of this with the Accessors property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax.EndEventStatement">
 <summary>
 The End Event statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax.WithEndEventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndEventStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="eventStatement">
 The value for the EventStatement property.
 </param>
 <param name="accessors">
 The value for the Accessors property.
 </param>
 <param name="endEventStatement">
 The value for the EndEventStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax">
 <summary>
 Represents the parameter list in a method declaration.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax.OpenParenToken">
 <summary>
 The "(" token that introduces the parameter list. If no parameter list was
 present, Nothing is returned.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax.Parameters">
 <summary>
 The list of parameters. If no parameter list was present, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax.WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax})">
 <summary>
 Returns a copy of this with the Parameters property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax.CloseParenToken">
 <summary>
 The ")" token that concludes the parameter list. If no parameter list was
 present, Nothing is returned.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="parameters">
 The value for the Parameters property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax">
 <summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax.ImplementsKeyword">
 <summary>
 The "Implements" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax.WithImplementsKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ImplementsKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax.InterfaceMembers">
 <summary>
 The list of interface members being implemented.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax.WithInterfaceMembers(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax})">
 <summary>
 Returns a copy of this with the InterfaceMembers property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="implementsKeyword">
 The value for the ImplementsKeyword property.
 </param>
 <param name="interfaceMembers">
 The value for the InterfaceMembers property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax">
 <summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax.HandlesKeyword">
 <summary>
 The "Handles" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax.WithHandlesKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HandlesKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax.Events">
 <summary>
 The list of event members being handled.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax.WithEvents(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax})">
 <summary>
 Returns a copy of this with the Events property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="handlesKeyword">
 The value for the HandlesKeyword property.
 </param>
 <param name="events">
 The value for the Events property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EventContainerSyntax">
 <summary>
 Represents container of an event in a Handles clause item.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.KeywordEventContainerSyntax">
 <summary>
 Represents event container specified through special keywords "Me", "MyBase" or
 "MyClass"..
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.KeywordEventContainerSyntax.Keyword">
 <summary>
 The container of the event. This can be one of the special keywords: "Me",
 "MyBase" or "MyClass".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.KeywordEventContainerSyntax.WithKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Keyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.KeywordEventContainerSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="keyword">
 The value for the Keyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax">
 <summary>
 Represents event container that refers to a WithEvents member.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax.Identifier">
 <summary>
 The container of the event. It is a simple identifier that refers to a
 WithEvents member of the containing type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="identifier">
 The value for the Identifier property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsPropertyEventContainerSyntax">
 <summary>
 Represents event container that refers to a WithEvents member's property.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsPropertyEventContainerSyntax.WithEventsContainer">
 <summary>
 The container of the event.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsPropertyEventContainerSyntax.WithWithEventsContainer(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax)">
 <summary>
 Returns a copy of this with the WithEventsContainer property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsPropertyEventContainerSyntax.DotToken">
 <summary>
 The "." token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsPropertyEventContainerSyntax.WithDotToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the DotToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsPropertyEventContainerSyntax.Property">
 <summary>
 The provider of the event. It is a property of a WithEvents member of the
 containing type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsPropertyEventContainerSyntax.WithProperty(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Returns a copy of this with the [Property] property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsPropertyEventContainerSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="withEventsContainer">
 The value for the WithEventsContainer property.
 </param>
 <param name="dotToken">
 The value for the DotToken property.
 </param>
 <param name="property">
 The value for the Property property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax">
 <summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax.EventContainer">
 <summary>
 The container of the event. This can either be a simple identifier (identifying
 a members of the containing type) or one of the special keywords "Me", "MyBase"
 or "MyClass".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax.WithEventContainer(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventContainerSyntax)">
 <summary>
 Returns a copy of this with the EventContainer property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax.DotToken">
 <summary>
 The "." token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax.WithDotToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the DotToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax.EventMember">
 <summary>
 The event being handled. This must be a simple identifier.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax.WithEventMember(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Returns a copy of this with the EventMember property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventContainerSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="eventContainer">
 The value for the EventContainer property.
 </param>
 <param name="dotToken">
 The value for the DotToken property.
 </param>
 <param name="eventMember">
 The value for the EventMember property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.IncompleteMemberSyntax">
 <summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.IncompleteMemberSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IncompleteMemberSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.IncompleteMemberSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IncompleteMemberSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.IncompleteMemberSyntax.MissingIdentifier">
 <summary>
 The missing identifier token for this incomplete member. Should only be used to
 have a location for error reporting.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IncompleteMemberSyntax.WithMissingIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the MissingIdentifier property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IncompleteMemberSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="missingIdentifier">
 The value for the MissingIdentifier property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax">
 <summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax.Modifiers">
 <summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax.Declarators">
 <summary>
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax.WithDeclarators(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax})">
 <summary>
 Returns a copy of this with the Declarators property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="declarators">
 The value for the Declarators property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax">
 <summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax.Names">
 <summary>
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax.WithNames(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax})">
 <summary>
 Returns a copy of this with the Names property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax.AsClause">
 <summary>
 The "As" clause that describes the return type, and possibly includes "New",
 "With" or "From". If no As clause was present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax.WithAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)">
 <summary>
 Returns a copy of this with the AsClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax.Initializer">
 <summary>
 If present, an "= initial-value" clause describing the initial value of the
 variable or the value of the constant.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax.WithInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax)">
 <summary>
 Returns a copy of this with the Initializer property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax.Update(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="names">
 The value for the Names property.
 </param>
 <param name="asClause">
 The value for the AsClause property.
 </param>
 <param name="initializer">
 The value for the Initializer property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax">
 <summary>
 Abstract node class that represents the different kinds of "As {type-name}"
 clauses in a declaration: simple "As" clauses and "As New" clauses. The type
 has optional attributes associated with it, although attributes are not
 permitted in all possible places where this node occurs.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax.AsKeyword">
 <summary>
 The "As" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax">
 <summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax.AsKeyword">
 <summary>
 The "As" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax.WithAsKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the AsKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax.Type">
 <summary>
 The type-name part of the As clause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax.WithType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the Type property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="asKeyword">
 The value for the AsKeyword property.
 </param>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="type">
 The value for the Type property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax">
 <summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax.AsKeyword">
 <summary>
 The "As" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax.WithAsKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the AsKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax.NewExpression">
 <summary>
 The New expression
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax.WithNewExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax)">
 <summary>
 Returns a copy of this with the NewExpression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="asKeyword">
 The value for the AsKeyword property.
 </param>
 <param name="newExpression">
 The value for the NewExpression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationInitializerSyntax">
 <summary>
 An abstract node class that represents a "With" or "From" clause used to
 initializer an new object.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax">
 <summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax.WithKeyword">
 <summary>
 The "With" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax.WithWithKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the WithKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax.OpenBraceToken">
 <summary>
 The "{" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax.WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenBraceToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax.Initializers">
 <summary>
 The comma-separated list of field initializers.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax.WithInitializers(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax})">
 <summary>
 Returns a copy of this with the Initializers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax.CloseBraceToken">
 <summary>
 The "}" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax.WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseBraceToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="withKeyword">
 The value for the WithKeyword property.
 </param>
 <param name="openBraceToken">
 The value for the OpenBraceToken property.
 </param>
 <param name="initializers">
 The value for the Initializers property.
 </param>
 <param name="closeBraceToken">
 The value for the CloseBraceToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax">
 <summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax.FromKeyword">
 <summary>
 The "From" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax.WithFromKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the FromKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax.Initializer">
 <summary>
 The initializer including the braces.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax.WithInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax)">
 <summary>
 Returns a copy of this with the Initializer property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="fromKeyword">
 The value for the FromKeyword property.
 </param>
 <param name="initializer">
 The value for the Initializer property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax">
 <summary>
 Abstract class that represent a single field initializer used in a "With {...}"
 field initializer list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax.KeyKeyword">
 <summary>
 The optional "Key" keyword.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax">
 <summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax.KeyKeyword">
 <summary>
 The optional "Key" keyword.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax.WithKeyKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the KeyKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax.Expression">
 <summary>
 The value being assigned.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="keyKeyword">
 The value for the KeyKeyword property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax">
 <summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax.KeyKeyword">
 <summary>
 The optional "Key" keyword.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax.WithKeyKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the KeyKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax.DotToken">
 <summary>
 The "." token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax.WithDotToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the DotToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax.Name">
 <summary>
 The name of the field being initialized.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax.EqualsToken">
 <summary>
 The "=" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax.WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EqualsToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax.Expression">
 <summary>
 The value being assigned to the field.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="keyKeyword">
 The value for the KeyKeyword property.
 </param>
 <param name="dotToken">
 The value for the DotToken property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="equalsToken">
 The value for the EqualsToken property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax">
 <summary>
 Represents an "= initializer" clause in a declaration for a variable, parameter
 or automatic property.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax.EqualsToken">
 <summary>
 The "=" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax.WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EqualsToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax.Value">
 <summary>
 The expression used as the initial value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax.WithValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Value property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="equalsToken">
 The value for the EqualsToken property.
 </param>
 <param name="value">
 The value for the Value property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax">
 <summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on this parameter. If no attributes were
 specified, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax.Modifiers">
 <summary>
 A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
 modify this parameter.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax.Identifier">
 <summary>
 The name of the parameter, including any "?" or "()" modifiers.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax.WithIdentifier(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax.AsClause">
 <summary>
 If present, the "As type-name" clause describing the type of the parameter. If
 no As clause is present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax.WithAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the AsClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax.Default">
 <summary>
 If present, an initializer with the default value of the parameter. If no
 default value is present, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax.WithDefault(Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax)">
 <summary>
 Returns a copy of this with the [Default] property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="asClause">
 The value for the AsClause property.
 </param>
 <param name="default">
 The value for the Default property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax">
 <summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax.Identifier">
 <summary>
 The identifier that names the item being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax.Nullable">
 <summary>
 The "?" token that indicates a nullable type.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax.WithNullable(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Nullable property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax.ArrayBounds">
 <summary>
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax.WithArrayBounds(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Returns a copy of this with the ArrayBounds property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax.ArrayRankSpecifiers">
 <summary>
 A list of array modifiers for the type. If no array modifiers were present, an
 empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax.WithArrayRankSpecifiers(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax})">
 <summary>
 Returns a copy of this with the ArrayRankSpecifiers property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="nullable">
 The value for the Nullable property.
 </param>
 <param name="arrayBounds">
 The value for the ArrayBounds property.
 </param>
 <param name="arrayRankSpecifiers">
 The value for the ArrayRankSpecifiers property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax">
 <summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax.LessThanToken">
 <summary>
 The "&lt;" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax.WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LessThanToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax.Attributes">
 <summary>
 A comma separated list of attribute declarations in this attribute list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax.WithAttributes(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax})">
 <summary>
 Returns a copy of this with the Attributes property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax.GreaterThanToken">
 <summary>
 The "&gt;" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax.WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the GreaterThanToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="lessThanToken">
 The value for the LessThanToken property.
 </param>
 <param name="attributes">
 The value for the Attributes property.
 </param>
 <param name="greaterThanToken">
 The value for the GreaterThanToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax.Target">
 <summary>
 Optional attribute target. Assembly|Module :
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax.WithTarget(Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax)">
 <summary>
 Returns a copy of this with the Target property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax.Name">
 <summary>
 The name of the attribute.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax.ArgumentList">
 <summary>
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax.WithArgumentList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Returns a copy of this with the ArgumentList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="target">
 The value for the Target property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="argumentList">
 The value for the ArgumentList property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax.AttributeModifier">
 <summary>
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax.WithAttributeModifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the AttributeModifier property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax.ColonToken">
 <summary>
 The ":" token, if an attribute modifier is present. If no attribute modifier is
 present, Nothing is returned.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax.WithColonToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ColonToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeModifier">
 The value for the AttributeModifier property.
 </param>
 <param name="colonToken">
 The value for the ColonToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax">
 <summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax.AttributeLists">
 <summary>
 The list of attribute lists.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax">
 <summary>
 Represent an expression in a statement context. This may only be a invocation
 or await expression in standard code but may be any expression in VB
 Interactive code.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax.Expression">
 <summary>
 The expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax">
 <summary>
 Represent a "? expression" "Print" statement in VB Interactive code.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax.QuestionToken">
 <summary>
 "?" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax.WithQuestionToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the QuestionToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax.Expression">
 <summary>
 The expression whose value is being output.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="questionToken">
 The value for the QuestionToken property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax">
 <summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax.WhileStatement">
 <summary>
 The While statement that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax.WithWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax)">
 <summary>
 Returns a copy of this with the WhileStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax.Statements">
 <summary>
 The statements contained in the While...End While. This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax.EndWhileStatement">
 <summary>
 The End While statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax.WithEndWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndWhileStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="whileStatement">
 The value for the WhileStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="endWhileStatement">
 The value for the EndWhileStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax">
 <summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax.UsingStatement">
 <summary>
 The UsingStatement that begins the Using...End Using block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax.WithUsingStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax)">
 <summary>
 Returns a copy of this with the UsingStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax.Statements">
 <summary>
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax.EndUsingStatement">
 <summary>
 The End Using statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax.WithEndUsingStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndUsingStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="usingStatement">
 The value for the UsingStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="endUsingStatement">
 The value for the EndUsingStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax">
 <summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax.SyncLockStatement">
 <summary>
 The SyncLock statement that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax.WithSyncLockStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax)">
 <summary>
 Returns a copy of this with the SyncLockStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax.Statements">
 <summary>
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax.EndSyncLockStatement">
 <summary>
 The End SyncLock statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax.WithEndSyncLockStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndSyncLockStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="syncLockStatement">
 The value for the SyncLockStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="endSyncLockStatement">
 The value for the EndSyncLockStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax">
 <summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax.WithStatement">
 <summary>
 The WithStatement that begins the With...End With block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax.WithWithStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax)">
 <summary>
 Returns a copy of this with the WithStatement property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax.Statements">
 <summary>
 The statements contained in the With...End With block. This might be an empty
 list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax.EndWithStatement">
 <summary>
 The End With statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax.WithEndWithStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndWithStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="withStatement">
 The value for the WithStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="endWithStatement">
 The value for the EndWithStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax">
 <summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax.Modifiers">
 <summary>
 The modifier token (Static, Dim or Const) that introduces this local variable
 declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax.WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the Modifiers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax.Declarators">
 <summary>
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax.WithDeclarators(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax})">
 <summary>
 Returns a copy of this with the Declarators property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="modifiers">
 The value for the Modifiers property.
 </param>
 <param name="declarators">
 The value for the Declarators property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax">
 <summary>
 Represents a label statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax.LabelToken">
 <summary>
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax.WithLabelToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LabelToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax.ColonToken">
 <summary>
 The ":" token of the label statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax.WithColonToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ColonToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="labelToken">
 The value for the LabelToken property.
 </param>
 <param name="colonToken">
 The value for the ColonToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax">
 <summary>
 Represents a "GoTo" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax.GoToKeyword">
 <summary>
 The "GoTo" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax.WithGoToKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the GoToKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax.Label">
 <summary>
 The name of the label. If the label is a line number, wraps an IntegerLiteral
 that is the line number, otherwise, wraps an Identifier.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax.WithLabel(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Returns a copy of this with the Label property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="goToKeyword">
 The value for the GoToKeyword property.
 </param>
 <param name="label">
 The value for the Label property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax.LabelToken">
 <summary>
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax.WithLabelToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LabelToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="labelToken">
 The value for the LabelToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax">
 <summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax.StopOrEndKeyword">
 <summary>
 The "Stop" or "End" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax.WithStopOrEndKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the StopOrEndKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="stopOrEndKeyword">
 The value for the StopOrEndKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax.ExitKeyword">
 <summary>
 The "Exit" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax.WithExitKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ExitKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax.BlockKeyword">
 <summary>
 The keyword describing the block to exit.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax.WithBlockKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the BlockKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="exitKeyword">
 The value for the ExitKeyword property.
 </param>
 <param name="blockKeyword">
 The value for the BlockKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax.ContinueKeyword">
 <summary>
 The "Continue" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax.WithContinueKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ContinueKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax.BlockKeyword">
 <summary>
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax.WithBlockKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the BlockKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="continueKeyword">
 The value for the ContinueKeyword property.
 </param>
 <param name="blockKeyword">
 The value for the BlockKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax">
 <summary>
 Represents a "Return" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax.ReturnKeyword">
 <summary>
 The "Return" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax.WithReturnKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ReturnKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax.Expression">
 <summary>
 The expression being returned, if present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="returnKeyword">
 The value for the ReturnKeyword property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax">
 <summary>
 Represents a single-line "If ... Then ... Else ..." statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax.IfKeyword">
 <summary>
 The "If" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax.WithIfKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the IfKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax.Condition">
 <summary>
 The condition expression to be evaluated.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax.WithCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Condition property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax.ThenKeyword">
 <summary>
 The "Then" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax.WithThenKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ThenKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax.Statements">
 <summary>
 A list of statements to be executed if the condition expression evaluates as
 true. Multiple statements must be separated by colons.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax.ElseClause">
 <summary>
 An "Else" clause to be executed if the condition expression evaluates as false.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax.WithElseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax)">
 <summary>
 Returns a copy of this with the ElseClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="ifKeyword">
 The value for the IfKeyword property.
 </param>
 <param name="condition">
 The value for the Condition property.
 </param>
 <param name="thenKeyword">
 The value for the ThenKeyword property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="elseClause">
 The value for the ElseClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax">
 <summary>
 Represents the "Else ..." clause of a single-line "If" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax.ElseKeyword">
 <summary>
 The "Else" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax.WithElseKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ElseKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax.Statements">
 <summary>
 A list of statements to be executed. Multiple statements must be separated by
 colons.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="elseKeyword">
 The value for the ElseKeyword property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax">
 <summary>
 Represents a multi-line "If ... Then ... ElseIf ... Then ... Else ... End If"
 block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax.IfStatement">
 <summary>
 The "If" statement that begins the "If" block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax.WithIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax)">
 <summary>
 Returns a copy of this with the IfStatement property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax.Statements">
 <summary>
 A list of statements to be executed if the condition expression evaluates as
 true.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax.ElseIfBlocks">
 <summary>
 A list of "ElseIf" blocks to be evaluated, in order, if the condition
 expression of the "If" statement evaluates as false.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax.WithElseIfBlocks(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax})">
 <summary>
 Returns a copy of this with the ElseIfBlocks property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax.ElseBlock">
 <summary>
 An "Else" block to be executed if the condition expression of the "If"
 statement and all "ElseIf" blocks evaluate as false.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax.WithElseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax)">
 <summary>
 Returns a copy of this with the ElseBlock property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax.EndIfStatement">
 <summary>
 Then "End If" statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax.WithEndIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndIfStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="ifStatement">
 The value for the IfStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="elseIfBlocks">
 The value for the ElseIfBlocks property.
 </param>
 <param name="elseBlock">
 The value for the ElseBlock property.
 </param>
 <param name="endIfStatement">
 The value for the EndIfStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax">
 <summary>
 Represents the "If ... Then" statement that begins a multi-line "If" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax.IfKeyword">
 <summary>
 The "If" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax.WithIfKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the IfKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax.Condition">
 <summary>
 The condition expression to be evaluated.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax.WithCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Condition property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax.ThenKeyword">
 <summary>
 The "Then" keyword.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax.WithThenKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ThenKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="ifKeyword">
 The value for the IfKeyword property.
 </param>
 <param name="condition">
 The value for the Condition property.
 </param>
 <param name="thenKeyword">
 The value for the ThenKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax">
 <summary>
 Represents an "ElseIf ... Then ..." block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax.ElseIfStatement">
 <summary>
 The "ElseIf ... Then" statement the begins the "ElseIf" block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax.WithElseIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax)">
 <summary>
 Returns a copy of this with the ElseIfStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax.Statements">
 <summary>
 A list of statements to be executed if the condition expression of the "ElseIf"
 statement evaluates as true.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="elseIfStatement">
 The value for the ElseIfStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax">
 <summary>
 Represents the "ElseIf ... Then" statement that begins an "ElseIf" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax.ElseIfKeyword">
 <summary>
 The "ElseIf" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax.WithElseIfKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ElseIfKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax.Condition">
 <summary>
 The condition expression to be evaluated.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax.WithCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Condition property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax.ThenKeyword">
 <summary>
 The "Then" keyword.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax.WithThenKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ThenKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="elseIfKeyword">
 The value for the ElseIfKeyword property.
 </param>
 <param name="condition">
 The value for the Condition property.
 </param>
 <param name="thenKeyword">
 The value for the ThenKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax">
 <summary>
 Represents an "Else ..." block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax.ElseStatement">
 <summary>
 The "Else" statement that begins the "Else" block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax.WithElseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseStatementSyntax)">
 <summary>
 Returns a copy of this with the ElseStatement property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax.Statements">
 <summary>
 A list of statements to be executed.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="elseStatement">
 The value for the ElseStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseStatementSyntax">
 <summary>
 Represents the "Else" statement that begins an "Else" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseStatementSyntax.ElseKeyword">
 <summary>
 The "Else" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseStatementSyntax.WithElseKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ElseKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="elseKeyword">
 The value for the ElseKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax">
 <summary>
 Represents a "Try ... Catch ... Finally ... End Try" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax.TryStatement">
 <summary>
 The "Try" statement that begins the "Try" block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax.WithTryStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.TryStatementSyntax)">
 <summary>
 Returns a copy of this with the TryStatement property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax.Statements">
 <summary>
 A list of statements to be executed.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax.CatchBlocks">
 <summary>
 A list of "Catch" blocks which may be executed if an exception is thrown while
 executing the statements in the "Try" block.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax.WithCatchBlocks(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax})">
 <summary>
 Returns a copy of this with the CatchBlocks property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax.FinallyBlock">
 <summary>
 A "Finally" block to be executed before execution leaves the "Try" block.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax.WithFinallyBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax)">
 <summary>
 Returns a copy of this with the FinallyBlock property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax.EndTryStatement">
 <summary>
 The "End Try" statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax.WithEndTryStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndTryStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.TryStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="tryStatement">
 The value for the TryStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="catchBlocks">
 The value for the CatchBlocks property.
 </param>
 <param name="finallyBlock">
 The value for the FinallyBlock property.
 </param>
 <param name="endTryStatement">
 The value for the EndTryStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryStatementSyntax">
 <summary>
 Represents the "Try" statement that begins a "Try" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryStatementSyntax.TryKeyword">
 <summary>
 The "Try" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryStatementSyntax.WithTryKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the TryKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="tryKeyword">
 The value for the TryKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax">
 <summary>
 Represents a "Catch ..." block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax.CatchStatement">
 <summary>
 The "Catch" statement that begins the "Catch" block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax.WithCatchStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax)">
 <summary>
 Returns a copy of this with the CatchStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax.Statements">
 <summary>
 A list of statements to be executed if an exception is caught by the "Catch"
 block.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="catchStatement">
 The value for the CatchStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax">
 <summary>
 Represents the "Catch ... When ..." statement that begins a "Catch" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax.CatchKeyword">
 <summary>
 The "Catch" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax.WithCatchKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CatchKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax.IdentifierName">
 <summary>
 An identifier declaring a new variable or naming an existing variable to store
 the exception caught by the "Catch" statement.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax.WithIdentifierName(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Returns a copy of this with the IdentifierName property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax.AsClause">
 <summary>
 A simple "As" clause specifying the type of exception to catch.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax.WithAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the AsClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax.WhenClause">
 <summary>
 A "When" clause to filter exceptions before catching.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax.WithWhenClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax)">
 <summary>
 Returns a copy of this with the WhenClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="catchKeyword">
 The value for the CatchKeyword property.
 </param>
 <param name="identifierName">
 The value for the IdentifierName property.
 </param>
 <param name="asClause">
 The value for the AsClause property.
 </param>
 <param name="whenClause">
 The value for the WhenClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax">
 <summary>
 Represents the "When ..." clause of a "Catch" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax.WhenKeyword">
 <summary>
 The "When" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax.WithWhenKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the WhenKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax.Filter">
 <summary>
 The filter expression to be evaluated.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax.WithFilter(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Filter property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="whenKeyword">
 The value for the WhenKeyword property.
 </param>
 <param name="filter">
 The value for the Filter property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax">
 <summary>
 Represents a "Finally ..." block of a "Try" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax.FinallyStatement">
 <summary>
 The "Finally" statement that begins the "Finally" block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax.WithFinallyStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyStatementSyntax)">
 <summary>
 Returns a copy of this with the FinallyStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax.Statements">
 <summary>
 A list of statements to be executed.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="finallyStatement">
 The value for the FinallyStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyStatementSyntax">
 <summary>
 Represents the "Finally" statement that begins a "Finally" block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyStatementSyntax.FinallyKeyword">
 <summary>
 The "Finally" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyStatementSyntax.WithFinallyKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the FinallyKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="finallyKeyword">
 The value for the FinallyKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax">
 <summary>
 Represents the "Error" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax.ErrorKeyword">
 <summary>
 The "Error" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax.WithErrorKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ErrorKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax.ErrorNumber">
 <summary>
 The expression that represents the error number.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax.WithErrorNumber(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the ErrorNumber property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="errorKeyword">
 The value for the ErrorKeyword property.
 </param>
 <param name="errorNumber">
 The value for the ErrorNumber property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax">
 <summary>
 Represents an OnError Goto statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax.OnKeyword">
 <summary>
 The "On" keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax.WithOnKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OnKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax.ErrorKeyword">
 <summary>
 The "Error" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax.WithErrorKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ErrorKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax.GoToKeyword">
 <summary>
 The "GoTo" keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax.WithGoToKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the GoToKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax.Minus">
 <summary>
 An optional minus for On Error Goto -1
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax.WithMinus(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Minus property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax.Label">
 <summary>
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax.WithLabel(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Returns a copy of this with the Label property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="onKeyword">
 The value for the OnKeyword property.
 </param>
 <param name="errorKeyword">
 The value for the ErrorKeyword property.
 </param>
 <param name="goToKeyword">
 The value for the GoToKeyword property.
 </param>
 <param name="minus">
 The value for the Minus property.
 </param>
 <param name="label">
 The value for the Label property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax">
 <summary>
 Represents an OnError Resume Next statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax.OnKeyword">
 <summary>
 The "On" keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax.WithOnKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OnKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax.ErrorKeyword">
 <summary>
 The "Error" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax.WithErrorKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ErrorKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax.ResumeKeyword">
 <summary>
 The "Resume" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax.WithResumeKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ResumeKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax.NextKeyword">
 <summary>
 The "Next"
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax.WithNextKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the NextKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="onKeyword">
 The value for the OnKeyword property.
 </param>
 <param name="errorKeyword">
 The value for the ErrorKeyword property.
 </param>
 <param name="resumeKeyword">
 The value for the ResumeKeyword property.
 </param>
 <param name="nextKeyword">
 The value for the NextKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax.ResumeKeyword">
 <summary>
 The "Resume" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax.WithResumeKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ResumeKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax.Label">
 <summary>
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax.WithLabel(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Returns a copy of this with the Label property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="resumeKeyword">
 The value for the ResumeKeyword property.
 </param>
 <param name="label">
 The value for the Label property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax">
 <summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax.SelectStatement">
 <summary>
 The Select Case statement that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax.WithSelectStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax)">
 <summary>
 Returns a copy of this with the SelectStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax.CaseBlocks">
 <summary>
 A list of the contained Case blocks.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax.WithCaseBlocks(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax})">
 <summary>
 Returns a copy of this with the CaseBlocks property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax.EndSelectStatement">
 <summary>
 The End Select statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax.WithEndSelectStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the EndSelectStatement property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="selectStatement">
 The value for the SelectStatement property.
 </param>
 <param name="caseBlocks">
 The value for the CaseBlocks property.
 </param>
 <param name="endSelectStatement">
 The value for the EndSelectStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax">
 <summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax.SelectKeyword">
 <summary>
 The "Select" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax.WithSelectKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the SelectKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax.CaseKeyword">
 <summary>
 The "Case" keyword, if present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax.WithCaseKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CaseKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax.Expression">
 <summary>
 The value that branching is based on.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="selectKeyword">
 The value for the SelectKeyword property.
 </param>
 <param name="caseKeyword">
 The value for the CaseKeyword property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax.CaseKeyword">
 <summary>
 The "Case" keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax.WithCaseKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CaseKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax.Cases">
 <summary>
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax.WithCases(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax})">
 <summary>
 Returns a copy of this with the Cases property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="caseKeyword">
 The value for the CaseKeyword property.
 </param>
 <param name="cases">
 The value for the Cases property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax">
 <summary>
 Represents a single clause in a case statement. An abstract node that is the
 parent of different kinds of Case clauses.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseCaseClauseSyntax">
 <summary>
 The "Else" part in a Case Else statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseCaseClauseSyntax.ElseKeyword">
 <summary>
 The "Else" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseCaseClauseSyntax.WithElseKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ElseKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseCaseClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="elseKeyword">
 The value for the ElseKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleCaseClauseSyntax">
 <summary>
 Represents a single value in a Case.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleCaseClauseSyntax.Value">
 <summary>
 The expression that denotes the value being tested against.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleCaseClauseSyntax.WithValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Value property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleCaseClauseSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="value">
 The value for the Value property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax">
 <summary>
 Represents a range "expression To expression" in a Case.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax.LowerBound">
 <summary>
 The lower bound of the range.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax.WithLowerBound(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the LowerBound property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax.ToKeyword">
 <summary>
 The "To" keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax.WithToKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ToKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax.UpperBound">
 <summary>
 The upper bound of the range.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax.WithUpperBound(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the UpperBound property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="lowerBound">
 The value for the LowerBound property.
 </param>
 <param name="toKeyword">
 The value for the ToKeyword property.
 </param>
 <param name="upperBound">
 The value for the UpperBound property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax.IsKeyword">
 <summary>
 The "Is" keyword, if present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax.WithIsKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the IsKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax.OperatorToken">
 <summary>
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax.WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OperatorToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax.Value">
 <summary>
 The expression that denotes the value being tested against.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax.WithValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Value property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="isKeyword">
 The value for the IsKeyword property.
 </param>
 <param name="operatorToken">
 The value for the OperatorToken property.
 </param>
 <param name="value">
 The value for the Value property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax">
 <summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax.SyncLockKeyword">
 <summary>
 The "SyncLock" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax.WithSyncLockKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the SyncLockKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax.Expression">
 <summary>
 The expression being synchronized on.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="syncLockKeyword">
 The value for the SyncLockKeyword property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax.DoStatement">
 <summary>
 The Do statement that begins the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax.WithDoStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax)">
 <summary>
 Returns a copy of this with the DoStatement property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax.Statements">
 <summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax.WithStatements(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Returns a copy of this with the Statements property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax.LoopStatement">
 <summary>
 The Loop statement that ends the block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax.WithLoopStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Returns a copy of this with the LoopStatement property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="doStatement">
 The value for the DoStatement property.
 </param>
 <param name="statements">
 The value for the Statements property.
 </param>
 <param name="loopStatement">
 The value for the LoopStatement property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax.DoKeyword">
 <summary>
 The "Do" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax.WithDoKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the DoKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax.WhileOrUntilClause">
 <summary>
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax.WithWhileOrUntilClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 Returns a copy of this with the WhileOrUntilClause property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="doKeyword">
 The value for the DoKeyword property.
 </param>
 <param name="whileOrUntilClause">
 The value for the WhileOrUntilClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax.LoopKeyword">
 <summary>
 The "Loop" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax.WithLoopKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LoopKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax.WhileOrUntilClause">
 <summary>
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax.WithWhileOrUntilClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 Returns a copy of this with the WhileOrUntilClause property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="loopKeyword">
 The value for the LoopKeyword property.
 </param>
 <param name="whileOrUntilClause">
 The value for the WhileOrUntilClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax">
 <summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax.WhileOrUntilKeyword">
 <summary>
 The "While" or "Until" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax.WithWhileOrUntilKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the WhileOrUntilKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax.Condition">
 <summary>
 The boolean expression after the While or Until.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax.WithCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Condition property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="whileOrUntilKeyword">
 The value for the WhileOrUntilKeyword property.
 </param>
 <param name="condition">
 The value for the Condition property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax">
 <summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax.WhileKeyword">
 <summary>
 The "While" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax.WithWhileKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the WhileKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax.Condition">
 <summary>
 The boolean expression that controls the While loop.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax.WithCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Condition property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="whileKeyword">
 The value for the WhileKeyword property.
 </param>
 <param name="condition">
 The value for the Condition property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachStatementSyntax">
 <summary>
 Represents a For or For Each statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachStatementSyntax.ForKeyword">
 <summary>
 The "For" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachStatementSyntax.ControlVariable">
 <summary>
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax">
 <summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.ForKeyword">
 <summary>
 The "For" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.WithForKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ForKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.ControlVariable">
 <summary>
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.WithControlVariable(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Returns a copy of this with the ControlVariable property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.EqualsToken">
 <summary>
 The "=" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EqualsToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.FromValue">
 <summary>
 The expression denoting the initial value of the iteration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.WithFromValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the FromValue property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.ToKeyword">
 <summary>
 The "To" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.WithToKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ToKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.ToValue">
 <summary>
 The expression denoting the final value of the iteration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.WithToValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the ToValue property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.StepClause">
 <summary>
 The optional Step clause.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.WithStepClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax)">
 <summary>
 Returns a copy of this with the StepClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="forKeyword">
 The value for the ForKeyword property.
 </param>
 <param name="controlVariable">
 The value for the ControlVariable property.
 </param>
 <param name="equalsToken">
 The value for the EqualsToken property.
 </param>
 <param name="fromValue">
 The value for the FromValue property.
 </param>
 <param name="toKeyword">
 The value for the ToKeyword property.
 </param>
 <param name="toValue">
 The value for the ToValue property.
 </param>
 <param name="stepClause">
 The value for the StepClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax">
 <summary>
 The Step clause in a For Statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax.StepKeyword">
 <summary>
 The "Step" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax.WithStepKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the StepKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax.StepValue">
 <summary>
 The expression denoting the step increment.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax.WithStepValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the StepValue property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="stepKeyword">
 The value for the StepKeyword property.
 </param>
 <param name="stepValue">
 The value for the StepValue property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax">
 <summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax.ForKeyword">
 <summary>
 The "For" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax.WithForKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ForKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax.EachKeyword">
 <summary>
 The "Each" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax.WithEachKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EachKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax.ControlVariable">
 <summary>
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax.WithControlVariable(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Returns a copy of this with the ControlVariable property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax.InKeyword">
 <summary>
 The "In" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax.WithInKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the InKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax.Expression">
 <summary>
 The expression denoting the collection to iterate over.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="forKeyword">
 The value for the ForKeyword property.
 </param>
 <param name="eachKeyword">
 The value for the EachKeyword property.
 </param>
 <param name="controlVariable">
 The value for the ControlVariable property.
 </param>
 <param name="inKeyword">
 The value for the InKeyword property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax">
 <summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax.NextKeyword">
 <summary>
 The "Next" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax.WithNextKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the NextKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax.ControlVariables">
 <summary>
 The variables in the Next statement, if present
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax.WithControlVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax})">
 <summary>
 Returns a copy of this with the ControlVariables property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="nextKeyword">
 The value for the NextKeyword property.
 </param>
 <param name="controlVariables">
 The value for the ControlVariables property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax">
 <summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax.UsingKeyword">
 <summary>
 The "Using" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax.WithUsingKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the UsingKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax.Expression">
 <summary>
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax.Variables">
 <summary>
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax.WithVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax})">
 <summary>
 Returns a copy of this with the Variables property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="usingKeyword">
 The value for the UsingKeyword property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="variables">
 The value for the Variables property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax">
 <summary>
 Represents a Throw statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax.ThrowKeyword">
 <summary>
 The "Throw" keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax.WithThrowKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ThrowKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax.Expression">
 <summary>
 The expression denoting the value being thrown.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="throwKeyword">
 The value for the ThrowKeyword property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Left">
 <summary>
 The target (left hand side) of the assignment.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.WithLeft(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Left property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.OperatorToken">
 <summary>
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OperatorToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Right">
 <summary>
 The source (right hand side) of the assignment.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.WithRight(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Right property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="left">
 The value for the Left property.
 </param>
 <param name="operatorToken">
 The value for the OperatorToken property.
 </param>
 <param name="right">
 The value for the Right property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax">
 <summary>
 Represents a left-hand side of a MidAssignment statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Mid">
 <summary>
 The "Mid" possibly followed by a type character.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.WithMid(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Mid property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.ArgumentList">
 <summary>
 The argument list.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.WithArgumentList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Returns a copy of this with the ArgumentList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="mid">
 The value for the Mid property.
 </param>
 <param name="argumentList">
 The value for the ArgumentList property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax">
 <summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax.CallKeyword">
 <summary>
 The "Call" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax.WithCallKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CallKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax.Invocation">
 <summary>
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax.WithInvocation(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Invocation property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="callKeyword">
 The value for the CallKeyword property.
 </param>
 <param name="invocation">
 The value for the Invocation property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax.AddHandlerOrRemoveHandlerKeyword">
 <summary>
 The "AddHandler" or "RemoveHandler" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax.WithAddHandlerOrRemoveHandlerKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the AddHandlerOrRemoveHandlerKeyword property
 changed to the specified value. Returns this instance if the specified value is
 the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax.EventExpression">
 <summary>
 The event being accessed.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax.WithEventExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the EventExpression property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax.CommaToken">
 <summary>
 The "," token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax.WithCommaToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CommaToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax.DelegateExpression">
 <summary>
 The delegate being added or removed.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax.WithDelegateExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the DelegateExpression property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="addHandlerOrRemoveHandlerKeyword">
 The value for the AddHandlerOrRemoveHandlerKeyword property.
 </param>
 <param name="eventExpression">
 The value for the EventExpression property.
 </param>
 <param name="commaToken">
 The value for the CommaToken property.
 </param>
 <param name="delegateExpression">
 The value for the DelegateExpression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax">
 <summary>
 Represent a RaiseEvent statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax.RaiseEventKeyword">
 <summary>
 The "RaiseEvent" keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax.WithRaiseEventKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the RaiseEventKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax.Name">
 <summary>
 The name of the event being raised.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax.ArgumentList">
 <summary>
 The argument list, if present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax.WithArgumentList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Returns a copy of this with the ArgumentList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="raiseEventKeyword">
 The value for the RaiseEventKeyword property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="argumentList">
 The value for the ArgumentList property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax">
 <summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax.WithKeyword">
 <summary>
 The "With" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax.WithWithKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the WithKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax.Expression">
 <summary>
 The expression that is the operand of the With statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="withKeyword">
 The value for the WithKeyword property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax">
 <summary>
 Represents a ReDim statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax.ReDimKeyword">
 <summary>
 The "ReDim" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax.WithReDimKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ReDimKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax.PreserveKeyword">
 <summary>
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax.WithPreserveKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the PreserveKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax.Clauses">
 <summary>
 The list of ReDim clauses.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax.WithClauses(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax})">
 <summary>
 Returns a copy of this with the Clauses property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="reDimKeyword">
 The value for the ReDimKeyword property.
 </param>
 <param name="preserveKeyword">
 The value for the PreserveKeyword property.
 </param>
 <param name="clauses">
 The value for the Clauses property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax">
 <summary>
 Represents a ReDim statement clause.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax.Expression">
 <summary>
 The target of the ReDim statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax.ArrayBounds">
 <summary>
 The ArraySizeInitializationModifier.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax.WithArrayBounds(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Returns a copy of this with the ArrayBounds property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="arrayBounds">
 The value for the ArrayBounds property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax">
 <summary>
 Represents an "Erase" statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax.EraseKeyword">
 <summary>
 The "Erase" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax.WithEraseKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EraseKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax.Expressions">
 <summary>
 A list of expressions denoting the arrays to erase.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax.WithExpressions(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax})">
 <summary>
 Returns a copy of this with the Expressions property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="eraseKeyword">
 The value for the EraseKeyword property.
 </param>
 <param name="expressions">
 The value for the Expressions property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax">
 <summary>
 An abstract base class for all node classes that define expressions.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax.Token">
 <summary>
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax.WithToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Token property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="token">
 The value for the Token property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax">
 <summary>
 Represents a parenthesized expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax.Expression">
 <summary>
 The expression inside the parentheses.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InstanceExpressionSyntax">
 <summary>
 Identifies one of the special instances "Me", "MyClass" or "MyBase". The Kind
 property identifies which.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InstanceExpressionSyntax.Keyword">
 <summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax">
 <summary>
 Identifies the special instance "Me"
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax.Keyword">
 <summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax.WithKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Keyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="keyword">
 The value for the Keyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax">
 <summary>
 Identifies the special instance "MyBase"
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax.Keyword">
 <summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax.WithKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Keyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="keyword">
 The value for the Keyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax">
 <summary>
 Identifies the special instance "MyClass"
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax.Keyword">
 <summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax.WithKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Keyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="keyword">
 The value for the Keyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax">
 <summary>
 Represents a GetType expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax.GetTypeKeyword">
 <summary>
 The "GetType" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax.WithGetTypeKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the GetTypeKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax.Type">
 <summary>
 The type to get the Type object for. This can be an open generic type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax.WithType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the Type property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="getTypeKeyword">
 The value for the GetTypeKeyword property.
 </param>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="type">
 The value for the Type property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax.TypeOfKeyword">
 <summary>
 The "TypeOf" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax.WithTypeOfKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the TypeOfKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax.Expression">
 <summary>
 The expression being tested.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax.OperatorToken">
 <summary>
 The "Is" or "IsNot" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax.WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OperatorToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax.Type">
 <summary>
 The name of the type being tested against.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax.WithType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the Type property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="typeOfKeyword">
 The value for the TypeOfKeyword property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="operatorToken">
 The value for the OperatorToken property.
 </param>
 <param name="type">
 The value for the Type property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax">
 <summary>
 Represents a GetXmlNamespace expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax.GetXmlNamespaceKeyword">
 <summary>
 The "GetXmlNamespace" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax.WithGetXmlNamespaceKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the GetXmlNamespaceKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax.Name">
 <summary>
 The Xml namespace name being referenced.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="getXmlNamespaceKeyword">
 The value for the GetXmlNamespaceKeyword property.
 </param>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax.Expression">
 <summary>
 The expression on the left-hand-side of the "." or "!" token.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax.OperatorToken">
 <summary>
 The "." or "!" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax.WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OperatorToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax.Name">
 <summary>
 The identifier after the "." or "!" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="operatorToken">
 The value for the OperatorToken property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax.Base">
 <summary>
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax.WithBase(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Base property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax.Token1">
 <summary>
 The initial dot "." part of the separator.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax.WithToken1(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Token1 property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax.Token2">
 <summary>
 The "@" part of .@ or the second "." of "...".
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax.WithToken2(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Token2 property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax.Token3">
 <summary>
 The third "." in a "..." separator.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax.WithToken3(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Token3 property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax.Name">
 <summary>
 The identifier after the ".", ".@" or "..."
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="base">
 The value for the Base property.
 </param>
 <param name="token1">
 The value for the Token1 property.
 </param>
 <param name="token2">
 The value for the Token2 property.
 </param>
 <param name="token3">
 The value for the Token3 property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax">
 <summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax.Expression">
 <summary>
 The target of the call or index expression.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax.ArgumentList">
 <summary>
 The argument list.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax.WithArgumentList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Returns a copy of this with the ArgumentList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="argumentList">
 The value for the ArgumentList property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax">
 <summary>
 Base class for object, array and anonymous object creation expressions
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax.NewKeyword">
 <summary>
 The "New" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax">
 <summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax.NewKeyword">
 <summary>
 The "New" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax.WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the NewKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax.Type">
 <summary>
 The type of the object being initialized.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax.WithType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the Type property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax.ArgumentList">
 <summary>
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax.WithArgumentList(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Returns a copy of this with the ArgumentList property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax.Initializer">
 <summary>
 An optional From or With clause to initialize the new object.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax.WithInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationInitializerSyntax)">
 <summary>
 Returns a copy of this with the Initializer property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationInitializerSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="newKeyword">
 The value for the NewKeyword property.
 </param>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="type">
 The value for the Type property.
 </param>
 <param name="argumentList">
 The value for the ArgumentList property.
 </param>
 <param name="initializer">
 The value for the Initializer property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax">
 <summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax.NewKeyword">
 <summary>
 The "New" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax.WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the NewKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax.Initializer">
 <summary>
 The With clause to initialize the new object.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax.WithInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax)">
 <summary>
 Returns a copy of this with the Initializer property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="newKeyword">
 The value for the NewKeyword property.
 </param>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="initializer">
 The value for the Initializer property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax">
 <summary>
 Represents an expression that creates a new array.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax.NewKeyword">
 <summary>
 The "New" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax.WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the NewKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax.AttributeLists">
 <summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax.WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Returns a copy of this with the AttributeLists property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax.Type">
 <summary>
 The element type of the array being created.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax.WithType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the Type property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax.ArrayBounds">
 <summary>
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax.WithArrayBounds(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Returns a copy of this with the ArrayBounds property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax.RankSpecifiers">
 <summary>
 A list of array modifiers such as "()" or "(,)". If no array modifiers were
 present, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax.WithRankSpecifiers(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax})">
 <summary>
 Returns a copy of this with the RankSpecifiers property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax.Initializer">
 <summary>
 The initializer including the braces.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax.WithInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax)">
 <summary>
 Returns a copy of this with the Initializer property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="newKeyword">
 The value for the NewKeyword property.
 </param>
 <param name="attributeLists">
 The value for the AttributeLists property.
 </param>
 <param name="type">
 The value for the Type property.
 </param>
 <param name="arrayBounds">
 The value for the ArrayBounds property.
 </param>
 <param name="rankSpecifiers">
 The value for the RankSpecifiers property.
 </param>
 <param name="initializer">
 The value for the Initializer property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax">
 <summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax.OpenBraceToken">
 <summary>
 The "{" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax.WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenBraceToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax.Initializers">
 <summary>
 The list of initializers between the braces.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax.WithInitializers(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax})">
 <summary>
 Returns a copy of this with the Initializers property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax.CloseBraceToken">
 <summary>
 The "}" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax.WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseBraceToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="openBraceToken">
 The value for the OpenBraceToken property.
 </param>
 <param name="initializers">
 The value for the Initializers property.
 </param>
 <param name="closeBraceToken">
 The value for the CloseBraceToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax">
 <summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax.Keyword">
 <summary>
 The "CType", "DirectCast" or "TryCast" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax.Expression">
 <summary>
 The expression being cast.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax.CommaToken">
 <summary>
 The "," token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax.Type">
 <summary>
 The type the expression is being cast to.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax.Keyword">
 <summary>
 The "CType", "DirectCast" or "TryCast" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax.WithKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Keyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax.Expression">
 <summary>
 The expression being cast.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax.CommaToken">
 <summary>
 The "," token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax.WithCommaToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CommaToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax.Type">
 <summary>
 The type the expression is being cast to.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax.WithType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the Type property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="keyword">
 The value for the Keyword property.
 </param>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="commaToken">
 The value for the CommaToken property.
 </param>
 <param name="type">
 The value for the Type property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax.Keyword">
 <summary>
 The "CType", "DirectCast" or "TryCast" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax.WithKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Keyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax.Expression">
 <summary>
 The expression being cast.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax.CommaToken">
 <summary>
 The "," token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax.WithCommaToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CommaToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax.Type">
 <summary>
 The type the expression is being cast to.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax.WithType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the Type property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="keyword">
 The value for the Keyword property.
 </param>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="commaToken">
 The value for the CommaToken property.
 </param>
 <param name="type">
 The value for the Type property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax.Keyword">
 <summary>
 The "CType", "DirectCast" or "TryCast" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax.WithKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Keyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax.Expression">
 <summary>
 The expression being cast.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax.CommaToken">
 <summary>
 The "," token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax.WithCommaToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CommaToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax.Type">
 <summary>
 The type the expression is being cast to.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax.WithType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the Type property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="keyword">
 The value for the Keyword property.
 </param>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="commaToken">
 The value for the CommaToken property.
 </param>
 <param name="type">
 The value for the Type property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax">
 <summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax.Keyword">
 <summary>
 The keyword that was used in the cast operation.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax.WithKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Keyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax.Expression">
 <summary>
 The expression being cast.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="keyword">
 The value for the Keyword property.
 </param>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax.Left">
 <summary>
 The left operand.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax.WithLeft(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Left property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax.WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OperatorToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax.Right">
 <summary>
 The right operand.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax.WithRight(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Right property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="left">
 The value for the Left property.
 </param>
 <param name="operatorToken">
 The value for the OperatorToken property.
 </param>
 <param name="right">
 The value for the Right property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax.OperatorToken">
 <summary>
 The token that is the operator.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax.WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OperatorToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax.Operand">
 <summary>
 The expression being operated on.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax.WithOperand(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Operand property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="operatorToken">
 The value for the OperatorToken property.
 </param>
 <param name="operand">
 The value for the Operand property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax.IfKeyword">
 <summary>
 The "If" keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax.WithIfKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the IfKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax.FirstExpression">
 <summary>
 The first expression inside the parentheses.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax.WithFirstExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the FirstExpression property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax.CommaToken">
 <summary>
 The "," token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax.WithCommaToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CommaToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax.SecondExpression">
 <summary>
 The second expression inside the parentheses.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax.WithSecondExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the SecondExpression property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="ifKeyword">
 The value for the IfKeyword property.
 </param>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="firstExpression">
 The value for the FirstExpression property.
 </param>
 <param name="commaToken">
 The value for the CommaToken property.
 </param>
 <param name="secondExpression">
 The value for the SecondExpression property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.IfKeyword">
 <summary>
 The "If" keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.WithIfKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the IfKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.Condition">
 <summary>
 The first expression inside the parentheses.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.WithCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Condition property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.FirstCommaToken">
 <summary>
 The "," token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.WithFirstCommaToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the FirstCommaToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.WhenTrue">
 <summary>
 The second expression inside the parentheses.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.WithWhenTrue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the WhenTrue property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.SecondCommaToken">
 <summary>
 The "," token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.WithSecondCommaToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the SecondCommaToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.WhenFalse">
 <summary>
 The second expression inside the parentheses.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.WithWhenFalse(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the WhenFalse property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="ifKeyword">
 The value for the IfKeyword property.
 </param>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="condition">
 The value for the Condition property.
 </param>
 <param name="firstCommaToken">
 The value for the FirstCommaToken property.
 </param>
 <param name="whenTrue">
 The value for the WhenTrue property.
 </param>
 <param name="secondCommaToken">
 The value for the SecondCommaToken property.
 </param>
 <param name="whenFalse">
 The value for the WhenFalse property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax">
 <summary>
 Represents a parenthesized argument list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax.Arguments">
 <summary>
 The list of arguments. This may be empty. Omitted argument are represented by
 an OmittedArgumentSyntax node.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax.WithArguments(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax})">
 <summary>
 Returns a copy of this with the Arguments property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="arguments">
 The value for the Arguments property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax">
 <summary>
 Represents an identifier name followed by a ":=" token in a named argument.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax.Name">
 <summary>
 The name used to identify the named argument.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax.ColonEqualsToken">
 <summary>
 The ":=" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax.WithColonEqualsToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ColonEqualsToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="colonEqualsToken">
 The value for the ColonEqualsToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax">
 <summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax.Clauses">
 <summary>
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax.WithClauses(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax})">
 <summary>
 Returns a copy of this with the Clauses property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="clauses">
 The value for the Clauses property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax">
 <summary>
 This is a base class for all query operators.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax">
 <summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax.Identifier">
 <summary>
 The name of the range variable being defined.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax.WithIdentifier(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax.AsClause">
 <summary>
 Describes the type of the variable being defined.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax.WithAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the AsClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax.InKeyword">
 <summary>
 The "In" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax.WithInKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the InKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax.Expression">
 <summary>
 The expression that serves as the source of items for the range variable.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="asClause">
 The value for the AsClause property.
 </param>
 <param name="inKeyword">
 The value for the InKeyword property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax">
 <summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax.NameEquals">
 <summary>
 The optional name and type of the expression range variable. If omitted, the
 name of the expression range variable is inferred from the expression.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax.WithNameEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax)">
 <summary>
 Returns a copy of this with the NameEquals property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax.Expression">
 <summary>
 The expression used to initialize the expression variable.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="nameEquals">
 The value for the NameEquals property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax">
 <summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax.NameEquals">
 <summary>
 The optional name and type of the expression range variable. If omitted, the
 name of the expression range variable is inferred from the aggregation
 expression.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax.WithNameEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax)">
 <summary>
 Returns a copy of this with the NameEquals property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax.Aggregation">
 <summary>
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax.WithAggregation(Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationSyntax)">
 <summary>
 Returns a copy of this with the Aggregation property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="nameEquals">
 The value for the NameEquals property.
 </param>
 <param name="aggregation">
 The value for the Aggregation property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax">
 <summary>
 Represents the name and optional type of an expression range variable.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax.Identifier">
 <summary>
 The name of the variable being defined.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax.WithIdentifier(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax.AsClause">
 <summary>
 Describes the type of the variable being defined.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax.WithAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the AsClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax.EqualsToken">
 <summary>
 The "=" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax.WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EqualsToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="asClause">
 The value for the AsClause property.
 </param>
 <param name="equalsToken">
 The value for the EqualsToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationSyntax">
 <summary>
 Represents aggregation in aggregation range variable declaration of a Group By,
 Group Join or Aggregate query operator.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax">
 <summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax.FunctionName">
 <summary>
 The name of the aggregation function.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax.WithFunctionName(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the FunctionName property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax.OpenParenToken">
 <summary>
 The "(" token if present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax.Argument">
 <summary>
 The argument to the aggregation function.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax.WithArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Argument property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax.CloseParenToken">
 <summary>
 The ")" token, if present.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="functionName">
 The value for the FunctionName property.
 </param>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="argument">
 The value for the Argument property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax">
 <summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax.GroupKeyword">
 <summary>
 The "Group" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax.WithGroupKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the GroupKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="groupKeyword">
 The value for the GroupKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax">
 <summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax.FromKeyword">
 <summary>
 The "From" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax.WithFromKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the FromKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax.Variables">
 <summary>
 The list of collection variables declared by this From operator.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax.WithVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the Variables property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="fromKeyword">
 The value for the FromKeyword property.
 </param>
 <param name="variables">
 The value for the Variables property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax">
 <summary>
 Represents a "Let" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax.LetKeyword">
 <summary>
 The "Let" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax.WithLetKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LetKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax.Variables">
 <summary>
 The list of expression range variable being defined by the Let operator.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax.WithVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the Variables property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="letKeyword">
 The value for the LetKeyword property.
 </param>
 <param name="variables">
 The value for the Variables property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax">
 <summary>
 Represents an Aggregate query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax.AggregateKeyword">
 <summary>
 The "Aggregate" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax.WithAggregateKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the AggregateKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax.Variables">
 <summary>
 The list of collection range variables declared by this Aggregate operator.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax.WithVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the Variables property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax.AdditionalQueryOperators">
 <summary>
 A list of additional query operators. It may be empty.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax.WithAdditionalQueryOperators(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax})">
 <summary>
 Returns a copy of this with the AdditionalQueryOperators property changed to
 the specified value. Returns this instance if the specified value is the same
 as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax.IntoKeyword">
 <summary>
 The "Into" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax.WithIntoKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the IntoKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax.AggregationVariables">
 <summary>
 The list of new variables being defined by the aggregation.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax.WithAggregationVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the AggregationVariables property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="aggregateKeyword">
 The value for the AggregateKeyword property.
 </param>
 <param name="variables">
 The value for the Variables property.
 </param>
 <param name="additionalQueryOperators">
 The value for the AdditionalQueryOperators property.
 </param>
 <param name="intoKeyword">
 The value for the IntoKeyword property.
 </param>
 <param name="aggregationVariables">
 The value for the AggregationVariables property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax">
 <summary>
 Represents the "Distinct" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax.DistinctKeyword">
 <summary>
 The "Distinct" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax.WithDistinctKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the DistinctKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="distinctKeyword">
 The value for the DistinctKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax">
 <summary>
 Represents a "Where" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax.WhereKeyword">
 <summary>
 The "Where" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax.WithWhereKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the WhereKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax.Condition">
 <summary>
 The boolean expression used for filtering.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax.WithCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Condition property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="whereKeyword">
 The value for the WhereKeyword property.
 </param>
 <param name="condition">
 The value for the Condition property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax.SkipOrTakeKeyword">
 <summary>
 The "Skip" or "Take" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax.WithSkipOrTakeKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the SkipOrTakeKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax.WhileKeyword">
 <summary>
 The "While" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax.WithWhileKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the WhileKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax.Condition">
 <summary>
 The boolean expression used for partitioning.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax.WithCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Condition property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="skipOrTakeKeyword">
 The value for the SkipOrTakeKeyword property.
 </param>
 <param name="whileKeyword">
 The value for the WhileKeyword property.
 </param>
 <param name="condition">
 The value for the Condition property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax.SkipOrTakeKeyword">
 <summary>
 The "Skip" or "Take" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax.WithSkipOrTakeKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the SkipOrTakeKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax.Count">
 <summary>
 Represents the expression with the number of items to take or skip.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax.WithCount(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Count property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="skipOrTakeKeyword">
 The value for the SkipOrTakeKeyword property.
 </param>
 <param name="count">
 The value for the Count property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax">
 <summary>
 Represents the "Group By" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax.GroupKeyword">
 <summary>
 The "Group" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax.WithGroupKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the GroupKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax.Items">
 <summary>
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax.WithItems(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the Items property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax.ByKeyword">
 <summary>
 The "By" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax.WithByKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ByKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax.Keys">
 <summary>
 The key values being used for grouping.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax.WithKeys(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the Keys property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax.WithIntoKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the IntoKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax.AggregationVariables">
 <summary>
 The list of new variables that calculate aggregations.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax.WithAggregationVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the AggregationVariables property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="groupKeyword">
 The value for the GroupKeyword property.
 </param>
 <param name="items">
 The value for the Items property.
 </param>
 <param name="byKeyword">
 The value for the ByKeyword property.
 </param>
 <param name="keys">
 The value for the Keys property.
 </param>
 <param name="intoKeyword">
 The value for the IntoKeyword property.
 </param>
 <param name="aggregationVariables">
 The value for the AggregationVariables property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax">
 <summary>
 Represents a Join or a Group Join query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax.JoinKeyword">
 <summary>
 The "Join" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax.JoinedVariables">
 <summary>
 Defines the collection range variables being joined to.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax.AdditionalJoins">
 <summary>
 An additional Join or Group Join query operator.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax.OnKeyword">
 <summary>
 The "On" keyword.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax.JoinConditions">
 <summary>
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax">
 <summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax.Left">
 <summary>
 The left expression in the Join condition.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax.WithLeft(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Left property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax.EqualsKeyword">
 <summary>
 The "Equals" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax.WithEqualsKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EqualsKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax.Right">
 <summary>
 The right expression in the Join condition.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax.WithRight(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Right property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="left">
 The value for the Left property.
 </param>
 <param name="equalsKeyword">
 The value for the EqualsKeyword property.
 </param>
 <param name="right">
 The value for the Right property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax">
 <summary>
 Represents a Join query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax.JoinKeyword">
 <summary>
 The "Join" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax.WithJoinKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the JoinKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax.JoinedVariables">
 <summary>
 Defines the collection range variables being joined to.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax.WithJoinedVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the JoinedVariables property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax.AdditionalJoins">
 <summary>
 An additional Join or Group Join query operator.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax.WithAdditionalJoins(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax})">
 <summary>
 Returns a copy of this with the AdditionalJoins property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax.OnKeyword">
 <summary>
 The "On" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax.WithOnKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OnKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax.JoinConditions">
 <summary>
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax.WithJoinConditions(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax})">
 <summary>
 Returns a copy of this with the JoinConditions property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="joinKeyword">
 The value for the JoinKeyword property.
 </param>
 <param name="joinedVariables">
 The value for the JoinedVariables property.
 </param>
 <param name="additionalJoins">
 The value for the AdditionalJoins property.
 </param>
 <param name="onKeyword">
 The value for the OnKeyword property.
 </param>
 <param name="joinConditions">
 The value for the JoinConditions property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax">
 <summary>
 Represents the "Group Join" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.GroupKeyword">
 <summary>
 The "Group" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.WithGroupKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the GroupKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.JoinKeyword">
 <summary>
 The "Join" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.WithJoinKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the JoinKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.JoinedVariables">
 <summary>
 Defines the collection range variables being joined to.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.WithJoinedVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the JoinedVariables property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.AdditionalJoins">
 <summary>
 An additional Join or Group Join query operator.
 </summary>
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.WithAdditionalJoins(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax})">
 <summary>
 Returns a copy of this with the AdditionalJoins property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.OnKeyword">
 <summary>
 The "On" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.WithOnKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OnKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.JoinConditions">
 <summary>
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.WithJoinConditions(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax})">
 <summary>
 Returns a copy of this with the JoinConditions property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.IntoKeyword">
 <summary>
 The "Into" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.WithIntoKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the IntoKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.AggregationVariables">
 <summary>
 The list of new variables that calculate aggregations.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.WithAggregationVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the AggregationVariables property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="groupKeyword">
 The value for the GroupKeyword property.
 </param>
 <param name="joinKeyword">
 The value for the JoinKeyword property.
 </param>
 <param name="joinedVariables">
 The value for the JoinedVariables property.
 </param>
 <param name="additionalJoins">
 The value for the AdditionalJoins property.
 </param>
 <param name="onKeyword">
 The value for the OnKeyword property.
 </param>
 <param name="joinConditions">
 The value for the JoinConditions property.
 </param>
 <param name="intoKeyword">
 The value for the IntoKeyword property.
 </param>
 <param name="aggregationVariables">
 The value for the AggregationVariables property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax">
 <summary>
 Represents the "Order By" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax.OrderKeyword">
 <summary>
 The "Order" keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax.WithOrderKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OrderKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax.ByKeyword">
 <summary>
 The "By" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax.WithByKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ByKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax.Orderings">
 <summary>
 The list of OrderExpression's to sort by.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax.WithOrderings(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax})">
 <summary>
 Returns a copy of this with the Orderings property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="orderKeyword">
 The value for the OrderKeyword property.
 </param>
 <param name="byKeyword">
 The value for the ByKeyword property.
 </param>
 <param name="orderings">
 The value for the Orderings property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax.Expression">
 <summary>
 The expression to sort by.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax.AscendingOrDescendingKeyword">
 <summary>
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax.WithAscendingOrDescendingKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the AscendingOrDescendingKeyword property changed
 to the specified value. Returns this instance if the specified value is the
 same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="ascendingOrDescendingKeyword">
 The value for the AscendingOrDescendingKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax">
 <summary>
 Represents the "Select" query operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax.SelectKeyword">
 <summary>
 The "Select" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax.WithSelectKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the SelectKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax.Variables">
 <summary>
 The list of expression range variables being defined by the Select query
 operator.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax.WithVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the Variables property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="selectKeyword">
 The value for the SelectKeyword property.
 </param>
 <param name="variables">
 The value for the Variables property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax">
 <summary>
 This is the base class for all XML expression syntax nodes (XmlDocument and
 XmlElement).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax">
 <summary>
 Represents an XML Document literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax.WithDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax)">
 <summary>
 Returns a copy of this with the Declaration property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax.PrecedingMisc">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax.WithPrecedingMisc(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Returns a copy of this with the PrecedingMisc property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax.WithRoot(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Returns a copy of this with the Root property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax.FollowingMisc">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax.WithFollowingMisc(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Returns a copy of this with the FollowingMisc property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="declaration">
 The value for the Declaration property.
 </param>
 <param name="precedingMisc">
 The value for the PrecedingMisc property.
 </param>
 <param name="root">
 The value for the Root property.
 </param>
 <param name="followingMisc">
 The value for the FollowingMisc property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax">
 <summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax.WithLessThanQuestionToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LessThanQuestionToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax.WithXmlKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the XmlKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax.WithVersion(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax)">
 <summary>
 Returns a copy of this with the Version property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax.Encoding">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax.WithEncoding(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax)">
 <summary>
 Returns a copy of this with the Encoding property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax.Standalone">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax.WithStandalone(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax)">
 <summary>
 Returns a copy of this with the Standalone property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax.WithQuestionGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the QuestionGreaterThanToken property changed to
 the specified value. Returns this instance if the specified value is the same
 as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="lessThanQuestionToken">
 The value for the LessThanQuestionToken property.
 </param>
 <param name="xmlKeyword">
 The value for the XmlKeyword property.
 </param>
 <param name="version">
 The value for the Version property.
 </param>
 <param name="encoding">
 The value for the Encoding property.
 </param>
 <param name="standalone">
 The value for the Standalone property.
 </param>
 <param name="questionGreaterThanToken">
 The value for the QuestionGreaterThanToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax">
 <summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax.WithName(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax.WithEquals(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Equals property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax.WithValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax)">
 <summary>
 Returns a copy of this with the Value property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="equals">
 The value for the Equals property.
 </param>
 <param name="value">
 The value for the Value property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax">
 <summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax.WithStartTag(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax)">
 <summary>
 Returns a copy of this with the StartTag property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax.Content">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax.WithContent(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Returns a copy of this with the Content property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax.WithEndTag(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax)">
 <summary>
 Returns a copy of this with the EndTag property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="startTag">
 The value for the StartTag property.
 </param>
 <param name="content">
 The value for the Content property.
 </param>
 <param name="endTag">
 The value for the EndTag property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax">
 <summary>
 Represents Xml text.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax.TextTokens">
 <summary>
 A list of all the text tokens in the Xml text. This list always contains at
 least one token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax.WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the TextTokens property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax.Update(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="textTokens">
 The value for the TextTokens property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax">
 <summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax.WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LessThanToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax.Attributes">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax.WithAttributes(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Returns a copy of this with the Attributes property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax.WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the GreaterThanToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="lessThanToken">
 The value for the LessThanToken property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="attributes">
 The value for the Attributes property.
 </param>
 <param name="greaterThanToken">
 The value for the GreaterThanToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax">
 <summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax.WithLessThanSlashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LessThanSlashToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax.Name">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax.WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the GreaterThanToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="lessThanSlashToken">
 The value for the LessThanSlashToken property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="greaterThanToken">
 The value for the GreaterThanToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax">
 <summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax.WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LessThanToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax.Attributes">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax.WithAttributes(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Returns a copy of this with the Attributes property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax.WithSlashGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the SlashGreaterThanToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="lessThanToken">
 The value for the LessThanToken property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="attributes">
 The value for the Attributes property.
 </param>
 <param name="slashGreaterThanToken">
 The value for the SlashGreaterThanToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax">
 <summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax.WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EqualsToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax.WithValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Returns a copy of this with the Value property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="equalsToken">
 The value for the EqualsToken property.
 </param>
 <param name="value">
 The value for the Value property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.BaseXmlAttributeSyntax">
 <summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax">
 <summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax.WithStartQuoteToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the StartQuoteToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax.TextTokens">
 <remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax.WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the TextTokens property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax.WithEndQuoteToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EndQuoteToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="startQuoteToken">
 The value for the StartQuoteToken property.
 </param>
 <param name="textTokens">
 The value for the TextTokens property.
 </param>
 <param name="endQuoteToken">
 The value for the EndQuoteToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax">
 <summary>
 Represents an XML name of the form 'name' appearing in GetXmlNamespace().
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax.WithName(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="name">
 The value for the Name property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax">
 <summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax.Prefix">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax.WithPrefix(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax)">
 <summary>
 Returns a copy of this with the Prefix property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax.WithLocalName(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LocalName property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="prefix">
 The value for the Prefix property.
 </param>
 <param name="localName">
 The value for the LocalName property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax">
 <summary>
 Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
 of an XML literal or member access expression or an XML namespace import
 clause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax.WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LessThanToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax.WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the GreaterThanToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="lessThanToken">
 The value for the LessThanToken property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="greaterThanToken">
 The value for the GreaterThanToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax">
 <summary>
 Represents an XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax.WithName(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax.WithColonToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ColonToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="colonToken">
 The value for the ColonToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax">
 <summary>
 Represents an XML comment of the form &lt;!-- Comment --&gt; appearing in an
 XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax.WithLessThanExclamationMinusMinusToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LessThanExclamationMinusMinusToken property
 changed to the specified value. Returns this instance if the specified value is
 the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax.WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the TextTokens property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax.WithMinusMinusGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the MinusMinusGreaterThanToken property changed to
 the specified value. Returns this instance if the specified value is the same
 as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="lessThanExclamationMinusMinusToken">
 The value for the LessThanExclamationMinusMinusToken property.
 </param>
 <param name="textTokens">
 The value for the TextTokens property.
 </param>
 <param name="minusMinusGreaterThanToken">
 The value for the MinusMinusGreaterThanToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax">
 <summary>
 Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
 XMLProcessingValue ?&gt;'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax.WithLessThanQuestionToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LessThanQuestionToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax.WithName(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax.WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the TextTokens property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax.WithQuestionGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the QuestionGreaterThanToken property changed to
 the specified value. Returns this instance if the specified value is the same
 as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="lessThanQuestionToken">
 The value for the LessThanQuestionToken property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="textTokens">
 The value for the TextTokens property.
 </param>
 <param name="questionGreaterThanToken">
 The value for the QuestionGreaterThanToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax">
 <summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax.WithBeginCDataToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the BeginCDataToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax.WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Returns a copy of this with the TextTokens property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax.WithEndCDataToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EndCDataToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="beginCDataToken">
 The value for the BeginCDataToken property.
 </param>
 <param name="textTokens">
 The value for the TextTokens property.
 </param>
 <param name="endCDataToken">
 The value for the EndCDataToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax">
 <summary>
 Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
 obj.Name =%&gt;&lt;/name&gt;'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax.WithLessThanPercentEqualsToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LessThanPercentEqualsToken property changed to
 the specified value. Returns this instance if the specified value is the same
 as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax.WithPercentGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the PercentGreaterThanToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="lessThanPercentEqualsToken">
 The value for the LessThanPercentEqualsToken property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="percentGreaterThanToken">
 The value for the PercentGreaterThanToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax">
 <summary>
 Abstract node class that represents the textual description of a type, possibly
 include generic type arguments, qualified names, array specifiers, nullable
 specifier and the like.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax">
 <summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax.ElementType">
 <summary>
 The type of the elements of the array.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax.WithElementType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the ElementType property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax.RankSpecifiers">
 <summary>
 Represents the list of "()" or "(,,)" modifiers on the array type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax.WithRankSpecifiers(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax})">
 <summary>
 Returns a copy of this with the RankSpecifiers property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="elementType">
 The value for the ElementType property.
 </param>
 <param name="rankSpecifiers">
 The value for the RankSpecifiers property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax">
 <summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax.ElementType">
 <summary>
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax.WithElementType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the ElementType property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax.QuestionMarkToken">
 <summary>
 The "?" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax.WithQuestionMarkToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the QuestionMarkToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="elementType">
 The value for the ElementType property.
 </param>
 <param name="questionMarkToken">
 The value for the QuestionMarkToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedTypeSyntax">
 <summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedTypeSyntax.Keyword">
 <summary>
 The keyword that was used to describe the built-in type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedTypeSyntax.WithKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Keyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedTypeSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="keyword">
 The value for the Keyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax">
 <summary>
 Abstract node class that represents a name, possibly include generic arguments.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax.Identifier">
 <summary>
 The identifier in the name.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax">
 <summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax.Identifier">
 <summary>
 The identifier in the name.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="identifier">
 The value for the Identifier property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax">
 <summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax.Identifier">
 <summary>
 The identifier in the name.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax.WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Identifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax.TypeArgumentList">
 <summary>
 The generic argument list.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax.WithTypeArgumentList(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax)">
 <summary>
 Returns a copy of this with the TypeArgumentList property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="identifier">
 The value for the Identifier property.
 </param>
 <param name="typeArgumentList">
 The value for the TypeArgumentList property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax">
 <summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax.Left">
 <summary>
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax.WithLeft(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax)">
 <summary>
 Returns a copy of this with the Left property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax.DotToken">
 <summary>
 The "." token that separates the names.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax.WithDotToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the DotToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax.Right">
 <summary>
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax.WithRight(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Returns a copy of this with the Right property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="left">
 The value for the Left property.
 </param>
 <param name="dotToken">
 The value for the DotToken property.
 </param>
 <param name="right">
 The value for the Right property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax">
 <summary>
 Represents a name in the global namespace.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax.GlobalKeyword">
 <summary>
 The "Global" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax.WithGlobalKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the GlobalKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="globalKeyword">
 The value for the GlobalKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax">
 <summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax.OfKeyword">
 <summary>
 The "Of" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax.WithOfKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OfKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax.Arguments">
 <summary>
 A list of all the type arguments.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax.WithArguments(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax})">
 <summary>
 Returns a copy of this with the Arguments property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="ofKeyword">
 The value for the OfKeyword property.
 </param>
 <param name="arguments">
 The value for the Arguments property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax">
 <summary>
 Syntax node class that represents a value of 'cref' attribute inside
 documentation comment trivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax.Signature">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax.WithSignature(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax)">
 <summary>
 Returns a copy of this with the Signature property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax.AsClause">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax.WithAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the AsClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="signature">
 The value for the Signature property.
 </param>
 <param name="asClause">
 The value for the AsClause property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax">
 <summary>
 Represents a parenthesized list of argument types for a signature inside
 CrefReferenceSyntax syntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax.WithArgumentTypes(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax})">
 <summary>
 Returns a copy of this with the ArgumentTypes property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="argumentTypes">
 The value for the ArgumentTypes property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax.Modifier">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax.WithModifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Modifier property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax.Type">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax.WithType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the Type property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="modifier">
 The value for the Modifier property.
 </param>
 <param name="type">
 The value for the Type property.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedCrefOperatorReferenceSyntax.WithLeft(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax)">
 <summary>
 Returns a copy of this with the Left property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedCrefOperatorReferenceSyntax.WithDotToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the DotToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedCrefOperatorReferenceSyntax.WithRight(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefOperatorReferenceSyntax)">
 <summary>
 Returns a copy of this with the Right property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedCrefOperatorReferenceSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefOperatorReferenceSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="left">
 The value for the Left property.
 </param>
 <param name="dotToken">
 The value for the DotToken property.
 </param>
 <param name="right">
 The value for the Right property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax">
 <summary>
 Represent a Yield statement.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax.YieldKeyword">
 <summary>
 The "Yield" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax.WithYieldKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the YieldKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax.Expression">
 <summary>
 The expression whose value is being yielded.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="yieldKeyword">
 The value for the YieldKeyword property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax">
 <summary>
 Represents an Await expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax.AwaitKeyword">
 <summary>
 The "Await" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax.WithAwaitKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the AwaitKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax.Expression">
 <summary>
 The expression being awaited.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="awaitKeyword">
 The value for the AwaitKeyword property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax">
 <summary>
 A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or
 &lt;seealso&gt; documentation comment tag). For example, the M in &lt;see
 cref="M" /&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax.WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EqualsToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax.WithStartQuoteToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the StartQuoteToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax.WithReference(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax)">
 <summary>
 Returns a copy of this with the Reference property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax.WithEndQuoteToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EndQuoteToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="equalsToken">
 The value for the EqualsToken property.
 </param>
 <param name="startQuoteToken">
 The value for the StartQuoteToken property.
 </param>
 <param name="reference">
 The value for the Reference property.
 </param>
 <param name="endQuoteToken">
 The value for the EndQuoteToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameAttributeSyntax">
 <summary>
 A param or type param symbol referenced by a name attribute (e.g. in a
 &lt;param&gt; or &lt;typeparam&gt; documentation comment tag). For example, the
 M in &lt;param name="M" /&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameAttributeSyntax.WithName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameAttributeSyntax.WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EqualsToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameAttributeSyntax.WithStartQuoteToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the StartQuoteToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameAttributeSyntax.WithReference(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Returns a copy of this with the Reference property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameAttributeSyntax.WithEndQuoteToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EndQuoteToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameAttributeSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="equalsToken">
 The value for the EqualsToken property.
 </param>
 <param name="startQuoteToken">
 The value for the StartQuoteToken property.
 </param>
 <param name="reference">
 The value for the Reference property.
 </param>
 <param name="endQuoteToken">
 The value for the EndQuoteToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax">
 <summary>
 ExpressionSyntax node representing the object conditionally accessed.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax.Expression">
 <summary>
 The expression on the left-hand-side of the "?".
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax.QuestionMarkToken">
 <summary>
 "?" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax.WithQuestionMarkToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the QuestionMarkToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax.WhenNotNull">
 <summary>
 ExpressionSyntax node representing the access expression to be executed when
 the object is not null."
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax.WithWhenNotNull(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the WhenNotNull property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="questionMarkToken">
 The value for the QuestionMarkToken property.
 </param>
 <param name="whenNotNull">
 The value for the WhenNotNull property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax">
 <summary>
 Represents a NameOf expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax.NameOfKeyword">
 <summary>
 The "NameOf" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax.WithNameOfKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the NameOfKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax.OpenParenToken">
 <summary>
 The "(" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax.Argument">
 <summary>
 The argument.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax.WithArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Argument property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax.CloseParenToken">
 <summary>
 The ")" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="nameOfKeyword">
 The value for the NameOfKeyword property.
 </param>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="argument">
 The value for the Argument property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax">
 <summary>
 Represents an interpolated string expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax.DollarSignDoubleQuoteToken">
 <summary>
 The opening '$"', '$“', or '$”' token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax.WithDollarSignDoubleQuoteToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the DollarSignDoubleQuoteToken property changed to
 the specified value. Returns this instance if the specified value is the same
 as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax.Contents">
 <summary>
 The contents of the interpolated string.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax.WithContents(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax})">
 <summary>
 Returns a copy of this with the Contents property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax.DoubleQuoteToken">
 <summary>
 The closing '"', '”', or '“' token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax.WithDoubleQuoteToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the DoubleQuoteToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="dollarSignDoubleQuoteToken">
 The value for the DollarSignDoubleQuoteToken property.
 </param>
 <param name="contents">
 The value for the Contents property.
 </param>
 <param name="doubleQuoteToken">
 The value for the DoubleQuoteToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax">
 <summary>
 Represents either text content or an interpolation.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringTextSyntax">
 <summary>
 Represents literal text content in an interpolated string.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringTextSyntax.TextToken">
 <summary>
 The text token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringTextSyntax.WithTextToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the TextToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringTextSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="textToken">
 The value for the TextToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax">
 <summary>
 Represents an interpolation of an expression in an interpolated string
 expression e.g. '{expression[,alignment][:formatString]}'.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax.OpenBraceToken">
 <summary>
 The opening curly brace '{' token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax.WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenBraceToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax.Expression">
 <summary>
 The expression whose formatted value should be embedded in the resultant
 string.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax.WithExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Expression property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax.AlignmentClause">
 <summary>
 Optional. The alignment clause ',alignment' of the embedded expression.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax.WithAlignmentClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax)">
 <summary>
 Returns a copy of this with the AlignmentClause property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax.FormatClause">
 <summary>
 Optional. The format string clause ':formatString' of the embedded expression.
 </summary>
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax.WithFormatClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax)">
 <summary>
 Returns a copy of this with the FormatClause property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax.CloseBraceToken">
 <summary>
 The closing curly brace '}' token of the embedded expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax.WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseBraceToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="openBraceToken">
 The value for the OpenBraceToken property.
 </param>
 <param name="expression">
 The value for the Expression property.
 </param>
 <param name="alignmentClause">
 The value for the AlignmentClause property.
 </param>
 <param name="formatClause">
 The value for the FormatClause property.
 </param>
 <param name="closeBraceToken">
 The value for the CloseBraceToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax">
 <summary>
 Represents an alignment clause ',alignment' of an interpolated string embedded
 expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax.CommaToken">
 <summary>
 The comma ',' token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax.WithCommaToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CommaToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax.Value">
 <summary>
 An expression representing the alignment of the interpolated expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax.WithValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Value property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="commaToken">
 The value for the CommaToken property.
 </param>
 <param name="value">
 The value for the Value property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax">
 <summary>
 Represents a format string clause ':formatString' of an interpolated string
 embedded expression.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax.ColonToken">
 <summary>
 The ':' token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax.WithColonToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ColonToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax.FormatStringToken">
 <summary>
 The format string.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax.WithFormatStringToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the FormatStringToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="colonToken">
 The value for the ColonToken property.
 </param>
 <param name="formatStringToken">
 The value for the FormatStringToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax">
 <summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax.WithHashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HashToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax.ConstKeyword">
 <summary>
 The "Const" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax.WithConstKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ConstKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax.Name">
 <summary>
 The name of the pre-processing constant being defined.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax.WithName(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax.EqualsToken">
 <summary>
 The "=" token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax.WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EqualsToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax.Value">
 <summary>
 An expression representing the value of the pre-processing constant being
 defined.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax.WithValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Value property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="hashToken">
 The value for the HashToken property.
 </param>
 <param name="constKeyword">
 The value for the ConstKeyword property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
 <param name="equalsToken">
 The value for the EqualsToken property.
 </param>
 <param name="value">
 The value for the Value property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax.WithHashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HashToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax.ElseKeyword">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax.WithElseKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ElseKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax.WithIfOrElseIfKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the IfOrElseIfKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax.WithCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns a copy of this with the Condition property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax.ThenKeyword">
 <remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax.WithThenKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ThenKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax.Update(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="kind">
 The new kind.
 </param>
 <param name="hashToken">
 The value for the HashToken property.
 </param>
 <param name="elseKeyword">
 The value for the ElseKeyword property.
 </param>
 <param name="ifOrElseIfKeyword">
 The value for the IfOrElseIfKeyword property.
 </param>
 <param name="condition">
 The value for the Condition property.
 </param>
 <param name="thenKeyword">
 The value for the ThenKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseDirectiveTriviaSyntax">
 <summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseDirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseDirectiveTriviaSyntax.WithHashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HashToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseDirectiveTriviaSyntax.WithElseKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ElseKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseDirectiveTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="hashToken">
 The value for the HashToken property.
 </param>
 <param name="elseKeyword">
 The value for the ElseKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndIfDirectiveTriviaSyntax">
 <summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndIfDirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndIfDirectiveTriviaSyntax.WithHashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HashToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndIfDirectiveTriviaSyntax.WithEndKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EndKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndIfDirectiveTriviaSyntax.WithIfKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the IfKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndIfDirectiveTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="hashToken">
 The value for the HashToken property.
 </param>
 <param name="endKeyword">
 The value for the EndKeyword property.
 </param>
 <param name="ifKeyword">
 The value for the IfKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.RegionDirectiveTriviaSyntax">
 <summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RegionDirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RegionDirectiveTriviaSyntax.WithHashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HashToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RegionDirectiveTriviaSyntax.RegionKeyword">
 <summary>
 The "Region" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RegionDirectiveTriviaSyntax.WithRegionKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the RegionKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.RegionDirectiveTriviaSyntax.Name">
 <summary>
 The label of the code region being defined.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RegionDirectiveTriviaSyntax.WithName(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Name property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.RegionDirectiveTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="hashToken">
 The value for the HashToken property.
 </param>
 <param name="regionKeyword">
 The value for the RegionKeyword property.
 </param>
 <param name="name">
 The value for the Name property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndRegionDirectiveTriviaSyntax">
 <summary>
 Represents an #End Region directive appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndRegionDirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndRegionDirectiveTriviaSyntax.WithHashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HashToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndRegionDirectiveTriviaSyntax.EndKeyword">
 <summary>
 The "End" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndRegionDirectiveTriviaSyntax.WithEndKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EndKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndRegionDirectiveTriviaSyntax.RegionKeyword">
 <summary>
 The "Region" keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndRegionDirectiveTriviaSyntax.WithRegionKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the RegionKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndRegionDirectiveTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="hashToken">
 The value for the HashToken property.
 </param>
 <param name="endKeyword">
 The value for the EndKeyword property.
 </param>
 <param name="regionKeyword">
 The value for the RegionKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax">
 <summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax.WithHashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HashToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax.WithExternalSourceKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ExternalSourceKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax.WithExternalSource(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ExternalSource property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax.WithCommaToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CommaToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax.WithLineStart(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the LineStart property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="hashToken">
 The value for the HashToken property.
 </param>
 <param name="externalSourceKeyword">
 The value for the ExternalSourceKeyword property.
 </param>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="externalSource">
 The value for the ExternalSource property.
 </param>
 <param name="commaToken">
 The value for the CommaToken property.
 </param>
 <param name="lineStart">
 The value for the LineStart property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndExternalSourceDirectiveTriviaSyntax">
 <summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndExternalSourceDirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndExternalSourceDirectiveTriviaSyntax.WithHashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HashToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndExternalSourceDirectiveTriviaSyntax.WithEndKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EndKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndExternalSourceDirectiveTriviaSyntax.WithExternalSourceKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ExternalSourceKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EndExternalSourceDirectiveTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="hashToken">
 The value for the HashToken property.
 </param>
 <param name="endKeyword">
 The value for the EndKeyword property.
 </param>
 <param name="externalSourceKeyword">
 The value for the ExternalSourceKeyword property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax">
 <summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax.WithHashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HashToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax.WithExternalChecksumKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ExternalChecksumKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax.WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the OpenParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax.WithExternalSource(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ExternalSource property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax.WithFirstCommaToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the FirstCommaToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax.WithGuid(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Guid property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax.WithSecondCommaToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the SecondCommaToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax.WithChecksum(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the Checksum property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax.WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the CloseParenToken property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="hashToken">
 The value for the HashToken property.
 </param>
 <param name="externalChecksumKeyword">
 The value for the ExternalChecksumKeyword property.
 </param>
 <param name="openParenToken">
 The value for the OpenParenToken property.
 </param>
 <param name="externalSource">
 The value for the ExternalSource property.
 </param>
 <param name="firstCommaToken">
 The value for the FirstCommaToken property.
 </param>
 <param name="guid">
 The value for the Guid property.
 </param>
 <param name="secondCommaToken">
 The value for the SecondCommaToken property.
 </param>
 <param name="checksum">
 The value for the Checksum property.
 </param>
 <param name="closeParenToken">
 The value for the CloseParenToken property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnableWarningDirectiveTriviaSyntax">
 <summary>
 Represents #Enable Warning pre-processing directive appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnableWarningDirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnableWarningDirectiveTriviaSyntax.WithHashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HashToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnableWarningDirectiveTriviaSyntax.WithEnableKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the EnableKeyword property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnableWarningDirectiveTriviaSyntax.WithWarningKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the WarningKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnableWarningDirectiveTriviaSyntax.WithErrorCodes(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax})">
 <summary>
 Returns a copy of this with the ErrorCodes property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.EnableWarningDirectiveTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="hashToken">
 The value for the HashToken property.
 </param>
 <param name="enableKeyword">
 The value for the EnableKeyword property.
 </param>
 <param name="warningKeyword">
 The value for the WarningKeyword property.
 </param>
 <param name="errorCodes">
 The value for the ErrorCodes property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.DisableWarningDirectiveTriviaSyntax">
 <summary>
 Represents #Disable Warning pre-processing directive appearing in source.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.DisableWarningDirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DisableWarningDirectiveTriviaSyntax.WithHashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HashToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DisableWarningDirectiveTriviaSyntax.WithDisableKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the DisableKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DisableWarningDirectiveTriviaSyntax.WithWarningKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the WarningKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DisableWarningDirectiveTriviaSyntax.WithErrorCodes(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax})">
 <summary>
 Returns a copy of this with the ErrorCodes property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.DisableWarningDirectiveTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax})">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="hashToken">
 The value for the HashToken property.
 </param>
 <param name="disableKeyword">
 The value for the DisableKeyword property.
 </param>
 <param name="warningKeyword">
 The value for the WarningKeyword property.
 </param>
 <param name="errorCodes">
 The value for the ErrorCodes property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReferenceDirectiveTriviaSyntax">
 <summary>
 Represents an #r directive appearing in scripts.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReferenceDirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReferenceDirectiveTriviaSyntax.WithHashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HashToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReferenceDirectiveTriviaSyntax.WithReferenceKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the ReferenceKeyword property changed to the
 specified value. Returns this instance if the specified value is the same as
 the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReferenceDirectiveTriviaSyntax.WithFile(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the File property changed to the specified value.
 Returns this instance if the specified value is the same as the current value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.ReferenceDirectiveTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="hashToken">
 The value for the HashToken property.
 </param>
 <param name="referenceKeyword">
 The value for the ReferenceKeyword property.
 </param>
 <param name="file">
 The value for the File property.
 </param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.BadDirectiveTriviaSyntax">
 <summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.BadDirectiveTriviaSyntax.HashToken">
 <summary>
 The "#" token in a preprocessor directive.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.BadDirectiveTriviaSyntax.WithHashToken(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the HashToken property changed to the specified
 value. Returns this instance if the specified value is the same as the current
 value.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Syntax.BadDirectiveTriviaSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns a copy of this with the specified changes. Returns this instance if
 there are no actual changes.
 </summary>
 <param name="hashToken">
 The value for the HashToken property.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.PredefinedPreprocessorSymbols.AddPredefinedPreprocessorSymbols(Microsoft.CodeAnalysis.OutputKind,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
 <summary>
 Adds predefined preprocessor symbols VBC_VER and TARGET to given list of preprocessor symbols if not included yet.
 </summary>
 <param name="kind">The Output kind to derive the value of TARGET symbol from.</param>
 <param name="symbols">A collection of KeyValue pairs representing existing symbols.</param>
 <returns>Array of symbols that include VBC_VER and TARGET.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.PredefinedPreprocessorSymbols.AddPredefinedPreprocessorSymbols(Microsoft.CodeAnalysis.OutputKind,System.Collections.Generic.KeyValuePair{System.String,System.Object}[])">
 <summary>
 Adds predefined preprocessor symbols VBC_VER and TARGET to given list of preprocessor symbols if not included yet.
 </summary>
 <param name="kind">The Output kind to derive the value of TARGET symbol from.</param>
 <param name="symbols">An parameter array of KeyValue pairs representing existing symbols.</param>
 <returns>Array of symbols that include VBC_VER and TARGET.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.PredefinedPreprocessorSymbols.AddPredefinedPreprocessorSymbols(Microsoft.CodeAnalysis.OutputKind,System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
 <summary>
 Adds predefined preprocessor symbols VBC_VER and TARGET to given list of preprocessor symbols if not included yet.
 </summary>
 <param name="kind">The Output kind to derive the value of TARGET symbol from.</param>
 <param name="symbols">An ImmutableArray of KeyValue pairs representing existing symbols.</param>
 <returns>Array of symbols that include VBC_VER and TARGET.</returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts">
 <summary>
 Provides members for determining Syntax facts about characters and Unicode conversions.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsWhitespace(System.Char)">
 <summary>
 Determines if Unicode character represents a whitespace.
 </summary>
 <param name="c">The Unicode character.</param>
 <returns>A boolean value set to True if character represents whitespace.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsXmlWhitespace(System.Char)">
 <summary>
 Determines if Unicode character represents a XML whitespace.
 </summary>
 <param name="c">The unicode character</param>
 <returns>A boolean value set to True if character represents XML whitespace.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsNewLine(System.Char)">
 <summary>
 Determines if the Unicode character is a newline character.
 </summary>
 <param name="c">The Unicode character.</param>
 <returns>A boolean value set to True if character is a newline character.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsColon(System.Char)">
 <summary>
 Determines if the unicode character is a colon character.
 </summary>
 <param name="c">The unicode character.</param>
 <returns>A boolean value set to True if character is a colon character.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsUnderscore(System.Char)">
 <summary>
 Determines if the unicode character is a underscore character.
 </summary>
 <param name="c">The unicode character.</param>
 <returns>A boolean value set to True if character is an underscore character.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsHash(System.Char)">
 <summary>
 Determines if the unicode character is a hash character.
 </summary>
 <param name="c">The unicode character.</param>
 <returns>A boolean value set to True if character is a hash character.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsIdentifierStartCharacter(System.Char)">
 <summary>
 Determines if the Unicode character can be the starting character of a Visual Basic identifier.
 </summary>
 <param name="c">The Unicode character.</param>
 <returns>A boolean value set to True if character can be part of a valid start character in an identifier.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsIdentifierPartCharacter(System.Char)">
 <summary>
 Determines if the Unicode character can be a part of a Visual Basic identifier.
 </summary>
 <param name="c">The Unicode character.</param>
 <returns>A boolean value set to True if character can be part of a valid identifier.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsValidIdentifier(System.String)">
 <summary>
 Determines if the name is a valid identifier.
 </summary>
 <param name="name">The identifier name.</param>
 <returns>A boolean value set to True if name is valid identifier.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.MakeHalfWidthIdentifier(System.String)">
 <summary>
 Creates a half width form Unicode character string. 
 </summary>
 <param name="text">The text representing the original identifier.  This can be in full width or half width Unicode form.  </param>
 <returns>A string representing the text in a half width Unicode form.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.MatchOneOrAnother(System.Char,System.Char,System.Char)">
 <summary>
 matches one char or another.
 Typical usage is for matching lowercase and uppercase.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.MatchOneOrAnotherOrFullwidth(System.Char,System.Char,System.Char)">
 <summary>
 matches one char or another.
 it will try normal width and then fullwidth variations.
 Typical usage is for matching lowercase and uppercase.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsTrivia(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Determine if the token instance represents a syntax trivia such as comment, whitespace, etc...
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.GetKeywordKinds">
 <summary>
 Get all reserved and contextual keywords
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsPredefinedType(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Helper to check whether the token is a predefined type
 </summary>
 <returns>True if it is a predefined type</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsPredefinedTypeOrVariant(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Helper to check whether the token is a predefined type OR Variant keyword
 </summary>
 <returns>True if it is a predefined type OR Variant keyword</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsInvoked(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns true if the node is the object of an invocation expression
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsAddressOfOperand(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns true if the node is the operand of an AddressOf expression
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsInvocationOrAddressOfOperand(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Returns true if the node is the operand of an AddressOf expression, or the object
 of an invocation. This is used for special binding rules around the return value variable 
 inside Functions and Property Get accessors.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.InOrBeforeSpanOrEffectiveTrailingOfNode(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
 <summary>
 Determines if position is before or within the span of a node, or in the trailing trivia of a node 
 up to, but not including, a newline or colon trivia (which mark the end of a statement.)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.InSpanOrEffectiveTrailingOfNode(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
 <summary>
 Determines if position is within the span of a node, or in the trailing trivia of a node 
 up to, but not including, a newline or colon trivia (which mark the end of a statement.)
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.InLambdaInterior(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
 <summary>
 Determines if possibleLambda is a lambda expression and position is in the interior.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.BeginOfBlockStatementIfAny(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 If "node" is a block statement return the Begin statement  of "node", otherwise return "node".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsAttributeName(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Checks if the SyntaxNode is an attribute name. To be an attribute name, the syntax
 must be parented by an Attribute and the node itself must be equal to the Attribute.Name
 property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsNamedArgumentName(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Is the node the name of a named argument of an invocation or object creation expression, 
 but not an attribute.
 </summary>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.GetBlockName(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Return keyword or punctuation text based on SyntaxKind
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.AllowsTrailingImplicitLineContinuation(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Indicates whether a newline may validly follow the specified SyntaxToken without requiring an explicit line continuation sequence ' _' or terminating the containing statement.
 </summary>
 <param name="token">The token to test. This token must be parented by a SyntaxNode.</param>
 <returns>True if implicit line continuation is allowed after token.</returns>
 <remarks>
 <para>Refer to "Statements in Visual Basic", 2010 version, http://msdn.microsoft.com/en-us/library/865x40k4(v=vs.100).aspx 
 for examples.</para>
 <para>Implicit line continuation may be used in Visual Basic: </para>
 <list>
   <item>After a comma (,).</item>
   <item>After a less-than sign (&lt;) or before a greater-than sign (&gt;) when you specify an attribute.</item>
   <item>After an open parenthesis (() or before a closing parenthesis ()).</item>
   <item>After an open curly brace ({) or before a closing curly brace (}).</item>
   <item>After an open embedded expression (&lt;%=) or before the close of an embedded expression (%&gt;) within an XML literal.</item>
   <item>
     <para>Before and after query operators (Aggregate, Distinct, From, Group By, Group Join, Join, Let, 
 Order By, Select, Skip, Skip While, Take, Take While, Where, In, Into, On, Ascending, and Descending).</para>
     <para>You cannot break a line between the keywords of query operators that are made up of multiple keywords 
 (Order By, Group Join, Take While, and Skip While).</para>
   </item>
   <item>After the concatenation operator (&amp;).</item>
   <item>After assignment operators (=, &amp;=, :=, +=, -=, *=, /=, \=, ^=, &lt;&lt;=, &gt;&gt;=).</item>
   <item>After binary operators (+, -, /, *, Mod, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=, ^, &gt;&gt;, &lt;&lt;, And, AndAlso, Or, OrElse, Like, Xor) within an expression.</item>
   <item>After the Is and IsNot operators.</item>
   <item>After a less-than sign (&lt;) or before a greater-than sign (&gt;) when you specify an attribute.</item>
   <item>
     <para>Also after a greater-than sign (&gt;) when you specify an attribute.</para>
     <para>However, you must include a line-continuation character (_) when you specify assembly-level or module-level attributes.</para>
   </item>
   <item>
     <para>After a member qualifier character (.) and before the member name.</para>
     <para>However, you must include a line-continuation character (_) following a member qualifier character when you are using the With statement or 
 supplying values in the initialization list for a type.</para>
   </item>
   <item>
     <para>After an XML axis property qualifier (. or ...).</para> 
     <para>However, you must include a line-continuation character (_) when you specify a member qualifier when you are using the With keyword.</para>
   </item>
   <item>After the From keyword in a collection initializer.</item>
   <item>After the With keyword in a member initializer.</item>
   <item>After the In keyword in a For Each statement.</item>
 </list>
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.AllowsLeadingImplicitLineContinuation(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Indicates whether a newline may validly precede the specified SyntaxToken without requiring an explicit line continuation sequence ' _' or terminating the containing statement.
 </summary>
 <param name="token">The token to test. This token must be parented by a SyntaxNode.</param>
 <returns>True if implicit line continuation is allowed after token.</returns>
 <remarks>
 <para>Refer to "Statements in Visual Basic", 2010 version, http://msdn.microsoft.com/en-us/library/865x40k4(v=vs.100).aspx 
 for examples.</para>
 <para>Implicit line continuation may be used in Visual Basic: </para>
 <list>
   <item>After a comma (,).</item>
   <item>After a less-than sign (&lt;) or before a greater-than sign (&gt;) when you specify an attribute.</item>
   <item>After an open parenthesis (() or before a closing parenthesis ()).</item>
   <item>After an open curly brace ({) or before a closing curly brace (}).</item>
   <item>After an open embedded expression (&lt;%=) or before the close of an embedded expression (%&gt;) within an XML literal.</item>
   <item>
     <para>Before and after query operators (Aggregate, Distinct, From, Group By, Group Join, Join, Let, 
 Order By, Select, Skip, Skip While, Take, Take While, Where, In, Into, On, Ascending, and Descending).</para>
     <para>You cannot break a line between the keywords of query operators that are made up of multiple keywords 
 (Order By, Group Join, Take While, and Skip While).</para>
   </item>
   <item>After the concatenation operator (&amp;).</item>
   <item>After assignment operators (=, &amp;=, :=, +=, -=, *=, /=, \=, ^=, &lt;&lt;=, &gt;&gt;=).</item>
   <item>After binary operators (+, -, /, *, Mod, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=, ^, &gt;&gt;, &lt;&lt;, And, AndAlso, Or, OrElse, Like, Xor) within an expression.</item>
   <item>After the Is and IsNot operators.</item>
   <item>After a less-than sign (&lt;) or before a greater-than sign (&gt;) when you specify an attribute.</item>
   <item>
     <para>Also after a greater-than sign (&gt;) when you specify an attribute.</para>
     <para>However, you must include a line-continuation character (_) when you specify assembly-level or module-level attributes.</para>
   </item>
   <item>
     <para>After a member qualifier character (.) and before the member name.</para>
     <para>However, you must include a line-continuation character (_) following a member qualifier character when you are using the With statement or 
 supplying values in the initialization list for a type.</para>
   </item>
   <item>
     <para>After an XML axis property qualifier (. or ...).</para> 
     <para>However, you must include a line-continuation character (_) when you specify a member qualifier when you are using the With keyword.</para>
   </item>
   <item>After the From keyword in a collection initializer.</item>
   <item>After the With keyword in a member initializer.</item>
   <item>After the In keyword in a For Each statement.</item>
 </list>
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.EqualityComparer">
 <summary>
 A custom equality comparer for <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/>
 </summary>
 <remarks>
 PERF: The framework specializes EqualityComparer for enums, but only if the underlying type is System.Int32
 Since SyntaxKind's underlying type is System.UInt16, ObjectEqualityComparer will be chosen instead.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsReservedKeyword(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Determine if the kind represents a reserved keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsContextualKeyword(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Determine if the kind represents a contextual keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsInstanceExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Determine if the token instance represents 'Me', 'MyBase' or 'MyClass' keywords
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.GetInstanceExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Return correspondent expression syntax for 'Me', 'MyBase' and 'MyClass' 
 keywords or SyntaxKind.None for other syntax kinds
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.IsPreprocessorKeyword(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Determine if the token instance represents a preprocessor keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.GetReservedKeywordKinds">
 <summary>
 Get all reserved keywords
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.GetContextualKeywordKinds">
 <summary>
 Get contextual keywords
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.GetPunctuationKinds">
 <summary>
 Get punctuations
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.GetPreprocessorKeywordKinds">
 <summary>
 Get preprocessor keywords
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts.GetText(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Return keyword or punctuation text based on SyntaxKind
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.AccessCheckResult">
 <summary>
 The possible reasons a symbol may be inaccessible
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.AccessCheck">
 <summary>
 Contains the code for determining VB accessibility rules.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.IsSymbolAccessible(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Checks if 'symbol' is accessible from within assembly 'within'.  
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.CheckSymbolAccessibility(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Checks if 'symbol' is accessible from within assembly 'within'.  
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.IsSymbolAccessible(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Checks if 'symbol' is accessible from within type 'within', with
 an optional qualifier of type "throughTypeOpt".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.CheckSymbolAccessibility(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol})">
 <summary>
 Checks if 'symbol' is accessible from within type 'within', with
 an qualifier of type "throughTypeOpt". Sets "failedThroughTypeCheck" to true
 if it failed the "through type" check.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.CheckSymbolAccessibilityCore(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.VisualBasic.Symbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Checks if 'symbol' is accessible from within 'within', which must be a NamedTypeSymbol or 
 an AssemblySymbol.  If 'symbol' is accessed off
 of an expression then 'throughTypeOpt' is the type of that expression. This is needed to
 properly do protected access checks. Sets "failedThroughTypeCheck" to true if this protected
 check failed.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.AccessExposure">
 <summary>
 Captures information about illegal access exposure.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.AccessExposure.ExposedType">
 <summary>
 The exposed type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.AccessExposure.ExposedTo">
 <summary>
 Namespace or type that "gains" access to the type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.VerifyAccessExposure(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.AccessCheck.AccessExposure}@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Returns true if there is no illegal access exposure, false otherwise.
 </summary>
 <param name="exposedThrough">
 Type or member exposing the type.
 </param>
 <param name="exposedType">
 The exposed type.
 </param>
 <param name="illegalExposure">
 If function returns false, it requests an instance of ArrayBuilder from the pool and populates
 it with information about illegal exposure. The caller is responsible for returning the ArrayBuilder
 to the pool.
 </param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.VerifyAccessExposure(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Returns true if there is no illegal access exposure, false otherwise.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.MemberIsOrNestedInType(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)">
 <summary>
 Determine if member is the definition of the type, or 
 is contained (directly or indirectly) in the definition of the type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.VerifyAccessExposureHelper(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol@,System.Boolean@,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Returns true if there is no illegal access exposure, false otherwise.
 
 Four cases:
 1: Member is not protected, non of its enclosing scopes are protected
 2: Member is not protected, but some of its enclosing scopes are protected
 3: Member is protected, non of its enclosing scopes are protected
 4: Member is protected, some of its enclosing scopes are also protected
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.CanBeAccessedThroughInheritance(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Can type be accessed through container's inheritance?
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.FindEnclosingTypeWithGivenAccess(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.Accessibility,System.Boolean)">
 <summary>
 This function finds the inner most enclosing scope whose Access
 is lesser than or equal to the given access "StopAtAccess".
 </summary>
 <param name="member">Member - for which the enclosing scope has to be found</param>
 <param name="stopAtAccess">the enclosing scope's access has to be lesser than</param>
 <param name="isOutsideAssembly"></param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.AccessCheck.VerifyAccessExposureOfBaseClassOrInterface(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
 <summary>
 Returns false if there were errors reported due to access exposure, true otherwise.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.CompileTimeCalculations.NarrowIntegralResult(System.Int64,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean@)">
 <summary>
 Narrow a quadword result to a specific integral type, setting Overflow true
 if the result value cannot be represented in the result type.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Conversion">
 <summary>
 Summarizes whether a conversion is allowed, and if so, which kind of conversion (and in some cases, the
 associated symbol).
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.Exists">
 <summary>
 Returns True if the conversion exists, either as a widening or narrowing conversion.
 </summary>
 <remarks>
 If this returns True, exactly one of <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsNarrowing"/> or <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsWidening"/> will return True. 
 If this returns False, neither <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsNarrowing"/> or <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsWidening"/> will return True.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsNarrowing">
 <summary>
 Returns True if this conversion a narrowing conversion, and not a widening conversion. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsWidening">
 <summary>
 Returns True if this conversion is a widening conversion, and not a narrowing conversion.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsIdentity">
 <summary>
 Returns True if this conversion is an identity conversion. 
 </summary>
 <remarks>
 Note that identity conversion are also considered widening conversions.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsDefault">
 <summary>
 Returns True if this conversion is a default conversion (a conversion from the "Nothing" literal). 
 </summary>
 <remarks>Note that default conversions are considered widening conversions.</remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsNumeric">
 <summary>
 Returns True if this conversion is a widening numeric conversion or a narrowing numeric conversion, as defined in
 section 8.3.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsBoolean">
 <summary>
 Returns True if this conversion is a narrowing boolean conversion, as defined in section 8.2.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsReference">
 <summary>
 Returns True if this conversion is a widening reference conversion or narrowing reference conversion, as defined in
 section 8.4.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsAnonymousDelegate">
 <summary>
 Returns True if this conversion is a widening anonymous delegate conversion as defined in section 8.8, or a
 narrowing anonymous delegate conversion as defined in section 8.9.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsLambda">
 <summary>
 Returns True if this is a lambda conversion.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsArray">
 <summary>
 Returns True if this conversion is a widening array conversion or a narrowing array conversion, as defined in
 section 8.5.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsValueType">
 <summary>
 Returns True if this conversion a widening value type conversion or a narrowing value type conversion as defined in
 section 8.6.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsNullableValueType">
 <summary>
 Returns True if this conversion a widening nullable value type conversion or a narrowing nullable value type
 conversion as defined in section 8.6.1.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsString">
 <summary>
 Returns True if this conversion a widening string conversion or a narrowing string conversion as defined in section
 8.7.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsTypeParameter">
 <summary>
 Returns True if this conversion a widening type parameter or a narrowing type parameter conversion, as defined in
 section 8.10.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.IsUserDefined">
 <summary>
 Returns True if this conversion a widening user defined or a narrowing user defined conversion, as defined in
 section 8.11.
 </summary>
 <remarks>
 If this returns True, the involved conversion method can be obtained with the <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.Method"/>
 property.
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Conversion.MethodSymbol">
 <summary>
 Returns the method that defines the user defined conversion, if any. Otherwise returns Nothing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversion.op_Equality(Microsoft.CodeAnalysis.VisualBasic.Conversion,Microsoft.CodeAnalysis.VisualBasic.Conversion)">
 <summary>
 Returns True if two <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Conversion"/> values are equal.
 </summary>
 <param name="left">The left value.</param>
 <param name="right">The right value.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversion.op_Inequality(Microsoft.CodeAnalysis.VisualBasic.Conversion,Microsoft.CodeAnalysis.VisualBasic.Conversion)">
 <summary>
 Returns True if two <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Conversion"/> values are not equal.
 </summary>
 <param name="left">The left value.</param>
 <param name="right">The right value.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversion.Equals(System.Object)">
 <summary>
 Determines whether the specified object is equal to the current object.
 </summary>
 <param name="obj">
 The object to compare with the current object. 
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversion.Equals(Microsoft.CodeAnalysis.VisualBasic.Conversion)">
 <summary>
 Determines whether the specified object is equal to the current object.
 </summary>
 <param name="other">
 The object to compare with the current object. 
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversion.GetHashCode">
 <summary>
 Returns a hash code for the current object.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversion.ToString">
 <summary>
 Returns a string that represents the current object.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.ConversionKind.Identity">
 <summary>
 Because flags can be combined, use the method IsIdentityConversion when testing for ConversionKind.Identity
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Conversions">
 <summary>
 The purpose of this class is to answer questions about convertibility of one type to another.
 It also answers questions about conversions from an expression to a type.

 The code is organized such that each method attempts to implement exactly one section of the
 specification.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.TryFoldConstantConversion(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean@)">
 <summary>
 Attempts to fold conversion of a constant expression. 
 
 Returns Nothing if conversion cannot be folded.
 
 If conversion failed due to non-integer overflow, ConstantValue.Bad is returned. Consumer 
 is responsible for reporting appropriate diagnostics.
 
 If integer overflow occurs, integerOverflow is set to True and ConstantValue for overflowed result is returned. 
 Consumer is responsible for reporting appropriate diagnostics and potentially discarding the result.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.TryFoldConstantNumericOrBooleanConversion(Microsoft.CodeAnalysis.ConstantValue@,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean@)">
 <summary>
 Attempts to fold conversion of a constant expression.
 
 Returns Nothing if conversion cannot be folded, i.e. unexpected source and destination types. 
 Returns Bad value (Discriminator = ConstantValueTypeDiscriminator.Bad) if conversion failed due to non-integer overflow. 
 
 If integer overflow occurs, integerOverflow is set to True and the overflowed result is returned. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyConversion(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 This function classifies all intrinsic language conversions and user-defined conversions.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyPredefinedConversion(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 This function classifies all intrinsic language conversions, such as inheritance,
 implementation, array covariance, and conversions between intrinsic types.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyConversion(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 This function classifies all intrinsic language conversions and user-defined conversions.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyExpressionReclassification(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Reclassify lambdas, array literals, etc. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyUserDefinedConversion(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 This function classifies user-defined conversions between two types.
 </summary>
 <param name="source"></param>
 <param name="destination"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyUserDefinedConversion(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 This function classifies user-defined conversions.
 </summary>
 <param name="source"></param>
 <param name="destination"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyPredefinedConversion(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 This function classifies all intrinsic language conversions, such as inheritance,
 implementation, array covariance, and conversions between intrinsic types.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Conversions.ToInterfaceConversionClassifier">
 <summary>
 Helper structure to classify conversions from named types to interfaces
 in accumulating fashion.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.ToInterfaceConversionClassifier.AccumulateConversionClassificationToVariantCompatibleInterface(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,System.Int32,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Accumulates classification information about conversion to interface.
 Returns True when classification gets promoted to Identity, this method should not 
 be called after that.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.ToInterfaceConversionClassifier.ClassifyInterfaceImmediateVarianceCompatibility(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,System.Int32,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Returns when classification gets promoted to Identity.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.IsDerivedFrom(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Returns true if and only if baseType is a base class of derivedType.
 </summary>
 <param name="derivedType">
 Derived class type.
 </param>
 <param name="baseType">
 Target base class type.
 </param>
 <returns></returns>
 <remarks>
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyMethodConversionBasedOnReturnType(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Calculate MethodConversionKind based on required return type conversion.
 
 TODO: It looks like Dev10 MethodConversionKinds for return are badly named because
       they appear to give classification in the direction opposite to the data
       flow. This is very confusing. However, I am not going to rename them just yet.
       Will do this when all parts are ported and working together, otherwise it will 
       be very hard to port the rest of the feature.
 
 We are trying to classify conversion between methods
 ConvertFrom(...) As returnTypeOfConvertFromMethod -> ConvertTo(...) As returnTypeOfConvertToMethod
 
 The relaxation stub would look like:
 Stub(...) As returnTypeOfConvertToMethod
     Return ConvertFrom(...)
 End ... 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyMethodConversionBasedOnArgumentConversion(Microsoft.CodeAnalysis.VisualBasic.ConversionKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Returns the methods conversions for the given conversion kind

 We are trying to classify conversion between methods arguments
 delegateInvoke(parameterConvertFrom) -> targetMethod(parameterConvertTo)
 
 The relaxation stub would look like (stub has same signature as delegate invoke):
 Stub(parameterConvertFrom)
     return targetMethod(parameterConvertTo)
 End Method
 </summary>
 <param name="conversion">The conversion.</param>
 <param name="delegateParameterType">The delegate parameter type.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.DetermineDelegateRelaxationLevelForLambdaReturn(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Will set only bits used for delegate relaxation level.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.DetermineDelegateRelaxationLevel(Microsoft.CodeAnalysis.VisualBasic.MethodConversionKind)">
 <summary>
 Determine the relaxation level of a given conversion. This will be used by
 overload resolution in case of conflict. This is to prevent applications that compiled in VB8
 to fail in VB9 because there are more matches. And the same for flipping strict On to Off.
 
 Will set only bits used for delegate relaxation level.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.IsStubRequiredForMethodConversion(Microsoft.CodeAnalysis.VisualBasic.MethodConversionKind)">
 <summary>
 Determines whether a stub needed for the delegate creations conversion based on the given method conversions.
 </summary>
 <param name="methodConversions">The method conversions.</param><returns>
   <c>true</c> if a stub needed for conversion; otherwise, <c>false</c>.
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.IsNarrowingMethodConversion(Microsoft.CodeAnalysis.VisualBasic.MethodConversionKind,System.Boolean)">
 <summary>
 Tells whether the method conversion is considered to be narrowing or not.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Conversions.IsCLRPredefinedConversion(Microsoft.CodeAnalysis.VisualBasic.ConversionKind)">
 <summary>
 Determines whether the given conversion is CLR supported conversion or not.
 </summary>
 <param name="conversion">The conversion.</param><returns>
   <c>true</c> if the given conversion is a CLR supported conversion; otherwise, <c>false</c>.
 </returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ArrayLiteralTypeSymbol">
 <summary>
 Used by ClassifyUserDefinedConversion to pass an ArrayTypeSymbol that has a link back to the BoundArrayLiteral node.
 This allows the ClassifyConversionOperatorInOutConversions to properly classify a conversion from the inferred array 
 type to the input type of a user defined conversion.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ArrayLiteralTypeSymbol.#ctor(Microsoft.CodeAnalysis.VisualBasic.BoundArrayLiteral)">
 <summary>
 Create a new ArrayTypeSymbol.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.s_operatorNames">
 <summary>
 A map from Operator name to number of parameters and kind.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.OperatorInfo">
 <summary>
 Operator kind and expected number of parameters.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ResolveUnaryOperator(Microsoft.CodeAnalysis.VisualBasic.UnaryOperatorKind,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.SpecialType@,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.OverloadResolutionResult@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Returns UnaryOperatorKind.Error in case of error, otherwise adjusted operator kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ResolveNotLiftedIntrinsicUnaryOperator(Microsoft.CodeAnalysis.VisualBasic.UnaryOperatorKind,Microsoft.CodeAnalysis.SpecialType)">
 <summary>
 Returns result type of the operator or SpecialType.None if operator is not supported.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.TryFoldConstantUnaryOperator(Microsoft.CodeAnalysis.VisualBasic.UnaryOperatorKind,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean@)">
 <summary>
 Attempts to fold unary operator applied to a constant expression. 
 
 Returns Nothing if operator cannot be folded.
 
 If folding failed due to non-integer overflow, ConstantValue.Bad is returned. Consumer 
 is responsible for reporting appropriate diagnostics.
 
 If integer overflow occurs, integerOverflow is set to True and ConstantValue for overflowed result is returned. 
 Consumer is responsible for reporting appropriate diagnostics and potentially discarding the result.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ResolveBinaryOperator(Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Boolean,Microsoft.CodeAnalysis.SpecialType@,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.OverloadResolutionResult@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Returns UnaryOperatorKind.Error in case of error, otherwise adjusted operator kind.
 
 For comparison operators, the operator type computed here is not
 the result type of the comparison (which is typically boolean),
 but is the type to which the operands are to be converted. For
 other operators, the type computed here is both the result type
 and the common operand type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.TryFoldConstantBinaryOperator(Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean@,System.Boolean@,System.Boolean@,System.Int32@)">
 <summary>
 Attempts to fold binary operator applied to constant expressions. 
 
 Returns Nothing if operator cannot be folded.
 
 If folding failed due to non-integer overflow or divide by zero, 
 ConstantValue.Bad is returned. Consumer is responsible for reporting appropriate diagnostics.
 
 If divide by zero occurs, divideByZero is set to True.
 
 If integer overflow occurs, integerOverflow is set to True and ConstantValue for overflowed result is returned. 
 Consumer is responsible for reporting appropriate diagnostics and potentially discarding the result.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.FoldStringBinaryOperator(Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind,Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.ConstantValue,System.Int32@)">
 <summary>
 Returns ConstantValue.Bad if, and only if, compound string length is out of supported limit.
 The <paramref name="compoundStringLength"/> parameter contains value corresponding to the 
 <paramref name="left"/> node, or zero, which will trigger inference. Upon return, it will 
 be adjusted to correspond future result node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ResolveNotLiftedIntrinsicBinaryOperator(Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind,Microsoft.CodeAnalysis.SpecialType,Microsoft.CodeAnalysis.SpecialType)">
 <summary>
 Returns result type of the operator or SpecialType.None if operator is not supported.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.DetermineMostSpecificWideningConversion(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},Microsoft.CodeAnalysis.ArrayBuilder{System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.VisualBasic.ConversionKind,Microsoft.CodeAnalysis.VisualBasic.ConversionKind}},Microsoft.CodeAnalysis.BitVector@,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol@,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Returns True if resolution of user defined conversions is complete, i.e. there were operators
 applicable for the "Most Specific Widening Conversion" purposes. 
 This, however, doesn't mean that resolution is successful.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ClassifyConversionOperatorInOutConversions(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol,Microsoft.CodeAnalysis.VisualBasic.ConversionKind@,Microsoft.CodeAnalysis.VisualBasic.ConversionKind@,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Returns false if operator should be ignored.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.DetermineMostSpecificNarrowingConversion(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},Microsoft.CodeAnalysis.ArrayBuilder{System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.VisualBasic.ConversionKind,Microsoft.CodeAnalysis.VisualBasic.ConversionKind}},Microsoft.CodeAnalysis.BitVector@,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol@,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Returns True if resolution of user defined conversions is complete, i.e. there was an operator
 that converts from the most specific source type to the most specific target type. 
 This, however, doesn't mean that resolution is successful.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.MostEncompassed(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 The most encompassed type in a set of types is the one type that is encompassed
 by all other types in the set. If no single type is encompassed by all other types,
 then the set has no most encompassed type. In intuitive terms, the most encompassed
 type is the "smallest" type in the set—the one type that can be converted from each
 of the other types through a narrowing conversion.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.MostEncompassing(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 The most encompassing type in a set of types is the one type that encompasses
 all other types in the set. If no single type encompasses all other types, then
 the set has no most encompassing type. In intuitive terms, the most encompassing
 type is the "largest" type in the set—the one type to which each of the other
 types can be converted through a widening conversion.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.DetermineConversionOperatorDegreeOfGenericity(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 Returns number of types in the list of {input type, output type} that refer to a generic type parameter.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.IsWidening(Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)">
 <summary>
 A quick check whether given conversion operator is a widening operator.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CollectUserDefinedConversionOperators(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Collect user-defined conversion operators.
 Operators declared in the same type are grouped together. 
 Within a group, widening operators are followed by narrowing operators.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CollectUserDefinedOperators(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.MethodKind,System.String,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.OperatorInfo,System.String,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.OperatorInfo,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Collect user-defined operators.
 Operators declared in the same type are grouped together. 
 Within a group, name1 operators are followed by name2 operators.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CollectUserDefinedOperators(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,Microsoft.CodeAnalysis.MethodKind,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.OperatorInfo,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol})">
 <summary>
 Returns True if we should stop climbing inheritance hierarchy.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.GetTypeToLookForOperatorsIn(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Given the type of operator's argument, return corresponding type to
 look for operator in. Can return Nothing.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.Candidate">
 <summary>
 Information about a candidate from a group.
 Will have different implementation for methods, extension methods and properties.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.Candidate.IsExtensionMethod">
 <summary>
 Whether the method is used as extension method vs. called as a static method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.Candidate.IsOperator">
 <summary>
 Whether the method is used as an operator.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.Candidate.IsLifted">
 <summary>
 Whether the method is used in a lifted to nullable form.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.Candidate.PrecedenceLevel">
 <summary>
 Precedence level for an extension method.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.Candidate.FixedTypeParameters">
 <summary>
 Extension method type parameters that were fixed during currying, if any.
 If none were fixed, BitArray.Null should be returned. 
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.Candidate.ReceiverType">
 <summary>
 Receiver type for extension method. Otherwise, containing type.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.Candidate.ReceiverTypeDefinition">
 <summary>
 For extension methods, the type of the fist parameter in method's definition (i.e. before type parameters are substituted).
 Otherwise, same as the ReceiverType.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.MethodCandidate">
 <summary>
 Implementation for an ordinary method (based on usage).
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ExtensionMethodCandidate">
 <summary>
 Implementation for an extension method, i.e. it is used as an extension method.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.OperatorCandidate">
 <summary>
 Implementation for an operator
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.LiftedOperatorCandidate">
 <summary>
 Implementation for a lifted operator.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.PropertyCandidate">
 <summary>
 Implementation for a property.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult.MaxDelegateRelaxationLevel">
 <summary>
 Only bits specific to delegate relaxation level are returned.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.OverloadResolutionResult.RemainingCandidatesRequireNarrowingConversion">
 <summary>
 This might simplify error reporting. If not, consider getting rid of this property. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.MethodOrPropertyInvocationOverloadResolution(Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,System.Boolean,System.Boolean)">
 <summary>
 Perform overload resolution on the given method or property group, with the given arguments and names.
 The names can be null if no names were supplied to any arguments.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.QueryOperatorInvocationOverloadResolution(Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,System.Boolean)">
 <summary>
 Perform overload resolution on the given method group, with the given arguments.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.MethodInvocationOverloadResolution(Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundNode,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 Perform overload resolution on the given method group, with the given arguments and names.
 The names can be null if no names were supplied to any arguments.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.PropertyInvocationOverloadResolution(Microsoft.CodeAnalysis.VisualBasic.BoundPropertyGroup,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,System.Boolean)">
 <summary>
 Perform overload resolution on the given array of property symbols. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ShouldConsiderExtensionMethods(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult})">
 <summary>
 Given instance method candidates gone through applicability analysis, 
 figure out if we should consider extension methods, if any.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.EliminateLessApplicableToTheArguments(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,System.Boolean)">
 <summary>
 §11.8.1 Overloaded Method Resolution
      6.	Next, if, given any two members of the set, M and N, M is more applicable than N 
         to the argument list, eliminate N from the set. If more than one member remains 
         in the set and the remaining members are not equally applicable to the argument 
         list, a compile-time error results.
      7.	Otherwise, given any two members of the set, M and N, apply the following tie-breaking rules, in order.
 
 Returns amount of applicable candidates left.
 
 Note that less applicable candidates are going to be eliminated if and only if there are most applicable
 candidates.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ApplyTieBreakingRulesToEquallyApplicableCandidates(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Returns amount of applicable candidates left.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.FastFindMostApplicableCandidates(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.ArrayBuilder{System.Int32},Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Returns True if there are most applicable candidates.
 
 indexesOfMostApplicableCandidates will contain indexes of equally applicable candidates, which are most applicable
 by comparison to the other (non-equal) candidates. The indexes will be in ascending order.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ApplyTieBreakingRules(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult},Microsoft.CodeAnalysis.ArrayBuilder{System.Int32},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 §11.8.1 Overloaded Method Resolution
      7.	Otherwise, given any two members of the set, M and N, apply the following tie-breaking rules, in order.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ShadowBasedOnTieBreakingRules(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean@,System.Boolean@,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 §11.8.1 Overloaded Method Resolution
      7.	Otherwise, given any two members of the set, M and N, apply the following tie-breaking rules, in order.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ShadowBasedOnSubOrFunction(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean@,System.Boolean@)">
 <summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.10.	If the overload resolution is being done to resolve the target of a 
             delegate-creation expression from an AddressOf expression and M is a 
             function, while N is a subroutine, eliminate N from the set.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ShadowBasedOnDelegateRelaxation(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult},System.Int32@)">
 <summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
 7.8.	If one or more arguments are AddressOf or lambda expressions, and all of the corresponding 
         delegate types in M match exactly, but not all do in N, eliminate N from the set.
 7.9.	If one or more arguments are AddressOf or lambda expressions, and all of the corresponding 
         delegate types in M are widening conversions, but not all are in N, eliminate N from the set.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ShadowBasedOnOptionalParametersDefaultsUsed(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@)">
 <summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
 7.9.	If M did not use any optional parameter defaults in place of explicit 
         arguments, but N did, then eliminate N from the set.
 
 !!!WARNING!!! The index (7.9) is based on "VB11 spec [draft 3]" version of documentation rather 
 than Dev10 documentation.
 TODO: Update indexes of other overload method resolution rules 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ShadowBasedOnInferenceLevel(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Int32@,System.Int32@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
 7.7.  If M and N both required type inference to produce type arguments, and M did not 
       require determining the dominant type for any of its type arguments (i.e. each the 
       type arguments inferred to a single type), but N did, eliminate N from the set.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CompareApplicabilityToTheArguments(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 §11.8.1.1 Applicability
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CompareParameterTypeApplicability(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 §11.8.1.1 Applicability
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.GroupEquallyApplicableCandidates(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 This method groups equally applicable (§11.8.1.1 Applicability) candidates into buckets. 
 
 Returns an ArrayBuilder of buckets. Each bucket is represented by an ArrayBuilder(Of Integer), 
 which contains indexes of equally applicable candidates from input parameter 'candidates'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.AnalyzeNarrowingCandidates(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Boolean@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 §11.8.1 Overloaded Method Resolution
      3.	Next, eliminate all members from the set that require narrowing conversions 
         to be applicable to the argument list, except for the case where the argument 
         expression type is Object.
      4.	Next, eliminate all remaining members from the set that require narrowing coercions 
         to be applicable to the argument list. If the set is empty, the type containing the 
         method group is not an interface, and strict semantics are not being used, the 
         invocation target expression is reclassified as a late-bound method access.
         Otherwise, the normal rules apply.
 
 Returns amount of applicable candidates left.
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.EliminateNotApplicableToArguments(Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.VisualBasic.Binder,System.Int32@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.BoundExpression}@,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 §11.8.1 Overloaded Method Resolution
     2.	Next, eliminate all members from the set that are inaccessible or not applicable to the argument list.
 
 Note, similar to Dev10 compiler this process will eliminate candidates requiring narrowing conversions
 if strict semantics is used, exception are candidates that require narrowing only from numeric constants.
 
 Returns amount of applicable candidates left.
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.BuildParameterToArgumentMap(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.ArrayBuilder{System.Int32}@,Microsoft.CodeAnalysis.ArrayBuilder{System.Int32}@)">
 <summary>
 Figure out corresponding arguments for parameters §11.8.2 Applicable Methods.
 
 Note, this function mutates the candidate structure.
 
 If non-Nothing ArrayBuilders are returned through parameterToArgumentMap and paramArrayItems
 parameters, the caller is responsible fo returning them into the pool.
 
 Assumptions: 
    1) This function is never called for a candidate that should be rejected due to parameter count.
    2) Omitted arguments [ Call Foo(a, , b) ] are represented by OmittedArgumentExpression node in the arguments array.
    3) Omitted argument never has name.
    4) argumentNames contains Nothing for all positional arguments.
 
 !!! Should keep this function in sync with Binder.PassArguments, which uses data this function populates.              !!!
 !!! Should keep this function in sync with Binder.ReportOverloadResolutionFailureForASingleCandidate.                  !!!
 !!! Everything we flag as an error here, Binder.ReportOverloadResolutionFailureForASingleCandidate should detect as well. !!!
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.MatchArguments(Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.BoundExpression}@,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Match candidate's parameters to arguments §11.8.2 Applicable Methods.
 
 Note, similar to Dev10 compiler this process will eliminate candidate requiring narrowing conversions
 if strict semantics is used, exception are candidates that require narrowing only from numeric constants.
 
 Assumptions: 
    1) This function is never called for a candidate that should be rejected due to parameter count.
    2) Omitted arguments [ Call Foo(a, , b) ] are represented by OmittedArgumentExpression node in the arguments array.
    3) Omitted argument never has name.
    4) argumentNames contains Nothing for all positional arguments.
 
 !!! Should keep this function in sync with Binder.PassArguments, which uses data this function populates.              !!!
 !!! Should keep this function in sync with Binder.ReportOverloadResolutionFailureForASingleCandidate.                  !!!
 !!! Should keep this function in sync with InferenceGraph.PopulateGraph.                                               !!!
 !!! Everything we flag as an error here, Binder.ReportOverloadResolutionFailureForASingleCandidate should detect as well. !!!
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.MatchArgumentToByRefParameter(Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.VisualBasic.ConversionKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol}@,System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.VisualBasic.ConversionKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol}@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.BoundExpression}@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Should be in sync with Binder.ReportByRefConversionErrors.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.MatchArgumentToByValParameter(Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.VisualBasic.ConversionKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol}@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.BoundExpression}@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,System.Boolean)">
 <summary>
 Should be in sync with Binder.ReportByValConversionErrors.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CollectOverloadedCandidates(Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.Candidate},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundNode,System.Boolean,System.Boolean,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.VisualBasic.BoundExpression}@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Performs an initial pass through the group of candidates and does
 the following in the process.
 1) Eliminates candidates based on the number of supplied arguments and number of supplied generic type arguments.
 2) Adds additional entries for expanded ParamArray forms when applicable.
 3) Infers method's generic type arguments if needed.
 4) Substitutes method's generic type arguments.
 5) Eliminates candidates based on shadowing by signature.
    This partially takes care of §11.8.1 Overloaded Method Resolution, section 7.1.	
      If M is defined in a more derived type than N, eliminate N from the set. 
 6) Eliminates candidates with identical virtual signatures by applying various shadowing and
    tie-breaking rules from §11.8.1 Overloaded Method Resolution, section 7.0 
     • If M has fewer parameters from an expanded paramarray than N, eliminate N from the set. 
 7) Takes care of unsupported overloading within the same type for instance methods/properties.
 
 Assumptions:
 1) Shadowing by name has been already applied.
 2) group can include extension methods.
 3) group contains original definitions, i.e. method type arguments have not been substituted yet. 
    Exception are extension methods with type parameters substituted based on receiver type rather 
    than based on type arguments supplied at the call site.    
 4) group contains only accessible candidates.
 5) group doesn't contain members involved into unsupported overloading, i.e. differ by casing or custom modifiers only.
 6) group does not contain duplicates.
 7) All elements of arguments array are Not Nothing, omitted arguments are represented by OmittedArgumentExpression node.
 </summary>
 <remarks>
 This method is destructive to content of the [group] parameter.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CombineCandidates(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult},Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Int32,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Combine new candidate with the list of existing candidates, applying various shadowing and
 tie-breaking rules. New candidate may or may not be added to the result, some
 existing candidates may be removed from the result.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ShadowBasedOnExtensionVsInstanceAndPrecedence(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@)">
 <summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.5.	If M is not an extension method and N is, eliminate N from the set.
    7.6.	If M and N are extension methods and M was found before N, eliminate N from the set.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ShadowBasedOnGenericity(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.4.	If M is less generic than N, eliminate N from the set.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ShadowBasedOnDepthOfGenericity(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.BoundExpression},Microsoft.CodeAnalysis.VisualBasic.Binder)">
 <summary>
 Implements shadowing based on
 §11.8.1.3 Depth of genericity
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CompareParameterTypeGenericDepth(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean@,System.Boolean@)">
 <summary>
 
 </summary>
 <returns>False if node of candidates wins</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ShadowBasedOnExtensionMethodTargetTypeGenericity(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@)">
 <summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.3.	If M and N are extension methods and the target type of M has fewer type 
         parameters than the target type of N, eliminate N from the set. 
         !!! Note that spec talks about "fewer type parameters", but it is not really about count. 
         !!! It is about one refers to a type parameter and the other one doesn't.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ShadowBasedOnReceiverType(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.1.	If M is defined in a more derived type than N, eliminate N from the set.
         This rule also applies to the types that extension methods are defined on. 
    7.2.	If M and N are extension methods and the target type of M is a class or 
         structure and the target type of N is an interface, eliminate N from the set.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.DoesReceiverMatchInstance(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 For a receiver to match an instance, more or less, the type of that instance has to be convertible
 to the type of the receiver with the same bit-representation (i.e. identity on value-types
 and reference-convertibility on reference types).
 Actually, we don't include the reference-convertibilities that seem nonsensical, e.g. enum() to underlyingtype()
 We do include inheritance, implements and variance conversions amongst others.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.ShadowBasedOnParamArrayUsage(Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@)">
 <summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
 •	If M has fewer parameters from an expanded paramarray than N, eliminate N from the set.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.StatementSyntaxWalker">
 <summary>
 This class walks all the statements in some syntax, in order, except those statements that are contained
 inside expressions (a statement can occur inside an expression if it is inside
 a lambda.)
 
 This is used when collecting the declarations and declaration spaces of a method body.
 
 Typically the client overrides this class and overrides various Visit methods, being sure to always
 delegate back to the base.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.TypeArgumentInference">
 <summary>
 The only public entry point is the Infer method.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.TypeArgumentInference.InferenceNode.InferTypeAndPropagateHints">
 <summary>
 Returns True if the inference algorithm should be restarted.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.TypeArgumentInference.InferenceGraph.FindMatchingBaseInterface(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol@)">
 <summary>
 Returns False if the search should be cancelled.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.TypeArgumentInference.InferenceGraph.FindMatchingBaseClass(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol@)">
 <summary>
 Returns False if the search should be cancelled.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.CustomSymbolDisplayFormatter">
 <summary>
 This class associates a symbol with particular custom format for display.
 It can be passed as an argument for an error message in place where symbol display should go, 
 which allows to defer building strings and doing many other things (like loading metadata) 
 associated with that until the error message is actually requested.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay">
 <summary>
 Displays a value in the VisualBasic style.
 </summary>
 <seealso cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ObjectDisplay"/>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay.FormatPrimitive(System.Object,Microsoft.CodeAnalysis.ObjectDisplayOptions)">
 <summary>
 Returns a string representation of an object of primitive type.
 </summary>
 <param name="obj">A value to display as a string.</param>
 <param name="options">Options used to customize formatting of an Object value.</param>
 <returns>A string representation of an object of primitive type (or null if the type is not supported).</returns>
 <remarks>
 Handles <see cref="T:System.Boolean"/>, <see cref="T:System.String"/>, <see cref="T:System.Char"/>, <see cref="T:System.SByte"/>
 <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, <see cref="T:System.Int32"/>, <see cref="T:System.UInt32"/>,
 <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>, <see cref="T:System.Double"/>, <see cref="T:System.Single"/>, <see cref="T:System.Decimal"/>,
 <see cref="T:System.DateTime"/>, and <c>Nothing</c>.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay.FormatLiteral(System.String,Microsoft.CodeAnalysis.ObjectDisplayOptions)">
 <summary>
 Formats string literal.
 </summary>
 <param name="value">Literal value.</param>
 <param name="options">Options used to customize formatting of a literal value.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SymbolDisplay">
 <summary>
 Displays a symbol in the VisualBasic style.
 </summary>
 <seealso cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolDisplay"/>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SymbolDisplay.ToDisplayString(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
 <summary>
 Displays a symbol in the Visual Basic style, based on a <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayFormat"/>.
 </summary>
 <param name="symbol">The symbol to be displayed.</param>
 <param name="format">The formatting options to apply.  If Nothing is passed, <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.VisualBasicErrorMessageFormat"/> will be used.</param>
 <returns>A formatted string that can be displayed to the user.</returns>
 <remarks>
 The return value is not expected to be syntactically valid Visual Basic.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SymbolDisplay.ToMinimalDisplayString(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
 <summary>
 Displays a symbol in the Visual Basic style, based on a <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayFormat"/>.
 Based on the context, qualify type And member names as little as possible without
 introducing ambiguities.
 </summary>
 <param name="symbol">The symbol to be displayed.</param>
 <param name="semanticModel">Semantic information about the context in which the symbol is being displayed.</param>
 <param name="position">A position within the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> Or <paramref name="semanticModel"/>.</param>
 <param name="format">The formatting options to apply.  If null is passed, <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CSharpErrorMessageFormat"/> will be used.</param>
 <returns>A formatted string that can be displayed to the user.</returns>
 <remarks>
 The return value is not expected to be syntactically valid Visual Basic.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SymbolDisplay.ToDisplayParts(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
 <summary>
 Convert a symbol to an array of string parts, each of which has a kind. Useful for
 colorizing the display string.
 </summary>
 <param name="symbol">The symbol to be displayed.</param>
 <param name="format">The formatting options to apply.  If Nothing Is passed, <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.VisualBasicErrorMessageFormat"/> will be used.</param>
 <returns>A list of display parts.</returns>
 <remarks>
 Parts are not localized until they are converted to strings.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SymbolDisplay.ToMinimalDisplayParts(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
 <summary>
 Convert a symbol to an array of string parts, each of which has a kind. Useful for
 colorizing the display string.
 </summary>
 <param name="symbol">The symbol to be displayed.</param>
 <param name="semanticModel">Semantic information about the context in which the symbol is being displayed.</param>
 <param name="position">A position within the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> or <paramref name="semanticModel"/>.</param>
 <param name="format">The formatting options to apply.  If null is passed, <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CSharpErrorMessageFormat"/> will be used.</param>
 <returns>A list of display parts.</returns>
 <remarks>
 Parts are not localized until they are converted to strings.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SymbolDisplay.FormatPrimitive(System.Object,System.Boolean,System.Boolean)">
 <summary>
 Returns a string representation of an object of primitive type.
 </summary>
 <param name="obj">A value to display as a string.</param>
 <param name="quoteStrings">Whether or not to quote string literals.</param>
 <param name="useHexadecimalNumbers">Whether or not to display integral literals in hexadecimal.</param>
 <returns>A string representation of an object of primitive type (or null if the type is not supported).</returns>
 <remarks>
 Handles <see cref="T:System.Boolean"/>, <see cref="T:System.String"/>, <see cref="T:System.Char"/>, <see cref="T:System.SByte"/>
 <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, <see cref="T:System.Int32"/>, <see cref="T:System.UInt32"/>,
 <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>, <see cref="T:System.Double"/>, <see cref="T:System.Single"/>, <see cref="T:System.Decimal"/>,
 <see cref="T:System.DateTime"/>, and <c>Nothing</c>.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SymbolDisplayVisitor.TypeParameterSpecialConstraintCount(Microsoft.CodeAnalysis.ITypeParameterSymbol)">
 <summary>
 Return the number of special constraints ('Class', 'Structure',
 and 'New') associated with the type parameter.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SymbolDisplayVisitor.AddConstantValue(Microsoft.CodeAnalysis.ITypeSymbol,System.Object,System.Boolean)">
 <summary> Append a default argument (i.e. the default argument of an optional parameter). 
 Assumed to be non-null. 
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.HandledEvent">
 <summary>
 represents a single item in Handles list.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.HandledEvent.HandlesKind">
 <summary>
 Kind of Handles event container. (Me, MyBase, MyClass or a WithEvents variable)
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.HandledEvent.EventSymbol">
 <summary>
 Symbol for the event handled in current Handles item.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.HandledEventKind">
 <summary>
 Kind of a Handles item represented by a HandledEvent
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.HandledEventKind.Me">
 <summary>
 Handles Me.Event1
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.HandledEventKind.MyClass">
 <summary>
 Handles MyClass.Event1
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.HandledEventKind.MyBase">
 <summary>
 Handles MyBase.Event1
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.HandledEventKind.WithEvents">
 <summary>
 Handles SomeWithEventsVariable.Event1
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSymbolVisitor`2">
 <summary>
 Virtual dispatch based on a symbol's particular class. 
 </summary>
 <typeparam name="TResult">Result type</typeparam>
 <typeparam name="TArgument">Additional argument type</typeparam>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSymbolVisitor`2.Visit(Microsoft.CodeAnalysis.VisualBasic.Symbol,`0)">
 <summary>
 Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.TypedConstantExtensions.ToVisualBasicString(Microsoft.CodeAnalysis.TypedConstant)">
 <summary>
 Returns the System.String that represents the current TypedConstant.
 </summary>
 <returns>A System.String that represents the current TypedConstant.</returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.BeginOfBlockSyntaxReference">
 <summary>
 This is a SyntaxReference implementation that lazily finds the beginning of the block (if any) of the original syntax reference
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.NamespaceDeclarationSyntaxReference">
 <summary>
 this is a SyntaxReference implementation that lazily translates the result (SyntaxNode) of the original syntax reference
 to other one.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Type(Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax)">
 <summary>
 Returns the TypeSyntax of the given NewExpressionSyntax if specified.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Type(Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)">
 <summary>
 Returns the TypeSyntax of the given AsClauseSyntax if specified.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Attributes(Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)">
 <summary>
 Returns the AttributeBlockSyntax of the given AsClauseSyntax if specified.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.WithIdentifier(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Updates the given SimpleNameSyntax node with the given identifier token.
 This function is a wrapper that calls WithIdentifier on derived syntax nodes.
 </summary>
 <param name="simpleName"></param>
 <param name="identifier"></param>
 <returns>The given simple name updated with the given identifier.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CarriageReturnLineFeed">
 <summary>
 A trivia with kind EndOfLineTrivia containing both the carriage return And line feed characters.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LineFeed">
 <summary>
 A trivia with kind EndOfLineTrivia containing a single line feed character.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CarriageReturn">
 <summary>
 A trivia with kind EndOfLineTrivia containing a single carriage return character.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Space">
 <summary>
  A trivia with kind WhitespaceTrivia containing a single space character.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Tab">
 <summary>
 A trivia with kind WhitespaceTrivia containing a single tab character.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElasticCarriageReturnLineFeed">
 <summary>
 An elastic trivia with kind EndOfLineTrivia containing both the carriage return And line feed characters.
 Elastic trivia are used to denote trivia that was Not produced by parsing source text, And are usually Not
 preserved during formatting.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElasticLineFeed">
 <summary>
 An elastic trivia with kind EndOfLineTrivia containing a single line feed character. Elastic trivia are used
 to denote trivia that was Not produced by parsing source text, And are usually Not preserved during
 formatting.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElasticCarriageReturn">
 <summary>
 An elastic trivia with kind EndOfLineTrivia containing a single carriage return character. Elastic trivia
 are used to denote trivia that was Not produced by parsing source text, And are usually Not preserved during
 formatting.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElasticSpace">
 <summary>
 An elastic trivia with kind WhitespaceTrivia containing a single space character. Elastic trivia are used to
 denote trivia that was Not produced by parsing source text, And are usually Not preserved during formatting.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElasticTab">
 <summary>
 An elastic trivia with kind WhitespaceTrivia containing a single tab character. Elastic trivia are used to
 denote trivia that was Not produced by parsing source text, And are usually Not preserved during formatting.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElasticMarker">
 <summary>
 An elastic trivia with kind WhitespaceTrivia containing no characters. Elastic marker trivia are included
 automatically by factory methods when trivia Is Not specified. Syntax formatting will replace elastic
 markers with appropriate trivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndOfLine(System.String)">
 <summary>
 Creates a trivia with kind EndOfLineTrivia containing the specified text. 
 </summary>
 <param name="text">The text of the end of line. Any text can be specified here, however only carriage return And
 line feed characters are recognized by the parser as end of line.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElasticEndOfLine(System.String)">
 <summary>
 Creates a trivia with kind EndOfLineTrivia containing the specified text. Elastic trivia are used to
 denote trivia that was Not produced by parsing source text, And are usually Not preserved during formatting.
 </summary>
 <param name="text">The text of the end of line. Any text can be specified here, however only carriage return And
 line feed characters are recognized by the parser as end of line.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Whitespace(System.String)">
 <summary>
 Creates a trivia with kind WhitespaceTrivia containing the specified text.
 </summary>
 <param name="text">The text of the whitespace. Any text can be specified here, however only specific
 whitespace characters are recognized by the parser.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElasticWhitespace(System.String)">
 <summary>
 Creates a trivia with kind WhitespaceTrivia containing the specified text. Elastic trivia are used to
 denote trivia that was Not produced by parsing source text, And are usually Not preserved during formatting.
 </summary>
 <param name="text">The text of the whitespace. Any text can be specified here, however only specific
 whitespace characters are recognized by the parser.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GetStandaloneExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary> 
 Names on the right of qualified names and member access expressions are not stand-alone expressions.
 This method returns the appropriate parent of name syntax nodes that are on right of these constructs.
 </summary> 
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.Int32)">
 <summary> Creates a token with kind IntegerLiteralToken from a 4-byte signed integer value. </summary> 
 <param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.String,System.Int32)">
 <summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 4-byte signed integer value. </summary> 
 <param name="text">The raw text of the literal.</param> <param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Int32,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 4-byte signed integer value. </summary> 
 <param name="leading">A list of trivia immediately preceding the token.</param> 
 <param name="text">The raw text of the literal.</param> 
 <param name="value">The 4-byte signed integer value to be represented by the returned token.</param> 
 <param name="trailing">A list of trivia immediately following the token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.UInt32)">
 <summary> Creates a token with kind IntegerLiteralToken from a 4-byte unsigned integer
 value. </summary>
 <param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.String,System.UInt32)">
 <summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 4-byte unsigned integer value. </summary>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.UInt32,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 4-byte unsigned integer value. </summary>
 <param name="leading">A list of trivia immediately preceding the token.</param>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
 <param name="trailing">A list of trivia immediately following the token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.Int64)">
 <summary> Creates a token with kind IntegerLiteralToken from an 8-byte signed integer value. </summary>
 <param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.String,System.Int64)">
 <summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 8-byte signed integer value. </summary>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Int64,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 8-byte signed integer value. </summary>
 <param name="leading">A list of trivia immediately preceding the token.</param>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
 <param name="trailing">A list of trivia immediately following the token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.UInt64)">
 <summary> Creates a token with kind IntegerLiteralToken from an 8-byte unsigned integer value. </summary>
 <param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.String,System.UInt64)">
 <summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 8-byte unsigned integer value. </summary>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.UInt64,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 8-byte unsigned integer value. </summary>
 <param name="leading">A list of trivia immediately preceding the token.</param>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
 <param name="trailing">A list of trivia immediately following the token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.Single)">
 <summary> Creates a token with kind FloatingLiteralToken from a 4-byte floating point value. </summary>
 <param name="value">The 4-byte floating point value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.String,System.Single)">
 <summary> Creates a token with kind FloatingLiteralToken from the text and corresponding 4-byte floating point value. </summary>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The 4-byte floating point value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Single,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary> Creates a token with kind FloatingLiteralToken from the text and corresponding 4-byte floating point value. </summary>
 <param name="leading">A list of trivia immediately preceding the token.</param>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The 4-byte floating point value to be represented by the returned token.</param>
 <param name="trailing">A list of trivia immediately following the token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.Double)">
 <summary> Creates a token with kind FloatingLiteralToken from an 8-byte floating point value. </summary>
 <param name="value">The 8-byte floating point value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.String,System.Double)">
 <summary> Creates a token with kind FloatingLiteralToken from the text and corresponding 8-byte floating point value. </summary>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The 8-byte floating point value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Double,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary> Creates a token with kind FloatingLiteralToken from the text and corresponding 8-byte floating point value. </summary>
 <param name="leading">A list of trivia immediately preceding the token.</param>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The 8-byte floating point value to be represented by the returned token.</param>
 <param name="trailing">A list of trivia immediately following the token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.Decimal)">
 <summary> Creates a token with kind DecimalLiteralToken from a decimal value. </summary>
 <param name="value">The decimal value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.String,System.Decimal)">
 <summary> Creates a token with kind DecimalLiteralToken from the text and corresponding decimal value. </summary>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The decimal value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Decimal,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary> Creates a token with kind DecimalLiteralToken from the text and corresponding decimal value. </summary>
 <param name="leading">A list of trivia immediately preceding the token.</param>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The decimal value to be represented by the returned token.</param>
 <param name="trailing">A list of trivia immediately following the token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.String)">
 <summary> Creates a token with kind StringLiteralToken from a string value. </summary>
 <param name="value">The string value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.String,System.String)">
 <summary> Creates a token with kind StringLiteralToken from the text and corresponding string value. </summary>
 <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
 <param name="value">The string value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary> Creates a token with kind StringLiteralToken from the text and corresponding string value. </summary>
 <param name="leading">A list of trivia immediately preceding the token.</param>
 <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
 <param name="value">The string value to be represented by the returned token.</param>
 <param name="trailing">A list of trivia immediately following the token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.Char)">
 <summary> Creates a token with kind CharacterLiteralToken from a character value. </summary>
 <param name="value">The character value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(System.String,System.Char)">
 <summary> Creates a token with kind CharacterLiteralToken from the text and corresponding character value. </summary>
 <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
 <param name="value">The character value to be represented by the returned token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Char,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary> Creates a token with kind CharacterLiteralToken from the text and corresponding character value. </summary>
 <param name="leading">A list of trivia immediately preceding the token.</param>
 <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
 <param name="value">The character value to be represented by the returned token.</param>
 <param name="trailing">A list of trivia immediately following the token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DocumentationComment(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[])">
 <summary>
 Creates an xml documentation comment that abstracts xml syntax creation.
 </summary>
 <param name="content">
 A list of xml node syntax that will be the content within the xml documentation comment
 (e.g. a summary element, a returns element, exception element and so on).
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlSummaryElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[])">
 <summary>
 Creates a summary element within an xml documentation comment.
 </summary>
 <param name="content">A list of xml node syntax that will be the content within the summary element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlSummaryElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates a summary element within an xml documentation comment.
 </summary>
 <param name="content">A list of xml node syntax that will be the content within the summary element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlSeeElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax)">
 <summary>
 Creates a see element within an xml documentation comment.
 </summary>
 <param name="cref">A cref syntax node that points to the referenced item (e.g. a class, struct).</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlSeeAlsoElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax)">
 <summary>
 Creates a seealso element within an xml documentation comment.
 </summary>
 <param name="cref">A cref syntax node that points to the referenced item (e.g. a class, struct).</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlSeeAlsoElement(System.Uri,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates a seealso element within an xml documentation comment.
 </summary>
 <param name="linkAddress">The uri of the referenced item.</param>
 <param name="linkText"> A list of xml node syntax that will be used as the link text for the referenced item.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlThreadSafetyElement">
 <summary>
 Creates a threadsafty element within an xml documentation comment.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlThreadSafetyElement(System.Boolean,System.Boolean)">
 <summary>
 Creates a threadsafty element within an xml documentation comment.
 </summary>
 <param name="isStatic" static="sfd">Indicates whether static member of this type are safe for multi-threaded operations.</param>
 <param name="isInstance">Indicates whether instance members of this type are safe for multi-threaded operations.</param>
 <threadsafety static="true" instance=""/>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlNameAttribute(System.String)">
 <summary>
 Creates a syntax node for a name attribute in a xml element within a xml documentation comment.
 </summary>
 <param name="parameterName">The value of the name attribute.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlPreliminaryElement">
 <summary>
 Creates a syntax node for a priliminary element within a xml documentation comment.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlCrefAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax)">
 <summary>
 Creates a syntax node for a cref attribute within a xml documentation comment.
 </summary>
 <param name="cref">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax"/> used for the xml cref attribute syntax.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlCrefAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Creates a syntax node for a cref attribute within a xml documentation comment.
 </summary>
 <param name="cref">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax"/> used for the xml cref attribute syntax.</param>
 <param name="quoteKind">The kind of the quote for the referenced item in the cref attribute.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlRemarksElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[])">
 <summary>
 Creates a remarks element within an xml documentation comment.
 </summary>
 <param name="content">A list of xml node syntax that will be the content within the remarks element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlRemarksElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates a remarks element within an xml documentation comment.
 </summary>
 <param name="content">A list of xml node syntax that will be the content within the remarks element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlReturnsElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[])">
 <summary>
 Creates a returns element within an xml documentation comment.
 </summary>
 <param name="content">A list of xml node syntax that will be the content within the returns element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlReturnsElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates a returns element within an xml documentation comment.
 </summary>
 <param name="content">A list of xml node syntax that will be the content within the returns element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlValueElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[])">
 <summary>
 Creates the the syntax representation of an xml value element (e.g. for xml documentation comments).
 </summary>
 <param name="content">A list of xml syntax nodes that represents the content of the value element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlValueElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates the the syntax representation of an xml value element (e.g. for xml documentation comments).
 </summary>
 <param name="content">A list of xml syntax nodes that represents the content of the value element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlExceptionElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[])">
 <summary>
 Creates the syntax representation of an exception element within xml documentation comments.
 </summary>
 <param name="cref">Syntax representation of the reference to the exception type.</param>
 <param name="content">A list of syntax nodes that represents the content of the exception element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlExceptionElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates the syntax representation of an exception element within xml documentation comments.
 </summary>
 <param name="cref">Syntax representation of the reference to the exception type.</param>
 <param name="content">A list of syntax nodes that represents the content of the exception element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlPermissionElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[])">
 <summary>
 Creates the syntax representation of a permission element within xml documentation comments.
 </summary>
 <param name="cref">Syntax representation of the reference to the permission type.</param>
 <param name="content">A list of syntax nodes that represents the content of the permission element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlPermissionElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates the syntax representation of a permission element within xml documentation comments.
 </summary>
 <param name="cref">Syntax representation of the reference to the permission type.</param>
 <param name="content">A list of syntax nodes that represents the content of the permission element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlExampleElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[])">
 <summary>
 Creates the syntax representation of an example element within xml documentation comments.
 </summary>
 <param name="content">A list of syntax nodes that represents the content of the example element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlExampleElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates the syntax representation of an example element within xml documentation comments.
 </summary>
 <param name="content">A list of syntax nodes that represents the content of the example element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlParaElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[])">
 <summary>
 Creates the syntax representation of a para element within xml documentation comments.
 </summary>
 <param name="content">A list of syntax nodes that represents the content of the para element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlParaElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates the syntax representation of a para element within xml documentation comments.
 </summary>
 <param name="content">A list of syntax nodes that represents the content of the para element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlParamElement(System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[])">
 <summary>
 Creates the syntax representation of a param element within xml documentation comments (e.g. for
 documentation of method parameters).
 </summary>
 <param name="parameterName">The name of the parameter.</param>
 <param name="content">A list of syntax nodes that represents the content of the param element (e.g. 
 the description and meaning of the parameter).</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlParamElement(System.String,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates the syntax representation of a param element within xml documentation comments (e.g. for
 documentation of method parameters).
 </summary>
 <param name="parameterName">The name of the parameter.</param>
 <param name="content">A list of syntax nodes that represents the content of the param element (e.g. 
 the description and meaning of the parameter).</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlParamRefElement(System.String)">
 <summary>
 Creates the syntax representation of a paramref element within xml documentation comments (e.g. for
 referencing particular parameters of a method).
 </summary>
 <param name="parameterName">The name of the referenced parameter.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlNullKeywordElement">
 <summary>
 Creates the syntax representation of a see element within xml documentation comments,
 that points to the 'null' language keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlKeywordElement(System.String)">
 <summary>
 Creates the syntax representation of a see element within xml documentation comments,
 that points to a language keyword.
 </summary>
 <param name="keyword">The language keyword to which the see element points to.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlPlaceholderElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[])">
 <summary>
 Creates the syntax representation of a placeholder element within xml documentation comments.
 </summary>
 <param name="content">A list of syntax nodes that represents the content of the placeholder element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlPlaceholderElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates the syntax representation of a placeholder element within xml documentation comments.
 </summary>
 <param name="content">A list of syntax nodes that represents the content of the placeholder element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlEmptyElement(System.String)">
 <summary>
 Creates the syntax representation of a named empty xml element within xml documentation comments.
 </summary>
 <param name="localName">The name of the empty xml element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlElement(System.String,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates the syntax representation of a named xml element within xml documentation comments.
 </summary>
 <param name="localName">The name of the empty xml element.</param>
 <param name="content">A list of syntax nodes that represents the content of the xml element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates the syntax representation of a named xml element within xml documentation comments.
 </summary>
 <param name="name">The name of the empty xml element.</param>
 <param name="content">A list of syntax nodes that represents the content of the xml element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlMultiLineElement(System.String,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates the syntax representation of an xml element that spans multiple text lines.
 </summary>
 <param name="localName">The name of the xml element.</param>
 <param name="content">A list of syntax nodes that represents the content of the xml multi line element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlMultiLineElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Creates the syntax representation of an xml element that spans multiple text lines.
 </summary>
 <param name="name">The name of the xml element.</param>
 <param name="content">A list of syntax nodes that represents the content of the xml multi line element.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlNewLine(System.String)">
 <summary>
 Creates the syntax representation of an xml text that contains a newline token with a documentation comment 
 exterior trivia at the end (continued documentation comment).
 </summary>
 <param name="text">The raw text within the new line.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlTextNewLine(System.String)">
 <summary>
 Creates the syntax representation of an xml newline token with a documentation comment exterior trivia at 
 the end (continued documentation comment).
 </summary>
 <param name="text">The raw text within the new line.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlTextNewLine(System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary>
 Creates a token with kind XmlTextLiteralNewLineToken.
 </summary>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The xml text new line value.</param>
 <param name="leading">A list of trivia immediately preceding the token.</param>
 <param name="trailing">A list of trivia immediately following the token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlTextNewLine(System.String,System.Boolean)">
 <summary>
 Creates the syntax representation of an xml newline token for xml documentation comments.
 </summary>
 <param name="text">The raw text within the new line.</param>
 <param name="continueXmlDocumentationComment">
 If set to true, a documentation comment exterior token will be added to the trailing trivia
 of the new token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlText(System.String)">
 <summary>
 Generates the syntax representation of a xml text node (e.g. for xml documentation comments).
 </summary>
 <param name="value">The string literal used as the text of the xml text node.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlText(Microsoft.CodeAnalysis.SyntaxToken[])">
 <summary>
 Generates the syntax representation of a xml text node (e.g. for xml documentation comments).
 </summary>
 <param name="textTokens">A list of text tokens used as the text of the xml text node.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlTextLiteral(System.String)">
 <summary>
 Generates the syntax representation of an xml text literal.
 </summary>
 <param name="value">The text used within the xml text literal.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlTextLiteral(System.String,System.String)">
 <summary>
 Generates the syntax representation of an xml text literal.
 </summary>
 <param name="text">The raw text of the literal.</param>
 <param name="value">The text used within the xml text literal.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlReplaceBracketTokens(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Helper method that replaces less-than and greater-than characters with brackets. 
 </summary>
 <param name="originalToken">The original token that is to be replaced.</param>
 <param name="rewrittenToken">The new rewritten token.</param>
 <returns>Returns the new rewritten token with replaced characters.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
 <summary>
 Determines if two trees are the same, disregarding trivia differences.
 </summary>
 <param name="oldTree">The original tree.</param>
 <param name="newTree">The new tree.</param>
 <param name="topLevel"> 
 True to ignore any differences of nodes inside bodies of methods, operators, constructors and accessors, and field and auto-property initializers, 
 otherwise all nodes and tokens must be equivalent. 
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
 <summary>
 Determines if two syntax nodes are the same, disregarding trivia differences.
 </summary>
 <param name="oldNode">The old node.</param>
 <param name="newNode">The new node.</param>
 <param name="topLevel"> 
 True to ignore any differences of nodes inside bodies of methods, operators, constructors and accessors, and field and auto-property initializers, 
 otherwise all nodes and tokens must be equivalent. 
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,System.Boolean})">
 <summary>
 Determines if two syntax nodes are the same, disregarding trivia differences.
 </summary>
 <param name="oldNode">The old node.</param>
 <param name="newNode">The new node.</param>
 <param name="ignoreChildNode">
 If specified called for every child syntax node (not token) that is visited during the comparison. 
 It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Determines if two syntax tokens are the same, disregarding trivia differences.
 </summary>
 <param name="oldToken">The old token.</param>
 <param name="newToken">The new token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Determines if two lists of tokens are the same, disregarding trivia differences.
 </summary>
 <param name="oldList">The old token list.</param>
 <param name="newList">The new token list.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AreEquivalent``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.SyntaxList{``0},System.Func{Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,System.Boolean})">
 <summary>
 Determines if two lists of syntax nodes are the same, disregarding trivia differences.
 </summary>
 <param name="oldList">The old list.</param>
 <param name="newList">The new list.</param>
 <param name="ignoreChildNode">
 If specified called for every child syntax node (not token) that is visited during the comparison. 
 It returns true the child is recursively visited, otherwise the child and its subtree is disregarded.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AreEquivalent``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},System.Func{Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,System.Boolean})">
 <summary>
 Determines if two lists of syntax nodes are the same, disregarding trivia differences.
 </summary>
 <param name="oldList">The old list.</param>
 <param name="newList">The new list.</param>
 <param name="ignoreChildNode">
 If specified called for every child syntax node (not token) that is visited during the comparison. 
 It returns true the child is recursively visited, otherwise the child and its subtree is disregarded.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IsPartOfLinqQueryNotFollowedByNewLine(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Determines if a submission contains an LINQ query not followed by an empty line.

 Examples:
 1. <c>Dim x = 1</c> returns false since the statement is not a LINQ query
 2. <c>
 Dim x = FROM {1, 2, 3}

 </c> return false since the statement is followed by an empty new line.
 3. <c>Dim x = FROM {1, 2, 3}</c> returns true since the LINQ statement is not followed by an empty new line.
 </summary>
 <param name="token">Last expected token of the last statement in a submission.</param>
 <param name="statementNode">Top level statement which token is part of.</param>
 <param name="endOfFileToken">Token that marks the end of submission.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IsCompleteSubmission(Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Determines if a submission is complete.
 Returns false if the syntax is valid but incomplete.
 Returns true if the syntax is invalid or complete.
 Throws <see cref="T:System.ArgumentNullException"/> in case the tree is null.
 Throws <see cref="T:System.ArgumentException"/> in case the tree is not a submission.
 </summary>
 <param name="tree">Syntax tree.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SyntaxTree(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ParseOptions,System.String,System.Text.Encoding)">
 <summary>
 Create a new syntax tree from a syntax node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseSyntaxTree(System.String,Microsoft.CodeAnalysis.ParseOptions,System.String,System.Text.Encoding,System.Threading.CancellationToken)">
 <summary>
 Produces a syntax tree by parsing the source text.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseSyntaxTree(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.ParseOptions,System.String,System.Threading.CancellationToken)">
 <summary>
 Produces a syntax tree by parsing the source text.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseLeadingTrivia(System.String,System.Int32)">
 <summary>
Parse the input for leading trivia.
 </summary>
 <param name="text">The input string</param>
 <param name="offset">The starting offset in the string</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseTrailingTrivia(System.String,System.Int32)">
 <summary>
 Parse the input for trailing trivia.
 </summary>
 <param name="text">The input string</param>
 <param name="offset">The starting offset in the string</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseToken(System.String,System.Int32,System.Boolean)">
 <summary>
 Parse one token.
 </summary>
 <param name="text">The input string</param>
 <param name="offset">The starting offset in the string</param>
 <param name="startStatement">Scan using rules for the start of a statement</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseTokens(System.String,System.Int32,System.Int32,Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions)">
 <summary>
 Parse tokens in the input.
 </summary>
 <param name="text">The input string</param>
 <param name="offset">The starting offset in the string</param>
 <param name="initialTokenPosition">The position of the first token</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseName(System.String,System.Int32,System.Boolean)">
 <summary>
 Parse a name.
 </summary>
 <param name="text">The input string</param>
 <param name="offset">The starting offset in the string</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseTypeName(System.String,System.Int32,System.Boolean)">
 <summary>
 Parse a type name.
 </summary>
 <param name="text">The input string</param>
 <param name="offset">The starting offset in the string</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseExpression(System.String,System.Int32,System.Boolean)">
 <summary>
 Parse an expression.
 </summary>
 <param name="text">The input string</param>
 <param name="offset">The starting offset in the string</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseExecutableStatement(System.String,System.Int32,System.Boolean)">
 <summary>
 Parse an executable statement.
 </summary>
 <param name="text">The input string</param>
 <param name="offset">The starting offset in the string</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseCompilationUnit(System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions)">
 <summary>
 Parse a compilation unit (a single source file).
 </summary>
 <param name="text">The input string</param>
 <param name="offset">The starting offset in the string</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseParameterList(System.String,System.Int32,System.Boolean)">
 <summary>
 Parse a parameter list.
 </summary>
 <param name="text">The input string</param>
 <param name="offset">The starting offset in the string</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseArgumentList(System.String,System.Int32,System.Boolean)">
 <summary>
 Parse an argument list.
 </summary>
 <param name="text">The input string</param>
 <param name="offset">The starting offset in the string</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MakeSourceText(System.String,System.Int32)">
 <summary>
 Helper method for wrapping a string and offset in an SourceText.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParseDocCommentAttributeAsStandAloneEntity(System.String,System.String)">
 <summary>
 Try parse the attribute represented as a stand-alone string like [cref="A.B"] and recognize 
 'cref' and 'name' attributes like in documentation-comment mode. This method should only be
  used internally from code handling documentation comment includes.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.BracketedIdentifier(System.String)">
 <summary>
 Create a bracketed identifier.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.BracketedIdentifier(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary>
 Create a bracketed identifier.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MissingIdentifier">
 <summary>
 Create a missing identifier.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MissingIdentifier(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Create a missing contextual keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MissingKeyword(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Create a missing keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MissingPunctuation(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Create a missing punctuation mark.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MissingStringLiteral">
 <summary>
 Create a missing string literal.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MissingCharacterLiteralToken">
 <summary>
 Create a missing character literal.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MissingIntegerLiteralToken">
 <summary>
 Create a missing integer literal.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MissingToken(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Creates a copy of a token.
 <para name="err"></para>
 <para name="trivia"></para>
 </summary>
 <returns>The new token</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.List``1">
 <summary>
 Creates an empty list of syntax nodes.
 </summary>
 <typeparam name="TNode">The specific type of the element nodes.</typeparam>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SingletonList``1(``0)">
 <summary>
 Creates a singleton list of syntax nodes.
 </summary>
 <typeparam name="TNode">The specific type of the element nodes.</typeparam>
 <param name="node">The single element node.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.List``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Creates a list of syntax nodes.
 </summary>
 <typeparam name="TNode">The specific type of the element nodes.</typeparam>
 <param name="nodes">A sequence of element nodes.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TokenList">
 <summary>
 Creates an empty list of tokens.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TokenList(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Creates a singleton list of tokens.
 </summary>
 <param name="token">The single token.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TokenList(Microsoft.CodeAnalysis.SyntaxToken[])">
 <summary>
 Creates a list of tokens.
 </summary>
 <param name="tokens">An array of tokens.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TokenList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
 <summary>
 Creates a list of tokens.
 </summary>
 <param name="tokens"></param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TriviaList">
 <summary>
 Creates an empty list of trivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TriviaList(Microsoft.CodeAnalysis.SyntaxTrivia)">
 <summary>
 Creates a singleton list of trivia.
 </summary>
 <param name="trivia">A single trivia.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TriviaList(Microsoft.CodeAnalysis.SyntaxTrivia[])">
 <summary>
 Creates a list of trivia.
 </summary>
 <param name="trivias">An array of trivia.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TriviaList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
 <summary>
 Creates a list of trivia.
 </summary>
 <param name="trivias">A sequence of trivia.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SeparatedList``1">
 <summary>
 Creates an empty separated list.
 </summary>
 <typeparam name="TNode">The specific type of the element nodes.</typeparam>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SingletonSeparatedList``1(``0)">
 <summary>
 Creates a singleton separated list.
 </summary>
 <typeparam name="TNode">The specific type of the element nodes.</typeparam>
 <param name="node">A single node.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SeparatedList``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Creates a separated list of nodes from a sequence of nodes, synthesizing comma separators in between.
 </summary>
 <typeparam name="TNode">The specific type of the element nodes.</typeparam>
 <param name="nodes">A sequence of syntax nodes.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SeparatedList``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
 <summary>
 Creates a separated list of nodes from a sequence of nodes and a sequence of separator tokens.
 </summary>
 <typeparam name="TNode">The specific type of the element nodes.</typeparam>
 <param name="nodes">A sequence of syntax nodes.</param>
 <param name="separators">A sequence of token to be interleaved between the nodes. The number of tokens must
 be one less than the number of nodes.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SeparatedList``1(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
 <summary>
 Creates a separated list from a sequence of nodes or tokens.
 The sequence must start with a node and alternate between nodes and separator tokens.
 </summary>
 <typeparam name="TNode">The specific type of the element nodes.</typeparam>
 <param name="nodesAndTokens">A alternating sequence of nodes and tokens.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SeparatedList``1(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)">
 <summary>
 Creates a separated list from a <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/>.
 The <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> must start with a node and alternate between nodes and separator tokens.
 </summary>
 <typeparam name="TNode">The specific type of the element nodes.</typeparam>
 <param name="nodesAndTokens">An alternating list of nodes and tokens.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NodeOrTokenList">
 <summary>
 Creates an empty <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/>.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NodeOrTokenList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
 <summary>
 Creates a <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> from a sequence of nodes and tokens.
 </summary>
 <param name="nodesAndTokens">A sequence of nodes and tokens.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NodeOrTokenList(Microsoft.CodeAnalysis.SyntaxNodeOrToken[])">
 <summary>
 Creates a <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> from one or more nodes and tokens.
 </summary>
 <param name="nodesAndTokens">An array of nodes and tokens.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EmptyStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
 <param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EmptyStatement">
 <summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndIfStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndIfStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndUsingStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndUsingStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndWithStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndWithStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndSelectStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndSelectStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndStructureStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndStructureStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndEnumStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndEnumStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndInterfaceStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndInterfaceStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndClassStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndClassStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndModuleStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndModuleStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndNamespaceStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndNamespaceStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndSubStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndSubStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndFunctionStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndFunctionStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndGetStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndGetStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndSetStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndSetStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndPropertyStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndPropertyStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndOperatorStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndOperatorStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndEventStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndEventStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndAddHandlerStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndAddHandlerStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndRemoveHandlerStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndRemoveHandlerStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndRaiseEventStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndRaiseEventStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndWhileStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndWhileStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndTryStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndTryStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndSyncLockStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndSyncLockStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndBlockStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 EndBlockStatementSyntax. One of EndIfStatement, EndUsingStatement,
 EndWithStatement, EndSelectStatement, EndStructureStatement, EndEnumStatement,
 EndInterfaceStatement, EndClassStatement, EndModuleStatement,
 EndNamespaceStatement, EndSubStatement, EndFunctionStatement, EndGetStatement,
 EndSetStatement, EndPropertyStatement, EndOperatorStatement, EndEventStatement,
 EndAddHandlerStatement, EndRemoveHandlerStatement, EndRaiseEventStatement,
 EndWhileStatement, EndTryStatement, EndSyncLockStatement.
 </param>
 <param name="endKeyword">
 The "End" keyword
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndBlockStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 EndBlockStatementSyntax. One of EndIfStatement, EndUsingStatement,
 EndWithStatement, EndSelectStatement, EndStructureStatement, EndEnumStatement,
 EndInterfaceStatement, EndClassStatement, EndModuleStatement,
 EndNamespaceStatement, EndSubStatement, EndFunctionStatement, EndGetStatement,
 EndSetStatement, EndPropertyStatement, EndOperatorStatement, EndEventStatement,
 EndAddHandlerStatement, EndRemoveHandlerStatement, EndRaiseEventStatement,
 EndWhileStatement, EndTryStatement, EndSyncLockStatement.
 </param>
 <param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CompilationUnit(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an entire source file of VB code.
 </summary>
 <param name="options">
 Represents the list of Option statements at the beginning of a source file.
 </param>
 <param name="imports">
 Represents the list of Imports statements at the beginning of a source file.
 </param>
 <param name="attributes">
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </param>
 <param name="members">
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </param>
 <param name="endOfFileToken">
 Represents the end of the source file. This token may have trivia (whitespace,
 comments, ...) attached to it.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CompilationUnit(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents an entire source file of VB code.
 </summary>
 <param name="options">
 Represents the list of Option statements at the beginning of a source file.
 </param>
 <param name="imports">
 Represents the list of Imports statements at the beginning of a source file.
 </param>
 <param name="attributes">
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </param>
 <param name="members">
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CompilationUnit">
 <summary>
 Represents an entire source file of VB code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OptionStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
 <param name="optionKeyword">
 The "Option" keyword.
 </param>
 <param name="nameKeyword">
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </param>
 <param name="valueKeyword">
 The keyword that identifiers the value being set for the option: On, Off, Text
 or Binary.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OptionStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
 <param name="nameKeyword">
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </param>
 <param name="valueKeyword">
 The keyword that identifiers the value being set for the option: On, Off, Text
 or Binary.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OptionStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
 <param name="nameKeyword">
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ImportsStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsClauseSyntax})">
 <summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
 <param name="importsKeyword">
 The "Imports" keyword.
 </param>
 <param name="importsClauses">
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ImportsStatement(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsClauseSyntax})">
 <summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
 <param name="importsClauses">
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ImportsStatement">
 <summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleImportsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax)">
 <summary>
 Represents the clause of an Imports statement that imports all members of a
 type or namespace or aliases a type or namespace.
 </summary>
 <param name="alias">
 An optional alias for the namespace or type being imported.
 </param>
 <param name="name">
 The namespace or type being imported.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleImportsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax)">
 <summary>
 Represents the clause of an Imports statement that imports all members of a
 type or namespace or aliases a type or namespace.
 </summary>
 <param name="name">
 The namespace or type being imported.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ImportAliasClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an alias identifier followed by an "=" token in an Imports clause.
 </summary>
 <param name="identifier">
 The identifier being introduced.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ImportAliasClause(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an alias identifier followed by an "=" token in an Imports clause.
 </summary>
 <param name="identifier">
 The identifier being introduced.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ImportAliasClause(System.String)">
 <summary>
 Represents an alias identifier followed by an "=" token in an Imports clause.
 </summary>
 <param name="identifier">
 The identifier being introduced.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlNamespaceImportsClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Defines a XML namespace for XML expressions.
 </summary>
 <param name="xmlNamespace">
 Identifies the XML namespace alias and URI.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlNamespaceImportsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax)">
 <summary>
 Defines a XML namespace for XML expressions.
 </summary>
 <param name="xmlNamespace">
 Identifies the XML namespace alias and URI.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NamespaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
 <param name="namespaceStatement">
 The statement that begins the NamespaceBlock.
 </param>
 <param name="members">
 The declarations contained in the namespace statement.
 </param>
 <param name="endNamespaceStatement">
 The End Namespace statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NamespaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
 <param name="namespaceStatement">
 The statement that begins the NamespaceBlock.
 </param>
 <param name="members">
 The declarations contained in the namespace statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NamespaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax)">
 <summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
 <param name="namespaceStatement">
 The statement that begins the NamespaceBlock.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NamespaceStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax)">
 <summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
 <param name="namespaceKeyword">
 The "Namespace" keyword.
 </param>
 <param name="name">
 A (possibly dotted) name denoting the namespace being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NamespaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax)">
 <summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
 <param name="name">
 A (possibly dotted) name denoting the namespace being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ModuleBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
 <param name="moduleStatement">
 The "Module" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
 <param name="endModuleStatement">
 The "End Module" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ModuleBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
 <param name="moduleStatement">
 The "Module" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ModuleBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax)">
 <summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
 <param name="moduleStatement">
 The "Module" statement that begins the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.StructureBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
 <param name="structureStatement">
 The "Structure" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
 <param name="endStructureStatement">
 The "End Structure" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.StructureBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
 <param name="structureStatement">
 The "Structure" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.StructureBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax)">
 <summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
 <param name="structureStatement">
 The "Structure" statement that begins the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterfaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
 <param name="interfaceStatement">
 The "Interface" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
 <param name="endInterfaceStatement">
 The "End Interface" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterfaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
 <param name="interfaceStatement">
 The "Interface" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterfaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax)">
 <summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
 <param name="interfaceStatement">
 The "Interface" statement that begins the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ClassBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
 <param name="classStatement">
 The "Class" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
 <param name="endClassStatement">
 The "End Class" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ClassBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
 <param name="classStatement">
 The "Class" statement that begins the block.
 </param>
 <param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
 <param name="implements">
 A list of the Implements declarations for the type.
 </param>
 <param name="members">
 The declarations contained in the type or module.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ClassBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax)">
 <summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
 <param name="classStatement">
 The "Class" statement that begins the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EnumBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
 <param name="enumStatement">
 The statement that begins the type or module.
 </param>
 <param name="members">
 The declarations contained in the enumeration.
 </param>
 <param name="endEnumStatement">
 The End XXX statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EnumBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
 <param name="enumStatement">
 The statement that begins the type or module.
 </param>
 <param name="members">
 The declarations contained in the enumeration.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EnumBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax)">
 <summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
 <param name="enumStatement">
 The statement that begins the type or module.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InheritsStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax})">
 <summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
 <param name="inheritsKeyword">
 The "Inherits" keyword.
 </param>
 <param name="types">
 A list of the types being inherited.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InheritsStatement(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax})">
 <summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
 <param name="types">
 A list of the types being inherited.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InheritsStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax[])">
 <summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
 <param name="types">
 A list of the types being inherited.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ImplementsStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax})">
 <summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
 <param name="implementsKeyword">
 The "Implements" keyword.
 </param>
 <param name="types">
 A list of the types being implemented.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ImplementsStatement(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax})">
 <summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
 <param name="types">
 A list of the types being implemented.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ImplementsStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax[])">
 <summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
 <param name="types">
 A list of the types being implemented.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ModuleStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="moduleKeyword">
 The "Module" keyword.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ModuleStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ModuleStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
 <param name="identifier">
 The name of the type being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ModuleStatement(System.String)">
 <summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
 <param name="identifier">
 The name of the type being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.StructureStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="structureKeyword">
 The "Structure" keyword.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.StructureStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.StructureStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
 <param name="identifier">
 The name of the type being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.StructureStatement(System.String)">
 <summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
 <param name="identifier">
 The name of the type being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterfaceStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="interfaceKeyword">
 The "Interface" keyword.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterfaceStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterfaceStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
 <param name="identifier">
 The name of the type being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterfaceStatement(System.String)">
 <summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
 <param name="identifier">
 The name of the type being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ClassStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="classKeyword">
 The "Class" keyword.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ClassStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax)">
 <summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="identifier">
 The name of the type being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ClassStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
 <param name="identifier">
 The name of the type being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ClassStatement(System.String)">
 <summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
 <param name="identifier">
 The name of the type being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EnumStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)">
 <summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="enumKeyword">
 The "Enum" keyword.
 </param>
 <param name="identifier">
 The name of the enum being declared.
 </param>
 <param name="underlyingType">
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EnumStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)">
 <summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="identifier">
 The name of the enum being declared.
 </param>
 <param name="underlyingType">
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EnumStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
 <param name="identifier">
 The name of the enum being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EnumStatement(System.String)">
 <summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
 <param name="identifier">
 The name of the enum being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeParameterList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the type parameter list in a declaration.
 </summary>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="ofKeyword">
 The "Of" keyword.
 </param>
 <param name="parameters">
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax})">
 <summary>
 Represents the type parameter list in a declaration.
 </summary>
 <param name="parameters">
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeParameterList(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax[])">
 <summary>
 Represents the type parameter list in a declaration.
 </summary>
 <param name="parameters">
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeParameter(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterConstraintClauseSyntax)">
 <summary>
 Represents a type parameter on a generic type declaration.
 </summary>
 <param name="varianceKeyword">
 Represents the "In" or "Out" variance keyword on a type parameter, if present.
 If no variance modifier was present, Nothing is returned.
 </param>
 <param name="identifier">
 The name of the type parameter
 </param>
 <param name="typeParameterConstraintClause">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeParameter(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a type parameter on a generic type declaration.
 </summary>
 <param name="identifier">
 The name of the type parameter
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeParameter(System.String)">
 <summary>
 Represents a type parameter on a generic type declaration.
 </summary>
 <param name="identifier">
 The name of the type parameter
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeParameterSingleConstraintClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax)">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
 <param name="asKeyword">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
 <param name="constraint">
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeParameterSingleConstraintClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax)">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
 <param name="constraint">
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeParameterMultipleConstraintClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
 <param name="asKeyword">
 The "As" keyword.
 </param>
 <param name="openBraceToken">
 The "{" token.
 </param>
 <param name="constraints">
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </param>
 <param name="closeBraceToken">
 The "}" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeParameterMultipleConstraintClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax})">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
 <param name="constraints">
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeParameterMultipleConstraintClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax[])">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
 <param name="constraints">
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NewConstraint(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
 <param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ClassConstraint(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
 <param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.StructureConstraint(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
 <param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SpecialConstraint(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 SpecialConstraintSyntax. One of NewConstraint, ClassConstraint,
 StructureConstraint.
 </param>
 <param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeConstraint(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents a type parameter constraint that is a type.
 </summary>
 <param name="type">
 The type describing the constraint.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EnumMemberDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax)">
 <summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
 <param name="initializer">
 An optional value for the enum member.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EnumMemberDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EnumMemberDeclaration(System.String)">
 <summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 The "End Sub" or "End Function" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax)">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 The "End Sub" or "End Function" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax)">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MethodBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of MethodBlockSyntax.
 One of SubBlock, FunctionBlock.
 </param>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 The "End Sub" or "End Function" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MethodBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of MethodBlockSyntax.
 One of SubBlock, FunctionBlock.
 </param>
 <param name="subOrFunctionStatement">
 The "Sub" or "Function" statement that begins the block.
 </param>
 <param name="endSubOrFunctionStatement">
 The "End Sub" or "End Function" statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ConstructorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a constructor block declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subNewStatement">
 The "Sub New" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endSubStatement">
 The "End Sub" statement that ends the block declaration.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ConstructorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a constructor block declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subNewStatement">
 The "Sub New" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ConstructorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax)">
 <summary>
 Represents a constructor block declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement.
 </summary>
 <param name="subNewStatement">
 The "Sub New" statement that begins the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OperatorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents an Operator block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="operatorStatement">
 The "Operator" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endOperatorStatement">
 The "End Operator" statement that ends the block declaration.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OperatorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents an Operator block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="operatorStatement">
 The "Operator" statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OperatorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax)">
 <summary>
 Represents an Operator block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
 <param name="operatorStatement">
 The "Operator" statement that begins the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RemoveHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RemoveHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RemoveHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RaiseEventAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RaiseEventAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RaiseEventAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AccessorBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of AccessorBlockSyntax.
 One of GetAccessorBlock, SetAccessorBlock, AddHandlerAccessorBlock,
 RemoveHandlerAccessorBlock, RaiseEventAccessorBlock.
 </param>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AccessorBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of AccessorBlockSyntax.
 One of GetAccessorBlock, SetAccessorBlock, AddHandlerAccessorBlock,
 RemoveHandlerAccessorBlock, RaiseEventAccessorBlock.
 </param>
 <param name="accessorStatement">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
 begins the accessor block.
 </param>
 <param name="endAccessorStatement">
 The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
 RaiseEvent" statement that ends the accessor block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PropertyBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
 <param name="propertyStatement">
 The property declaration that begins the block.
 </param>
 <param name="accessors">
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </param>
 <param name="endPropertyStatement">
 The End Property statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PropertyBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax})">
 <summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
 <param name="propertyStatement">
 The property declaration that begins the block.
 </param>
 <param name="accessors">
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EventBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
 <param name="eventStatement">
 The event declaration that begins the block.
 </param>
 <param name="accessors">
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </param>
 <param name="endEventStatement">
 The End Event statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EventBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax})">
 <summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
 <param name="eventStatement">
 The event declaration that begins the block.
 </param>
 <param name="accessors">
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParameterList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the parameter list in a method declaration.
 </summary>
 <param name="openParenToken">
 The "(" token that introduces the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="parameters">
 The list of parameters. If no parameter list was present, Nothing is returned.
 </param>
 <param name="closeParenToken">
 The ")" token that concludes the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax})">
 <summary>
 Represents the parameter list in a method declaration.
 </summary>
 <param name="parameters">
 The list of parameters. If no parameter list was present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParameterList">
 <summary>
 Represents the parameter list in a method declaration.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this method declaration.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="identifier">
 The name of the method being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubStatement(System.String)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="identifier">
 The name of the method being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this method declaration.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="identifier">
 The name of the method being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionStatement(System.String)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="identifier">
 The name of the method being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MethodStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MethodStatementSyntax. One of SubStatement, FunctionStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this method declaration.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MethodStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MethodStatementSyntax. One of SubStatement, FunctionStatement.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this method declaration.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MethodStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,System.String)">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MethodStatementSyntax. One of SubStatement, FunctionStatement.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this method declaration.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubNewStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subKeyword">
 The "Sub" keyword.
 </param>
 <param name="newKeyword">
 The "New" keyword in the constructor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubNewStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubNewStatement">
 <summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DeclareSubStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="declareKeyword">
 The "Declare" keyword.
 </param>
 <param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libKeyword">
 The "Lib" keyword.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
 <param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
 <param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DeclareSubStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
 <param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DeclareSubStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DeclareSubStatement(System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DeclareFunctionStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="declareKeyword">
 The "Declare" keyword.
 </param>
 <param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libKeyword">
 The "Lib" keyword.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
 <param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
 <param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DeclareFunctionStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
 <param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DeclareFunctionStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DeclareFunctionStatement(System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DeclareStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="declareKeyword">
 The "Declare" keyword.
 </param>
 <param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libKeyword">
 The "Lib" keyword.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
 <param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
 <param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DeclareStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
 <param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DeclareStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DeclareStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax)">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the method being declared.
 </param>
 <param name="libraryName">
 The string literal with the library name.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DelegateSubStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DelegateSubStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DelegateSubStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DelegateSubStatement(System.String)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DelegateFunctionStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DelegateFunctionStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DelegateFunctionStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DelegateFunctionStatement(System.String)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DelegateStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DelegateStatementSyntax. One of DelegateSubStatement,
 DelegateFunctionStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DelegateStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DelegateStatementSyntax. One of DelegateSubStatement,
 DelegateFunctionStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
 <param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DelegateStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DelegateStatementSyntax. One of DelegateSubStatement,
 DelegateFunctionStatement.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DelegateStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,System.String)">
 <summary>
 A statement that declares a delegate type.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DelegateStatementSyntax. One of DelegateSubStatement,
 DelegateFunctionStatement.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword.
 </param>
 <param name="identifier">
 The name of the delegate being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EventStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="customKeyword">
 The optional Custom keyword for custom event declarations.
 </param>
 <param name="eventKeyword">
 The "Event" keyword that introduces this event declaration.
 </param>
 <param name="identifier">
 The name of the event being declared.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EventStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="identifier">
 The name of the event being declared.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EventStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
 <param name="identifier">
 The name of the event being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EventStatement(System.String)">
 <summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
 <param name="identifier">
 The name of the event being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OperatorStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="operatorKeyword">
 The "Operator" keyword that introduces this operator declaration.
 </param>
 <param name="operatorToken">
 The operator being defined.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OperatorStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="operatorToken">
 The operator being defined.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OperatorStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
 <param name="operatorToken">
 The operator being defined.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PropertyStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="propertyKeyword">
 The "Property" keyword that introduces this property declaration.
 </param>
 <param name="identifier">
 The name of the property being declared.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="initializer">
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PropertyStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax)">
 <summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="identifier">
 The name of the property being declared.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
 <param name="initializer">
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </param>
 <param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PropertyStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
 <param name="identifier">
 The name of the property being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PropertyStatement(System.String)">
 <summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
 <param name="identifier">
 The name of the property being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GetAccessorStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GetAccessorStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GetAccessorStatement">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SetAccessorStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SetAccessorStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SetAccessorStatement">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddHandlerAccessorStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddHandlerAccessorStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddHandlerAccessorStatement">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RemoveHandlerAccessorStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RemoveHandlerAccessorStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RemoveHandlerAccessorStatement">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RaiseEventAccessorStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RaiseEventAccessorStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RaiseEventAccessorStatement">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AccessorStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AccessorStatementSyntax. One of GetAccessorStatement, SetAccessorStatement,
 AddHandlerAccessorStatement, RemoveHandlerAccessorStatement,
 RaiseEventAccessorStatement.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AccessorStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AccessorStatementSyntax. One of GetAccessorStatement, SetAccessorStatement,
 AddHandlerAccessorStatement, RemoveHandlerAccessorStatement,
 RaiseEventAccessorStatement.
 </param>
 <param name="accessorKeyword">
 The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
 introduces this accessor declaration.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ImplementsClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax})">
 <summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
 <param name="implementsKeyword">
 The "Implements" keyword.
 </param>
 <param name="interfaceMembers">
 The list of interface members being implemented.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ImplementsClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax})">
 <summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
 <param name="interfaceMembers">
 The list of interface members being implemented.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ImplementsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax[])">
 <summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
 <param name="interfaceMembers">
 The list of interface members being implemented.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.HandlesClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax})">
 <summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
 <param name="handlesKeyword">
 The "Handles" keyword.
 </param>
 <param name="events">
 The list of event members being handled.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.HandlesClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax})">
 <summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
 <param name="events">
 The list of event members being handled.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.HandlesClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax[])">
 <summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
 <param name="events">
 The list of event members being handled.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.KeywordEventContainer(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents event container specified through special keywords "Me", "MyBase" or
 "MyClass"..
 </summary>
 <param name="keyword">
 The container of the event. This can be one of the special keywords: "Me",
 "MyBase" or "MyClass".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WithEventsEventContainer(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents event container that refers to a WithEvents member.
 </summary>
 <param name="identifier">
 The container of the event. It is a simple identifier that refers to a
 WithEvents member of the containing type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WithEventsEventContainer(System.String)">
 <summary>
 Represents event container that refers to a WithEvents member.
 </summary>
 <param name="identifier">
 The container of the event. It is a simple identifier that refers to a
 WithEvents member of the containing type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WithEventsPropertyEventContainer(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Represents event container that refers to a WithEvents member's property.
 </summary>
 <param name="withEventsContainer">
 The container of the event.
 </param>
 <param name="dotToken">
 The "." token.
 </param>
 <param name="property">
 The provider of the event. It is a property of a WithEvents member of the
 containing type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WithEventsPropertyEventContainer(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Represents event container that refers to a WithEvents member's property.
 </summary>
 <param name="withEventsContainer">
 The container of the event.
 </param>
 <param name="property">
 The provider of the event. It is a property of a WithEvents member of the
 containing type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.HandlesClauseItem(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventContainerSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
 <param name="eventContainer">
 The container of the event. This can either be a simple identifier (identifying
 a members of the containing type) or one of the special keywords "Me", "MyBase"
 or "MyClass".
 </param>
 <param name="dotToken">
 The "." token.
 </param>
 <param name="eventMember">
 The event being handled. This must be a simple identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.HandlesClauseItem(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventContainerSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
 <param name="eventContainer">
 The container of the event. This can either be a simple identifier (identifying
 a members of the containing type) or one of the special keywords "Me", "MyBase"
 or "MyClass".
 </param>
 <param name="eventMember">
 The event being handled. This must be a simple identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IncompleteMember(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="missingIdentifier">
 The missing identifier token for this incomplete member. Should only be used to
 have a location for error reporting.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IncompleteMember">
 <summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FieldDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax})">
 <summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
 <param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FieldDeclaration(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax})">
 <summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
 <param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FieldDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax[])">
 <summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
 <param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.VariableDeclarator(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax)">
 <summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
 <param name="names">
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type, and possibly includes "New",
 "With" or "From". If no As clause was present, Nothing is returned.
 </param>
 <param name="initializer">
 If present, an "= initial-value" clause describing the initial value of the
 variable or the value of the constant.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.VariableDeclarator(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax})">
 <summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
 <param name="names">
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.VariableDeclarator(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax[])">
 <summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
 <param name="names">
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleAsClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
 <param name="asKeyword">
 The "As" keyword.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="type">
 The type-name part of the As clause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleAsClause(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="type">
 The type-name part of the As clause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
 <param name="type">
 The type-name part of the As clause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AsNewClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax)">
 <summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
 <param name="asKeyword">
 The "As" keyword.
 </param>
 <param name="newExpression">
 The New expression
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AsNewClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax)">
 <summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
 <param name="newExpression">
 The New expression
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ObjectMemberInitializer(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
 <param name="withKeyword">
 The "With" keyword.
 </param>
 <param name="openBraceToken">
 The "{" token.
 </param>
 <param name="initializers">
 The comma-separated list of field initializers.
 </param>
 <param name="closeBraceToken">
 The "}" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ObjectMemberInitializer(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax})">
 <summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
 <param name="initializers">
 The comma-separated list of field initializers.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ObjectMemberInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax[])">
 <summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
 <param name="initializers">
 The comma-separated list of field initializers.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ObjectCollectionInitializer(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax)">
 <summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
 <param name="fromKeyword">
 The "From" keyword.
 </param>
 <param name="initializer">
 The initializer including the braces.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ObjectCollectionInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax)">
 <summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
 <param name="initializer">
 The initializer including the braces.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InferredFieldInitializer(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
 <param name="keyKeyword">
 The optional "Key" keyword.
 </param>
 <param name="expression">
 The value being assigned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InferredFieldInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
 <param name="expression">
 The value being assigned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NamedFieldInitializer(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
 <param name="keyKeyword">
 The optional "Key" keyword.
 </param>
 <param name="dotToken">
 The "." token.
 </param>
 <param name="name">
 The name of the field being initialized.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
 <param name="expression">
 The value being assigned to the field.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NamedFieldInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
 <param name="name">
 The name of the field being initialized.
 </param>
 <param name="expression">
 The value being assigned to the field.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EqualsValue(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an "= initializer" clause in a declaration for a variable, parameter
 or automatic property.
 </summary>
 <param name="equalsToken">
 The "=" token.
 </param>
 <param name="value">
 The expression used as the initial value.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EqualsValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an "= initializer" clause in a declaration for a variable, parameter
 or automatic property.
 </summary>
 <param name="value">
 The expression used as the initial value.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Parameter(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax)">
 <summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this parameter. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
 modify this parameter.
 </param>
 <param name="identifier">
 The name of the parameter, including any "?" or "()" modifiers.
 </param>
 <param name="asClause">
 If present, the "As type-name" clause describing the type of the parameter. If
 no As clause is present, Nothing is returned.
 </param>
 <param name="default">
 If present, an initializer with the default value of the parameter. If no
 default value is present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Parameter(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax)">
 <summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
 <param name="identifier">
 The name of the parameter, including any "?" or "()" modifiers.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ModifiedIdentifier(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax})">
 <summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
 <param name="identifier">
 The identifier that names the item being declared.
 </param>
 <param name="nullable">
 The "?" token that indicates a nullable type.
 </param>
 <param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
 <param name="arrayRankSpecifiers">
 A list of array modifiers for the type. If no array modifiers were present, an
 empty list is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ModifiedIdentifier(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
 <param name="identifier">
 The identifier that names the item being declared.
 </param>
 <param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ModifiedIdentifier(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
 <param name="identifier">
 The identifier that names the item being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ModifiedIdentifier(System.String)">
 <summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
 <param name="identifier">
 The identifier that names the item being declared.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ArrayRankSpecifier(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="commaTokens">
 The comma tokens in the array type. There is one less comma than the rank.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ArrayRankSpecifier">
 <summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AttributeList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
 <param name="lessThanToken">
 The "&lt;" token.
 </param>
 <param name="attributes">
 A comma separated list of attribute declarations in this attribute list.
 </param>
 <param name="greaterThanToken">
 The "&gt;" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AttributeList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax})">
 <summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
 <param name="attributes">
 A comma separated list of attribute declarations in this attribute list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AttributeList">
 <summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Attribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
 <param name="target">
 Optional attribute target. Assembly|Module :
 </param>
 <param name="name">
 The name of the attribute.
 </param>
 <param name="argumentList">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Attribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
 <param name="name">
 The name of the attribute.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AttributeTarget(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
 <param name="attributeModifier">
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </param>
 <param name="colonToken">
 The ":" token, if an attribute modifier is present. If no attribute modifier is
 present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AttributeTarget(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
 <param name="attributeModifier">
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AttributesStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax})">
 <summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
 <param name="attributeLists">
 The list of attribute lists.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AttributesStatement">
 <summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExpressionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represent an expression in a statement context. This may only be a invocation
 or await expression in standard code but may be any expression in VB
 Interactive code.
 </summary>
 <param name="expression">
 The expression.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PrintStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represent a "? expression" "Print" statement in VB Interactive code.
 </summary>
 <param name="questionToken">
 "?" token.
 </param>
 <param name="expression">
 The expression whose value is being output.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PrintStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represent a "? expression" "Print" statement in VB Interactive code.
 </summary>
 <param name="expression">
 The expression whose value is being output.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
 <param name="whileStatement">
 The While statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the While...End While. This might be an empty list.
 </param>
 <param name="endWhileStatement">
 The End While statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
 <param name="whileStatement">
 The While statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the While...End While. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax)">
 <summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
 <param name="whileStatement">
 The While statement that begins the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.UsingBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
 <param name="usingStatement">
 The UsingStatement that begins the Using...End Using block.
 </param>
 <param name="statements">
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </param>
 <param name="endUsingStatement">
 The End Using statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.UsingBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
 <param name="usingStatement">
 The UsingStatement that begins the Using...End Using block.
 </param>
 <param name="statements">
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.UsingBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax)">
 <summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
 <param name="usingStatement">
 The UsingStatement that begins the Using...End Using block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SyncLockBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statement.
 </summary>
 <param name="syncLockStatement">
 The SyncLock statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </param>
 <param name="endSyncLockStatement">
 The End SyncLock statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SyncLockBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statement.
 </summary>
 <param name="syncLockStatement">
 The SyncLock statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SyncLockBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax)">
 <summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statement.
 </summary>
 <param name="syncLockStatement">
 The SyncLock statement that begins the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WithBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
 <param name="withStatement">
 The WithStatement that begins the With...End With block.
 </param>
 <param name="statements">
 The statements contained in the With...End With block. This might be an empty
 list.
 </param>
 <param name="endWithStatement">
 The End With statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WithBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
 <param name="withStatement">
 The WithStatement that begins the With...End With block.
 </param>
 <param name="statements">
 The statements contained in the With...End With block. This might be an empty
 list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WithBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax)">
 <summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
 <param name="withStatement">
 The WithStatement that begins the With...End With block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax})">
 <summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
 <param name="modifiers">
 The modifier token (Static, Dim or Const) that introduces this local variable
 declaration.
 </param>
 <param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LabelStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a label statement.
 </summary>
 <param name="labelToken">
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </param>
 <param name="colonToken">
 The ":" token of the label statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LabelStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a label statement.
 </summary>
 <param name="labelToken">
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LabelStatement(System.String)">
 <summary>
 Represents a label statement.
 </summary>
 <param name="labelToken">
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GoToStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents a "GoTo" statement.
 </summary>
 <param name="goToKeyword">
 The "GoTo" keyword.
 </param>
 <param name="label">
 The name of the label. If the label is a line number, wraps an IntegerLiteral
 that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GoToStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents a "GoTo" statement.
 </summary>
 <param name="label">
 The name of the label. If the label is a line number, wraps an IntegerLiteral
 that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IdentifierLabel(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IdentifierLabel(System.String)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NumericLabel(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NumericLabel">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NextLabel(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NextLabel">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Label(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LabelSyntax. One of
 IdentifierLabel, NumericLabel, NextLabel.
 </param>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Label(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,System.String)">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LabelSyntax. One of
 IdentifierLabel, NumericLabel, NextLabel.
 </param>
 <param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.StopStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
 <param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
 <param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.StopOrEndStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 StopOrEndStatementSyntax. One of StopStatement, EndStatement.
 </param>
 <param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitDoStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitDoStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitForStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitForStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitSubStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitSubStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitFunctionStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitFunctionStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitOperatorStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitOperatorStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitPropertyStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitPropertyStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitTryStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitTryStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitSelectStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitSelectStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitWhileStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitWhileStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of ExitStatementSyntax.
 One of ExitDoStatement, ExitForStatement, ExitSubStatement,
 ExitFunctionStatement, ExitOperatorStatement, ExitPropertyStatement,
 ExitTryStatement, ExitSelectStatement, ExitWhileStatement.
 </param>
 <param name="exitKeyword">
 The "Exit" keyword.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExitStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of ExitStatementSyntax.
 One of ExitDoStatement, ExitForStatement, ExitSubStatement,
 ExitFunctionStatement, ExitOperatorStatement, ExitPropertyStatement,
 ExitTryStatement, ExitSelectStatement, ExitWhileStatement.
 </param>
 <param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ContinueWhileStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
 <param name="continueKeyword">
 The "Continue" keyword.
 </param>
 <param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ContinueWhileStatement">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ContinueDoStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
 <param name="continueKeyword">
 The "Continue" keyword.
 </param>
 <param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ContinueDoStatement">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ContinueForStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
 <param name="continueKeyword">
 The "Continue" keyword.
 </param>
 <param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ContinueForStatement">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ContinueStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 ContinueStatementSyntax. One of ContinueWhileStatement, ContinueDoStatement,
 ContinueForStatement.
 </param>
 <param name="continueKeyword">
 The "Continue" keyword.
 </param>
 <param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ContinueStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 ContinueStatementSyntax. One of ContinueWhileStatement, ContinueDoStatement,
 ContinueForStatement.
 </param>
 <param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReturnStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Return" statement.
 </summary>
 <param name="returnKeyword">
 The "Return" keyword.
 </param>
 <param name="expression">
 The expression being returned, if present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReturnStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Return" statement.
 </summary>
 <param name="expression">
 The expression being returned, if present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReturnStatement">
 <summary>
 Represents a "Return" statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SingleLineIfStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax)">
 <summary>
 Represents a single-line "If ... Then ... Else ..." statement.
 </summary>
 <param name="ifKeyword">
 The "If" keyword.
 </param>
 <param name="condition">
 The condition expression to be evaluated.
 </param>
 <param name="thenKeyword">
 The "Then" keyword.
 </param>
 <param name="statements">
 A list of statements to be executed if the condition expression evaluates as
 true. Multiple statements must be separated by colons.
 </param>
 <param name="elseClause">
 An "Else" clause to be executed if the condition expression evaluates as false.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SingleLineIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax)">
 <summary>
 Represents a single-line "If ... Then ... Else ..." statement.
 </summary>
 <param name="condition">
 The condition expression to be evaluated.
 </param>
 <param name="statements">
 A list of statements to be executed if the condition expression evaluates as
 true. Multiple statements must be separated by colons.
 </param>
 <param name="elseClause">
 An "Else" clause to be executed if the condition expression evaluates as false.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SingleLineIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a single-line "If ... Then ... Else ..." statement.
 </summary>
 <param name="condition">
 The condition expression to be evaluated.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SingleLineElseClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents the "Else ..." clause of a single-line "If" statement.
 </summary>
 <param name="elseKeyword">
 The "Else" keyword.
 </param>
 <param name="statements">
 A list of statements to be executed. Multiple statements must be separated by
 colons.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SingleLineElseClause(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents the "Else ..." clause of a single-line "If" statement.
 </summary>
 <param name="statements">
 A list of statements to be executed. Multiple statements must be separated by
 colons.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SingleLineElseClause">
 <summary>
 Represents the "Else ..." clause of a single-line "If" statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MultiLineIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line "If ... Then ... ElseIf ... Then ... Else ... End If"
 block.
 </summary>
 <param name="ifStatement">
 The "If" statement that begins the "If" block.
 </param>
 <param name="statements">
 A list of statements to be executed if the condition expression evaluates as
 true.
 </param>
 <param name="elseIfBlocks">
 A list of "ElseIf" blocks to be evaluated, in order, if the condition
 expression of the "If" statement evaluates as false.
 </param>
 <param name="elseBlock">
 An "Else" block to be executed if the condition expression of the "If"
 statement and all "ElseIf" blocks evaluate as false.
 </param>
 <param name="endIfStatement">
 Then "End If" statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MultiLineIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax)">
 <summary>
 Represents a multi-line "If ... Then ... ElseIf ... Then ... Else ... End If"
 block.
 </summary>
 <param name="ifStatement">
 The "If" statement that begins the "If" block.
 </param>
 <param name="statements">
 A list of statements to be executed if the condition expression evaluates as
 true.
 </param>
 <param name="elseIfBlocks">
 A list of "ElseIf" blocks to be evaluated, in order, if the condition
 expression of the "If" statement evaluates as false.
 </param>
 <param name="elseBlock">
 An "Else" block to be executed if the condition expression of the "If"
 statement and all "ElseIf" blocks evaluate as false.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MultiLineIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax)">
 <summary>
 Represents a multi-line "If ... Then ... ElseIf ... Then ... Else ... End If"
 block.
 </summary>
 <param name="ifStatement">
 The "If" statement that begins the "If" block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IfStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the "If ... Then" statement that begins a multi-line "If" block.
 </summary>
 <param name="ifKeyword">
 The "If" keyword.
 </param>
 <param name="condition">
 The condition expression to be evaluated.
 </param>
 <param name="thenKeyword">
 The "Then" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents the "If ... Then" statement that begins a multi-line "If" block.
 </summary>
 <param name="condition">
 The condition expression to be evaluated.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents an "ElseIf ... Then ..." block.
 </summary>
 <param name="elseIfStatement">
 The "ElseIf ... Then" statement the begins the "ElseIf" block.
 </param>
 <param name="statements">
 A list of statements to be executed if the condition expression of the "ElseIf"
 statement evaluates as true.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax)">
 <summary>
 Represents an "ElseIf ... Then ..." block.
 </summary>
 <param name="elseIfStatement">
 The "ElseIf ... Then" statement the begins the "ElseIf" block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseIfStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the "ElseIf ... Then" statement that begins an "ElseIf" block.
 </summary>
 <param name="elseIfKeyword">
 The "ElseIf" keyword.
 </param>
 <param name="condition">
 The condition expression to be evaluated.
 </param>
 <param name="thenKeyword">
 The "Then" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents the "ElseIf ... Then" statement that begins an "ElseIf" block.
 </summary>
 <param name="condition">
 The condition expression to be evaluated.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents an "Else ..." block.
 </summary>
 <param name="elseStatement">
 The "Else" statement that begins the "Else" block.
 </param>
 <param name="statements">
 A list of statements to be executed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseBlock(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents an "Else ..." block.
 </summary>
 <param name="statements">
 A list of statements to be executed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseBlock">
 <summary>
 Represents an "Else ..." block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the "Else" statement that begins an "Else" block.
 </summary>
 <param name="elseKeyword">
 The "Else" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseStatement">
 <summary>
 Represents the "Else" statement that begins an "Else" block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TryBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.TryStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a "Try ... Catch ... Finally ... End Try" block.
 </summary>
 <param name="tryStatement">
 The "Try" statement that begins the "Try" block.
 </param>
 <param name="statements">
 A list of statements to be executed.
 </param>
 <param name="catchBlocks">
 A list of "Catch" blocks which may be executed if an exception is thrown while
 executing the statements in the "Try" block.
 </param>
 <param name="finallyBlock">
 A "Finally" block to be executed before execution leaves the "Try" block.
 </param>
 <param name="endTryStatement">
 The "End Try" statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TryBlock(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax)">
 <summary>
 Represents a "Try ... Catch ... Finally ... End Try" block.
 </summary>
 <param name="statements">
 A list of statements to be executed.
 </param>
 <param name="catchBlocks">
 A list of "Catch" blocks which may be executed if an exception is thrown while
 executing the statements in the "Try" block.
 </param>
 <param name="finallyBlock">
 A "Finally" block to be executed before execution leaves the "Try" block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TryBlock">
 <summary>
 Represents a "Try ... Catch ... Finally ... End Try" block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TryStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the "Try" statement that begins a "Try" block.
 </summary>
 <param name="tryKeyword">
 The "Try" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TryStatement">
 <summary>
 Represents the "Try" statement that begins a "Try" block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CatchBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a "Catch ..." block.
 </summary>
 <param name="catchStatement">
 The "Catch" statement that begins the "Catch" block.
 </param>
 <param name="statements">
 A list of statements to be executed if an exception is caught by the "Catch"
 block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CatchBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax)">
 <summary>
 Represents a "Catch ..." block.
 </summary>
 <param name="catchStatement">
 The "Catch" statement that begins the "Catch" block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CatchStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax)">
 <summary>
 Represents the "Catch ... When ..." statement that begins a "Catch" block.
 </summary>
 <param name="catchKeyword">
 The "Catch" keyword.
 </param>
 <param name="identifierName">
 An identifier declaring a new variable or naming an existing variable to store
 the exception caught by the "Catch" statement.
 </param>
 <param name="asClause">
 A simple "As" clause specifying the type of exception to catch.
 </param>
 <param name="whenClause">
 A "When" clause to filter exceptions before catching.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CatchStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax)">
 <summary>
 Represents the "Catch ... When ..." statement that begins a "Catch" block.
 </summary>
 <param name="identifierName">
 An identifier declaring a new variable or naming an existing variable to store
 the exception caught by the "Catch" statement.
 </param>
 <param name="asClause">
 A simple "As" clause specifying the type of exception to catch.
 </param>
 <param name="whenClause">
 A "When" clause to filter exceptions before catching.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CatchStatement">
 <summary>
 Represents the "Catch ... When ..." statement that begins a "Catch" block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CatchFilterClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents the "When ..." clause of a "Catch" statement.
 </summary>
 <param name="whenKeyword">
 The "When" keyword.
 </param>
 <param name="filter">
 The filter expression to be evaluated.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CatchFilterClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents the "When ..." clause of a "Catch" statement.
 </summary>
 <param name="filter">
 The filter expression to be evaluated.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FinallyBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a "Finally ..." block of a "Try" block.
 </summary>
 <param name="finallyStatement">
 The "Finally" statement that begins the "Finally" block.
 </param>
 <param name="statements">
 A list of statements to be executed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FinallyBlock(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a "Finally ..." block of a "Try" block.
 </summary>
 <param name="statements">
 A list of statements to be executed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FinallyBlock">
 <summary>
 Represents a "Finally ..." block of a "Try" block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FinallyStatement(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the "Finally" statement that begins a "Finally" block.
 </summary>
 <param name="finallyKeyword">
 The "Finally" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FinallyStatement">
 <summary>
 Represents the "Finally" statement that begins a "Finally" block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ErrorStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents the "Error" statement.
 </summary>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="errorNumber">
 The expression that represents the error number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ErrorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents the "Error" statement.
 </summary>
 <param name="errorNumber">
 The expression that represents the error number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OnErrorGoToZeroStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="goToKeyword">
 The "GoTo" keyword
 </param>
 <param name="minus">
 An optional minus for On Error Goto -1
 </param>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OnErrorGoToZeroStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OnErrorGoToMinusOneStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="goToKeyword">
 The "GoTo" keyword
 </param>
 <param name="minus">
 An optional minus for On Error Goto -1
 </param>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OnErrorGoToMinusOneStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OnErrorGoToLabelStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="goToKeyword">
 The "GoTo" keyword
 </param>
 <param name="minus">
 An optional minus for On Error Goto -1
 </param>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OnErrorGoToLabelStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OnErrorGoToStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 OnErrorGoToStatementSyntax. One of OnErrorGoToZeroStatement,
 OnErrorGoToMinusOneStatement, OnErrorGoToLabelStatement.
 </param>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="goToKeyword">
 The "GoTo" keyword
 </param>
 <param name="minus">
 An optional minus for On Error Goto -1
 </param>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OnErrorGoToStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents an OnError Goto statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 OnErrorGoToStatementSyntax. One of OnErrorGoToZeroStatement,
 OnErrorGoToMinusOneStatement, OnErrorGoToLabelStatement.
 </param>
 <param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OnErrorResumeNextStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an OnError Resume Next statement.
 </summary>
 <param name="onKeyword">
 The "On" keyword
 </param>
 <param name="errorKeyword">
 The "Error" keyword.
 </param>
 <param name="resumeKeyword">
 The "Resume" keyword.
 </param>
 <param name="nextKeyword">
 The "Next"
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OnErrorResumeNextStatement">
 <summary>
 Represents an OnError Resume Next statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ResumeStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="resumeKeyword">
 The "Resume" keyword.
 </param>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ResumeStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ResumeStatement">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ResumeLabelStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="resumeKeyword">
 The "Resume" keyword.
 </param>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ResumeLabelStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ResumeLabelStatement">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ResumeNextStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="resumeKeyword">
 The "Resume" keyword.
 </param>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ResumeNextStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ResumeNextStatement">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ResumeStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 ResumeStatementSyntax. One of ResumeStatement, ResumeLabelStatement,
 ResumeNextStatement.
 </param>
 <param name="resumeKeyword">
 The "Resume" keyword.
 </param>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ResumeStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 ResumeStatementSyntax. One of ResumeStatement, ResumeLabelStatement,
 ResumeNextStatement.
 </param>
 <param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ResumeStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 ResumeStatementSyntax. One of ResumeStatement, ResumeLabelStatement,
 ResumeNextStatement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SelectBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
 <param name="selectStatement">
 The Select Case statement that begins the block.
 </param>
 <param name="caseBlocks">
 A list of the contained Case blocks.
 </param>
 <param name="endSelectStatement">
 The End Select statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SelectBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax})">
 <summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
 <param name="selectStatement">
 The Select Case statement that begins the block.
 </param>
 <param name="caseBlocks">
 A list of the contained Case blocks.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SelectBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax)">
 <summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
 <param name="selectStatement">
 The Select Case statement that begins the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SelectStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
 <param name="selectKeyword">
 The "Select" keyword.
 </param>
 <param name="caseKeyword">
 The "Case" keyword, if present.
 </param>
 <param name="expression">
 The value that branching is based on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SelectStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
 <param name="expression">
 The value that branching is based on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
 <param name="caseStatement">
 The statement that begins the case block.
 </param>
 <param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax)">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
 <param name="caseStatement">
 The statement that begins the case block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseElseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
 <param name="caseStatement">
 The statement that begins the case block.
 </param>
 <param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseElseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax)">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
 <param name="caseStatement">
 The statement that begins the case block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax})">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of CaseBlockSyntax. One
 of CaseBlock, CaseElseBlock.
 </param>
 <param name="caseStatement">
 The statement that begins the case block.
 </param>
 <param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax)">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of CaseBlockSyntax. One
 of CaseBlock, CaseElseBlock.
 </param>
 <param name="caseStatement">
 The statement that begins the case block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax})">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
 <param name="caseKeyword">
 The "Case" keyword
 </param>
 <param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseStatement(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax})">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
 <param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax[])">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
 <param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseElseStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax})">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
 <param name="caseKeyword">
 The "Case" keyword
 </param>
 <param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseElseStatement(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax})">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
 <param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseElseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax[])">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
 <param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax})">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of CaseStatementSyntax.
 One of CaseStatement, CaseElseStatement.
 </param>
 <param name="caseKeyword">
 The "Case" keyword
 </param>
 <param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax})">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of CaseStatementSyntax.
 One of CaseStatement, CaseElseStatement.
 </param>
 <param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax[])">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of CaseStatementSyntax.
 One of CaseStatement, CaseElseStatement.
 </param>
 <param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a ElseCaseClause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseCaseClause(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 The "Else" part in a Case Else statement.
 </summary>
 <param name="elseKeyword">
 The "Else" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseCaseClause">
 <summary>
 The "Else" part in a Case Else statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a single value in a Case.
 </summary>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RangeCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a range "expression To expression" in a Case.
 </summary>
 <param name="lowerBound">
 The lower bound of the range.
 </param>
 <param name="toKeyword">
 The "To" keyword
 </param>
 <param name="upperBound">
 The upper bound of the range.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RangeCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a range "expression To expression" in a Case.
 </summary>
 <param name="lowerBound">
 The lower bound of the range.
 </param>
 <param name="upperBound">
 The upper bound of the range.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseEqualsClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseEqualsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseNotEqualsClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseNotEqualsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseLessThanClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseLessThanClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseLessThanOrEqualClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseLessThanOrEqualClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseGreaterThanOrEqualClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseGreaterThanOrEqualClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseGreaterThanClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CaseGreaterThanClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RelationalCaseClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 RelationalCaseClauseSyntax. One of CaseEqualsClause, CaseNotEqualsClause,
 CaseLessThanClause, CaseLessThanOrEqualClause, CaseGreaterThanOrEqualClause,
 CaseGreaterThanClause.
 </param>
 <param name="isKeyword">
 The "Is" keyword, if present.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RelationalCaseClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 RelationalCaseClauseSyntax. One of CaseEqualsClause, CaseNotEqualsClause,
 CaseLessThanClause, CaseLessThanOrEqualClause, CaseGreaterThanOrEqualClause,
 CaseGreaterThanClause.
 </param>
 <param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
 <param name="value">
 The expression that denotes the value being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SyncLockStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
 <param name="syncLockKeyword">
 The "SyncLock" keyword.
 </param>
 <param name="expression">
 The expression being synchronized on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SyncLockStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
 <param name="expression">
 The expression being synchronized on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleDoLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleDoLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoWhileLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoWhileLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoUntilLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoUntilLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoLoopWhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoLoopWhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoLoopUntilBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoLoopUntilBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoLoopBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of DoLoopBlockSyntax.
 One of SimpleDoLoopBlock, DoWhileLoopBlock, DoUntilLoopBlock, DoLoopWhileBlock,
 DoLoopUntilBlock.
 </param>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoLoopBlock(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)">
 <summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of DoLoopBlockSyntax.
 One of SimpleDoLoopBlock, DoWhileLoopBlock, DoUntilLoopBlock, DoLoopWhileBlock,
 DoLoopUntilBlock.
 </param>
 <param name="doStatement">
 The Do statement that begins the block.
 </param>
 <param name="loopStatement">
 The Loop statement that ends the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleDoStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="doKeyword">
 The "Do" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleDoStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleDoStatement">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoWhileStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="doKeyword">
 The "Do" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoWhileStatement">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoUntilStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="doKeyword">
 The "Do" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoUntilStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoUntilStatement">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of DoStatementSyntax.
 One of SimpleDoStatement, DoWhileStatement, DoUntilStatement.
 </param>
 <param name="doKeyword">
 The "Do" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of DoStatementSyntax.
 One of SimpleDoStatement, DoWhileStatement, DoUntilStatement.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Do statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DoStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 The Do statement that begins a Do-Loop block.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of DoStatementSyntax.
 One of SimpleDoStatement, DoWhileStatement, DoUntilStatement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleLoopStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="loopKeyword">
 The "Loop" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleLoopStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleLoopStatement">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LoopWhileStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="loopKeyword">
 The "Loop" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LoopWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LoopWhileStatement">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LoopUntilStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="loopKeyword">
 The "Loop" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LoopUntilStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LoopUntilStatement">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LoopStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LoopStatementSyntax.
 One of SimpleLoopStatement, LoopWhileStatement, LoopUntilStatement.
 </param>
 <param name="loopKeyword">
 The "Loop" keyword.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LoopStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LoopStatementSyntax.
 One of SimpleLoopStatement, LoopWhileStatement, LoopUntilStatement.
 </param>
 <param name="whileOrUntilClause">
 The "While expression" or "Until expression" clause of the Loop statement, if
 present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LoopStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 The Loop statement that begins a Do-Loop block.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LoopStatementSyntax.
 One of SimpleLoopStatement, LoopWhileStatement, LoopUntilStatement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WhileClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
 <param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
 <param name="condition">
 The boolean expression after the While or Until.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WhileClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
 <param name="condition">
 The boolean expression after the While or Until.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.UntilClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
 <param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
 <param name="condition">
 The boolean expression after the While or Until.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.UntilClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
 <param name="condition">
 The boolean expression after the While or Until.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WhileOrUntilClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 WhileOrUntilClauseSyntax. One of WhileClause, UntilClause.
 </param>
 <param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
 <param name="condition">
 The boolean expression after the While or Until.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WhileStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
 <param name="whileKeyword">
 The "While" keyword.
 </param>
 <param name="condition">
 The boolean expression that controls the While loop.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
 <param name="condition">
 The boolean expression that controls the While loop.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ForBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax)">
 <summary>
 Represents a For block, including the introducing statement, the body and the
 "Next" (which can be omitted if a containing For has a Next with multiple
 variables).
 </summary>
 <param name="forStatement">
 The For statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
 <param name="nextStatement">
 The Next statement that ends the block. If two For or For Each statements are
 ended by a single Next statement, the inner For will not have a Next statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ForBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax)">
 <summary>
 Represents a For block, including the introducing statement, the body and the
 "Next" (which can be omitted if a containing For has a Next with multiple
 variables).
 </summary>
 <param name="forStatement">
 The For statement that begins the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ForEachBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax)">
 <summary>
 Represents a For Each block, including the introducing statement, the body and
 the "Next" (which can be omitted if a containing For has a Next with multiple
 variables).
 </summary>
 <param name="forEachStatement">
 The For Each statement that begins the block.
 </param>
 <param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
 <param name="nextStatement">
 The Next statement that ends the block. If two For or For Each statements are
 ended by a single Next statement, the inner For will not have a Next statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ForEachBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax)">
 <summary>
 Represents a For Each block, including the introducing statement, the body and
 the "Next" (which can be omitted if a containing For has a Next with multiple
 variables).
 </summary>
 <param name="forEachStatement">
 The For Each statement that begins the block.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ForStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax)">
 <summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
 <param name="forKeyword">
 The "For" keyword.
 </param>
 <param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
 <param name="fromValue">
 The expression denoting the initial value of the iteration.
 </param>
 <param name="toKeyword">
 The "To" keyword.
 </param>
 <param name="toValue">
 The expression denoting the final value of the iteration.
 </param>
 <param name="stepClause">
 The optional Step clause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ForStatement(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax)">
 <summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
 <param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
 <param name="fromValue">
 The expression denoting the initial value of the iteration.
 </param>
 <param name="toValue">
 The expression denoting the final value of the iteration.
 </param>
 <param name="stepClause">
 The optional Step clause.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ForStatement(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
 <param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
 <param name="fromValue">
 The expression denoting the initial value of the iteration.
 </param>
 <param name="toValue">
 The expression denoting the final value of the iteration.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ForStepClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 The Step clause in a For Statement.
 </summary>
 <param name="stepKeyword">
 The "Step" keyword.
 </param>
 <param name="stepValue">
 The expression denoting the step increment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ForStepClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 The Step clause in a For Statement.
 </summary>
 <param name="stepValue">
 The expression denoting the step increment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ForEachStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
 <param name="forKeyword">
 The "For" keyword.
 </param>
 <param name="eachKeyword">
 The "Each" keyword.
 </param>
 <param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
 <param name="inKeyword">
 The "In" keyword.
 </param>
 <param name="expression">
 The expression denoting the collection to iterate over.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ForEachStatement(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
 <param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
 <param name="expression">
 The expression denoting the collection to iterate over.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NextStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax})">
 <summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
 <param name="nextKeyword">
 The "Next" keyword.
 </param>
 <param name="controlVariables">
 The variables in the Next statement, if present
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NextStatement(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax})">
 <summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
 <param name="controlVariables">
 The variables in the Next statement, if present
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NextStatement">
 <summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.UsingStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax})">
 <summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
 <param name="usingKeyword">
 The "Using" keyword.
 </param>
 <param name="expression">
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </param>
 <param name="variables">
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.UsingStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax})">
 <summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
 <param name="expression">
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </param>
 <param name="variables">
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.UsingStatement">
 <summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ThrowStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a Throw statement.
 </summary>
 <param name="throwKeyword">
 The "Throw" keyword
 </param>
 <param name="expression">
 The expression denoting the value being thrown.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ThrowStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a Throw statement.
 </summary>
 <param name="expression">
 The expression denoting the value being thrown.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ThrowStatement">
 <summary>
 Represents a Throw statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MidAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MidAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubtractAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubtractAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MultiplyAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MultiplyAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DivideAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DivideAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IntegerDivideAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IntegerDivideAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExponentiateAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExponentiateAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LeftShiftAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LeftShiftAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RightShiftAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RightShiftAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ConcatenateAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ConcatenateAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AssignmentStatementSyntax. One of SimpleAssignmentStatement,
 MidAssignmentStatement, AddAssignmentStatement, SubtractAssignmentStatement,
 MultiplyAssignmentStatement, DivideAssignmentStatement,
 IntegerDivideAssignmentStatement, ExponentiateAssignmentStatement,
 LeftShiftAssignmentStatement, RightShiftAssignmentStatement,
 ConcatenateAssignmentStatement.
 </param>
 <param name="left">
 The target (left hand side) of the assignment.
 </param>
 <param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
 <param name="right">
 The source (right hand side) of the assignment.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MidExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Represents a left-hand side of a MidAssignment statement.
 </summary>
 <param name="mid">
 The "Mid" possibly followed by a type character.
 </param>
 <param name="argumentList">
 The argument list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MidExpression(System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Represents a left-hand side of a MidAssignment statement.
 </summary>
 <param name="mid">
 The "Mid" possibly followed by a type character.
 </param>
 <param name="argumentList">
 The argument list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CallStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
 <param name="callKeyword">
 The "Call" keyword.
 </param>
 <param name="invocation">
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CallStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
 <param name="invocation">
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddHandlerStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
 <param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
 <param name="eventExpression">
 The event being accessed.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
 <param name="eventExpression">
 The event being accessed.
 </param>
 <param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RemoveHandlerStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
 <param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
 <param name="eventExpression">
 The event being accessed.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RemoveHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
 <param name="eventExpression">
 The event being accessed.
 </param>
 <param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddRemoveHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AddRemoveHandlerStatementSyntax. One of AddHandlerStatement,
 RemoveHandlerStatement.
 </param>
 <param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
 <param name="eventExpression">
 The event being accessed.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddRemoveHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AddRemoveHandlerStatementSyntax. One of AddHandlerStatement,
 RemoveHandlerStatement.
 </param>
 <param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
 <param name="eventExpression">
 The event being accessed.
 </param>
 <param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RaiseEventStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Represent a RaiseEvent statement.
 </summary>
 <param name="raiseEventKeyword">
 The "RaiseEvent" keyword
 </param>
 <param name="name">
 The name of the event being raised.
 </param>
 <param name="argumentList">
 The argument list, if present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RaiseEventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Represent a RaiseEvent statement.
 </summary>
 <param name="name">
 The name of the event being raised.
 </param>
 <param name="argumentList">
 The argument list, if present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RaiseEventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Represent a RaiseEvent statement.
 </summary>
 <param name="name">
 The name of the event being raised.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WithStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
 <param name="withKeyword">
 The "With" keyword.
 </param>
 <param name="expression">
 The expression that is the operand of the With statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WithStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
 <param name="expression">
 The expression that is the operand of the With statement.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReDimStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax})">
 <summary>
 Represents a ReDim statement.
 </summary>
 <param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
 <param name="preserveKeyword">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
 <param name="clauses">
 The list of ReDim clauses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReDimStatement(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax})">
 <summary>
 Represents a ReDim statement.
 </summary>
 <param name="clauses">
 The list of ReDim clauses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReDimStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax[])">
 <summary>
 Represents a ReDim statement.
 </summary>
 <param name="clauses">
 The list of ReDim clauses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReDimPreserveStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax})">
 <summary>
 Represents a ReDim statement.
 </summary>
 <param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
 <param name="preserveKeyword">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
 <param name="clauses">
 The list of ReDim clauses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReDimPreserveStatement(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax})">
 <summary>
 Represents a ReDim statement.
 </summary>
 <param name="clauses">
 The list of ReDim clauses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReDimPreserveStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax[])">
 <summary>
 Represents a ReDim statement.
 </summary>
 <param name="clauses">
 The list of ReDim clauses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReDimStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax})">
 <summary>
 Represents a ReDim statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 ReDimStatementSyntax. One of ReDimStatement, ReDimPreserveStatement.
 </param>
 <param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
 <param name="preserveKeyword">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
 <param name="clauses">
 The list of ReDim clauses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReDimStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax})">
 <summary>
 Represents a ReDim statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 ReDimStatementSyntax. One of ReDimStatement, ReDimPreserveStatement.
 </param>
 <param name="clauses">
 The list of ReDim clauses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReDimStatement(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax[])">
 <summary>
 Represents a ReDim statement.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 ReDimStatementSyntax. One of ReDimStatement, ReDimPreserveStatement.
 </param>
 <param name="clauses">
 The list of ReDim clauses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RedimClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Represents a ReDim statement clause.
 </summary>
 <param name="expression">
 The target of the ReDim statement.
 </param>
 <param name="arrayBounds">
 The ArraySizeInitializationModifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EraseStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax})">
 <summary>
 Represents an "Erase" statement.
 </summary>
 <param name="eraseKeyword">
 The "Erase" keyword.
 </param>
 <param name="expressions">
 A list of expressions denoting the arrays to erase.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EraseStatement(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax})">
 <summary>
 Represents an "Erase" statement.
 </summary>
 <param name="expressions">
 A list of expressions denoting the arrays to erase.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EraseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax[])">
 <summary>
 Represents an "Erase" statement.
 </summary>
 <param name="expressions">
 A list of expressions denoting the arrays to erase.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CharacterLiteralExpression(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TrueLiteralExpression(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FalseLiteralExpression(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NumericLiteralExpression(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DateLiteralExpression(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.StringLiteralExpression(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NothingLiteralExpression(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LiteralExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 LiteralExpressionSyntax. One of CharacterLiteralExpression,
 TrueLiteralExpression, FalseLiteralExpression, NumericLiteralExpression,
 DateLiteralExpression, StringLiteralExpression, NothingLiteralExpression.
 </param>
 <param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParenthesizedExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a parenthesized expression.
 </summary>
 <param name="openParenToken">
 The "(" token
 </param>
 <param name="expression">
 The expression inside the parentheses.
 </param>
 <param name="closeParenToken">
 The ")" token
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ParenthesizedExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a parenthesized expression.
 </summary>
 <param name="expression">
 The expression inside the parentheses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MeExpression(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Identifies the special instance "Me"
 </summary>
 <param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MeExpression">
 <summary>
 Identifies the special instance "Me"
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MyBaseExpression(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Identifies the special instance "MyBase"
 </summary>
 <param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MyBaseExpression">
 <summary>
 Identifies the special instance "MyBase"
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MyClassExpression(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Identifies the special instance "MyClass"
 </summary>
 <param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MyClassExpression">
 <summary>
 Identifies the special instance "MyClass"
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GetTypeExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a GetType expression.
 </summary>
 <param name="getTypeKeyword">
 The "GetType" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="type">
 The type to get the Type object for. This can be an open generic type.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GetTypeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents a GetType expression.
 </summary>
 <param name="type">
 The type to get the Type object for. This can be an open generic type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeOfIsExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
 <param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
 <param name="expression">
 The expression being tested.
 </param>
 <param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
 <param name="type">
 The name of the type being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeOfIsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
 <param name="expression">
 The expression being tested.
 </param>
 <param name="type">
 The name of the type being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeOfIsNotExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
 <param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
 <param name="expression">
 The expression being tested.
 </param>
 <param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
 <param name="type">
 The name of the type being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeOfIsNotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
 <param name="expression">
 The expression being tested.
 </param>
 <param name="type">
 The name of the type being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeOfExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 TypeOfExpressionSyntax. One of TypeOfIsExpression, TypeOfIsNotExpression.
 </param>
 <param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
 <param name="expression">
 The expression being tested.
 </param>
 <param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
 <param name="type">
 The name of the type being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeOfExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 TypeOfExpressionSyntax. One of TypeOfIsExpression, TypeOfIsNotExpression.
 </param>
 <param name="expression">
 The expression being tested.
 </param>
 <param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
 <param name="type">
 The name of the type being tested against.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GetXmlNamespaceExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a GetXmlNamespace expression.
 </summary>
 <param name="getXmlNamespaceKeyword">
 The "GetXmlNamespace" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="name">
 The Xml namespace name being referenced.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GetXmlNamespaceExpression">
 <summary>
 Represents a GetXmlNamespace expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleMemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
 <param name="operatorToken">
 The "." or "!" token.
 </param>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleMemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleMemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DictionaryAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
 <param name="operatorToken">
 The "." or "!" token.
 </param>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DictionaryAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DictionaryAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MemberAccessExpressionSyntax. One of SimpleMemberAccessExpression,
 DictionaryAccessExpression.
 </param>
 <param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
 <param name="operatorToken">
 The "." or "!" token.
 </param>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MemberAccessExpressionSyntax. One of SimpleMemberAccessExpression,
 DictionaryAccessExpression.
 </param>
 <param name="operatorToken">
 The "." or "!" token.
 </param>
 <param name="name">
 The identifier after the "." or "!" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlElementAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token1">
 The initial dot "." part of the separator.
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="token3">
 The third "." in a "..." separator.
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlElementAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlElementAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlDescendantAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token1">
 The initial dot "." part of the separator.
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="token3">
 The third "." in a "..." separator.
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlDescendantAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlDescendantAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlAttributeAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token1">
 The initial dot "." part of the separator.
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="token3">
 The third "." in a "..." separator.
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlAttributeAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlAttributeAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlMemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
 XmlDescendantAccessExpression, XmlAttributeAccessExpression.
 </param>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token1">
 The initial dot "." part of the separator.
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="token3">
 The third "." in a "..." separator.
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlMemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
 XmlDescendantAccessExpression, XmlAttributeAccessExpression.
 </param>
 <param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
 <param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlMemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
 XmlDescendantAccessExpression, XmlAttributeAccessExpression.
 </param>
 <param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InvocationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)">
 <summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
 <param name="expression">
 The target of the call or index expression.
 </param>
 <param name="argumentList">
 The argument list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InvocationExpression">
 <summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationInitializerSyntax)">
 <summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
 <param name="newKeyword">
 The "New" keyword.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="type">
 The type of the object being initialized.
 </param>
 <param name="argumentList">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
 <param name="initializer">
 An optional From or With clause to initialize the new object.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationInitializerSyntax)">
 <summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="type">
 The type of the object being initialized.
 </param>
 <param name="argumentList">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
 <param name="initializer">
 An optional From or With clause to initialize the new object.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ObjectCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
 <param name="type">
 The type of the object being initialized.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax)">
 <summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
 <param name="newKeyword">
 The "New" keyword.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="initializer">
 The With clause to initialize the new object.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax)">
 <summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="initializer">
 The With clause to initialize the new object.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax)">
 <summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
 <param name="initializer">
 The With clause to initialize the new object.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax)">
 <summary>
 Represents an expression that creates a new array.
 </summary>
 <param name="newKeyword">
 The "New" keyword.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="type">
 The element type of the array being created.
 </param>
 <param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
 <param name="rankSpecifiers">
 A list of array modifiers such as "()" or "(,)". If no array modifiers were
 present, an empty list is returned.
 </param>
 <param name="initializer">
 The initializer including the braces.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax)">
 <summary>
 Represents an expression that creates a new array.
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
 <param name="type">
 The element type of the array being created.
 </param>
 <param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
 <param name="initializer">
 The initializer including the braces.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ArrayCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax)">
 <summary>
 Represents an expression that creates a new array.
 </summary>
 <param name="type">
 The element type of the array being created.
 </param>
 <param name="initializer">
 The initializer including the braces.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CollectionInitializer(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
 <param name="openBraceToken">
 The "{" token.
 </param>
 <param name="initializers">
 The list of initializers between the braces.
 </param>
 <param name="closeBraceToken">
 The "}" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CollectionInitializer(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax})">
 <summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
 <param name="initializers">
 The list of initializers between the braces.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CollectionInitializer">
 <summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CTypeExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="expression">
 The expression being cast.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="type">
 The type the expression is being cast to.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CTypeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <param name="expression">
 The expression being cast.
 </param>
 <param name="type">
 The type the expression is being cast to.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DirectCastExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="expression">
 The expression being cast.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="type">
 The type the expression is being cast to.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DirectCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <param name="expression">
 The expression being cast.
 </param>
 <param name="type">
 The type the expression is being cast to.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TryCastExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="expression">
 The expression being cast.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="type">
 The type the expression is being cast to.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TryCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <param name="expression">
 The expression being cast.
 </param>
 <param name="type">
 The type the expression is being cast to.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PredefinedCastExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
 <param name="keyword">
 The keyword that was used in the cast operation.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="expression">
 The expression being cast.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PredefinedCastExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
 <param name="keyword">
 The keyword that was used in the cast operation.
 </param>
 <param name="expression">
 The expression being cast.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubtractExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubtractExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MultiplyExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MultiplyExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DivideExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DivideExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IntegerDivideExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IntegerDivideExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExponentiateExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExponentiateExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LeftShiftExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LeftShiftExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RightShiftExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RightShiftExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ConcatenateExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ConcatenateExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ModuloExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ModuloExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EqualsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EqualsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NotEqualsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NotEqualsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LessThanExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LessThanExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LessThanOrEqualExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LessThanOrEqualExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GreaterThanOrEqualExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GreaterThanOrEqualExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GreaterThanExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GreaterThanExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IsNotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IsNotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LikeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LikeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OrExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OrExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExclusiveOrExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExclusiveOrExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AndExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AndExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OrElseExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OrElseExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AndAlsoExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AndAlsoExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.BinaryExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 BinaryExpressionSyntax. One of AddExpression, SubtractExpression,
 MultiplyExpression, DivideExpression, IntegerDivideExpression,
 ExponentiateExpression, LeftShiftExpression, RightShiftExpression,
 ConcatenateExpression, ModuloExpression, EqualsExpression, NotEqualsExpression,
 LessThanExpression, LessThanOrEqualExpression, GreaterThanOrEqualExpression,
 GreaterThanExpression, IsExpression, IsNotExpression, LikeExpression,
 OrExpression, ExclusiveOrExpression, AndExpression, OrElseExpression,
 AndAlsoExpression.
 </param>
 <param name="left">
 The left operand.
 </param>
 <param name="right">
 The right operand.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.UnaryPlusExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.UnaryPlusExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.UnaryMinusExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.UnaryMinusExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NotExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddressOfExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AddressOfExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.UnaryExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 UnaryExpressionSyntax. One of UnaryPlusExpression, UnaryMinusExpression,
 NotExpression, AddressOfExpression.
 </param>
 <param name="operatorToken">
 The token that is the operator.
 </param>
 <param name="operand">
 The expression being operated on.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.BinaryConditionalExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
 <param name="ifKeyword">
 The "If" keyword
 </param>
 <param name="openParenToken">
 The "(" token
 </param>
 <param name="firstExpression">
 The first expression inside the parentheses.
 </param>
 <param name="commaToken">
 The "," token.
 </param>
 <param name="secondExpression">
 The second expression inside the parentheses.
 </param>
 <param name="closeParenToken">
 The ")" token
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.BinaryConditionalExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
 <param name="firstExpression">
 The first expression inside the parentheses.
 </param>
 <param name="secondExpression">
 The second expression inside the parentheses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TernaryConditionalExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
 <param name="ifKeyword">
 The "If" keyword
 </param>
 <param name="openParenToken">
 The "(" token
 </param>
 <param name="condition">
 The first expression inside the parentheses.
 </param>
 <param name="firstCommaToken">
 The "," token.
 </param>
 <param name="whenTrue">
 The second expression inside the parentheses.
 </param>
 <param name="secondCommaToken">
 The "," token.
 </param>
 <param name="whenFalse">
 The second expression inside the parentheses.
 </param>
 <param name="closeParenToken">
 The ")" token
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TernaryConditionalExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
 <param name="condition">
 The first expression inside the parentheses.
 </param>
 <param name="whenTrue">
 The second expression inside the parentheses.
 </param>
 <param name="whenFalse">
 The second expression inside the parentheses.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SingleLineFunctionLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Represents a single line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SingleLineSubLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Represents a single line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SingleLineLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Represents a single line lambda expression.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 SingleLineLambdaExpressionSyntax. One of SingleLineFunctionLambdaExpression,
 SingleLineSubLambdaExpression.
 </param>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MultiLineFunctionLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MultiLineFunctionLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="endSubOrFunctionStatement">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MultiLineSubLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MultiLineSubLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="endSubOrFunctionStatement">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MultiLineLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MultiLineLambdaExpressionSyntax. One of MultiLineFunctionLambdaExpression,
 MultiLineSubLambdaExpression.
 </param>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
 <param name="endSubOrFunctionStatement">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.MultiLineLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax)">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MultiLineLambdaExpressionSyntax. One of MultiLineFunctionLambdaExpression,
 MultiLineSubLambdaExpression.
 </param>
 <param name="subOrFunctionHeader">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
 <param name="endSubOrFunctionStatement">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubLambdaHeader(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Represents the header part of a lambda expression
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this lambda expression.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubLambdaHeader(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Represents the header part of a lambda expression
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SubLambdaHeader">
 <summary>
 Represents the header part of a lambda expression
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionLambdaHeader(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Represents the header part of a lambda expression
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this lambda expression.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionLambdaHeader(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Represents the header part of a lambda expression
 </summary>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionLambdaHeader">
 <summary>
 Represents the header part of a lambda expression
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LambdaHeader(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Represents the header part of a lambda expression
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LambdaHeaderSyntax.
 One of SubLambdaHeader, FunctionLambdaHeader.
 </param>
 <param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
 <param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this lambda expression.
 </param>
 <param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
 <param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LambdaHeader(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the header part of a lambda expression
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LambdaHeaderSyntax.
 One of SubLambdaHeader, FunctionLambdaHeader.
 </param>
 <param name="subOrFunctionKeyword">
 The "Sub" or "Function" keyword that introduces this lambda expression.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ArgumentList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a parenthesized argument list.
 </summary>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="arguments">
 The list of arguments. This may be empty. Omitted argument are represented by
 an OmittedArgumentSyntax node.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax})">
 <summary>
 Represents a parenthesized argument list.
 </summary>
 <param name="arguments">
 The list of arguments. This may be empty. Omitted argument are represented by
 an OmittedArgumentSyntax node.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ArgumentList">
 <summary>
 Represents a parenthesized argument list.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OmittedArgument(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
 <param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OmittedArgument">
 <summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an argument that is just an optional argument name and an
 expression.
 </summary>
 <param name="nameColonEquals">
 The optional name and ":=" prefix of a named argument.
 </param>
 <param name="expression">
 The expression that is the argument.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an argument that is just an optional argument name and an
 expression.
 </summary>
 <param name="expression">
 The expression that is the argument.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NameColonEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an identifier name followed by a ":=" token in a named argument.
 </summary>
 <param name="name">
 The name used to identify the named argument.
 </param>
 <param name="colonEqualsToken">
 The ":=" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NameColonEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 Represents an identifier name followed by a ":=" token in a named argument.
 </summary>
 <param name="name">
 The name used to identify the named argument.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RangeArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
 <param name="lowerBound">
 The lower bound of the range. This is typically the integer constant zero.
 </param>
 <param name="toKeyword">
 The "To" keyword.
 </param>
 <param name="upperBound">
 The upper bound of the range.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RangeArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
 <param name="lowerBound">
 The lower bound of the range. This is typically the integer constant zero.
 </param>
 <param name="upperBound">
 The upper bound of the range.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.QueryExpression(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax})">
 <summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
 <param name="clauses">
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.QueryExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax[])">
 <summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
 <param name="clauses">
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CollectionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
 <param name="identifier">
 The name of the range variable being defined.
 </param>
 <param name="asClause">
 Describes the type of the variable being defined.
 </param>
 <param name="inKeyword">
 The "In" keyword.
 </param>
 <param name="expression">
 The expression that serves as the source of items for the range variable.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CollectionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
 <param name="identifier">
 The name of the range variable being defined.
 </param>
 <param name="asClause">
 Describes the type of the variable being defined.
 </param>
 <param name="expression">
 The expression that serves as the source of items for the range variable.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CollectionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
 <param name="identifier">
 The name of the range variable being defined.
 </param>
 <param name="expression">
 The expression that serves as the source of items for the range variable.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExpressionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
 <param name="nameEquals">
 The optional name and type of the expression range variable. If omitted, the
 name of the expression range variable is inferred from the expression.
 </param>
 <param name="expression">
 The expression used to initialize the expression variable.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExpressionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
 <param name="expression">
 The expression used to initialize the expression variable.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AggregationRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationSyntax)">
 <summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
 <param name="nameEquals">
 The optional name and type of the expression range variable. If omitted, the
 name of the expression range variable is inferred from the aggregation
 expression.
 </param>
 <param name="aggregation">
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AggregationRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationSyntax)">
 <summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
 <param name="aggregation">
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.VariableNameEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the name and optional type of an expression range variable.
 </summary>
 <param name="identifier">
 The name of the variable being defined.
 </param>
 <param name="asClause">
 Describes the type of the variable being defined.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.VariableNameEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Represents the name and optional type of an expression range variable.
 </summary>
 <param name="identifier">
 The name of the variable being defined.
 </param>
 <param name="asClause">
 Describes the type of the variable being defined.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.VariableNameEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax)">
 <summary>
 Represents the name and optional type of an expression range variable.
 </summary>
 <param name="identifier">
 The name of the variable being defined.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionAggregation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
 <param name="functionName">
 The name of the aggregation function.
 </param>
 <param name="openParenToken">
 The "(" token if present.
 </param>
 <param name="argument">
 The argument to the aggregation function.
 </param>
 <param name="closeParenToken">
 The ")" token, if present.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionAggregation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
 <param name="functionName">
 The name of the aggregation function.
 </param>
 <param name="argument">
 The argument to the aggregation function.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionAggregation(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
 <param name="functionName">
 The name of the aggregation function.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FunctionAggregation(System.String)">
 <summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
 <param name="functionName">
 The name of the aggregation function.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GroupAggregation(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
 <param name="groupKeyword">
 The "Group" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GroupAggregation">
 <summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FromClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax})">
 <summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
 <param name="fromKeyword">
 The "From" keyword.
 </param>
 <param name="variables">
 The list of collection variables declared by this From operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FromClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax})">
 <summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
 <param name="variables">
 The list of collection variables declared by this From operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.FromClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax[])">
 <summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
 <param name="variables">
 The list of collection variables declared by this From operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LetClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax})">
 <summary>
 Represents a "Let" query operator.
 </summary>
 <param name="letKeyword">
 The "Let" keyword.
 </param>
 <param name="variables">
 The list of expression range variable being defined by the Let operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LetClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax})">
 <summary>
 Represents a "Let" query operator.
 </summary>
 <param name="variables">
 The list of expression range variable being defined by the Let operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LetClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax[])">
 <summary>
 Represents a "Let" query operator.
 </summary>
 <param name="variables">
 The list of expression range variable being defined by the Let operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AggregateClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents an Aggregate query operator.
 </summary>
 <param name="aggregateKeyword">
 The "Aggregate" keyword.
 </param>
 <param name="variables">
 The list of collection range variables declared by this Aggregate operator.
 </param>
 <param name="additionalQueryOperators">
 A list of additional query operators. It may be empty.
 </param>
 <param name="intoKeyword">
 The "Into" keyword.
 </param>
 <param name="aggregationVariables">
 The list of new variables being defined by the aggregation.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AggregateClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax},Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents an Aggregate query operator.
 </summary>
 <param name="variables">
 The list of collection range variables declared by this Aggregate operator.
 </param>
 <param name="additionalQueryOperators">
 A list of additional query operators. It may be empty.
 </param>
 <param name="aggregationVariables">
 The list of new variables being defined by the aggregation.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AggregateClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents an Aggregate query operator.
 </summary>
 <param name="variables">
 The list of collection range variables declared by this Aggregate operator.
 </param>
 <param name="aggregationVariables">
 The list of new variables being defined by the aggregation.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DistinctClause(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the "Distinct" query operator.
 </summary>
 <param name="distinctKeyword">
 The "Distinct" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DistinctClause">
 <summary>
 Represents the "Distinct" query operator.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WhereClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Where" query operator.
 </summary>
 <param name="whereKeyword">
 The "Where" keyword.
 </param>
 <param name="condition">
 The boolean expression used for filtering.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WhereClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Where" query operator.
 </summary>
 <param name="condition">
 The boolean expression used for filtering.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SkipWhileClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="whileKeyword">
 The "While" keyword.
 </param>
 <param name="condition">
 The boolean expression used for partitioning.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SkipWhileClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
 <param name="condition">
 The boolean expression used for partitioning.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TakeWhileClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="whileKeyword">
 The "While" keyword.
 </param>
 <param name="condition">
 The boolean expression used for partitioning.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TakeWhileClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
 <param name="condition">
 The boolean expression used for partitioning.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PartitionWhileClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 PartitionWhileClauseSyntax. One of SkipWhileClause, TakeWhileClause.
 </param>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="whileKeyword">
 The "While" keyword.
 </param>
 <param name="condition">
 The boolean expression used for partitioning.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PartitionWhileClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 PartitionWhileClauseSyntax. One of SkipWhileClause, TakeWhileClause.
 </param>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="condition">
 The boolean expression used for partitioning.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SkipClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SkipClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
 <param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TakeClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TakeClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
 <param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PartitionClause(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 PartitionClauseSyntax. One of SkipClause, TakeClause.
 </param>
 <param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
 <param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GroupByClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents the "Group By" query operator.
 </summary>
 <param name="groupKeyword">
 The "Group" keyword.
 </param>
 <param name="items">
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </param>
 <param name="byKeyword">
 The "By" keyword.
 </param>
 <param name="keys">
 The key values being used for grouping.
 </param>
 <param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GroupByClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax},Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax},Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents the "Group By" query operator.
 </summary>
 <param name="items">
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </param>
 <param name="keys">
 The key values being used for grouping.
 </param>
 <param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GroupByClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax},Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents the "Group By" query operator.
 </summary>
 <param name="keys">
 The key values being used for grouping.
 </param>
 <param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.JoinCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
 <param name="left">
 The left expression in the Join condition.
 </param>
 <param name="equalsKeyword">
 The "Equals" keyword.
 </param>
 <param name="right">
 The right expression in the Join condition.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.JoinCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
 <param name="left">
 The left expression in the Join condition.
 </param>
 <param name="right">
 The right expression in the Join condition.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleJoinClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax})">
 <summary>
 Represents a Join query operator.
 </summary>
 <param name="joinKeyword">
 The "Join" keyword.
 </param>
 <param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
 <param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
 <param name="onKeyword">
 The "On" keyword.
 </param>
 <param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleJoinClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax},Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax})">
 <summary>
 Represents a Join query operator.
 </summary>
 <param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
 <param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
 <param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SimpleJoinClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax})">
 <summary>
 Represents a Join query operator.
 </summary>
 <param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
 <param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GroupJoinClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents the "Group Join" query operator.
 </summary>
 <param name="groupKeyword">
 The "Group" keyword.
 </param>
 <param name="joinKeyword">
 The "Join" keyword.
 </param>
 <param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
 <param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
 <param name="onKeyword">
 The "On" keyword.
 </param>
 <param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
 <param name="intoKeyword">
 The "Into" keyword.
 </param>
 <param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GroupJoinClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax},Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax},Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents the "Group Join" query operator.
 </summary>
 <param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
 <param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
 <param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
 <param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GroupJoinClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax},Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax},Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax})">
 <summary>
 Represents the "Group Join" query operator.
 </summary>
 <param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
 <param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
 <param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OrderByClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax})">
 <summary>
 Represents the "Order By" query operator.
 </summary>
 <param name="orderKeyword">
 The "Order" keyword
 </param>
 <param name="byKeyword">
 The "By" keyword.
 </param>
 <param name="orderings">
 The list of OrderExpression's to sort by.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OrderByClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax})">
 <summary>
 Represents the "Order By" query operator.
 </summary>
 <param name="orderings">
 The list of OrderExpression's to sort by.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.OrderByClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax[])">
 <summary>
 Represents the "Order By" query operator.
 </summary>
 <param name="orderings">
 The list of OrderExpression's to sort by.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AscendingOrdering(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
 <param name="expression">
 The expression to sort by.
 </param>
 <param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AscendingOrdering(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
 <param name="expression">
 The expression to sort by.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DescendingOrdering(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
 <param name="expression">
 The expression to sort by.
 </param>
 <param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DescendingOrdering(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
 <param name="expression">
 The expression to sort by.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Ordering(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of OrderingSyntax. One
 of AscendingOrdering, DescendingOrdering.
 </param>
 <param name="expression">
 The expression to sort by.
 </param>
 <param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Ordering(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of OrderingSyntax. One
 of AscendingOrdering, DescendingOrdering.
 </param>
 <param name="expression">
 The expression to sort by.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SelectClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax})">
 <summary>
 Represents the "Select" query operator.
 </summary>
 <param name="selectKeyword">
 The "Select" keyword.
 </param>
 <param name="variables">
 The list of expression range variables being defined by the Select query
 operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SelectClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax})">
 <summary>
 Represents the "Select" query operator.
 </summary>
 <param name="variables">
 The list of expression range variables being defined by the Select query
 operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SelectClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax[])">
 <summary>
 Represents the "Select" query operator.
 </summary>
 <param name="variables">
 The list of expression range variables being defined by the Select query
 operator.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlDocument(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Represents an XML Document literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlDocument(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML Document literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlDeclaration(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax)">
 <summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax)">
 <summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlDeclarationOption(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax)">
 <summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlDeclarationOption(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax)">
 <summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax)">
 <summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax)">
 <summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlText(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Represents Xml text.
 </summary>
 <param name="textTokens">
 A list of all the text tokens in the Xml text. This list always contains at
 least one token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlText">
 <summary>
 Represents Xml text.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlElementStartTag(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlElementStartTag(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlElementStartTag(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlElementEndTag(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlElementEndTag(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax)">
 <summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlElementEndTag">
 <summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlEmptyElement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlEmptyElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlEmptyElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)">
 <summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlString(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlString(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlPrefixName(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an XML name of the form 'name' appearing in GetXmlNamespace().
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlPrefixName">
 <summary>
 Represents an XML name of the form 'name' appearing in GetXmlNamespace().
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlName">
 <summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlBracketedName(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
 of an XML literal or member access expression or an XML namespace import
 clause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlBracketedName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax)">
 <summary>
 Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
 of an XML literal or member access expression or an XML namespace import
 clause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlPrefix(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlPrefix">
 <summary>
 Represents an XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlComment(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an XML comment of the form &lt;!-- Comment --&gt; appearing in an
 XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlComment">
 <summary>
 Represents an XML comment of the form &lt;!-- Comment --&gt; appearing in an
 XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlProcessingInstruction(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
 XMLProcessingValue ?&gt;'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlProcessingInstruction">
 <summary>
 Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
 XMLProcessingValue ?&gt;'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlCDataSection(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlCDataSection">
 <summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlEmbeddedExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
 obj.Name =%&gt;&lt;/name&gt;'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlEmbeddedExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
 obj.Name =%&gt;&lt;/name&gt;'.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ArrayType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax})">
 <summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
 <param name="elementType">
 The type of the elements of the array.
 </param>
 <param name="rankSpecifiers">
 Represents the list of "()" or "(,,)" modifiers on the array type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ArrayType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
 <param name="elementType">
 The type of the elements of the array.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NullableType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
 <param name="elementType">
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </param>
 <param name="questionMarkToken">
 The "?" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NullableType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
 <param name="elementType">
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.PredefinedType(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
 <param name="keyword">
 The keyword that was used to describe the built-in type.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IdentifierName(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
 <param name="identifier">
 The identifier in the name.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IdentifierName(System.String)">
 <summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
 <param name="identifier">
 The identifier in the name.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GenericName(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax)">
 <summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
 <param name="identifier">
 The identifier in the name.
 </param>
 <param name="typeArgumentList">
 The generic argument list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GenericName(System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax)">
 <summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
 <param name="identifier">
 The identifier in the name.
 </param>
 <param name="typeArgumentList">
 The generic argument list.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.QualifiedName(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
 <param name="left">
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </param>
 <param name="dotToken">
 The "." token that separates the names.
 </param>
 <param name="right">
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.QualifiedName(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)">
 <summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
 <param name="left">
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </param>
 <param name="right">
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GlobalName(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a name in the global namespace.
 </summary>
 <param name="globalKeyword">
 The "Global" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.GlobalName">
 <summary>
 Represents a name in the global namespace.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeArgumentList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="ofKeyword">
 The "Of" keyword.
 </param>
 <param name="arguments">
 A list of all the type arguments.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax})">
 <summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
 <param name="arguments">
 A list of all the type arguments.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.TypeArgumentList(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax[])">
 <summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
 <param name="arguments">
 A list of all the type arguments.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CrefReference(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax)">
 <summary>
 Syntax node class that represents a value of 'cref' attribute inside
 documentation comment trivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CrefReference(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)">
 <summary>
 Syntax node class that represents a value of 'cref' attribute inside
 documentation comment trivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CrefSignature(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a parenthesized list of argument types for a signature inside
 CrefReferenceSyntax syntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CrefSignature(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax})">
 <summary>
 Represents a parenthesized list of argument types for a signature inside
 CrefReferenceSyntax syntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CrefSignature(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax[])">
 <summary>
 Represents a parenthesized list of argument types for a signature inside
 CrefReferenceSyntax syntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.YieldStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represent a Yield statement.
 </summary>
 <param name="yieldKeyword">
 The "Yield" keyword.
 </param>
 <param name="expression">
 The expression whose value is being yielded.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.YieldStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represent a Yield statement.
 </summary>
 <param name="expression">
 The expression whose value is being yielded.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AwaitExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an Await expression.
 </summary>
 <param name="awaitKeyword">
 The "Await" keyword.
 </param>
 <param name="expression">
 The expression being awaited.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.AwaitExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an Await expression.
 </summary>
 <param name="expression">
 The expression being awaited.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlNameToken(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlNameToken(System.String,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlTextLiteralToken(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlTextLiteralToken(System.String,System.String)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlEntityLiteralToken(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlEntityLiteralToken(System.String,System.String)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DocumentationCommentLineBreakToken(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DocumentationCommentLineBreakToken(System.String,System.String)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlTextToken(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of XmlTextTokenSyntax.
 One of XmlTextLiteralToken, XmlEntityLiteralToken,
 DocumentationCommentLineBreakToken.
 </param>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlTextToken(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,System.String,System.String)">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of XmlTextTokenSyntax.
 One of XmlTextLiteralToken, XmlEntityLiteralToken,
 DocumentationCommentLineBreakToken.
 </param>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterpolatedStringTextToken(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary>
 Represents literal character data in interpolated string expression.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterpolatedStringTextToken(System.String,System.String)">
 <summary>
 Represents literal character data in interpolated string expression.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DecimalLiteralToken(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter,System.Decimal,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary>
 Represents a Decimal literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DecimalLiteralToken(System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter,System.Decimal)">
 <summary>
 Represents a Decimal literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DateLiteralToken(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.DateTime,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary>
 Represents an Date literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DateLiteralToken(System.String,System.DateTime)">
 <summary>
 Represents an Date literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.StringLiteralToken(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary>
 Represents an string literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.StringLiteralToken(System.String,System.String)">
 <summary>
 Represents an string literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CharacterLiteralToken(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Char,Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary>
 Represents an string literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CharacterLiteralToken(System.String,System.Char)">
 <summary>
 Represents an string literal token.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SkippedTokensTrivia(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
 <param name="tokens">
 The list of tokens that were skipped by the parser.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SkippedTokensTrivia">
 <summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DocumentationCommentTrivia(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax})">
 <summary>
 Represents a documentation comment e.g. ''' &lt;Summary&gt; appearing in
 source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DocumentationCommentTrivia">
 <summary>
 Represents a documentation comment e.g. ''' &lt;Summary&gt; appearing in
 source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlCrefAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or
 &lt;seealso&gt; documentation comment tag). For example, the M in &lt;see
 cref="M" /&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlCrefAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or
 &lt;seealso&gt; documentation comment tag). For example, the M in &lt;see
 cref="M" /&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlNameAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A param or type param symbol referenced by a name attribute (e.g. in a
 &lt;param&gt; or &lt;typeparam&gt; documentation comment tag). For example, the
 M in &lt;param name="M" /&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.XmlNameAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 A param or type param symbol referenced by a name attribute (e.g. in a
 &lt;param&gt; or &lt;typeparam&gt; documentation comment tag). For example, the
 M in &lt;param name="M" /&gt;.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ConditionalAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 ExpressionSyntax node representing the object conditionally accessed.
 </summary>
 <param name="expression">
 The expression on the left-hand-side of the "?".
 </param>
 <param name="questionMarkToken">
 "?" token.
 </param>
 <param name="whenNotNull">
 ExpressionSyntax node representing the access expression to be executed when
 the object is not null."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ConditionalAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 ExpressionSyntax node representing the object conditionally accessed.
 </summary>
 <param name="expression">
 The expression on the left-hand-side of the "?".
 </param>
 <param name="whenNotNull">
 ExpressionSyntax node representing the access expression to be executed when
 the object is not null."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ConditionalAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 ExpressionSyntax node representing the object conditionally accessed.
 </summary>
 <param name="whenNotNull">
 ExpressionSyntax node representing the access expression to be executed when
 the object is not null."
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NameOfExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a NameOf expression.
 </summary>
 <param name="nameOfKeyword">
 The "NameOf" keyword.
 </param>
 <param name="openParenToken">
 The "(" token.
 </param>
 <param name="argument">
 The argument.
 </param>
 <param name="closeParenToken">
 The ")" token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.NameOfExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a NameOf expression.
 </summary>
 <param name="argument">
 The argument.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterpolatedStringExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an interpolated string expression.
 </summary>
 <param name="dollarSignDoubleQuoteToken">
 The opening '$"', '$“', or '$”' token.
 </param>
 <param name="contents">
 The contents of the interpolated string.
 </param>
 <param name="doubleQuoteToken">
 The closing '"', '”', or '“' token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterpolatedStringExpression(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax})">
 <summary>
 Represents an interpolated string expression.
 </summary>
 <param name="contents">
 The contents of the interpolated string.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterpolatedStringExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax[])">
 <summary>
 Represents an interpolated string expression.
 </summary>
 <param name="contents">
 The contents of the interpolated string.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterpolatedStringText(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents literal text content in an interpolated string.
 </summary>
 <param name="textToken">
 The text token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterpolatedStringText">
 <summary>
 Represents literal text content in an interpolated string.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Interpolation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an interpolation of an expression in an interpolated string
 expression e.g. '{expression[,alignment][:formatString]}'.
 </summary>
 <param name="openBraceToken">
 The opening curly brace '{' token.
 </param>
 <param name="expression">
 The expression whose formatted value should be embedded in the resultant
 string.
 </param>
 <param name="alignmentClause">
 Optional. The alignment clause ',alignment' of the embedded expression.
 </param>
 <param name="formatClause">
 Optional. The format string clause ':formatString' of the embedded expression.
 </param>
 <param name="closeBraceToken">
 The closing curly brace '}' token of the embedded expression.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Interpolation(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax)">
 <summary>
 Represents an interpolation of an expression in an interpolated string
 expression e.g. '{expression[,alignment][:formatString]}'.
 </summary>
 <param name="expression">
 The expression whose formatted value should be embedded in the resultant
 string.
 </param>
 <param name="alignmentClause">
 Optional. The alignment clause ',alignment' of the embedded expression.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.Interpolation(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an interpolation of an expression in an interpolated string
 expression e.g. '{expression[,alignment][:formatString]}'.
 </summary>
 <param name="expression">
 The expression whose formatted value should be embedded in the resultant
 string.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterpolationAlignmentClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an alignment clause ',alignment' of an interpolated string embedded
 expression.
 </summary>
 <param name="commaToken">
 The comma ',' token.
 </param>
 <param name="value">
 An expression representing the alignment of the interpolated expression.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterpolationAlignmentClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents an alignment clause ',alignment' of an interpolated string embedded
 expression.
 </summary>
 <param name="value">
 An expression representing the alignment of the interpolated expression.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterpolationFormatClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents a format string clause ':formatString' of an interpolated string
 embedded expression.
 </summary>
 <param name="colonToken">
 The ':' token.
 </param>
 <param name="formatStringToken">
 The format string.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.InterpolationFormatClause">
 <summary>
 Represents a format string clause ':formatString' of an interpolated string
 embedded expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.WhitespaceTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndOfLineTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ColonTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.CommentTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.LineContinuationTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DocumentationCommentExteriorTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DisabledTextTrivia(System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.SyntaxTrivia(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,System.String)">
 <summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of SyntaxTrivia. One of
 WhitespaceTrivia, EndOfLineTrivia, ColonTrivia, CommentTrivia,
 LineContinuationTrivia, DocumentationCommentExteriorTrivia, DisabledTextTrivia.
 </param>
 <param name="text">
 The actual text of this token.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ConstDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
 <param name="constKeyword">
 The "Const" keyword.
 </param>
 <param name="name">
 The name of the pre-processing constant being defined.
 </param>
 <param name="equalsToken">
 The "=" token.
 </param>
 <param name="value">
 An expression representing the value of the pre-processing constant being
 defined.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ConstDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
 <param name="name">
 The name of the pre-processing constant being defined.
 </param>
 <param name="value">
 An expression representing the value of the pre-processing constant being
 defined.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ConstDirectiveTrivia(System.String,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
 <param name="name">
 The name of the pre-processing constant being defined.
 </param>
 <param name="value">
 An expression representing the value of the pre-processing constant being
 defined.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IfDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IfDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseIfDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseIfDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IfDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 IfDirectiveTriviaSyntax. One of IfDirectiveTrivia, ElseIfDirectiveTrivia.
 </param>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.IfDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
 <param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 IfDirectiveTriviaSyntax. One of IfDirectiveTrivia, ElseIfDirectiveTrivia.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ElseDirectiveTrivia">
 <summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndIfDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndIfDirectiveTrivia">
 <summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RegionDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
 <param name="regionKeyword">
 The "Region" keyword.
 </param>
 <param name="name">
 The label of the code region being defined.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.RegionDirectiveTrivia">
 <summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndRegionDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an #End Region directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
 <param name="endKeyword">
 The "End" keyword.
 </param>
 <param name="regionKeyword">
 The "Region" keyword.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndRegionDirectiveTrivia">
 <summary>
 Represents an #End Region directive appearing in source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExternalSourceDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExternalSourceDirectiveTrivia">
 <summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndExternalSourceDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EndExternalSourceDirectiveTrivia">
 <summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExternalChecksumDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ExternalChecksumDirectiveTrivia">
 <summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EnableWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax})">
 <summary>
 Represents #Enable Warning pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EnableWarningDirectiveTrivia(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax})">
 <summary>
 Represents #Enable Warning pre-processing directive appearing in source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.EnableWarningDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax[])">
 <summary>
 Represents #Enable Warning pre-processing directive appearing in source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DisableWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax})">
 <summary>
 Represents #Disable Warning pre-processing directive appearing in source.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DisableWarningDirectiveTrivia(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax})">
 <summary>
 Represents #Disable Warning pre-processing directive appearing in source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.DisableWarningDirectiveTrivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax[])">
 <summary>
 Represents #Disable Warning pre-processing directive appearing in source.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReferenceDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an #r directive appearing in scripts.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.ReferenceDirectiveTrivia">
 <summary>
 Represents an #r directive appearing in scripts.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.BadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
 <param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory.BadDirectiveTrivia">
 <summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind">
 <summary>
 Enumeration with all Visual Basic syntax node kinds.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement">
 <summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndUsingStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndWithStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndStructureStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEnumStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndInterfaceStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndClassStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndModuleStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndNamespaceStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSubStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSetStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndPropertyStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEventStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndAddHandlerStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndRemoveHandlerStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndRaiseEventStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndWhileStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndTryStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSyncLockStatement">
 <summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CompilationUnit">
 <summary>
 Represents an entire source file of VB code.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OptionStatement">
 <summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImportsStatement">
 <summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleImportsClause">
 <summary>
 Represents the clause of an Imports statement that imports all members of a type or namespace or aliases a type or namespace.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlNamespaceImportsClause">
 <summary>
 Defines a XML namespace for XML expressions.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceBlock">
 <summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceStatement">
 <summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModuleBlock">
 <summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StructureBlock">
 <summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterfaceBlock">
 <summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ClassBlock">
 <summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EnumBlock">
 <summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InheritsStatement">
 <summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImplementsStatement">
 <summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModuleStatement">
 <summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StructureStatement">
 <summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterfaceStatement">
 <summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ClassStatement">
 <summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EnumStatement">
 <summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameterList">
 <summary>
 Represents the type parameter list in a declaration.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameter">
 <summary>
 Represents a type parameter on a generic type declaration.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameterSingleConstraintClause">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameterMultipleConstraintClause">
 <summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NewConstraint">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ClassConstraint">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StructureConstraint">
 <summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeConstraint">
 <summary>
 Represents a type parameter constraint that is a type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EnumMemberDeclaration">
 <summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubBlock">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock">
 <summary>
 Represents a Function or Sub block declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConstructorBlock">
 <summary>
 Represents a constructor block declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OperatorBlock">
 <summary>
 Represents an Operator block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GetAccessorBlock">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorBlock">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerAccessorBlock">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RemoveHandlerAccessorBlock">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventAccessorBlock">
 <summary>
 Represents an accessor block member declaration: A declaration that has a
 beginning declaration, a body of executable statements and an end statement.
 Examples include property accessors and custom event accessors.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PropertyBlock">
 <summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EventBlock">
 <summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ParameterList">
 <summary>
 Represents the parameter list in a method declaration.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubStatement">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionStatement">
 <summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubNewStatement">
 <summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DeclareSubStatement">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DeclareFunctionStatement">
 <summary>
 A Declare statement that declares an external DLL method.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DelegateSubStatement">
 <summary>
 A statement that declares a delegate type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DelegateFunctionStatement">
 <summary>
 A statement that declares a delegate type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EventStatement">
 <summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OperatorStatement">
 <summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PropertyStatement">
 <summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GetAccessorStatement">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorStatement">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerAccessorStatement">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RemoveHandlerAccessorStatement">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventAccessorStatement">
 <summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImplementsClause">
 <summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.HandlesClause">
 <summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.KeywordEventContainer">
 <summary>
 Represents event container specified through special keywords "Me", "MyBase" or
 "MyClass"..
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithEventsEventContainer">
 <summary>
 Represents event container that refers to a WithEvents member.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithEventsPropertyEventContainer">
 <summary>
 Represents event container that refers to a WithEvents member's property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.HandlesClauseItem">
 <summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IncompleteMember">
 <summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FieldDeclaration">
 <summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.VariableDeclarator">
 <summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleAsClause">
 <summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AsNewClause">
 <summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ObjectMemberInitializer">
 <summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ObjectCollectionInitializer">
 <summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InferredFieldInitializer">
 <summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer">
 <summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsValue">
 <summary>
 Represents an "= initializer" clause in a declaration for a variable,
 parameter or automatic property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Parameter">
 <summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModifiedIdentifier">
 <summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArrayRankSpecifier">
 <summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributeList">
 <summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Attribute">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributeTarget">
 <summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributesStatement">
 <summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExpressionStatement">
 <summary>
 Represent an expression in a statement context. This may only be a invocation
 or await expression in standard code but may be any expression in VB
 Interactive code.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PrintStatement">
 <summary>
 Represent a "? expression" "Print" statement in VB Interactive code.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WhileBlock">
 <summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock">
 <summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SyncLockBlock">
 <summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithBlock">
 <summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LocalDeclarationStatement">
 <summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LabelStatement">
 <summary>
 Represents a label statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GoToStatement">
 <summary>
 Represents a "GoTo" statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IdentifierLabel">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NumericLabel">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NextLabel">
 <summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StopStatement">
 <summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndStatement">
 <summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitDoStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitForStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitSubStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitFunctionStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitOperatorStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitPropertyStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitTryStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitSelectStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitWhileStatement">
 <summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ContinueWhileStatement">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ContinueDoStatement">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ContinueForStatement">
 <summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReturnStatement">
 <summary>
 Represents a "Return" statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineIfStatement">
 <summary>
 Represents a line If-Then-Else statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineIfPart">
 <summary>
 Represents part of a single line If statement, consisting of a beginning
 if-statement, followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an SingleLineIf.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineElseClause">
 <summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineIfBlock">
 <summary>
 Represents a block If...Then...Else...EndIf Statement. The Kind property can be
 used to determine if it is a block or line If.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseIfBlock">
 <summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseBlock">
 <summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IfStatement">
 <summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseIfStatement">
 <summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseStatement">
 <summary>
 Represents the Else part of a If...End If block (or line If). This statement is
 always the Begin of a ElsePart.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TryBlock">
 <summary>
 Represents an entire Try...Catch...Finally...End Try statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CatchBlock">
 <summary>
 Represents a Catch part of an Try...Catch...Finally...End Try statement,
 consisting of a Catch statement, followed by a body of statements controlled by
 that Catch statement. The Kind property returns which kind of part this is.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FinallyBlock">
 <summary>
 Represents the Finally part of an Try...Catch...Finally...End Try statement,
 consisting of a Finally statement, followed by a body of statements controlled
 by the Finally.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TryStatement">
 <summary>
 Represents the Try part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a TryPart.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CatchStatement">
 <summary>
 Represents the Catch part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a CatchPart.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CatchFilterClause">
 <summary>
 Represents the When/Filter clause of a Catch statement
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FinallyStatement">
 <summary>
 Represents the Finally part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a FinallyPart.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ErrorStatement">
 <summary>
 Represents the "Error" statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorGoToZeroStatement">
 <summary>
 Represents an OnError Goto statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorGoToMinusOneStatement">
 <summary>
 Represents an OnError Goto statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorGoToLabelStatement">
 <summary>
 Represents an OnError Goto statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorResumeNextStatement">
 <summary>
 Represents an OnError Resume Next statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ResumeStatement">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ResumeLabelStatement">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ResumeNextStatement">
 <summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectBlock">
 <summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectStatement">
 <summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseBlock">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseElseBlock">
 <summary>
 Represents a case statement and its subsequent block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseStatement">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseElseStatement">
 <summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseCaseClause">
 <summary>
 The "Else" part in a Case Else statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleCaseClause">
 <summary>
 Represents a single value in a Case.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RangeCaseClause">
 <summary>
 Represents a range "expression To expression" in a Case.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseEqualsClause">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseNotEqualsClause">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseLessThanClause">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseLessThanOrEqualClause">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseGreaterThanOrEqualClause">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseGreaterThanClause">
 <summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SyncLockStatement">
 <summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForBlock">
 <summary>
 Represents a For or For Each block, including the introducing statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForEachBlock">
 <summary>
 Represents a For or For Each block, including the introducing statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForStatement">
 <summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForStepClause">
 <summary>
 The Step clause in a For Statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForEachStatement">
 <summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NextStatement">
 <summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingStatement">
 <summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ThrowStatement">
 <summary>
 Represents a Throw statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleAssignmentStatement">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidAssignmentStatement">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddAssignmentStatement">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubtractAssignmentStatement">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiplyAssignmentStatement">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DivideAssignmentStatement">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IntegerDivideAssignmentStatement">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExponentiateAssignmentStatement">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LeftShiftAssignmentStatement">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RightShiftAssignmentStatement">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConcatenateAssignmentStatement">
 <summary>
 Represents a simple, compound, or Mid assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression">
 <summary>
 Represents a left-hand side of a MidAssignment statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CallStatement">
 <summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerStatement">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RemoveHandlerStatement">
 <summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventStatement">
 <summary>
 Represent a RaiseEvent statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithStatement">
 <summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReDimStatement">
 <summary>
 Represents a ReDim statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReDimPreserveStatement">
 <summary>
 Represents a ReDim statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RedimClause">
 <summary>
 Represents a ReDim statement clause.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EraseStatement">
 <summary>
 Represents an "Erase" statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TrueLiteralExpression">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FalseLiteralExpression">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NumericLiteralExpression">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StringLiteralExpression">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NothingLiteralExpression">
 <summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ParenthesizedExpression">
 <summary>
 Represents a parenthesized expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MeExpression">
 <summary>
 Identifies the special instance "Me"
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MyBaseExpression">
 <summary>
 Identifies the special instance "MyBase"
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MyClassExpression">
 <summary>
 Identifies the special instance "MyClass"
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GetTypeExpression">
 <summary>
 Represents a GetType expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeOfIsExpression">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeOfIsNotExpression">
 <summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GetXmlNamespaceExpression">
 <summary>
 Represents a GetXmlNamespace expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleMemberAccessExpression">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DictionaryAccessExpression">
 <summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElementAccessExpression">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlDescendantAccessExpression">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlAttributeAccessExpression">
 <summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InvocationExpression">
 <summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ObjectCreationExpression">
 <summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AnonymousObjectCreationExpression">
 <summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArrayCreationExpression">
 <summary>
 Represents an expression that creates a new array.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CollectionInitializer">
 <summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PredefinedCastExpression">
 <summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubtractExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiplyExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DivideExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IntegerDivideExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExponentiateExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LeftShiftExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RightShiftExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConcatenateExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModuloExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotEqualsExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanOrEqualExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanOrEqualExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsNotExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LikeExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OrExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExclusiveOrExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AndExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OrElseExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AndAlsoExpression">
 <summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UnaryPlusExpression">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UnaryMinusExpression">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotExpression">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression">
 <summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BinaryConditionalExpression">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TernaryConditionalExpression">
 <summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineFunctionLambdaExpression">
 <summary>
 Represents a single line lambda expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineSubLambdaExpression">
 <summary>
 Represents a single line lambda expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineFunctionLambdaExpression">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineSubLambdaExpression">
 <summary>
 Represents a multi-line lambda expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubLambdaHeader">
 <summary>
 Represents the header part of a lambda expression
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionLambdaHeader">
 <summary>
 Represents the header part of a lambda expression
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArgumentList">
 <summary>
 Represents a parenthesized argument list.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OmittedArgument">
 <summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleArgument">
 <summary>
 Represents an argument that is just an optional argument name and an expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RangeArgument">
 <summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QueryExpression">
 <summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CollectionRangeVariable">
 <summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExpressionRangeVariable">
 <summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregationRangeVariable">
 <summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.VariableNameEquals">
 <summary>
 Represents the name and optional type of an expression range variable.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionAggregation">
 <summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupAggregation">
 <summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FromClause">
 <summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LetClause">
 <summary>
 Represents a "Let" query operator.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregateClause">
 <summary>
 Represents an Aggregate query operator.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DistinctClause">
 <summary>
 Represents the "Distinct" query operator.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WhereClause">
 <summary>
 Represents a "Where" query operator.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SkipWhileClause">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TakeWhileClause">
 <summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SkipClause">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TakeClause">
 <summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupByClause">
 <summary>
 Represents the "Group By" query operator.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.JoinCondition">
 <summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleJoinClause">
 <summary>
 Represents a Join query operator.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupJoinClause">
 <summary>
 Represents the "Group Join" query operator.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OrderByClause">
 <summary>
 Represents the "Order By" query operator.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AscendingOrdering">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DescendingOrdering">
 <summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectClause">
 <summary>
 Represents the "Select" query operator.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlDocument">
 <summary>
 Represents an XML Document literal expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlDeclaration">
 <summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlDeclarationOption">
 <summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElement">
 <summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlText">
 <summary>
 Represents Xml text.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElementStartTag">
 <summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElementEndTag">
 <summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlEmptyElement">
 <summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlAttribute">
 <summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlString">
 <summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlPrefixName">
 <summary>
 Represents an XML name of the form 'name' appearing in GetXmlNamespace().
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlName">
 <summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlBracketedName">
 <summary>
 Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
 of an XML literal or member access expression or an XML namespace import
 clause.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlPrefix">
 <summary>
 Represents an XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlComment">
 <summary>
 Represents an XML comment of the form &lt;!-- Comment --&gt; appearing in an
 XML literal expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlProcessingInstruction">
 <summary>
 Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
 XMLProcessingValue ?&gt;'.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlCDataSection">
 <summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlEmbeddedExpression">
 <summary>
 Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
 obj.Name =%&gt;&lt;/name&gt;'.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArrayType">
 <summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NullableType">
 <summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PredefinedType">
 <summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IdentifierName">
 <summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GenericName">
 <summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QualifiedName">
 <summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GlobalName">
 <summary>
 Represents a name in the global namespace.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeArgumentList">
 <summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CrefReference">
 <summary>
 Syntax node class that represents a value of 'cref' attribute inside
 documentation comment trivia.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CrefSignature">
 <summary>
 Represents a parenthesized list of argument types for a signature inside
 CrefReferenceSyntax syntax.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.YieldStatement">
 <summary>
 Represent a Yield statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AwaitExpression">
 <summary>
 Represent a Await expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AliasKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AndKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AndAlsoKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AsKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BooleanKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ByRefKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ByteKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ByValKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CallKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CatchKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CBoolKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CByteKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CCharKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CDateKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CDecKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CDblKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CIntKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ClassKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CLngKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CObjKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConstKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReferenceKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ContinueKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CSByteKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CShortKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CSngKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CStrKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CTypeKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CUIntKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CULngKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CUShortKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DecimalKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DeclareKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DefaultKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DelegateKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DimKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DirectCastKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DoKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DoubleKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EachKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseIfKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EnumKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EraseKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ErrorKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EventKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FalseKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FinallyKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FriendKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GetKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GetTypeKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GetXmlNamespaceKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GlobalKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GoToKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.HandlesKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IfKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImplementsKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImportsKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InheritsKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IntegerKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterfaceKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsNotKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LetKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LibKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LikeKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LongKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LoopKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MeKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModuleKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MustInheritKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MustOverrideKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MyBaseKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MyClassKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NarrowingKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NextKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NewKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NothingKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotInheritableKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotOverridableKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ObjectKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OfKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OperatorKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OptionKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OptionalKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OrKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OrElseKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OverloadsKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OverridableKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OverridesKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ParamArrayKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PartialKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PrivateKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PropertyKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ProtectedKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PublicKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReadOnlyKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReDimKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.REMKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RemoveHandlerKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ResumeKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReturnKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SByteKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ShadowsKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SharedKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ShortKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StaticKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StepKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StopKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StringKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StructureKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SyncLockKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ThenKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ThrowKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ToKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TrueKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TryKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TryCastKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeOfKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UIntegerKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ULongKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UShortKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WhenKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WhileKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WideningKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithEventsKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WriteOnlyKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XorKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GosubKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.VariantKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WendKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregateKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AllKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AnsiKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AscendingKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AssemblyKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AutoKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BinaryKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ByKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CompareKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CustomKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DescendingKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DisableKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DistinctKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EnableKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExplicitKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExternalSourceKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExternalChecksumKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FromKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InferKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IntoKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsFalseKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsTrueKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.JoinKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.KeyKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OffKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OrderKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OutKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PreserveKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RegionKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SkipKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StrictKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TakeKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TextKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UnicodeKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UntilKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WarningKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WhereKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AsyncKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AwaitKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IteratorKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.YieldKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExclamationToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AtToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CommaToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.HashToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AmpersandToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleQuoteToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OpenParenToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CloseParenToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OpenBraceToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CloseBraceToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SemicolonToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AsteriskToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PlusToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MinusToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DotToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SlashToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ColonToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanEqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanGreaterThanToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanEqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BackslashToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaretToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ColonEqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AmpersandEqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AsteriskEqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PlusEqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MinusEqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SlashEqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BackslashEqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaretEqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanLessThanToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanGreaterThanToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanLessThanEqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanGreaterThanEqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QuestionToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DoubleQuoteToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StatementTerminatorToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOfFileToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SlashGreaterThanToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanSlashToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanExclamationMinusMinusToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MinusMinusGreaterThanToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanQuestionToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QuestionGreaterThanToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanPercentEqualsToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PercentGreaterThanToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BeginCDataToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndCDataToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOfXmlToken">
 <summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BadToken">
 <summary>
 Represents a sequence of characters appearing in source with no possible
 meaning in the Visual Basic language (e.g. the semicolon ';'). This token
 should only appear in SkippedTokenTrivia as an artifact of parsing error
 recovery.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlNameToken">
 <summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlTextLiteralToken">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlEntityLiteralToken">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DocumentationCommentLineBreakToken">
 <summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IdentifierToken">
 <summary>
 Represents an identifier token. This might include brackets around the name and
 a type character.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IntegerLiteralToken">
 <summary>
 Represents an integer literal token.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FloatingLiteralToken">
 <summary>
 Represents an floating literal token.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DecimalLiteralToken">
 <summary>
 Represents a Decimal literal token.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralToken">
 <summary>
 Represents an Date literal token.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StringLiteralToken">
 <summary>
 Represents an string literal token.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralToken">
 <summary>
 Represents an string literal token.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SkippedTokensTrivia">
 <summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DocumentationCommentTrivia">
 <summary>
 Represents a documentation comment e.g. ''' &lt;Summary&gt; appearing in source.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlCrefAttribute">
 <summary>
 A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or
 &lt;seealso&gt; documentation comment tag). For example, the M in &lt;see
 cref="M" /&gt;.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlNameAttribute">
 <summary>
 A param or type param symbol referenced by a name attribute (e.g. in a
 &lt;param&gt; or &lt;typeparam&gt; documentation comment tag). For example, the
 M in &lt;param name="M" /&gt;.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConditionalAccessExpression">
 <summary>
 ExpressionSyntax node representing the object conditionally accessed.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WhitespaceTrivia">
 <summary>
 Represents true whitespace: spaces, tabs, newlines and the like.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOfLineTrivia">
 <summary>
 Represents line breaks that are syntactically insignificant.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ColonTrivia">
 <summary>
 Represents colons that are syntactically insignificant.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CommentTrivia">
 <summary>
 Represents a comment.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LineContinuationTrivia">
 <summary>
 Represents an explicit line continuation character at the end of a line, i.e.,
 _
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DocumentationCommentExteriorTrivia">
 <summary>
 Represents a ''' prefix for an XML Documentation Comment.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DisabledTextTrivia">
 <summary>
 Represents text in a false preprocessor block
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConstDirectiveTrivia">
 <summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IfDirectiveTrivia">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseIfDirectiveTrivia">
 <summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseDirectiveTrivia">
 <summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfDirectiveTrivia">
 <summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RegionDirectiveTrivia">
 <summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndRegionDirectiveTrivia">
 <summary>
 Represents an #End Region directive appearing in source.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExternalSourceDirectiveTrivia">
 <summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndExternalSourceDirectiveTrivia">
 <summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExternalChecksumDirectiveTrivia">
 <summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EnableWarningDirectiveTrivia">
 <summary>
 Represents #Enable Warning pre-processing directive appearing in source.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DisableWarningDirectiveTrivia">
 <summary>
 Represents #Disable Warning pre-processing directive appearing in source.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReferenceDirectiveTrivia">
 <summary>
 Represents an #r directive appearing in scripts.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BadDirectiveTrivia">
 <summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImportAliasClause">
 <summary>
 Represents an alias identifier followed by an "=" token in an Imports clause.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NameColonEquals">
 <summary>
 Represents an identifier name followed by a ":=" token in a named argument.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleDoLoopBlock">
 <summary>
 Represents a "Do ... Loop" block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DoWhileLoopBlock">
 <summary>
 Represents a "Do ... Loop" block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DoUntilLoopBlock">
 <summary>
 Represents a "Do ... Loop" block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DoLoopWhileBlock">
 <summary>
 Represents a "Do ... Loop" block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DoLoopUntilBlock">
 <summary>
 Represents a "Do ... Loop" block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleDoStatement">
 <summary>
 Represents a simple "Do" statement that begins a "Do ... Loop" block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DoWhileStatement">
 <summary>
 Represents a "Do While" statement that begins a "Do ... Loop" block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DoUntilStatement">
 <summary>
 Represents a "Do Until" statement that begins a "Do ... Loop" block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleLoopStatement">
 <summary>
 Represents a simple "Loop" statement that end a "Do ... Loop" block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LoopWhileStatement">
 <summary>
 Represents a "Loop While" statement that end a "Do ... Loop" block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LoopUntilStatement">
 <summary>
 Represents a "Loop Until" statement that end a "Do ... Loop" block.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WhileClause">
 <summary>
 Represents a "While ..." clause of a "Do" or "Loop" statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UntilClause">
 <summary>
 Represents an "Until ..." clause of a "Do" or "Loop" statement.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NameOfKeyword">
 <summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NameOfExpression">
 <summary>
 Represents a NameOf expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterpolatedStringExpression">
 <summary>
 Represents an interpolated string expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterpolatedStringText">
 <summary>
 Represents literal text content in an interpolated string.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Interpolation">
 <summary>
 Represents an embedded expression in an interpolated string expression e.g. '{expression[,alignment][:formatString]}'.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterpolationAlignmentClause">
 <summary>
 Represents an alignment clause ', alignment' of an interpolated string embedded expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterpolationFormatClause">
 <summary>
 Represents a format string clause ':formatString' of an interpolated string embedded expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DollarSignDoubleQuoteToken">
 <summary>
 Represents a '$"' token in an interpolated string expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterpolatedStringTextToken">
 <summary>
 Represents literal character data in interpolated string expression.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOfInterpolatedStringToken">
 <summary>
 Represents the end of interpolated string when parsing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxKindExtensions.Contains(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind[],Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Determine if the given <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> array contains the given kind.
 </summary>
 <param name="kinds">Array to search</param>
 <param name="kind">Sought value</param>
 <returns>True if <paramref name="kinds"/> contains the value <paramref name="kind"/>.</returns>
 <remarks>PERF: Not using Array.IndexOf here because it results in a call to IndexOf on the default EqualityComparer for SyntaxKind. The default comparer for SyntaxKind is
 the ObjectEqualityComparer which results in boxing allocations.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxNodeExtensions.ContainingWithStatement(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Find enclosing WithStatement if it exists.
 </summary>
 <param name="node"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxNodeExtensions.ExtractAnonymousTypeMemberName(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax@)">
 <summary>
 Simplified version of ExtractAnonymousTypeMemberName implemented on inner tokens.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxNodeExtensions.AllAreMissing(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Returns true if all arguments are of the specified kind and they are also missing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxNodeExtensions.AllAreMissingIdentifierName(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode})">
 <summary>
 Returns true if all arguments are missing.
 </summary>
 <param name="arguments"></param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxNodeExtensions.QueryClauseKeywordOrRangeVariableIdentifier(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Given a syntax node of query clause returns its leading keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities.IsLambda(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Returns true if the specified node represents a lambda.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities.GetLambda(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Given a node that represents a lambda body returns a node that represents the lambda.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities.GetCorrespondingLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 SyntaxNode.GetCorrespondingLambdaBody(SyntaxNode)
 </summary>
 <remarks>
 We need to handle case when an old node that represents a lambda body with multiple nodes 
 of the same kind is mapped to a new node that belongs to the lambda body but is 
 different from the one that represents the new body.
 
 In that case <paramref name="newLambdaOrPeer"/> isn't lambda representing node (the first range variable of a clause)
 but its equivalent peer (another range variable of the same clause).
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities.IsLambdaBody(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Returns true if the specified <paramref name="node"/> represents a body of a lambda.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities.IsLambdaBodyStatementOrExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@)">
 <summary>
 Returns true if the specified <paramref name="node"/> is part of a lambda body. 
 Returns the node (<paramref name="lambdaBody"/>) that represents the containing lambda body.
 </summary>
 <remarks>
 VB lambda bodies may be non-contiguous sequences of nodes whose ancestor (parent or grandparent) is a lambda node.
 Whenever we need to check whether a node is a lambda body node we should use this method.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities.TryGetLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@,Microsoft.CodeAnalysis.SyntaxNode@)">
 <summary>
 If the specified node represents a lambda returns a node (or nodes) that represent its body (bodies).
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities.TryGetSimpleLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@)">
 <summary>
 If the specified node represents a "simple" lambda returns a node (or nodes) that represent its body (bodies).
 Lambda is "simple" if all its body nodes are also its child nodes and vice versa.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities.AreEquivalentIgnoringLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Compares content of two nodes ignoring lambda bodies and trivia.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities.IsNonUserCodeQueryLambda(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Non-user code lambdas are synthesized lambdas that create an instance of an anonymous type representing a pair of values,
 or otherwise transform sequences/anonymous types from one form to another without calling user code.
 TODO: Could we avoid generating proper lambdas for these?
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities.IsClosureScope(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Returns true if the specified node can represent a closure scope -- that is a scope of a captured variable.
 Doesn't validate whether or not the node actually declares any captured variable.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor">
 <summary>
 Represents a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> visitor that visits only the single SyntaxNode
 passed into its <see cref="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor.Visit(Microsoft.CodeAnalysis.SyntaxNode)"/> method.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1">
 <summary>
 Represents a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> visitor that visits only the single SyntaxNode
 passed into its <see cref="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(Microsoft.CodeAnalysis.SyntaxNode)"/> method and produces 
 a value of the type specified by the <typeparamref name="TResult"/> parameter.
 </summary>
 <typeparam name="TResult">
 The type of the return value of this visitor's Visit method.
 </typeparam>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode">
 <summary>
 The base class for all nodes in the VB syntax tree.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.#ctor(Microsoft.CodeAnalysis.GreenNode,System.Int32,Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Used by structured trivia which has no parent node, so need to know syntax tree explicitly
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.CloneNodeAsRoot``1(``0,Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Creates a clone of a red node that can be used as a root of given syntaxTree.
 New node has no parents, position == 0, and syntaxTree as specified.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.SyntaxTree">
 <summary>
 Returns a non-null SyntaxTree that owns this node.
 If this node was created with an explicit non-null SyntaxTree, returns that tree.
 Otherwise, if this node has a non-null parent, then returns the parent's SyntaxTree.
 Otherwise, returns a newly created SyntaxTree rooted at this node, preserving this node's reference identity.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.Kind">
 <summary>
 Returns the <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> of the node.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.Language">
 <summary>
 The language name this node is syntax of.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.Parent">
 <summary>
 The parent of this node.
 </summary>
 <value>The parent node of this node, or Nothing if this node is the root.</value>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.ToString">
 <summary>
 Returns the string representation of this node, not including its leading and trailing trivia.
 </summary>
 <returns>The string representation of this node, not including its leading and trailing trivia.</returns>
 <remarks>The length of the returned string is always the same as Span.Length</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.ToFullString">
 <summary>
 Returns full string representation of this node including its leading and trailing trivia.
 </summary>
 <returns>The full string representation of this node including its leading and trailing trivia.</returns>
 <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.WriteTo(System.IO.TextWriter)">
 <summary>
 Writes the full text of this node to the specified TextWriter
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.SerializeTo(System.IO.Stream,System.Threading.CancellationToken)">
 <summary>
 Serialize this node to a byte stream.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.DeserializeFrom(System.IO.Stream,System.Threading.CancellationToken)">
 <summary>
 Deserialize a syntax node from a byte stream.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.IsDirective">
 <summary>
 Returns True if this node represents a directive.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.SpanStart">
 <summary>
 Same as accessing <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.Start"/> on <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.Span"/>.
 </summary>
 <remarks>
 Slight performance improvement.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.GetLeadingTrivia">
 <summary>
 Get the preceding trivia nodes of this node. If this node is a token, returns the preceding trivia
 associated with this node. If this is a non-terminal, returns the preceding trivia of the first token
 of this node. 
 </summary>
 <returns>A list of the preceding trivia.</returns>
 <remarks>If this node is a non-terminal, the parents of the trivia will be the first token of this 
 non-terminal; NOT this node.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.GetTrailingTrivia">
 <summary>
 Get the following trivia nodes of this node. If this node is a token, returns the following trivia
 associated with this node. If this is a non-terminal, returns the following trivia of the last token
 of this node. 
 </summary>
 <returns>A list of the following trivia.</returns>
 <remarks>If this node is a non-terminal, the parents of the trivia will be the first token of this 
 non-terminal; NOT this node.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.GetSyntaxErrors(Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Get all syntax errors associated with this node, or any child nodes, grand-child nodes, etc. The errors
 are not in order.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.PushNodesWithErrors(System.Collections.Generic.Stack{Microsoft.CodeAnalysis.SyntaxNodeOrToken},Microsoft.CodeAnalysis.ChildSyntaxList)">
 <summary>
 Push any nodes that have errors in the given collection onto a stack
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.CreateSyntaxError(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.DiagnosticInfo)">
 <summary>
 Given a error info from this node, create the corresponding syntax error with the right span.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 Compares to tree for structural equivalence.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.AddError(Microsoft.CodeAnalysis.DiagnosticInfo)">
 <summary>
 Add an error to the given node, creating a new node that is the same except it has no parent,
 and has the given error attached to it. The error span is the entire span of this node.
 </summary>
 <param name="err">The error to attach to this node</param>
 <returns>A new node, with no parent, that has this error added to it.</returns>
 <remarks>Since nodes are immutable, the only way to create nodes with errors attached is to create a node without an error,
 then add an error with this method to create another node.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.ChildThatContainsPosition(System.Int32)">
 <summary>
 Returns child node or token that contains given position.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.GetLocation">
 <summary>
 Gets the location of this node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.GetReference">
 <summary>
 Gets a SyntaxReference for this syntax node. SyntaxReferences can be used to regain access to a
 syntax node without keeping the entire tree and source text in memory.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.GetDiagnostics">
 <summary>
 Gets a list of all the diagnostics in the sub tree that has this node as its root.
 This method does not filter diagnostics based on compiler options like nowarn, warnaserror etc.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode.FindToken(System.Int32,System.Boolean)">
 <summary>
 Finds a token according to the following rules:
 1)	If position matches the End of the node's Span, then its last token is returned. 
 
 2)	If node.FullSpan.Contains(position) then the token that contains given position is returned.
 
 3)	Otherwise an IndexOutOfRange is thrown
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxRewriter">
 <summary>
 Represents a <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor"/> which descends an entire <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> graph and
 may replace or remove visited SyntaxNodes in depth-first order.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree">
 <summary>
 The parsed representation of a Visual Basic source document.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.ConditionalSymbolsMap">
 <summary>
 Map containing information about all conditional symbol definitions in the source file corresponding to a parsed syntax tree.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.ConditionalSymbolsMap._conditionalsMap">
 <summary>
 Conditional symbols map, where each key-value pair indicates:
   Key: Conditional symbol name.
   Value: Stack of all active conditional symbol definitions, i.e. #Const directives, in the source file corresponding to a parsed syntax tree.
          All the defining #Const directives for a conditional symbol are pushed onto this stack in source code order.
          Each stack entry is a tuple {InternalSyntax.CConst, Integer} where:
            InternalSyntax.CConst: Constant value of the symbol.
            Integer: Source position of the defining #Const directive.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.ParsedSyntaxTree">
 <summary>
 A SyntaxTree is a tree of nodes that represents an entire file of VB
 code, and is parsed by the parser.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.ParsedSyntaxTree.#ctor(Microsoft.CodeAnalysis.Text.SourceText,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.String,Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Boolean,System.Boolean)">
 <summary>
 Used to create new tree incrementally.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.ParsedSyntaxTree.GetReference(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Get a reference to the given node.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.Options">
 <summary>
 The options used by the parser to produce the syntax tree.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.IsMyTemplate">
 <summary>
 Returns True for MyTemplate automatically added by compiler.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.CloneNodeAsRoot``1(``0)">
 <summary>
 Produces a clone of a <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode"/> which will have current syntax tree as its parent.
 
 Caller must guarantee that if the same instance of <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode"/> makes multiple calls
 to this function, only one result is observable.
 </summary>
 <typeparam name="T">Type of the syntax node.</typeparam>
 <param name="node">The original syntax node.</param>
 <returns>A clone of the original syntax node that has current <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree"/> as its parent.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetRoot(System.Threading.CancellationToken)">
 <summary>
 Gets the root node of the syntax tree.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetRootAsync(System.Threading.CancellationToken)">
 <summary>
 Gets the root node of the syntax tree asynchronously.
 </summary>
 <remarks>
 By default, the work associated with this method will be executed immediately on the current thread.
 Implementations that wish to schedule this work differently should override <see cref="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetRootAsync(System.Threading.CancellationToken)"/>.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.TryGetRoot(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode@)">
 <summary>
 Gets the root node of the syntax tree if it is already available.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetCompilationUnitRoot(System.Threading.CancellationToken)">
 <summary>
 Gets the root of the syntax tree statically typed as <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax"/>.
 </summary>
 <remarks>
 Ensure that <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.HasCompilationUnitRoot"/> is true for this tree prior to invoking this method.
 </remarks>
 <exception cref="T:System.InvalidCastException">Throws this exception if <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.HasCompilationUnitRoot"/> is false.</exception>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)">
 <summary>
 Creates a new syntax based off this tree using a new source text.
 </summary>
 <remarks>
 If the new source text is a minor change from the current source text an incremental parse will occur
 reusing most of the current syntax tree internal data.  Otherwise, a full parse will occur using the new
 source text.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.WithChanges(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextChangeRange[])">
 <summary>
 Applies a text change to this syntax tree, returning a new syntax tree with the changes applied to it.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.Create(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions,System.String,System.Text.Encoding)">
 <summary>
 Creates a new syntax tree from a syntax node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.CreateWithoutClone(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)">
 <summary>
 <para>
 Internal helper for <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode"/> class to create a new syntax tree rooted at the given root node.
 This method does not create a clone of the given root, but instead preserves its reference identity.
 </para>
 <para>NOTE: This method is only intended to be used from <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.SyntaxTree"/> property.</para>
 <para>NOTE: Do not use this method elsewhere, instead use <see cref="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.Create(Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions,System.String,System.Text.Encoding)"/> method for creating a syntax tree.</para>
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.ParseText(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions,System.String,System.Threading.CancellationToken)">
 <summary>
 Creates a syntax tree by parsing the source text.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Gets a list of all the diagnostics in the sub tree that has the specified node as its root.
 </summary>
 <remarks>
 This method does not filter diagnostics based on compiler options like /nowarn, /warnaserror etc.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Gets a list of all the diagnostics associated with the token and any related trivia.
 </summary>
 <remarks>
 This method does not filter diagnostics based on compiler options like /nowarn, /warnaserror etc.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxTrivia)">
 <summary>
 Gets a list of all the diagnostics associated with the trivia.
 </summary>
 <remarks>
 This method does not filter diagnostics based on compiler options like /nowarn, /warnaserror etc.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
 <summary>
 Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or
 associated with the token and its related trivia.
 </summary>
 <remarks>
 This method does not filter diagnostics based on compiler options like /nowarn, /warnaserror etc.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetDiagnostics(System.Threading.CancellationToken)">
 <summary>
 Gets a list of all the diagnostics in the syntax tree.
 </summary>
 <remarks>
 This method does not filter diagnostics based on compiler options like /nowarn, /warnaserror etc.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
 <summary>
 Gets the location in terms of path, line and column for a given <paramref name="span"/>.
 </summary>
 <param name="span">Span within the tree.</param>
 <param name="cancellationToken">Cancellation token.</param>
 <returns>
 <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.
 </returns>
 <remarks>
 The values are not affected by line mapping directives (<c>#ExternalSource</c>).
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetMappedLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
 <summary>
 Gets the location in terms of path, line and column after applying source line mapping directives (<c>#ExternalSource</c>).
 </summary>
 <param name="span">Span within the tree.</param>
 <param name="cancellationToken">Cancellation token.</param>
 <returns>
 A valid <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.

 If the location path is not mapped the resulting path is <see cref="T:System.String"/>.
 </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetLocation(Microsoft.CodeAnalysis.Text.TextSpan)">
 <summary>
 Gets a location for the specified text <paramref name="span"/>.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
 <summary>
 Determines if two trees are the same, disregarding trivia differences.
 </summary>
 <param name="tree">The tree to compare against.</param>
 <param name="topLevel">
 If true then the trees are equivalent if the contained nodes and tokens declaring metadata visible symbolic information are equivalent,
 ignoring any differences of nodes inside method bodies or initializer expressions, otherwise all nodes and tokens must be equivalent.
 </param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetChangedSpans(Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Produces a pessimistic list of spans that denote the regions of text in this tree that
 are changed from the text of the old tree.
 </summary>
 <param name="oldTree">The old tree. Cannot be <c>Nothing</c>.</param>
 <remarks>The list is pessimistic because it may claim more or larger regions than actually changed.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree.GetChanges(Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Gets a list of text changes that when applied to the old tree produce this tree.
 </summary>
 <param name="oldTree">The old tree. Cannot be <c>Nothing</c>.</param>
 <remarks>The list of changes may be different than the original changes that produced this tree.</remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxWalker">
 <summary>
 Represents a <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor"/> that descends an entire <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> tree
 visiting each SyntaxNode and its child <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>s and <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>s in depth-first order.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.TypeUnification.CanUnify(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)">
 <summary>
 Determine whether there is any substitution of type parameters that will
 make two types identical.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.TypeUnification.CanUnifyHelper(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeWithModifiers,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeWithModifiers,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution@)">
 <summary>
 Determine whether there is any substitution of type parameters that will
 make two types identical.
 </summary>
 <param name="containingGenericType">The generic containing type.</param>
 <param name="t1">LHS</param>
 <param name="t2">RHS</param>
 <param name="substitution">
 Substitutions performed so far (or null for none).
 Keys are type parameters, values are types (possibly type parameters).
 Will be updated with new substitutions by the callee.
 Irrelevant if false is returned.
 </param>
 <returns>True if there exists a type map such that Map(LHS) == Map(RHS).</returns>
 <remarks>
 Derived from C# Dev10's BSYMMGR::UnifyTypes.
 Two types will not unify if they have different custom modifiers.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.TypeUnification.AddSubstitution(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution@,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeWithModifiers)">
 <summary>
 Add a type parameter -> type argument substitution to a TypeSubstitution object, returning a new TypeSubstitution object
 ByRef.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.TypeUnification.Contains(Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol)">
 <summary>
 Return true if the given type contains the specified type parameter.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VarianceAmbiguity">
 <summary>
 Utility functions to check if two implemented interfaces have variance ambiguity.
 
 What is "Variance Ambiguity"? Here's an example:
 Class ReflectionType
   Implements IEnumerable(Of Field)
   Implements IEnumerable(Of Method)
   Public Sub GetEnumeratorF() As IEnumerator(Of Field) Implements IEnumerable(Of Field).GetEnumerator ...
   Public Sub GetEnumeratorM() As IEnumerator(Of Method) Implements IEnumerable(Of Method).GetEnumerator ...
 End Class
 Dim x as new ReflectionType
 Dim y as IEnumerable(Of Member) = x
 Dim z = y.GetEnumerator()

 Note that, through variance, both IEnumerable(Of Field) and IEnumerable(Of Method) have widening
 conversions to IEnumerable(Of Member). So it's ambiguous whether the initialization of "z" would
 invoke GetEnumeratorF or GetEnumeratorM. This function avoids such ambiguity at the declaration
 level, i.e. it reports a warning on the two implements classes inside ReflectionType that they
 may lead to ambiguity.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VarianceAmbiguity.HasVarianceAmbiguity(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Determine if two interfaces that were constructed from the same original definition
 have variance ambiguity.
 
 We have something like left=ICocon(Of Mammal, int32[]), right=ICocon(Of Fish, int32[])
 for some interface ICocon(Of Out T, In U). And we have to decide if left and right 
 might lead to ambiguous member-lookup later on in execution.

 To do this: go through each type parameter T, U...
   * For "Out T", judge whether the arguments Mammal/Fish cause ambiguity or prevent it.
   * For "In T", judge whether the arguments int32[]/int32[] cause ambiguity or prevent it.

 "Causing/preventing ambiguity" is described further below.
 
 Given all that, ambiguity was prevented in any positions, then left/right are fine.
 Otherwise, if ambiguity wasn't caused in any positions, then left/right are fine.
 Otherwise, left/right have an ambiguity.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VarianceAmbiguity.CheckCorrespondingTypeArguments(Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VarianceKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean@,System.Boolean@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
 <summary>
 Check two corresponding type arguments T1 and T2 and determine if the cause or prevent variable ambiguity.
 
 Identical types never cause or prevent ambiguity.
 
 If there could exist a **distinct** third type T3, such that T1 and T2 both convert via the variance
 conversion to T3, then ambiguity is caused. This boils down to:
   * Invariant parameters never cause ambiguity
   * Covariant parameters "Out T": ambiguity is caused when the two type arguments 
     are non-object types not known to be values (T3=Object)
   * Contravariant parameters "In U": ambiguity is caused when both:
       - Neither T1 or T2 is a value type or a sealed (NotInheritable) reference type
       - If T1 and T2 are both class types, one derives from the other. 
         (T3 is some type deriving or implementing both T1 and T2)
 
  Ambiguity is prevented when there T1 and T2 cannot unify to the same type, and there 
  cannot be a (not necessarily distinct) third type T3 that both T1 and T2 convert to via
  the variance conversion.
 
  This boils down to:
   * Invariant parameters: Ambiguity is prevented when:
       - they are non-unifying
   * Covariant parameters "Out T": Ambiguity is prevented when both:
       - they are non-unifying
       - at least one is a value type
   * Contravariant parameters "In U": Ambiguity is prevented when:
       - they are non-unifying AND
          - at least one is known to be a value type OR
          - both are known to be class types and neither derives from the other.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VBResources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.AggregateSyntaxNotWithinSyntaxTree">
<summary>
  Looks up a localized string similar to AggregateSyntax not within syntax tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.AnonymousObjectCreationExpressionSyntaxNotWithinTree">
<summary>
  Looks up a localized string similar to AnonymousObjectCreationExpressionSyntax not within syntax tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.AssociatedTypeDoesNotHaveTypeParameters">
<summary>
  Looks up a localized string similar to Associated type does not have type parameters.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.CannotAddCompilerSpecialTree">
<summary>
  Looks up a localized string similar to Cannot add compiler special tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.CannotRemoveCompilerSpecialTree">
<summary>
  Looks up a localized string similar to Cannot remove compiler special tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.CantReferenceCompilationFromTypes">
<summary>
  Looks up a localized string similar to Can&apos;t reference compilation of type &apos;{0}&apos; from {1} compilation..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ChainingSpeculativeModelIsNotSupported">
<summary>
  Looks up a localized string similar to Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.CompilationVisualBasic">
<summary>
  Looks up a localized string similar to Compilation (Visual Basic): .
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.DeclarationSyntaxNotWithinSyntaxTree">
<summary>
  Looks up a localized string similar to DeclarationSyntax not within syntax tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.DeclarationSyntaxNotWithinTree">
<summary>
  Looks up a localized string similar to DeclarationSyntax not within tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ElementsCannotBeNull">
<summary>
  Looks up a localized string similar to Elements cannot be null..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AbsentReferenceToPIA1">
<summary>
  Looks up a localized string similar to Cannot find the interop type that matches the embedded type &apos;{0}&apos;. Are you missing an assembly reference?.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AccessMismatch6">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot expose type &apos;{1}&apos; in {2} &apos;{3}&apos; through {4} &apos;{5}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AccessMismatchImplementedEvent4">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot expose the underlying delegate type &apos;{1}&apos; of the event it is implementing outside the project through {2} &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AccessMismatchImplementedEvent6">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot expose the underlying delegate type &apos;{1}&apos; of the event it is implementing to {2} &apos;{3}&apos; through {4} &apos;{5}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AccessMismatchOutsideAssembly4">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot expose type &apos;{1}&apos; outside the project through {2} &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AddOrRemoveHandlerEvent">
<summary>
  Looks up a localized string similar to &apos;AddHandler&apos; or &apos;RemoveHandler&apos; statement event operand must be a dot-qualified expression or a simple name..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AddParamWrongForWinRT">
<summary>
  Looks up a localized string similar to The type of the &apos;AddHandler&apos; method&apos;s parameter must be the same as the type of the event..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AddRemoveParamNotEventType">
<summary>
  Looks up a localized string similar to &apos;AddHandler&apos; and &apos;RemoveHandler&apos; method parameters must have the same delegate type as the containing event..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AddressOfInSelectCaseExpr">
<summary>
  Looks up a localized string similar to &apos;AddressOf&apos; expressions are not valid in the first expression of a &apos;Select Case&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AddressOfNotCreatableDelegate1">
<summary>
  Looks up a localized string similar to &apos;AddressOf&apos; expression cannot be converted to &apos;{0}&apos; because type &apos;{0}&apos; is declared &apos;MustInherit&apos; and cannot be created..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AddressOfNotDelegate1">
<summary>
  Looks up a localized string similar to &apos;AddressOf&apos; expression cannot be converted to &apos;{0}&apos; because &apos;{0}&apos; is not a delegate type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AddressOfNullableMethod">
<summary>
  Looks up a localized string similar to Methods of &apos;System.Nullable(Of T)&apos; cannot be used as operands of the &apos;AddressOf&apos; operator..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AddressOfOperandNotMethod">
<summary>
  Looks up a localized string similar to &apos;AddressOf&apos; operand must be the name of a method (without parentheses)..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AggrInitInvalidForObject">
<summary>
  Looks up a localized string similar to Object initializer syntax cannot be used to initialize an instance of &apos;System.Object&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AgnosticToMachineModule">
<summary>
  Looks up a localized string similar to Agnostic assembly cannot have a processor specific module &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AmbiguousAcrossInterfaces3">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is ambiguous across the inherited interfaces &apos;{1}&apos; and &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AmbiguousCastConversion2">
<summary>
  Looks up a localized string similar to Option Strict On does not allow implicit conversions from &apos;{0}&apos; to &apos;{1}&apos; because the conversion is ambiguous..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AmbiguousDelegateBinding2">
<summary>
  Looks up a localized string similar to No accessible &apos;{0}&apos; is most specific: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AmbiguousImplements3">
<summary>
  Looks up a localized string similar to Member &apos;{0}.{1}&apos; that matches this signature cannot be implemented because the interface &apos;{2}&apos; contains multiple members with this same name and signature:
   &apos;{3}&apos;
   &apos;{4}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AmbiguousImplementsMember3">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; exists in multiple base interfaces. Use the name of the interface that declares &apos;{0}&apos; in the &apos;Implements&apos; clause instead of the name of the derived interface..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AmbiguousInImports2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is ambiguous, imported from the namespaces or types &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AmbiguousInModules2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is ambiguous between declarations in Modules &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AmbiguousInNamespace2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is ambiguous in the namespace &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AmbiguousInNamespaces2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is ambiguous between declarations in namespaces &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AmbiguousInUnnamedNamespace1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is ambiguous..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AmbiguousOverrides3">
<summary>
  Looks up a localized string similar to Member &apos;{0}&apos; that matches this signature cannot be overridden because the class &apos;{1}&apos; contains multiple members with this same name and signature: {2}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AmbiguousWidestType3">
<summary>
  Looks up a localized string similar to Type of &apos;{0}&apos; is ambiguous because the loop bounds and the step clause do not convert to the same type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AnonTypeFieldXMLNameInference">
<summary>
  Looks up a localized string similar to Anonymous type member name cannot be inferred from an XML identifier that is not a valid Visual Basic identifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AnonymousTypeDisallowsTypeChar">
<summary>
  Looks up a localized string similar to Type characters cannot be used in anonymous type declarations..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AnonymousTypeExpectedIdentifier">
<summary>
  Looks up a localized string similar to Identifier expected, preceded with a period..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AnonymousTypeFieldNameInference">
<summary>
  Looks up a localized string similar to Anonymous type member name can be inferred only from a simple or qualified name with no arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AnonymousTypeNameWithoutPeriod">
<summary>
  Looks up a localized string similar to Anonymous type member name must be preceded by a period..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AnonymousTypeNeedField">
<summary>
  Looks up a localized string similar to Anonymous type must contain at least one member..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AnonymousTypePropertyOutOfOrder1">
<summary>
  Looks up a localized string similar to Anonymous type member property &apos;{0}&apos; cannot be used to infer the type of another member property because the type of &apos;{0}&apos; is not yet established..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArgumentCopyBackNarrowing3">
<summary>
  Looks up a localized string similar to Copying the value of &apos;ByRef&apos; parameter &apos;{0}&apos; back to the matching argument narrows from type &apos;{1}&apos; to type &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArgumentNarrowing2">
<summary>
  Looks up a localized string similar to Argument matching parameter &apos;{0}&apos; narrows to &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArgumentNarrowing3">
<summary>
  Looks up a localized string similar to Argument matching parameter &apos;{0}&apos; narrows from &apos;{1}&apos; to &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArgumentRequired">
<summary>
  Looks up a localized string similar to option &apos;{0}&apos; requires &apos;{1}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArgumentSyntax">
<summary>
  Looks up a localized string similar to Comma, &apos;)&apos;, or a valid expression continuation expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArrayInitForNonArray2">
<summary>
  Looks up a localized string similar to Array initializers are valid only for arrays, but the type of &apos;{0}&apos; is &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArrayInitializerForNonConstDim">
<summary>
  Looks up a localized string similar to Array initializer cannot be specified for a non constant dimension; use the empty initializer &apos;{}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArrayInitializerTooFewDimensions">
<summary>
  Looks up a localized string similar to Array initializer has too few dimensions..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArrayInitializerTooManyDimensions">
<summary>
  Looks up a localized string similar to Array initializer has too many dimensions..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArrayInitInStruct">
<summary>
  Looks up a localized string similar to Arrays declared as structure members cannot be declared with an initial size..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArrayInitNoType">
<summary>
  Looks up a localized string similar to Cannot infer an element type. Specifying the type of the array might correct this error..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArrayInitNoTypeObjectDisallowed">
<summary>
  Looks up a localized string similar to Cannot infer an element type, and Option Strict On does not allow &apos;Object&apos; to be assumed. Specifying the type of the array might correct this error..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArrayInitTooManyTypesObjectDisallowed">
<summary>
  Looks up a localized string similar to Cannot infer an element type because more than one type is possible. Specifying the type of the array might correct this error..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArrayOfRawGenericInvalid">
<summary>
  Looks up a localized string similar to &apos;(&apos; unexpected. Arrays of uninstantiated generic types are not allowed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ArrayRankLimit">
<summary>
  Looks up a localized string similar to Array exceeds the limit of 32 dimensions..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AsNewArray">
<summary>
  Looks up a localized string similar to Arrays cannot be declared with &apos;New&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AsyncSubMain">
<summary>
  Looks up a localized string similar to The &apos;Main&apos; method cannot be marked &apos;Async&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AttrAssignmentNotFieldOrProp1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be named as a parameter in an attribute specifier because it is not a field or property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AttrCannotBeGenerics">
<summary>
  Looks up a localized string similar to Type parameters, generic types or types contained in generic types cannot be used as attributes..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AttributeCannotBeAbstract">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be used as an attribute because it is declared &apos;MustInherit&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AttributeMustBeClassNotStruct1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be used as an attribute because it is not a class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AttributeMustInheritSysAttr">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be used as an attribute because it does not inherit from &apos;System.Attribute&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AttributeOnLambdaReturnType">
<summary>
  Looks up a localized string similar to Attributes cannot be applied to return types of lambda expressions..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AttributeOrder">
<summary>
  Looks up a localized string similar to XML attribute &apos;{0}&apos; must appear before XML attribute &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AttributeParameterRequired1">
<summary>
  Looks up a localized string similar to Attribute parameter &apos;{0}&apos; must be specified..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AttributeParameterRequired2">
<summary>
  Looks up a localized string similar to Attribute parameter &apos;{0}&apos; or &apos;{1}&apos; must be specified..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AttributeStmtWrongOrder">
<summary>
  Looks up a localized string similar to Assembly or Module attribute statements must precede any declarations in a file..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AutoPropertyCantBeWriteOnly">
<summary>
  Looks up a localized string similar to Auto-implemented properties cannot be WriteOnly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AutoPropertyCantHaveParams">
<summary>
  Looks up a localized string similar to Auto-implemented properties cannot have parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_AutoPropertyInitializedInStructure">
<summary>
  Looks up a localized string similar to Auto-implemented Properties contained in Structures cannot have initializers unless they are marked &apos;Shared&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAnonymousTypeForExprTree">
<summary>
  Looks up a localized string similar to Cannot convert anonymous type to an expression tree because a property of the type is used to initialize another property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAsyncByRefParam">
<summary>
  Looks up a localized string similar to Async methods cannot have ByRef parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAsyncInQuery">
<summary>
  Looks up a localized string similar to &apos;Await&apos; may only be used in a query expression within the first collection expression of the initial &apos;From&apos; clause or within the collection expression of a &apos;Join&apos; clause..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAsyncReturn">
<summary>
  Looks up a localized string similar to The &apos;Async&apos; modifier can only be used on Subs, or on Functions that return Task or Task(Of T)..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAsyncReturnOperand1">
<summary>
  Looks up a localized string similar to Since this is an async method, the return expression must be of type &apos;{0}&apos; rather than &apos;Task(Of {0})&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAttribute1">
<summary>
  Looks up a localized string similar to Attribute &apos;{0}&apos; is not valid: Incorrect argument value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAttributeConstructor1">
<summary>
  Looks up a localized string similar to Attribute constructor has a parameter of type &apos;{0}&apos;, which is not an integral, floating-point or Enum type or one of Object, Char, String, Boolean, System.Type or 1-dimensional array of these types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAttributeConstructor2">
<summary>
  Looks up a localized string similar to Attribute constructor has a &apos;ByRef&apos; parameter of type &apos;{0}&apos;; cannot use constructors with byref parameters to apply the attribute..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAttributeNonPublicConstructor">
<summary>
  Looks up a localized string similar to Attribute cannot be used because it does not have a Public constructor..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAttributeNonPublicContType2">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used in an attribute because its container &apos;{1}&apos; is not declared &apos;Public&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAttributeNonPublicProperty1">
<summary>
  Looks up a localized string similar to Attribute member &apos;{0}&apos; cannot be the target of an assignment because it is not declared &apos;Public&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAttributeNonPublicType1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used in an attribute because it is not declared &apos;Public&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAttributePropertyType1">
<summary>
  Looks up a localized string similar to Property or field &apos;{0}&apos; does not have a valid attribute type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAttributeReadOnlyProperty1">
<summary>
  Looks up a localized string similar to &apos;ReadOnly&apos; attribute property &apos;{0}&apos; cannot be the target of an assignment..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAttributeSharedProperty1">
<summary>
  Looks up a localized string similar to &apos;Shared&apos; attribute property &apos;{0}&apos; cannot be the target of an assignment..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAttributeUuid2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be applied because the format of the GUID &apos;{1}&apos; is not correct..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAwaitInNonAsyncLambda">
<summary>
  Looks up a localized string similar to &apos;Await&apos; can only be used within an Async lambda expression. Consider marking this lambda expression with the &apos;Async&apos; modifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAwaitInNonAsyncMethod">
<summary>
  Looks up a localized string similar to &apos;Await&apos; can only be used within an Async method. Consider marking this method with the &apos;Async&apos; modifier and changing its return type to &apos;Task(Of {0})&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAwaitInNonAsyncVoidMethod">
<summary>
  Looks up a localized string similar to &apos;Await&apos; can only be used within an Async method. Consider marking this method with the &apos;Async&apos; modifier and changing its return type to &apos;Task&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAwaitInTryHandler">
<summary>
  Looks up a localized string similar to &apos;Await&apos; cannot be used inside a &apos;Catch&apos; statement, a &apos;Finally&apos; statement, or a &apos;SyncLock&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAwaitNothing">
<summary>
  Looks up a localized string similar to Cannot await Nothing. Consider awaiting &apos;Task.Yield()&apos; instead..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadAwaitNotInAsyncMethodOrLambda">
<summary>
  Looks up a localized string similar to &apos;Await&apos; can only be used when contained within a method or lambda expression marked with the &apos;Async&apos; modifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadCCExpression">
<summary>
  Looks up a localized string similar to Syntax error in conditional compilation expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadClassFlags1">
<summary>
  Looks up a localized string similar to Classes cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadCodepage">
<summary>
  Looks up a localized string similar to code page &apos;{0}&apos; is invalid or not installed.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadCompilationOption">
<summary>
  Looks up a localized string similar to {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadConditionalWithRef">
<summary>
  Looks up a localized string similar to Leading &apos;?&apos; can only appear inside a &apos;With&apos; statement, but not inside an object member initializer..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadConstFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on a constant declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadConstraintSyntax">
<summary>
  Looks up a localized string similar to Type or &apos;New&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadDeclareFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on a Declare..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadDelegateFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on a Delegate declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadDimFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on a member variable declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadEmptyEnum1">
<summary>
  Looks up a localized string similar to Enum &apos;{0}&apos; must contain at least one member..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadEnumFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on an Enum declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadEventFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on an event declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadFlagsInNotInheritableClass1">
<summary>
  Looks up a localized string similar to &apos;NotInheritable&apos; classes cannot have members declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadFlagsOnNew1">
<summary>
  Looks up a localized string similar to &apos;Sub New&apos; cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadFlagsOnNewOverloads">
<summary>
  Looks up a localized string similar to The &apos;{0}&apos; keyword is used to overload inherited members; do not use the &apos;{0}&apos; keyword when overloading &apos;Sub New&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadFlagsOnSharedMeth1">
<summary>
  Looks up a localized string similar to &apos;Shared&apos; cannot be combined with &apos;{0}&apos; on a method declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadFlagsOnSharedProperty1">
<summary>
  Looks up a localized string similar to &apos;Shared&apos; cannot be combined with &apos;{0}&apos; on a property declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadFlagsOnStdModuleProperty1">
<summary>
  Looks up a localized string similar to Properties in a Module cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadFlagsWithDefault1">
<summary>
  Looks up a localized string similar to &apos;Default&apos; cannot be combined with &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadGenericParamForNewConstraint2">
<summary>
  Looks up a localized string similar to Type parameter &apos;{0}&apos; must have either a &apos;New&apos; constraint or a &apos;Structure&apos; constraint to satisfy the &apos;New&apos; constraint for type parameter &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadGetAwaiterMethod1">
<summary>
  Looks up a localized string similar to &apos;Await&apos; requires that the type &apos;{0}&apos; have a suitable GetAwaiter method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadImplementsType">
<summary>
  Looks up a localized string similar to Implemented type must be an interface..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadInstanceMemberAccess">
<summary>
  Looks up a localized string similar to Cannot refer to an instance member of a class from within a shared method or shared member initializer without an explicit instance of the class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadInterfaceClassSpecifier1">
<summary>
  Looks up a localized string similar to Class in an interface cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadInterfaceDelegateSpecifier1">
<summary>
  Looks up a localized string similar to Delegate in an interface cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadInterfaceEnumSpecifier1">
<summary>
  Looks up a localized string similar to Enum in an interface cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadInterfaceFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on an Interface declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadInterfaceInterfaceSpecifier1">
<summary>
  Looks up a localized string similar to Interface in an interface cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadInterfaceMethodFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on an interface method declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadInterfaceOrderOnInherits">
<summary>
  Looks up a localized string similar to &apos;Inherits&apos; statements must precede all declarations in an interface..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadInterfacePropertyFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on an interface property declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadInterfaceStructSpecifier1">
<summary>
  Looks up a localized string similar to Structure in an interface cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadIsCompletedOnCompletedGetResult2">
<summary>
  Looks up a localized string similar to &apos;Await&apos; requires that the return type &apos;{0}&apos; of &apos;{1}.GetAwaiter()&apos; have suitable IsCompleted, OnCompleted and GetResult members, and implement INotifyCompletion or ICriticalNotifyCompletion..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadIteratorByRefParam">
<summary>
  Looks up a localized string similar to Iterator methods cannot have ByRef parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadIteratorExpressionLambda">
<summary>
  Looks up a localized string similar to Single-line lambdas cannot have the &apos;Iterator&apos; modifier. Use a multiline lambda instead..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadIteratorReturn">
<summary>
  Looks up a localized string similar to Iterator functions must return either IEnumerable(Of T), or IEnumerator(Of T), or the non-generic forms IEnumerable or IEnumerator..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadLocalConstFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on a local constant declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadLocalDimFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on a local variable declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadMetaDataReference1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be referenced because it is not a valid assembly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadMethodFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on a method declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadModuleFile1">
<summary>
  Looks up a localized string similar to Unable to load module file &apos;{0}&apos;: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadModuleFlags1">
<summary>
  Looks up a localized string similar to Modules cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadNamespaceName1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not a valid name and cannot be used as the root namespace name..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadNullTypeInCCExpression">
<summary>
  Looks up a localized string similar to Nullable types are not allowed in conditional compilation expressions..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadOperatorFlags1">
<summary>
  Looks up a localized string similar to Operators cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadOverloadCandidates2">
<summary>
  Looks up a localized string similar to Overload resolution failed because no accessible &apos;{0}&apos; can be called:{1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadOverrideAccess2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot override &apos;{1}&apos; because they have different access levels..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadPdbData">
<summary>
  Looks up a localized string similar to Error reading debug information for &apos;{0}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadPropertyAccessorFlags">
<summary>
  Looks up a localized string similar to Property accessors cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadPropertyAccessorFlags1">
<summary>
  Looks up a localized string similar to Property accessors cannot be declared &apos;{0}&apos; in a &apos;NotOverridable&apos; property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadPropertyAccessorFlags2">
<summary>
  Looks up a localized string similar to Property accessors cannot be declared &apos;{0}&apos; in a &apos;Default&apos; property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadPropertyAccessorFlags3">
<summary>
  Looks up a localized string similar to Property cannot be declared &apos;{0}&apos; because it contains a &apos;Private&apos; accessor..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadPropertyAccessorFlagsRestrict">
<summary>
  Looks up a localized string similar to Access modifier &apos;{0}&apos; is not valid. The access modifier of &apos;Get&apos; and &apos;Set&apos; should be more restrictive than the property access level..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadPropertyFlags1">
<summary>
  Looks up a localized string similar to Properties cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadRecordFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on a Structure declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadRefLib1">
<summary>
  Looks up a localized string similar to Unable to load referenced library &apos;{0}&apos;: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadResumableAccessReturnVariable">
<summary>
  Looks up a localized string similar to The implicit return variable of an Iterator or Async method cannot be accessed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadReturnValueInIterator">
<summary>
  Looks up a localized string similar to To return a value from an Iterator function, use &apos;Yield&apos; rather than &apos;Return&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadSpecifierCombo2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; and &apos;{1}&apos; cannot be combined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadStaticInitializerInResumable">
<summary>
  Looks up a localized string similar to Static variables cannot appear inside Async or Iterator methods..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadStaticLocalInGenericMethod">
<summary>
  Looks up a localized string similar to Local variables within generic methods cannot be declared &apos;Static&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadStaticLocalInStruct">
<summary>
  Looks up a localized string similar to Local variables within methods of structures cannot be declared &apos;Static&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadTypeArgForRefConstraint2">
<summary>
  Looks up a localized string similar to Type argument &apos;{0}&apos; does not satisfy the &apos;Class&apos; constraint for type parameter &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadTypeArgForStructConstraint2">
<summary>
  Looks up a localized string similar to Type argument &apos;{0}&apos; does not satisfy the &apos;Structure&apos; constraint for type parameter &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadTypeArgForStructConstraintNull">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; must be a value type or a type argument constrained to &apos;Structure&apos; in order to be used with &apos;Nullable&apos; or nullable modifier &apos;?&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadTypeInCCExpression">
<summary>
  Looks up a localized string similar to Non-intrinsic type names are not allowed in conditional compilation expressions..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadUseOfVoid">
<summary>
  Looks up a localized string similar to &apos;System.Void&apos; can only be used in a GetType expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadWithEventsFlags1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on a WithEvents declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadWithRef">
<summary>
  Looks up a localized string similar to Leading &apos;.&apos; or &apos;!&apos; can only appear inside a &apos;With&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadYieldInNonIteratorMethod">
<summary>
  Looks up a localized string similar to &apos;Yield&apos; can only be used in a method marked with the &apos;Iterator&apos; modifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BadYieldInTryHandler">
<summary>
  Looks up a localized string similar to &apos;Yield&apos; cannot be used inside a &apos;Catch&apos; statement or a &apos;Finally&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BaseMismatchForPartialClass3">
<summary>
  Looks up a localized string similar to Base class &apos;{0}&apos; specified for class &apos;{1}&apos; cannot be different from the base class &apos;{2}&apos; of one of its other partial types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BaseOnlyClassesMustBeExplicit2">
<summary>
  Looks up a localized string similar to Class &apos;{0}&apos; must either be declared &apos;MustInherit&apos; or override the following inherited &apos;MustOverride&apos; member(s): {1}..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BaseTypeReferences2">
<summary>
  Looks up a localized string similar to 
    Base type of &apos;{0}&apos; needs &apos;{1}&apos; to be resolved..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BaseUnifiesWithInterfaces3">
<summary>
  Looks up a localized string similar to Cannot inherit interface &apos;{0}&apos; because the interface &apos;{1}&apos; from which it inherits could be identical to interface &apos;{2}&apos; for some type arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BinaryFile">
<summary>
  Looks up a localized string similar to the file &apos;{0}&apos; is not a text file.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BinaryOperands3">
<summary>
  Looks up a localized string similar to Operator &apos;{0}&apos; is not defined for types &apos;{1}&apos; and &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BinaryOperandsForXml4">
<summary>
  Looks up a localized string similar to Operator &apos;{0}&apos; is not defined for types &apos;{1}&apos; and &apos;{2}&apos;. You can use the &apos;Value&apos; property to get the string value of the first element of &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BinaryParamMustBeContainingType1">
<summary>
  Looks up a localized string similar to At least one parameter of this binary operator must be of the containing type &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BlockLocalShadowing1">
<summary>
  Looks up a localized string similar to Variable &apos;{0}&apos; hides a variable in an enclosing block..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BogusWithinLineIf">
<summary>
  Looks up a localized string similar to Statement cannot end a block outside of a line &apos;If&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_BranchOutOfFinally">
<summary>
  Looks up a localized string similar to Branching out of a &apos;Finally&apos; is not valid..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ByRefIllegal1">
<summary>
  Looks up a localized string similar to {0} parameters cannot be declared &apos;ByRef&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ByRefParamInExpressionTree">
<summary>
  Looks up a localized string similar to References to &apos;ByRef&apos; parameters cannot be converted to an expression tree..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotBeMadeNullable1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be made nullable..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotCallEvent1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is an event, and cannot be called directly. Use a &apos;RaiseEvent&apos; statement to raise an event..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotConvertValue2">
<summary>
  Looks up a localized string similar to Value &apos;{0}&apos; cannot be converted to &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotEmbedInterfaceWithGeneric">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be embedded because it has generic argument. Consider disabling the embedding of interop types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotGotoNonScopeBlocksWithClosure">
<summary>
  Looks up a localized string similar to &apos;{0}{1}&apos; is not valid because &apos;{2}&apos; is inside a scope that defines a variable that is used in a lambda or query expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotInferNullableForVariable1">
<summary>
  Looks up a localized string similar to A nullable type cannot be inferred for variable &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotLiftAnonymousType1">
<summary>
  Looks up a localized string similar to Anonymous type property &apos;{0}&apos; cannot be used in the definition of a lambda expression within the same initialization list..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotLiftByRefParamLambda1">
<summary>
  Looks up a localized string similar to &apos;ByRef&apos; parameter &apos;{0}&apos; cannot be used in a lambda expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotLiftByRefParamQuery1">
<summary>
  Looks up a localized string similar to &apos;ByRef&apos; parameter &apos;{0}&apos; cannot be used in a query expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotLiftRestrictedTypeLambda">
<summary>
  Looks up a localized string similar to Instance of restricted type &apos;{0}&apos; cannot be used in a lambda expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotLiftRestrictedTypeQuery">
<summary>
  Looks up a localized string similar to Instance of restricted type &apos;{0}&apos; cannot be used in a query expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotLiftRestrictedTypeResumable1">
<summary>
  Looks up a localized string similar to Variable of restricted type &apos;{0}&apos; cannot be declared in an Async or Iterator method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotLiftStructureMeLambda">
<summary>
  Looks up a localized string similar to Instance members and &apos;Me&apos; cannot be used within a lambda expression in structures..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotLiftStructureMeQuery">
<summary>
  Looks up a localized string similar to Instance members and &apos;Me&apos; cannot be used within query expressions in structures..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotLinkClassWithNoPIA1">
<summary>
  Looks up a localized string similar to Reference to class &apos;{0}&apos; is not allowed when its assembly is configured to embed interop types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotOverrideInAccessibleMember">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot override &apos;{1}&apos; because it is not accessible in this context..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotUseGenericTypeAcrossAssemblyBoundaries">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used across assembly boundaries because it has a generic type parameter that is an embedded interop type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CannotUseOnErrorGotoWithClosure">
<summary>
  Looks up a localized string similar to Method cannot contain both a &apos;{0}&apos; statement and a definition of a variable that is used in a lambda or query expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantAssignToConst">
<summary>
  Looks up a localized string similar to Constant cannot be the target of an assignment..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantAwaitAsyncSub1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; does not return a Task and cannot be awaited. Consider changing it to an Async Function..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantCallIIF">
<summary>
  Looks up a localized string similar to &apos;If&apos; operator cannot be used in a &apos;Call&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantCombineInitializers">
<summary>
  Looks up a localized string similar to An Object Initializer and a Collection Initializer cannot be combined in the same initialization..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantHaveWin32ResAndManifest">
<summary>
  Looks up a localized string similar to Conflicting options specified: Win32 resource file; Win32 manifest..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantOpenFileWrite">
<summary>
  Looks up a localized string similar to can&apos;t open &apos;{0}&apos; for writing: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantOverride4">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot override &apos;{1}&apos; because it is not declared &apos;Overridable&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantOverrideConstructor">
<summary>
  Looks up a localized string similar to &apos;Sub New&apos; cannot be declared &apos;Overrides&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantOverrideNotOverridable2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot override &apos;{1}&apos; because it is declared &apos;NotOverridable&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantRaiseBaseEvent">
<summary>
  Looks up a localized string similar to Derived classes cannot raise base class events..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantReadRulesetFile">
<summary>
  Looks up a localized string similar to Error reading ruleset file {0} - {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantReferToMyGroupInsideGroupType1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot refer to itself through its default instance; use &apos;Me&apos; instead..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantShadowAMustOverride1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot shadow a method declared &apos;MustOverride&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantSpecifyArrayAndNullableOnBoth">
<summary>
  Looks up a localized string similar to Nullable modifier &apos;?&apos; and array modifiers &apos;(&apos; and &apos;)&apos; cannot be specified on both a variable and its type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantSpecifyArraysOnBoth">
<summary>
  Looks up a localized string similar to Array modifiers cannot be specified on both a variable and its type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantSpecifyAsNewAndNullable">
<summary>
  Looks up a localized string similar to Nullable modifier cannot be specified in variable declarations with &apos;As New&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantSpecifyNullableOnBoth">
<summary>
  Looks up a localized string similar to Nullable modifier cannot be specified on both a variable and its type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantSpecifyParamsOnLambdaParamNoType">
<summary>
  Looks up a localized string similar to Array modifiers cannot be specified on lambda expression parameter name. They must be specified on its type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantSpecifyTypeCharacterOnIIF">
<summary>
  Looks up a localized string similar to Expressions used with an &apos;If&apos; expression cannot contain type characters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantThrowNonException">
<summary>
  Looks up a localized string similar to &apos;Throw&apos; operand must derive from &apos;System.Exception&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CantUseRequiredAttribute">
<summary>
  Looks up a localized string similar to The RequiredAttribute attribute is not permitted on Visual Basic types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CaseAfterCaseElse">
<summary>
  Looks up a localized string similar to &apos;Case&apos; cannot follow a &apos;Case Else&apos; in the same &apos;Select&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CaseElseNoSelect">
<summary>
  Looks up a localized string similar to &apos;Case Else&apos; can only appear inside a &apos;Select Case&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CaseNoSelect">
<summary>
  Looks up a localized string similar to &apos;Case&apos; can only appear inside a &apos;Select Case&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CatchAfterFinally">
<summary>
  Looks up a localized string similar to &apos;Catch&apos; cannot appear after &apos;Finally&apos; within a &apos;Try&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CatchNoMatchingTry">
<summary>
  Looks up a localized string similar to &apos;Catch&apos; cannot appear outside a &apos;Try&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CatchNotException1">
<summary>
  Looks up a localized string similar to &apos;Catch&apos; cannot catch type &apos;{0}&apos; because it is not &apos;System.Exception&apos; or a class that inherits from &apos;System.Exception&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CatchVariableNotLocal1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not a local variable or parameter, and so cannot be used as a &apos;Catch&apos; variable..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CharToIntegralTypeMismatch1">
<summary>
  Looks up a localized string similar to &apos;Char&apos; values cannot be converted to &apos;{0}&apos;. Use &apos;Microsoft.VisualBasic.AscW&apos; to interpret a character as a Unicode value or &apos;Microsoft.VisualBasic.Val&apos; to interpret it as a digit..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CircularBaseDependencies4">
<summary>
  Looks up a localized string similar to This inheritance causes circular dependencies between {0} &apos;{1}&apos; and its nested or base type &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CircularEvaluation1">
<summary>
  Looks up a localized string similar to Constant &apos;{0}&apos; cannot depend on its own value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CircularInference1">
<summary>
  Looks up a localized string similar to Type of &apos;{0}&apos; cannot be inferred from an expression containing &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ClashWithReservedEnumMember1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; conflicts with the reserved member by this name that is implicitly declared in all enums..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ClassConstraintNotInheritable1">
<summary>
  Looks up a localized string similar to Type constraint cannot be a &apos;NotInheritable&apos; class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ClassInheritsBaseUnifiesWithInterfaces3">
<summary>
  Looks up a localized string similar to Cannot implement interface &apos;{0}&apos; because the interface &apos;{1}&apos; from which it inherits could be identical to implemented interface &apos;{2}&apos; for some type arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ClassInheritsInterfaceBaseUnifiesWithBase4">
<summary>
  Looks up a localized string similar to Cannot implement interface &apos;{0}&apos; because the interface &apos;{1}&apos; from which it inherits could be identical to interface &apos;{2}&apos; from which the implemented interface &apos;{3}&apos; inherits for some type arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ClassInheritsInterfaceUnifiesWithBase3">
<summary>
  Looks up a localized string similar to Cannot implement interface &apos;{0}&apos; because it could be identical to interface &apos;{1}&apos; from which the implemented interface &apos;{2}&apos; inherits for some type arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ClassNotExpression1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is a class type and cannot be used as an expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CmdOptionConflictsSource">
<summary>
  Looks up a localized string similar to Attribute &apos;{0}&apos; given in a source file conflicts with option &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CoClassMissing2">
<summary>
  Looks up a localized string similar to Implementing class &apos;{0}&apos; for interface &apos;{1}&apos; cannot be found..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CollisionWithPublicTypeInModule">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; conflicts with public type defined in added module &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ComClassAndReservedAttribute1">
<summary>
  Looks up a localized string similar to &apos;Microsoft.VisualBasic.ComClassAttribute&apos; and &apos;{0}&apos; cannot both be applied to the same class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ComClassCantBeAbstract0">
<summary>
  Looks up a localized string similar to &apos;Microsoft.VisualBasic.ComClassAttribute&apos; cannot be applied to a class that is declared &apos;MustInherit&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ComClassDuplicateGuids1">
<summary>
  Looks up a localized string similar to &apos;InterfaceId&apos; and &apos;EventsId&apos; parameters for &apos;Microsoft.VisualBasic.ComClassAttribute&apos; on &apos;{0}&apos; cannot have the same value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ComClassGenericMethod">
<summary>
  Looks up a localized string similar to Generic methods cannot be exposed to COM..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ComClassOnGeneric">
<summary>
  Looks up a localized string similar to &apos;Microsoft.VisualBasic.ComClassAttribute&apos; cannot be applied to a class that is generic or contained inside a generic type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ComClassRequiresPublicClass1">
<summary>
  Looks up a localized string similar to &apos;Microsoft.VisualBasic.ComClassAttribute&apos; cannot be applied to &apos;{0}&apos; because it is not declared &apos;Public&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ComClassRequiresPublicClass2">
<summary>
  Looks up a localized string similar to &apos;Microsoft.VisualBasic.ComClassAttribute&apos; cannot be applied to &apos;{0}&apos; because its container &apos;{1}&apos; is not declared &apos;Public&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ComClassReservedDispId1">
<summary>
  Looks up a localized string similar to &apos;System.Runtime.InteropServices.DispIdAttribute&apos; cannot be applied to &apos;{0}&apos; because &apos;Microsoft.VisualBasic.ComClassAttribute&apos; reserves values less than zero..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ComClassReservedDispIdZero1">
<summary>
  Looks up a localized string similar to &apos;System.Runtime.InteropServices.DispIdAttribute&apos; cannot be applied to &apos;{0}&apos; because &apos;Microsoft.VisualBasic.ComClassAttribute&apos; reserves zero for the default property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConditionOperatorRequired3">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; must define operator &apos;{1}&apos; to be used in a &apos;{2}&apos; expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConflictDefaultPropertyAttribute">
<summary>
  Looks up a localized string similar to Conflict between the default property and the &apos;DefaultMemberAttribute&apos; defined on &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConflictingDirectConstraints3">
<summary>
  Looks up a localized string similar to Constraint &apos;{0}&apos; conflicts with the constraint &apos;{1}&apos; already specified for type parameter &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConflictingMachineModule">
<summary>
  Looks up a localized string similar to Assembly and module &apos;{0}&apos; cannot target different processors..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConflictingManifestSwitches">
<summary>
  Looks up a localized string similar to Error embedding Win32 manifest: Option /win32manifest conflicts with /nowin32manifest..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstantStringTooLong">
<summary>
  Looks up a localized string similar to Length of String constant exceeds current memory limit.  Try splitting the string into multiple constants..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstantWithNoValue">
<summary>
  Looks up a localized string similar to Constants must have a value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstAsNonConstant">
<summary>
  Looks up a localized string similar to Constants must be of an intrinsic or enumerated type, not a class, structure, type parameter, or array type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstNotClassInterfaceOrTypeParam1">
<summary>
  Looks up a localized string similar to Type constraint &apos;{0}&apos; must be either a class, interface or type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstraintAlreadyExists1">
<summary>
  Looks up a localized string similar to Constraint type &apos;{0}&apos; already specified for this type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstraintClashDirectIndirect3">
<summary>
  Looks up a localized string similar to Constraint &apos;{0}&apos; conflicts with the indirect constraint &apos;{1}&apos; obtained from the type parameter constraint &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstraintClashIndirectDirect3">
<summary>
  Looks up a localized string similar to Indirect constraint &apos;{0}&apos; obtained from the type parameter constraint &apos;{1}&apos; conflicts with the constraint &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstraintClashIndirectIndirect4">
<summary>
  Looks up a localized string similar to Indirect constraint &apos;{0}&apos; obtained from the type parameter constraint &apos;{1}&apos; conflicts with the indirect constraint &apos;{2}&apos; obtained from the type parameter constraint &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstraintCycle2">
<summary>
  Looks up a localized string similar to Type parameter &apos;{0}&apos; cannot be constrained to itself: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstraintCycleLink2">
<summary>
  Looks up a localized string similar to 
    &apos;{0}&apos; is constrained to &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstraintIsRestrictedType1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be used as a type constraint..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstructorAsync">
<summary>
  Looks up a localized string similar to Constructor must not have the &apos;Async&apos; modifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstructorCannotBeDeclaredPartial">
<summary>
  Looks up a localized string similar to &apos;Sub New&apos; cannot be declared &apos;Partial&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstructorFunction">
<summary>
  Looks up a localized string similar to Constructor must be declared as a Sub, not as a Function..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConstructorNotFound1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; has no constructors..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ContinueDoNotWithinDo">
<summary>
  Looks up a localized string similar to &apos;Continue Do&apos; can only appear inside a &apos;Do&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ContinueForNotWithinFor">
<summary>
  Looks up a localized string similar to &apos;Continue For&apos; can only appear inside a &apos;For&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ContinueWhileNotWithinWhile">
<summary>
  Looks up a localized string similar to &apos;Continue While&apos; can only appear inside a &apos;While&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConversionFromBaseType">
<summary>
  Looks up a localized string similar to Conversion operators cannot convert from a base type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConversionFromDerivedType">
<summary>
  Looks up a localized string similar to Conversion operators cannot convert from a derived type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConversionFromInterfaceType">
<summary>
  Looks up a localized string similar to Conversion operators cannot convert from an interface type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConversionFromObject">
<summary>
  Looks up a localized string similar to Conversion operators cannot convert from Object..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConversionToBaseType">
<summary>
  Looks up a localized string similar to Conversion operators cannot convert from a type to its base type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConversionToDerivedType">
<summary>
  Looks up a localized string similar to Conversion operators cannot convert from a type to its derived type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConversionToInterfaceType">
<summary>
  Looks up a localized string similar to Conversion operators cannot convert to an interface type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConversionToObject">
<summary>
  Looks up a localized string similar to Conversion operators cannot convert to Object..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConversionToSameType">
<summary>
  Looks up a localized string similar to Conversion operators cannot convert from a type to the same type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConvertArrayMismatch4">
<summary>
  Looks up a localized string similar to Value of type &apos;{0}&apos; cannot be converted to &apos;{1}&apos; because &apos;{2}&apos; is not derived from &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConvertArrayRankMismatch2">
<summary>
  Looks up a localized string similar to Value of type &apos;{0}&apos; cannot be converted to &apos;{1}&apos; because the array types have different numbers of dimensions..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConvertObjectArrayMismatch3">
<summary>
  Looks up a localized string similar to Value of type &apos;{0}&apos; cannot be converted to &apos;{1}&apos; because &apos;{2}&apos; is not a reference type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConvMustBeWideningOrNarrowing">
<summary>
  Looks up a localized string similar to Conversion operators must be declared either &apos;Widening&apos; or &apos;Narrowing&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ConvParamMustBeContainingType1">
<summary>
  Looks up a localized string similar to Either the parameter type or the return type of this conversion operator must be of the containing type &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CopyBackTypeMismatch3">
<summary>
  Looks up a localized string similar to Cannot copy the value of &apos;ByRef&apos; parameter &apos;{0}&apos; back to the matching argument because type &apos;{1}&apos; cannot be converted to type &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CryptoHashFailed">
<summary>
  Looks up a localized string similar to Cryptographic failure while creating hashes..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CustomEventInvInInterface">
<summary>
  Looks up a localized string similar to &apos;Custom&apos; modifier is not valid on events declared in interfaces..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_CustomEventRequiresAs">
<summary>
  Looks up a localized string similar to &apos;Custom&apos; modifier is not valid on events declared without explicit delegate types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DateToDoubleConversion">
<summary>
  Looks up a localized string similar to Conversion from &apos;Date&apos; to &apos;Double&apos; requires calling the &apos;Date.ToOADate&apos; method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DebugEntryPointNotSourceMethodDefinition">
<summary>
  Looks up a localized string similar to Debug entry point must be a definition of a method declared in the current compilation..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DeclaresCantBeInGeneric">
<summary>
  Looks up a localized string similar to &apos;Declare&apos; statements are not allowed in generic types or types contained in generic types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DefaultEventNotFound1">
<summary>
  Looks up a localized string similar to Event &apos;{0}&apos; specified by the &apos;DefaultEvent&apos; attribute is not a publicly accessible event for this class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DefaultMemberNotProperty1">
<summary>
  Looks up a localized string similar to Default member of &apos;{0}&apos; is not a property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DefaultMissingFromProperty2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; and &apos;{1}&apos; cannot overload each other because only one is declared &apos;Default&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DefaultPropertyAmbiguousAcrossInterfaces4">
<summary>
  Looks up a localized string similar to Default property access is ambiguous between the inherited interface members &apos;{0}&apos; of interface &apos;{1}&apos; and &apos;{2}&apos; of interface &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DefaultPropertyWithNoParams">
<summary>
  Looks up a localized string similar to Properties with no required parameters cannot be declared &apos;Default&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DefaultValueForNonOptionalParam">
<summary>
  Looks up a localized string similar to Default values cannot be supplied for parameters that are not declared &apos;Optional&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DelegateBindingFailure3">
<summary>
  Looks up a localized string similar to No accessible method &apos;{0}&apos; has a signature compatible with delegate &apos;{1}&apos;:{2}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DelegateBindingIncompatible2">
<summary>
  Looks up a localized string similar to Method &apos;{0}&apos; does not have a signature compatible with delegate &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DelegateBindingIncompatible3">
<summary>
  Looks up a localized string similar to Extension Method &apos;{0}&apos; defined in &apos;{2}&apos; does not have a signature compatible with delegate &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DelegateBindingMismatch">
<summary>
  Looks up a localized string similar to Method does not have a signature compatible with the delegate..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DelegateBindingMismatchStrictOff2">
<summary>
  Looks up a localized string similar to Option Strict On does not allow narrowing in implicit type conversions between method &apos;{0}&apos; and delegate &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DelegateBindingMismatchStrictOff3">
<summary>
  Looks up a localized string similar to Option Strict On does not allow narrowing in implicit type conversions between extension method &apos;{0}&apos; defined in &apos;{2}&apos; and delegate &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DelegateBindingTypeInferenceFails">
<summary>
  Looks up a localized string similar to Type arguments could not be inferred from the delegate..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DelegateCantHandleEvents">
<summary>
  Looks up a localized string similar to Delegates cannot handle events..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DelegateCantImplement">
<summary>
  Looks up a localized string similar to Delegates cannot implement interface methods..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DelegateNoInvoke1">
<summary>
  Looks up a localized string similar to Delegate class &apos;{0}&apos; has no Invoke method, so an expression of this type cannot be the target of a method call..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DllImportNotLegalOnDeclare">
<summary>
  Looks up a localized string similar to &apos;System.Runtime.InteropServices.DllImportAttribute&apos; cannot be applied to a Declare..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DllImportNotLegalOnEventMethod">
<summary>
  Looks up a localized string similar to &apos;System.Runtime.InteropServices.DllImportAttribute&apos; cannot be applied to &apos;AddHandler&apos;, &apos;RemoveHandler&apos; or &apos;RaiseEvent&apos; method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DllImportNotLegalOnGetOrSet">
<summary>
  Looks up a localized string similar to &apos;System.Runtime.InteropServices.DllImportAttribute&apos; cannot be applied to a Get or Set..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DllImportOnGenericSubOrFunction">
<summary>
  Looks up a localized string similar to &apos;System.Runtime.InteropServices.DllImportAttribute&apos; cannot be applied to a method that is generic or contained in a generic type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DllImportOnInstanceMethod">
<summary>
  Looks up a localized string similar to &apos;System.Runtime.InteropServices.DllImportAttribute&apos; cannot be applied to instance method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DllImportOnInterfaceMethod">
<summary>
  Looks up a localized string similar to &apos;System.Runtime.InteropServices.DllImportAttribute&apos; cannot be applied to interface methods..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DllImportOnNonEmptySubOrFunction">
<summary>
  Looks up a localized string similar to &apos;System.Runtime.InteropServices.DllImportAttribute&apos; cannot be applied to a Sub, Function, or Operator with a non-empty body..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DllImportOnResumableMethod">
<summary>
  Looks up a localized string similar to &apos;System.Runtime.InteropServices.DllImportAttribute&apos; cannot be applied to an Async or Iterator method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DoesntImplementAwaitInterface2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; does not implement &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DoubleToDateConversion">
<summary>
  Looks up a localized string similar to Conversion from &apos;Double&apos; to &apos;Date&apos; requires calling the &apos;Date.FromOADate&apos; method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DTDNotSupported">
<summary>
  Looks up a localized string similar to XML DTDs are not supported..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateAccessCategoryUsed">
<summary>
  Looks up a localized string similar to Only one of &apos;Public&apos;, &apos;Private&apos;, &apos;Protected&apos;, &apos;Friend&apos;, or &apos;Protected Friend&apos; can be specified..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateAddHandlerDef">
<summary>
  Looks up a localized string similar to &apos;AddHandler&apos; is already declared..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateAggrMemberInit1">
<summary>
  Looks up a localized string similar to Multiple initializations of &apos;{0}&apos;.  Fields and properties can be initialized only once in an object initializer expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateAnonTypeMemberName1">
<summary>
  Looks up a localized string similar to Anonymous type member or property &apos;{0}&apos; is already declared..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateConversionCategoryUsed">
<summary>
  Looks up a localized string similar to &apos;Widening&apos; and &apos;Narrowing&apos; cannot be combined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateDefaultProps1">
<summary>
  Looks up a localized string similar to &apos;Default&apos; can be applied to only one property name in a {0}..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateImport1">
<summary>
  Looks up a localized string similar to Namespace or type &apos;{0}&apos; has already been imported..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateInInherits1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be inherited more than once..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateLocals1">
<summary>
  Looks up a localized string similar to Local variable &apos;{0}&apos; is already declared in the current block..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateLocalStatic1">
<summary>
  Looks up a localized string similar to Static local variable &apos;{0}&apos; is already declared..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateLocalTypes3">
<summary>
  Looks up a localized string similar to Cannot embed interop type &apos;{0}&apos; found in both assembly &apos;{1}&apos; and &apos;{2}&apos;. Consider disabling the embedding of interop types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateModifierCategoryUsed">
<summary>
  Looks up a localized string similar to Only one of &apos;NotOverridable&apos;, &apos;MustOverride&apos;, or &apos;Overridable&apos; can be specified..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateNamedImportAlias1">
<summary>
  Looks up a localized string similar to Alias &apos;{0}&apos; is already declared..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateOption1">
<summary>
  Looks up a localized string similar to &apos;Option {0}&apos; statement can only appear once per file..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateParameterSpecifier">
<summary>
  Looks up a localized string similar to Parameter specifier is duplicated..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateParamName1">
<summary>
  Looks up a localized string similar to Parameter already declared with name &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicatePrefix">
<summary>
  Looks up a localized string similar to XML namespace prefix &apos;{0}&apos; is already declared..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateProcDef1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; has multiple definitions with identical signatures..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicatePropertyGet">
<summary>
  Looks up a localized string similar to &apos;Get&apos; is already declared..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicatePropertySet">
<summary>
  Looks up a localized string similar to &apos;Set&apos; is already declared..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateRaiseEventDef">
<summary>
  Looks up a localized string similar to &apos;RaiseEvent&apos; is already declared..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateRawGenericTypeImport1">
<summary>
  Looks up a localized string similar to Generic type &apos;{0}&apos; cannot be imported more than once..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateReference2">
<summary>
  Looks up a localized string similar to Project already has a reference to assembly &apos;{0}&apos;. A second reference to &apos;{1}&apos; cannot be added..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateReferenceStrong">
<summary>
  Looks up a localized string similar to Multiple assemblies with equivalent identity have been imported: &apos;{0}&apos; and &apos;{1}&apos;. Remove one of the duplicate references..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateRemoveHandlerDef">
<summary>
  Looks up a localized string similar to &apos;RemoveHandler&apos; is already declared..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateResourceFileName1">
<summary>
  Looks up a localized string similar to Each linked resource and module must have a unique filename. Filename &apos;{0}&apos; is specified more than once in this assembly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateResourceName1">
<summary>
  Looks up a localized string similar to Resource name &apos;{0}&apos; cannot be used more than once..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateSpecifier">
<summary>
  Looks up a localized string similar to Specifier is duplicated..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateTypeParamName1">
<summary>
  Looks up a localized string similar to Type parameter already declared with name &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateWriteabilityCategoryUsed">
<summary>
  Looks up a localized string similar to &apos;ReadOnly&apos; and &apos;WriteOnly&apos; cannot be combined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_DuplicateXmlAttribute">
<summary>
  Looks up a localized string similar to Duplicate XML attribute &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ElseIfNoMatchingIf">
<summary>
  Looks up a localized string similar to &apos;ElseIf&apos; must be preceded by a matching &apos;If&apos; or &apos;ElseIf&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ElseNoMatchingIf">
<summary>
  Looks up a localized string similar to &apos;Else&apos; must be preceded by a matching &apos;If&apos; or &apos;ElseIf&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EmbeddedExpression">
<summary>
  Looks up a localized string similar to An embedded expression cannot be used here..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EmptyAggregateInitializer">
<summary>
  Looks up a localized string similar to An aggregate collection initializer entry must contain at least one element..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EncNoPIAReference">
<summary>
  Looks up a localized string similar to Cannot continue since the edit includes a reference to an embedded type: &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EncodinglessSyntaxTree">
<summary>
  Looks up a localized string similar to Cannot emit debug information for a source text without encoding..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EncReferenceToAddedMember">
<summary>
  Looks up a localized string similar to Member &apos;{0}&apos; added during the current debug session can only be accessed from within its declaring assembly &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndClassNoClass">
<summary>
  Looks up a localized string similar to &apos;End Class&apos; must be preceded by a matching &apos;Class&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndDisallowedInDllProjects">
<summary>
  Looks up a localized string similar to &apos;End&apos; statement cannot be used in class library projects..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndExternalSource">
<summary>
  Looks up a localized string similar to &apos;#End ExternalSource&apos; must be preceded by a matching &apos;#ExternalSource&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndFunctionExpected">
<summary>
  Looks up a localized string similar to &apos;End Function&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndIfNoMatchingIf">
<summary>
  Looks up a localized string similar to &apos;End If&apos; must be preceded by a matching &apos;If&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndModuleNoModule">
<summary>
  Looks up a localized string similar to &apos;End Module&apos; must be preceded by a matching &apos;Module&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndNamespaceNoNamespace">
<summary>
  Looks up a localized string similar to &apos;End Namespace&apos; must be preceded by a matching &apos;Namespace&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndOperatorExpected">
<summary>
  Looks up a localized string similar to &apos;End Operator&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndOperatorNotAtLineStart">
<summary>
  Looks up a localized string similar to &apos;End Operator&apos; must be the first statement on a line..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndProp">
<summary>
  Looks up a localized string similar to Property missing &apos;End Property&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndRegionNoRegion">
<summary>
  Looks up a localized string similar to &apos;#End Region&apos; must be preceded by a matching &apos;#Region&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndSelectNoSelect">
<summary>
  Looks up a localized string similar to &apos;End Select&apos; must be preceded by a matching &apos;Select Case&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndStructureNoStructure">
<summary>
  Looks up a localized string similar to &apos;End Structure&apos; must be preceded by a matching &apos;Structure&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndSubExpected">
<summary>
  Looks up a localized string similar to &apos;End Sub&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndSyncLockNoSyncLock">
<summary>
  Looks up a localized string similar to &apos;End SyncLock&apos; must be preceded by a matching &apos;SyncLock&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndTryNoTry">
<summary>
  Looks up a localized string similar to &apos;End Try&apos; must be preceded by a matching &apos;Try&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndUsingWithoutUsing">
<summary>
  Looks up a localized string similar to &apos;End Using&apos; must be preceded by a matching &apos;Using&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndWhileNoWhile">
<summary>
  Looks up a localized string similar to &apos;End While&apos; must be preceded by a matching &apos;While&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EndWithWithoutWith">
<summary>
  Looks up a localized string similar to &apos;End With&apos; must be preceded by a matching &apos;With&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EnumNotExpression1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is an Enum type and cannot be used as an expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EqualsOperandIsBad">
<summary>
  Looks up a localized string similar to You must reference at least one range variable on both sides of the &apos;Equals&apos; operator. Range variable(s) {0} must appear on one side of the &apos;Equals&apos; operator, and range variable(s) {1} must appear on the other..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EqualsTypeMismatch">
<summary>
  Looks up a localized string similar to &apos;Equals&apos; cannot compare a value of type &apos;{0}&apos; with a value of type &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ErrorCreatingWin32ResourceFile">
<summary>
  Looks up a localized string similar to Error creating Win32 resources: {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EventAddRemoveByrefParamIllegal">
<summary>
  Looks up a localized string similar to &apos;AddHandler&apos; and &apos;RemoveHandler&apos; method parameters cannot be declared &apos;ByRef&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EventAddRemoveHasOnlyOneParam">
<summary>
  Looks up a localized string similar to &apos;AddHandler&apos; and &apos;RemoveHandler&apos; methods must have exactly one parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EventDelegatesCantBeFunctions">
<summary>
  Looks up a localized string similar to Events cannot be declared with a delegate type that has a return type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EventHandlerSignatureIncompatible2">
<summary>
  Looks up a localized string similar to Method &apos;{0}&apos; cannot handle event &apos;{1}&apos; because they do not have a compatible signature..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EventImplMismatch5">
<summary>
  Looks up a localized string similar to Event &apos;{0}&apos; cannot implement event &apos;{1}&apos; on interface &apos;{2}&apos; because their delegate types &apos;{3}&apos; and &apos;{4}&apos; do not match..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EventImplRemoveHandlerParamWrong">
<summary>
  Looks up a localized string similar to Event &apos;{0}&apos; cannot implement event &apos;{1}&apos; on interface &apos;{2}&apos; because the parameters of their &apos;RemoveHandler&apos; methods do not match..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EventMethodOptionalParamIllegal1">
<summary>
  Looks up a localized string similar to &apos;AddHandler&apos;, &apos;RemoveHandler&apos; and &apos;RaiseEvent&apos; method parameters cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EventNoPIANoBackingMember">
<summary>
  Looks up a localized string similar to Source interface &apos;{0}&apos; is missing method &apos;{1}&apos;, which is required to embed event &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EventNotFound1">
<summary>
  Looks up a localized string similar to Event &apos;{0}&apos; cannot be found..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EventsCantBeFunctions">
<summary>
  Looks up a localized string similar to Events cannot have a return type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EventSourceIsArray">
<summary>
  Looks up a localized string similar to &apos;WithEvents&apos; variables cannot be typed as arrays..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_EventTypeNotDelegate">
<summary>
  Looks up a localized string similar to Events declared with an &apos;As&apos; clause must have a delegate type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExecutableAsDeclaration">
<summary>
  Looks up a localized string similar to Statement cannot appear outside of a method body..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExitDoNotWithinDo">
<summary>
  Looks up a localized string similar to &apos;Exit Do&apos; can only appear inside a &apos;Do&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExitEventMemberNotInvalid">
<summary>
  Looks up a localized string similar to &apos;Exit AddHandler&apos;, &apos;Exit RemoveHandler&apos; and &apos;Exit RaiseEvent&apos; are not valid. Use &apos;Return&apos; to exit from event members..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExitForNotWithinFor">
<summary>
  Looks up a localized string similar to &apos;Exit For&apos; can only appear inside a &apos;For&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExitFuncOfSub">
<summary>
  Looks up a localized string similar to &apos;Exit Function&apos; is not valid in a Sub or Property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExitOperatorNotValid">
<summary>
  Looks up a localized string similar to &apos;Exit Operator&apos; is not valid. Use &apos;Return&apos; to exit an operator..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExitPropNot">
<summary>
  Looks up a localized string similar to &apos;Exit Property&apos; is not valid in a Function or Sub..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExitSelectNotWithinSelect">
<summary>
  Looks up a localized string similar to &apos;Exit Select&apos; can only appear inside a &apos;Select&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExitSubOfFunc">
<summary>
  Looks up a localized string similar to &apos;Exit Sub&apos; is not valid in a Function or Property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExitTryNotWithinTry">
<summary>
  Looks up a localized string similar to &apos;Exit Try&apos; can only appear inside a &apos;Try&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExitWhileNotWithinWhile">
<summary>
  Looks up a localized string similar to &apos;Exit While&apos; can only appear inside a &apos;While&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedAnd">
<summary>
  Looks up a localized string similar to &apos;And&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedArray1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; statement requires an array..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedAs">
<summary>
  Looks up a localized string similar to &apos;As&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedAssignmentOperator">
<summary>
  Looks up a localized string similar to &apos;=&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedAssignmentOperatorInInit">
<summary>
  Looks up a localized string similar to &apos;=&apos; expected (object initializer)..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedBy">
<summary>
  Looks up a localized string similar to &apos;By&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedCase">
<summary>
  Looks up a localized string similar to Statements and labels are not valid between &apos;Select Case&apos; and first &apos;Case&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedComma">
<summary>
  Looks up a localized string similar to Comma expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedConditionalDirective">
<summary>
  Looks up a localized string similar to &apos;If&apos;, &apos;ElseIf&apos;, &apos;Else&apos;, &apos;Const&apos;, &apos;Region&apos;, &apos;ExternalSource&apos;, &apos;ExternalChecksum&apos;, &apos;Enable&apos;, &apos;Disable&apos;, &apos;End&apos; or &apos;R&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedContinueKind">
<summary>
  Looks up a localized string similar to &apos;Continue&apos; must be followed by &apos;Do&apos;, &apos;For&apos; or &apos;While&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedDeclaration">
<summary>
  Looks up a localized string similar to Declaration expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedDiv">
<summary>
  Looks up a localized string similar to Expected &apos;/&apos; for XML end tag..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedDot">
<summary>
  Looks up a localized string similar to &apos;.&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedDotAfterGlobalNameSpace">
<summary>
  Looks up a localized string similar to &apos;Global&apos; must be followed by &apos;.&apos; and an identifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedDotAfterMyBase">
<summary>
  Looks up a localized string similar to &apos;MyBase&apos; must be followed by &apos;.&apos; and an identifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedDotAfterMyClass">
<summary>
  Looks up a localized string similar to &apos;MyClass&apos; must be followed by &apos;.&apos; and an identifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndClass">
<summary>
  Looks up a localized string similar to &apos;Class&apos; statement must end with a matching &apos;End Class&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndExternalSource">
<summary>
  Looks up a localized string similar to &apos;#ExternalSource&apos; statement must end with a matching &apos;#End ExternalSource&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndIf">
<summary>
  Looks up a localized string similar to &apos;If&apos; must end with a matching &apos;End If&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndModule">
<summary>
  Looks up a localized string similar to &apos;Module&apos; statement must end with a matching &apos;End Module&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndNamespace">
<summary>
  Looks up a localized string similar to &apos;Namespace&apos; statement must end with a matching &apos;End Namespace&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndOfExpression">
<summary>
  Looks up a localized string similar to End of expression expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndRegion">
<summary>
  Looks up a localized string similar to &apos;#Region&apos; statement must end with a matching &apos;#End Region&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndSelect">
<summary>
  Looks up a localized string similar to &apos;Select Case&apos; must end with a matching &apos;End Select&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndStructure">
<summary>
  Looks up a localized string similar to &apos;Structure&apos; statement must end with a matching &apos;End Structure&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndSyncLock">
<summary>
  Looks up a localized string similar to &apos;SyncLock&apos; statement must end with a matching &apos;End SyncLock&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndTry">
<summary>
  Looks up a localized string similar to &apos;Try&apos; must end with a matching &apos;End Try&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndUsing">
<summary>
  Looks up a localized string similar to &apos;Using&apos; must end with a matching &apos;End Using&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndWhile">
<summary>
  Looks up a localized string similar to &apos;While&apos; must end with a matching &apos;End While&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEndWith">
<summary>
  Looks up a localized string similar to &apos;With&apos; must end with a matching &apos;End With&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEOS">
<summary>
  Looks up a localized string similar to End of statement expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEQ">
<summary>
  Looks up a localized string similar to &apos;=&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedEquals">
<summary>
  Looks up a localized string similar to &apos;Equals&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedExitKind">
<summary>
  Looks up a localized string similar to &apos;Exit&apos; must be followed by &apos;Sub&apos;, &apos;Function&apos;, &apos;Property&apos;, &apos;Do&apos;, &apos;For&apos;, &apos;While&apos;, &apos;Select&apos;, or &apos;Try&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedExpression">
<summary>
  Looks up a localized string similar to Expression expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedForOptionStmt">
<summary>
  Looks up a localized string similar to &apos;Option&apos; must be followed by &apos;Compare&apos;, &apos;Explicit&apos;, &apos;Infer&apos;, or &apos;Strict&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedFrom">
<summary>
  Looks up a localized string similar to &apos;From&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedGreater">
<summary>
  Looks up a localized string similar to &apos;&gt;&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedIdentifier">
<summary>
  Looks up a localized string similar to Identifier expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedIdentifierOrGroup">
<summary>
  Looks up a localized string similar to &apos;Group&apos; or an identifier expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedIn">
<summary>
  Looks up a localized string similar to &apos;In&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedInOrEq">
<summary>
  Looks up a localized string similar to &apos;In&apos; or &apos;=&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedIntLiteral">
<summary>
  Looks up a localized string similar to Integer constant expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedInto">
<summary>
  Looks up a localized string similar to &apos;Into&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedJoin">
<summary>
  Looks up a localized string similar to &apos;Join&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedLbrace">
<summary>
  Looks up a localized string similar to &apos;{&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedLoop">
<summary>
  Looks up a localized string similar to &apos;Do&apos; must end with a matching &apos;Loop&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedLparen">
<summary>
  Looks up a localized string similar to &apos;(&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedLT">
<summary>
  Looks up a localized string similar to Expected beginning &apos;&lt;&apos; for an XML tag..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedMinus">
<summary>
  Looks up a localized string similar to &apos;-&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedNamedArgument">
<summary>
  Looks up a localized string similar to Named argument expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedNext">
<summary>
  Looks up a localized string similar to &apos;For&apos; must end with a matching &apos;Next&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedOn">
<summary>
  Looks up a localized string similar to &apos;On&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedOptional">
<summary>
  Looks up a localized string similar to &apos;Optional&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedOptionCompare">
<summary>
  Looks up a localized string similar to &apos;Compare&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedProcedure">
<summary>
  Looks up a localized string similar to Expression is not a method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedQualifiedNameInInit">
<summary>
  Looks up a localized string similar to Name of field or property being initialized in an object initializer must start with &apos;.&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedQueryableSource">
<summary>
  Looks up a localized string similar to Expression of type &apos;{0}&apos; is not queryable. Make sure you are not missing an assembly reference and/or namespace import for the LINQ provider..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedQuote">
<summary>
  Looks up a localized string similar to Expected matching closing double quote for XML attribute value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedRbrace">
<summary>
  Looks up a localized string similar to &apos;}&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedRelational">
<summary>
  Looks up a localized string similar to Relational operator expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedResumeOrGoto">
<summary>
  Looks up a localized string similar to &apos;Resume&apos; or &apos;GoTo&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedRparen">
<summary>
  Looks up a localized string similar to &apos;)&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedSColon">
<summary>
  Looks up a localized string similar to Expected closing &apos;;&apos; for XML entity..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedSingleScript">
<summary>
  Looks up a localized string similar to Expected a single script (.vbx file).
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedSpecifier">
<summary>
  Looks up a localized string similar to Expected one of &apos;Dim&apos;, &apos;Const&apos;, &apos;Public&apos;, &apos;Private&apos;, &apos;Protected&apos;, &apos;Friend&apos;, &apos;Shadows&apos;, &apos;ReadOnly&apos; or &apos;Shared&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedSQuote">
<summary>
  Looks up a localized string similar to Expected matching closing single quote for XML attribute value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedStringLiteral">
<summary>
  Looks up a localized string similar to String constant expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedSubFunction">
<summary>
  Looks up a localized string similar to &apos;Sub&apos; or &apos;Function&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedSubOrFunction">
<summary>
  Looks up a localized string similar to &apos;Sub&apos; or &apos;Function&apos; expected after &apos;Delegate&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedWarningKeyword">
<summary>
  Looks up a localized string similar to &apos;Warning&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedXmlBeginEmbedded">
<summary>
  Looks up a localized string similar to Expected &apos;%=&apos; at start of an embedded expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedXmlEndCData">
<summary>
  Looks up a localized string similar to Expected closing &apos;]]&gt;&apos; for XML CDATA section..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedXmlEndComment">
<summary>
  Looks up a localized string similar to Expected closing &apos;--&gt;&apos; for XML comment..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedXmlEndEmbedded">
<summary>
  Looks up a localized string similar to Expected closing &apos;%&gt;&apos; for embedded expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedXmlEndPI">
<summary>
  Looks up a localized string similar to Expected closing &apos;?&gt;&apos; for XML processor instruction..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedXmlName">
<summary>
  Looks up a localized string similar to XML name expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedXmlns">
<summary>
  Looks up a localized string similar to Namespace declaration must start with &apos;xmlns&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpectedXmlWhiteSpace">
<summary>
  Looks up a localized string similar to Missing required white space..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExportedTypeConflictsWithDeclaration">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; exported from module &apos;{1}&apos; conflicts with type declared in primary module of this assembly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExportedTypesConflict">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; exported from module &apos;{1}&apos; conflicts with type &apos;{2}&apos; exported from module &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpressionDoesntHaveName">
<summary>
  Looks up a localized string similar to This expression does not have a name..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpressionOverflow1">
<summary>
  Looks up a localized string similar to Constant expression not representable in type &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExpressionTreeNotSupported">
<summary>
  Looks up a localized string similar to Expression cannot be converted into an expression tree..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExprTreeNoLateBind">
<summary>
  Looks up a localized string similar to Late binding operations cannot be converted to an expression tree..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExprTreeNoMultiDimArrayCreation">
<summary>
  Looks up a localized string similar to Multi-dimensional array cannot be converted to an expression tree..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExtensionAttributeInvalid">
<summary>
  Looks up a localized string similar to The custom-designed version of &apos;System.Runtime.CompilerServices.ExtensionAttribute&apos; found by the compiler is not valid. Its attribute usage flags must be set to allow assemblies, classes, and methods..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExtensionMethodCannotBeLateBound">
<summary>
  Looks up a localized string similar to Late-bound extension methods are not supported..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExtensionMethodNoParams">
<summary>
  Looks up a localized string similar to Extension methods must declare at least one parameter. The first parameter specifies which type to extend..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExtensionMethodNotInModule">
<summary>
  Looks up a localized string similar to Extension methods can be defined only in modules..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExtensionMethodOptionalFirstArg">
<summary>
  Looks up a localized string similar to &apos;Optional&apos; cannot be applied to the first parameter of an extension method. The first parameter specifies which type to extend..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExtensionMethodOverloadCandidate2">
<summary>
  Looks up a localized string similar to 
    Extension method &apos;{0}&apos; defined in &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExtensionMethodOverloadCandidate3">
<summary>
  Looks up a localized string similar to 
    Extension method &apos;{0}&apos; defined in &apos;{1}&apos;: {2}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExtensionMethodParamArrayFirstArg">
<summary>
  Looks up a localized string similar to &apos;ParamArray&apos; cannot be applied to the first parameter of an extension method. The first parameter specifies which type to extend..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExtensionMethodUncallable1">
<summary>
  Looks up a localized string similar to Extension method &apos;{0}&apos; has type constraints that can never be satisfied..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExtensionOnlyAllowedOnModuleSubOrFunction">
<summary>
  Looks up a localized string similar to &apos;Extension&apos; attribute can be applied only to &apos;Module&apos;, &apos;Sub&apos;, or &apos;Function&apos; declarations..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExtraNextVariable">
<summary>
  Looks up a localized string similar to &apos;Next&apos; statement names more variables than there are matching &apos;For&apos; statements..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ExtraSpecifiers">
<summary>
  Looks up a localized string similar to Specifiers valid only at the beginning of a declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FailureSigningAssembly">
<summary>
  Looks up a localized string similar to Error signing assembly &apos;{0}&apos;: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FieldHasMultipleDistinctConstantValues">
<summary>
  Looks up a localized string similar to The field has multiple distinct constant values..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FieldOfValueFieldOfMarshalByRef3">
<summary>
  Looks up a localized string similar to Cannot refer to &apos;{0}&apos; because it is a member of the value-typed field &apos;{1}&apos; of class &apos;{2}&apos; which has &apos;System.MarshalByRefObject&apos; as a base class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FileAttributeNotAssemblyOrModule">
<summary>
  Looks up a localized string similar to &apos;Assembly&apos; or &apos;Module&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FileNotFound">
<summary>
  Looks up a localized string similar to file &apos;{0}&apos; could not be found.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FinallyAfterFinally">
<summary>
  Looks up a localized string similar to &apos;Finally&apos; can only appear once in a &apos;Try&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FinallyNoMatchingTry">
<summary>
  Looks up a localized string similar to &apos;Finally&apos; cannot appear outside a &apos;Try&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ForCtlVarArraySizesSpecified">
<summary>
  Looks up a localized string similar to Array declared as for loop control variable cannot be declared with an initial size..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ForEachAmbiguousIEnumerable1">
<summary>
  Looks up a localized string similar to &apos;For Each&apos; on type &apos;{0}&apos; is ambiguous because the type implements multiple instantiations of &apos;System.Collections.Generic.IEnumerable(Of T)&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ForEachCollectionDesignPattern1">
<summary>
  Looks up a localized string similar to Expression is of type &apos;{0}&apos;, which is not a collection type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ForIndexInUse1">
<summary>
  Looks up a localized string similar to For loop control variable &apos;{0}&apos; already in use by an enclosing For loop..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ForLoopOperatorRequired2">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; must define operator &apos;{1}&apos; to be used in a &apos;For&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ForLoopType1">
<summary>
  Looks up a localized string similar to &apos;For&apos; loop control variable cannot be of type &apos;{0}&apos; because the type does not support the required operators..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ForwardedTypeConflictsWithDeclaration">
<summary>
  Looks up a localized string similar to Forwarded type &apos;{0}&apos; conflicts with type declared in primary module of this assembly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ForwardedTypeConflictsWithExportedType">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; forwarded to assembly &apos;{1}&apos; conflicts with type &apos;{2}&apos; exported from module &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ForwardedTypesConflict">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; forwarded to assembly &apos;{1}&apos; conflicts with type &apos;{2}&apos; forwarded to assembly &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ForwardedTypeUnavailable3">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; in assembly &apos;{1}&apos; has been forwarded to assembly &apos;{2}&apos;. Either a reference to &apos;{2}&apos; is missing from your project or the type &apos;{0}&apos; is missing from assembly &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FriendAssemblyBadAccessOverride2">
<summary>
  Looks up a localized string similar to Member &apos;{0}&apos; cannot override member &apos;{1}&apos; defined in another assembly/project because the access modifier &apos;Protected Friend&apos; expands accessibility. Use &apos;Protected&apos; instead..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FriendAssemblyBadArguments">
<summary>
  Looks up a localized string similar to Friend assembly reference &apos;{0}&apos; is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FriendAssemblyNameInvalid">
<summary>
  Looks up a localized string similar to Friend declaration &apos;{0}&apos; is invalid and cannot be resolved..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FriendAssemblyStrongNameRequired">
<summary>
  Looks up a localized string similar to Friend assembly reference &apos;{0}&apos; is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FriendRefNotEqualToThis">
<summary>
  Looks up a localized string similar to Friend access was granted by &apos;{0}&apos;, but the public key of the output assembly does not match that specified by the attribute in the granting assembly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FriendRefSigningMismatch">
<summary>
  Looks up a localized string similar to Friend access was granted by &apos;{0}&apos;, but the strong name signing state of the output assembly does not match that of the granting assembly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FullWidthAsXmlDelimiter">
<summary>
  Looks up a localized string similar to Full width characters are not valid as XML delimiters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_FunctionResultCannotBeIndexed1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; has no parameters and its return type cannot be indexed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_GeneralProjectImportsError3">
<summary>
  Looks up a localized string similar to Error in project-level import &apos;{0}&apos; at &apos;{1}&apos; : {2}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_GenericArgsOnAttributeSpecifier">
<summary>
  Looks up a localized string similar to Type arguments are not valid because attributes cannot be generic..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_GenericClassCannotInheritAttr">
<summary>
  Looks up a localized string similar to Classes that are generic or contained in a generic type cannot inherit from an attribute class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_GenericConstraintNotSatisfied2">
<summary>
  Looks up a localized string similar to Type argument &apos;{0}&apos; does not inherit from or implement the constraint type &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_GenericParamBase2">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; cannot inherit from a type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_GenericParamsOnInvalidMember">
<summary>
  Looks up a localized string similar to Type parameters cannot be specified on this declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_GenericSubMainsFound1">
<summary>
  Looks up a localized string similar to None of the accessible &apos;Main&apos; methods with the appropriate signatures found in &apos;{0}&apos; can be the startup method since they are all either generic or nested in generic types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_GotoIntoFor">
<summary>
  Looks up a localized string similar to &apos;GoTo {0}&apos; is not valid because &apos;{0}&apos; is inside a &apos;For&apos; or &apos;For Each&apos; statement that does not contain this statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_GotoIntoSyncLock">
<summary>
  Looks up a localized string similar to &apos;GoTo {0}&apos; is not valid because &apos;{0}&apos; is inside a &apos;SyncLock&apos; statement that does not contain this statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_GotoIntoTryHandler">
<summary>
  Looks up a localized string similar to &apos;GoTo {0}&apos; is not valid because &apos;{0}&apos; is inside a &apos;Try&apos;, &apos;Catch&apos; or &apos;Finally&apos; statement that does not contain this statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_GotoIntoUsing">
<summary>
  Looks up a localized string similar to &apos;GoTo {0}&apos; is not valid because &apos;{0}&apos; is inside a &apos;Using&apos; statement that does not contain this statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_GotoIntoWith">
<summary>
  Looks up a localized string similar to &apos;GoTo {0}&apos; is not valid because &apos;{0}&apos; is inside a &apos;With&apos; statement that does not contain this statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_HandlesInvalidOnGenericMethod">
<summary>
  Looks up a localized string similar to Generic methods cannot use &apos;Handles&apos; clause..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_HandlesSyntaxInClass">
<summary>
  Looks up a localized string similar to &apos;Handles&apos; in classes must specify a &apos;WithEvents&apos; variable, &apos;MyBase&apos;, &apos;MyClass&apos; or &apos;Me&apos; qualified with a single identifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_HandlesSyntaxInModule">
<summary>
  Looks up a localized string similar to &apos;Handles&apos; in modules must specify a &apos;WithEvents&apos; variable qualified with a single identifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IconFileAndWin32ResFile">
<summary>
  Looks up a localized string similar to cannot specify both /win32icon and /win32resource.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IdentityDirectCastForFloat">
<summary>
  Looks up a localized string similar to Using DirectCast operator to cast a floating-point value to the same type is not supported..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IdentNotMemberOfInterface4">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot implement &apos;{1}&apos; because there is no matching {2} on interface &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IfNoType">
<summary>
  Looks up a localized string similar to Cannot infer a common type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IfNoTypeObjectDisallowed">
<summary>
  Looks up a localized string similar to Cannot infer a common type, and Option Strict On does not allow &apos;Object&apos; to be assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IfTooManyTypesObjectDisallowed">
<summary>
  Looks up a localized string similar to Cannot infer a common type because more than one type is possible..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalAttributeInXmlDecl">
<summary>
  Looks up a localized string similar to XML declaration does not allow attribute &apos;{0}{1}{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalBaseTypeReferences3">
<summary>
  Looks up a localized string similar to Inherits clause of {0} &apos;{1}&apos; causes cyclic dependency: {2}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalCallOrIndex">
<summary>
  Looks up a localized string similar to Illegal call expression or index expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalChar">
<summary>
  Looks up a localized string similar to Character is not valid..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalCharConstant">
<summary>
  Looks up a localized string similar to Character constant must contain exactly one character..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalCondTypeInIIF">
<summary>
  Looks up a localized string similar to First operand in a binary &apos;If&apos; expression must be nullable or a reference type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalDefaultNamespace">
<summary>
  Looks up a localized string similar to Namespace declaration with prefix cannot have an empty value inside an XML literal..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalOperandInIIFConversion">
<summary>
  Looks up a localized string similar to Cannot infer a common type for the second and third operands of the &apos;If&apos; operator. One must have a widening conversion to the other..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalOperandInIIFConversion2">
<summary>
  Looks up a localized string similar to Cannot infer a common type for the first and second operands of the binary &apos;If&apos; operator. One must have a widening conversion to the other..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalOperandInIIFCount">
<summary>
  Looks up a localized string similar to &apos;If&apos; operator requires either two or three operands..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalOperandInIIFName">
<summary>
  Looks up a localized string similar to &apos;If&apos; operands cannot be named arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalProcessingInstructionName">
<summary>
  Looks up a localized string similar to XML processing instruction name &apos;{0}&apos; is not valid..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalXmlCommentChar">
<summary>
  Looks up a localized string similar to Character sequence &apos;--&apos; is not allowed in an XML comment..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalXmlNameChar">
<summary>
  Looks up a localized string similar to Character &apos;{0}&apos; ({1}) is not allowed in an XML name..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalXmlnsPrefix">
<summary>
  Looks up a localized string similar to Element names cannot use the &apos;xmlns&apos; prefix..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalXmlStartNameChar">
<summary>
  Looks up a localized string similar to Character &apos;{0}&apos; ({1}) is not allowed at the beginning of an XML name..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IllegalXmlWhiteSpace">
<summary>
  Looks up a localized string similar to White space cannot appear here..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ImplementationMustBePrivate2">
<summary>
  Looks up a localized string similar to Method &apos;{0}&apos; must be declared &apos;Private&apos; in order to implement partial method &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ImplementsGenericParam">
<summary>
  Looks up a localized string similar to Type parameter not allowed in &apos;Implements&apos; clause..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ImplementsOnNew">
<summary>
  Looks up a localized string similar to &apos;Sub New&apos; cannot implement interface members..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ImplementsStmtWrongOrder">
<summary>
  Looks up a localized string similar to &apos;Implements&apos; statements must follow any &apos;Inherits&apos; statement and precede all declarations in a class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ImplementsWithConstraintMismatch3">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot implement &apos;{1}.{2}&apos; because they differ by type parameter constraints..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ImportAliasConflictsWithType2">
<summary>
  Looks up a localized string similar to Imports alias &apos;{0}&apos; conflicts with &apos;{1}&apos; declared in the root namespace..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ImportsMustBeFirst">
<summary>
  Looks up a localized string similar to &apos;Imports&apos; statements must precede any declarations..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InAccessibleCoClass3">
<summary>
  Looks up a localized string similar to Implementing class &apos;{0}&apos; for interface &apos;{1}&apos; is not accessible in this context because it is &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InaccessibleMember3">
<summary>
  Looks up a localized string similar to &apos;{0}.{1}&apos; is not accessible in this context because it is &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InAccessibleOverridingMethod5">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; in class &apos;{1}&apos; cannot override &apos;{2}&apos; in class &apos;{3}&apos; because an intermediate class &apos;{4}&apos; overrides &apos;{2}&apos; in class &apos;{3}&apos; but is not accessible..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InaccessibleReturnTypeOfMember2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not accessible in this context because the return type is not accessible..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InaccessibleSymbol2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not accessible in this context because it is &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IndexedNotArrayOrProc">
<summary>
  Looks up a localized string similar to Expression is not an array or a method, and cannot have an argument list..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IndirectUnreferencedAssembly4">
<summary>
  Looks up a localized string similar to Project &apos;{0}&apos; makes an indirect reference to assembly &apos;{1}&apos;, which contains &apos;{2}&apos;. Add a file reference to &apos;{3}&apos; to your project..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InferringNonArrayType1">
<summary>
  Looks up a localized string similar to Variable cannot be initialized with non-array type &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InheritanceAccessMismatch5">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot inherit from {1} &apos;{2}&apos; because it expands the access of the base {1} to {3} &apos;{4}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InheritanceAccessMismatchOutside3">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot inherit from {1} &apos;{2}&apos; because it expands the access of the base {1} outside the assembly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InheritanceCycle1">
<summary>
  Looks up a localized string similar to Class &apos;{0}&apos; cannot inherit from itself: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InheritanceCycleInImportedType1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; is not supported because it either directly or indirectly inherits from itself..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InheritsFrom2">
<summary>
  Looks up a localized string similar to 
    &apos;{0}&apos; inherits from &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InheritsFromCantInherit3">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot inherit from {2} &apos;{1}&apos; because &apos;{1}&apos; is declared &apos;NotInheritable&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InheritsFromNonClass">
<summary>
  Looks up a localized string similar to Classes can inherit only from other classes..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InheritsFromNonInterface">
<summary>
  Looks up a localized string similar to Interface can inherit only from another interface..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InheritsFromRestrictedType1">
<summary>
  Looks up a localized string similar to Inheriting from &apos;{0}&apos; is not valid..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InheritsStmtWrongOrder">
<summary>
  Looks up a localized string similar to &apos;Inherits&apos; statement must precede all declarations in a class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InheritsTypeArgAccessMismatch7">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot inherit from {1} &apos;{2}&apos; because it expands the access of type &apos;{3}&apos; to {4} &apos;{5}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InheritsTypeArgAccessMismatchOutside5">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot inherit from {1} &apos;{2}&apos; because it expands the access of type &apos;{3}&apos; outside the assembly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InitializedExpandedProperty">
<summary>
  Looks up a localized string similar to Expanded Properties cannot be initialized..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InitializerExpected">
<summary>
  Looks up a localized string similar to Initializer expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InitializerInStruct">
<summary>
  Looks up a localized string similar to Initializers on structure members are valid only for &apos;Shared&apos; members and constants..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InitializerTooFewElements1">
<summary>
  Looks up a localized string similar to Array initializer is missing {0} elements..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InitializerTooManyElements1">
<summary>
  Looks up a localized string similar to Array initializer has {0} too many elements..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InitWithExplicitArraySizes">
<summary>
  Looks up a localized string similar to Explicit initialization is not permitted for arrays declared with explicit bounds..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InitWithMultipleDeclarators">
<summary>
  Looks up a localized string similar to Explicit initialization is not permitted with multiple variables declared with a single type specifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InReferencedAssembly">
<summary>
  Looks up a localized string similar to There is an error in a referenced assembly &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IntegralToCharTypeMismatch1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; values cannot be converted to &apos;Char&apos;. Use &apos;Microsoft.VisualBasic.ChrW&apos; to interpret a numeric value as a Unicode character or first convert it to &apos;String&apos; to produce a digit..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterfaceBaseUnifiesWithBase4">
<summary>
  Looks up a localized string similar to Cannot inherit interface &apos;{0}&apos; because the interface &apos;{1}&apos; from which it inherits could be identical to interface &apos;{2}&apos; from which the interface &apos;{3}&apos; inherits for some type arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterfaceCantUseEventSpecifier1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid on an interface event declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterfaceCycle1">
<summary>
  Looks up a localized string similar to Interface &apos;{0}&apos; cannot inherit from itself: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterfaceEventCantUse1">
<summary>
  Looks up a localized string similar to Events in interfaces cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterfaceImplementedTwice1">
<summary>
  Looks up a localized string similar to Interface &apos;{0}&apos; can be implemented only once by this type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterfaceMemberSyntax">
<summary>
  Looks up a localized string similar to Interface members must be methods, properties, events, or type definitions..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterfaceNoDefault1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be indexed because it has no default property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterfaceNotExpression1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is an interface type and cannot be used as an expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterfaceNotImplemented1">
<summary>
  Looks up a localized string similar to Interface &apos;{0}&apos; is not implemented by this class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterfacePossiblyImplTwice2">
<summary>
  Looks up a localized string similar to Cannot implement interface &apos;{0}&apos; because its implementation could conflict with the implementation of another implemented interface &apos;{1}&apos; for some type arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterfaceUnifiesWithBase3">
<summary>
  Looks up a localized string similar to Cannot inherit interface &apos;{0}&apos; because it could be identical to interface &apos;{1}&apos; from which the interface &apos;{2}&apos; inherits for some type arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterfaceUnifiesWithInterface2">
<summary>
  Looks up a localized string similar to Cannot inherit interface &apos;{0}&apos; because it could be identical to interface &apos;{1}&apos; for some type arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InteropMethodWithBody1">
<summary>
  Looks up a localized string similar to Embedded interop method &apos;{0}&apos; contains a body..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterpolatedStringFactoryError">
<summary>
  Looks up a localized string similar to There were one or more errors emitting a call to {0}.{1}. Method or its return type may be missing or malformed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterpolationAlignmentOutOfRange">
<summary>
  Looks up a localized string similar to Alignment value is outside of the supported range..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InterpolationFormatWhitespace">
<summary>
  Looks up a localized string similar to Format specifier may not contain trailing whitespace..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidAssemblyAttribute1">
<summary>
  Looks up a localized string similar to Attribute &apos;{0}&apos; cannot be applied to an assembly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidAssemblyCulture">
<summary>
  Looks up a localized string similar to Assembly culture strings may not contain embedded NUL characters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidAssemblyCultureForExe">
<summary>
  Looks up a localized string similar to Executables cannot be satellite assemblies; culture should always be empty.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidAssemblyName">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not a valid value for /moduleassemblyname.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidAsyncIteratorModifiers">
<summary>
  Looks up a localized string similar to &apos;Async&apos; and &apos;Iterator&apos; modifiers cannot be used together..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidAttributeUsage2">
<summary>
  Looks up a localized string similar to Attribute &apos;{0}&apos; cannot be applied to &apos;{1}&apos; because the attribute is not valid on this declaration type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidAttributeUsageOnAccessor">
<summary>
  Looks up a localized string similar to Attribute &apos;{0}&apos; cannot be applied to &apos;{1}&apos; of &apos;{2}&apos; because the attribute is not valid on this declaration type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidAttributeValue1">
<summary>
  Looks up a localized string similar to Attribute value is not valid; expecting &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidAttributeValue2">
<summary>
  Looks up a localized string similar to Attribute value is not valid; expecting &apos;{0}&apos; or &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidCoClass1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used as an implementing class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidConstructorCall">
<summary>
  Looks up a localized string similar to Constructor call is valid only as the first statement in an instance constructor..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidDate">
<summary>
  Looks up a localized string similar to Date constant is not valid..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidDebugInformationFormat">
<summary>
  Looks up a localized string similar to Invalid debug information format: {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidEndAddHandler">
<summary>
  Looks up a localized string similar to &apos;End AddHandler&apos; must be preceded by a matching &apos;AddHandler&apos; declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidEndEnum">
<summary>
  Looks up a localized string similar to &apos;End Enum&apos; must be preceded by a matching &apos;Enum&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidEndEvent">
<summary>
  Looks up a localized string similar to &apos;End Event&apos; must be preceded by a matching &apos;Custom Event&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidEndFunction">
<summary>
  Looks up a localized string similar to &apos;End Function&apos; must be preceded by a matching &apos;Function&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidEndGet">
<summary>
  Looks up a localized string similar to &apos;End Get&apos; must be preceded by a matching &apos;Get&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidEndInterface">
<summary>
  Looks up a localized string similar to &apos;End Interface&apos; must be preceded by a matching &apos;Interface&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidEndOperator">
<summary>
  Looks up a localized string similar to &apos;End Operator&apos; must be preceded by a matching &apos;Operator&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidEndProperty">
<summary>
  Looks up a localized string similar to &apos;End Property&apos; must be preceded by a matching &apos;Property&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidEndRaiseEvent">
<summary>
  Looks up a localized string similar to &apos;End RaiseEvent&apos; must be preceded by a matching &apos;RaiseEvent&apos; declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidEndRemoveHandler">
<summary>
  Looks up a localized string similar to &apos;End RemoveHandler&apos; must be preceded by a matching &apos;RemoveHandler&apos; declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidEndSet">
<summary>
  Looks up a localized string similar to &apos;End Set&apos; must be preceded by a matching &apos;Set&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidEndSub">
<summary>
  Looks up a localized string similar to &apos;End Sub&apos; must be preceded by a matching &apos;Sub&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidEnumBase">
<summary>
  Looks up a localized string similar to Enums must be declared as an integral type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidFileAlignment">
<summary>
  Looks up a localized string similar to Invalid file section alignment &apos;{0}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidFormatForGuidForOption">
<summary>
  Looks up a localized string similar to Command-line syntax error: Invalid Guid format &apos;{0}&apos; for option &apos;{1}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidFormatSpecifier">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not a valid format specifier.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidHandles">
<summary>
  Looks up a localized string similar to &apos;Handles&apos; is not valid on operator declarations..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidImplements">
<summary>
  Looks up a localized string similar to &apos;Implements&apos; is not valid on operator declarations..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidImplicitMeReference">
<summary>
  Looks up a localized string similar to Implicit reference to object under construction is not valid when calling another constructor..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidImplicitVar">
<summary>
  Looks up a localized string similar to Implicit variable &apos;{0}&apos; is invalid because of &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidInNamespace">
<summary>
  Looks up a localized string similar to Statement is not valid in a namespace..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidLambdaModifier">
<summary>
  Looks up a localized string similar to &apos;Only the &apos;Async&apos; or &apos;Iterator&apos; modifier is valid on a lambda..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidLiteralExponent">
<summary>
  Looks up a localized string similar to Exponent is not valid..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidMe">
<summary>
  Looks up a localized string similar to &apos;Me&apos; cannot be the target of an assignment..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidMeReference">
<summary>
  Looks up a localized string similar to Reference to object under construction is not valid when calling another constructor..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidModuleAttribute1">
<summary>
  Looks up a localized string similar to Attribute &apos;{0}&apos; cannot be applied to a module..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidMultipleAttributeUsage1">
<summary>
  Looks up a localized string similar to Attribute &apos;{0}&apos; cannot be applied multiple times..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidMultipleAttributeUsageInNetModule2">
<summary>
  Looks up a localized string similar to Attribute &apos;{0}&apos; in &apos;{1}&apos; cannot be applied multiple times..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidNameOfSubExpression">
<summary>
  Looks up a localized string similar to This sub-expression cannot be used inside NameOf argument..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidNewInType">
<summary>
  Looks up a localized string similar to &apos;New&apos; is not valid in this context..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidNonSerializedUsage">
<summary>
  Looks up a localized string similar to &apos;NonSerialized&apos; attribute will not have any effect on this member because its containing class is not exposed as &apos;Serializable&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidOptionalParameterUsage1">
<summary>
  Looks up a localized string similar to Attribute &apos;{0}&apos; cannot be applied to a method with optional parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidOptionCompare">
<summary>
  Looks up a localized string similar to &apos;Option Compare&apos; must be followed by &apos;Text&apos; or &apos;Binary&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidOptionExplicit">
<summary>
  Looks up a localized string similar to &apos;Option Explicit&apos; can be followed only by &apos;On&apos; or &apos;Off&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidOptionInfer">
<summary>
  Looks up a localized string similar to &apos;Option Infer&apos; can be followed only by &apos;On&apos; or &apos;Off&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidOptionStrict">
<summary>
  Looks up a localized string similar to &apos;Option Strict&apos; can be followed only by &apos;On&apos; or &apos;Off&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidOptionStrictCustom">
<summary>
  Looks up a localized string similar to Option Strict Custom can only be used as an option to the command-line compiler (vbc.exe)..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidOutputName">
<summary>
  Looks up a localized string similar to Invalid output name: {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidOverrideDueToReturn2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot override &apos;{1}&apos; because they differ by their return types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidParameterSyntax">
<summary>
  Looks up a localized string similar to Comma or &apos;)&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidPathMap">
<summary>
  Looks up a localized string similar to The pathmap option was incorrectly formatted..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidSignaturePublicKey">
<summary>
  Looks up a localized string similar to Invalid signature public key specified in AssemblySignatureKeyAttribute..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidSpecifierOnNonConversion1">
<summary>
  Looks up a localized string similar to Only conversion operators can be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidStructMemberNoPIA1">
<summary>
  Looks up a localized string similar to Embedded interop structure &apos;{0}&apos; can contain only public instance fields..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InValidSubMainsFound1">
<summary>
  Looks up a localized string similar to No accessible &apos;Main&apos; method with an appropriate signature was found in &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidSubsystemVersion">
<summary>
  Looks up a localized string similar to The value &apos;{0}&apos; is not a valid subsystem version. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidSwitchValue">
<summary>
  Looks up a localized string similar to the value &apos;{1}&apos; is invalid for option &apos;{0}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidTypeForAliasesImport2">
<summary>
  Looks up a localized string similar to &apos;{1}&apos; for the Imports alias to &apos;{0}&apos; does not refer to a Namespace, Class, Structure, Interface, Enum or Module..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidUseOfCustomModifier">
<summary>
  Looks up a localized string similar to &apos;Custom&apos; modifier can only be used immediately before an &apos;Event&apos; declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidUseOfKeyword">
<summary>
  Looks up a localized string similar to Keyword is not valid as an identifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidVersionFormat">
<summary>
  Looks up a localized string similar to The specified version string does not conform to the required format - major[.minor[.build|*[.revision|*]]].
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvalidVersionFormat2">
<summary>
  Looks up a localized string similar to The specified version string does not conform to the recommended format - major.minor.build.revision.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvInsideBlock">
<summary>
  Looks up a localized string similar to Statement is not valid inside &apos;{0}&apos; block..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvInsideEndsEnum">
<summary>
  Looks up a localized string similar to Statement cannot appear within an Enum body. End of Enum assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvInsideEndsEvent">
<summary>
  Looks up a localized string similar to Statement cannot appear within an event body. End of event assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvInsideEndsInterface">
<summary>
  Looks up a localized string similar to Statement cannot appear within an interface body. End of interface assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvInsideEndsProc">
<summary>
  Looks up a localized string similar to Statement cannot appear within a method body. End of method assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvInsideEndsProperty">
<summary>
  Looks up a localized string similar to Statement cannot appear within a property body. End of property assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvInsideEnum">
<summary>
  Looks up a localized string similar to Statement cannot appear within an Enum body..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvInsideInterface">
<summary>
  Looks up a localized string similar to Statement cannot appear within an interface body..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvInsideProc">
<summary>
  Looks up a localized string similar to Statement is not valid inside a method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_InvOutsideProc">
<summary>
  Looks up a localized string similar to Labels are not valid outside methods..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IsNestedIn2">
<summary>
  Looks up a localized string similar to 
    &apos;{0}&apos; is nested in &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IsNotOperatorGenericParam1">
<summary>
  Looks up a localized string similar to &apos;IsNot&apos; operand of type &apos;{0}&apos; can be compared only to &apos;Nothing&apos; because &apos;{0}&apos; is a type parameter with no class constraint..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IsNotOperatorNullable1">
<summary>
  Looks up a localized string similar to &apos;IsNot&apos; operand of type &apos;{0}&apos; can be compared only to &apos;Nothing&apos; because &apos;{0}&apos; is a nullable type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IsNotOpRequiresReferenceTypes1">
<summary>
  Looks up a localized string similar to &apos;IsNot&apos; requires operands that have reference types, but this operand has the value type &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IsOperatorGenericParam1">
<summary>
  Looks up a localized string similar to &apos;Is&apos; operand of type &apos;{0}&apos; can be compared only to &apos;Nothing&apos; because &apos;{0}&apos; is a type parameter with no class constraint..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IsOperatorNullable1">
<summary>
  Looks up a localized string similar to &apos;Is&apos; operand of type &apos;{0}&apos; can be compared only to &apos;Nothing&apos; because &apos;{0}&apos; is a nullable type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IsOperatorRequiresReferenceTypes1">
<summary>
  Looks up a localized string similar to &apos;Is&apos; operator does not accept operands of type &apos;{0}&apos;. Operands must be reference or nullable types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IterationVariableShadowLocal1">
<summary>
  Looks up a localized string similar to Range variable &apos;{0}&apos; hides a variable in an enclosing block or a range variable previously defined in the query expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_IterationVariableShadowLocal2">
<summary>
  Looks up a localized string similar to Range variable &apos;{0}&apos; hides a variable in an enclosing block, a previously defined range variable, or an implicitly declared variable in a query expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_KeywordNotAllowedInScript">
<summary>
  Looks up a localized string similar to You cannot use &apos;{0}&apos; in top-level script code.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LabelNotDefined1">
<summary>
  Looks up a localized string similar to Label &apos;{0}&apos; is not defined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LambdaBindingMismatch1">
<summary>
  Looks up a localized string similar to Nested function does not have the same signature as delegate &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LambdaBindingMismatch2">
<summary>
  Looks up a localized string similar to Nested sub does not have a signature that is compatible with delegate &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LambdaInSelectCaseExpr">
<summary>
  Looks up a localized string similar to Lambda expressions are not valid in the first expression of a &apos;Select Case&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LambdaNotCreatableDelegate1">
<summary>
  Looks up a localized string similar to Lambda expression cannot be converted to &apos;{0}&apos; because type &apos;{0}&apos; is declared &apos;MustInherit&apos; and cannot be created..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LambdaNotDelegate1">
<summary>
  Looks up a localized string similar to Lambda expression cannot be converted to &apos;{0}&apos; because &apos;{0}&apos; is not a delegate type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LambdaNoType">
<summary>
  Looks up a localized string similar to Cannot infer a return type.  Consider adding an &apos;As&apos; clause to specify the return type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LambdaNoTypeObjectDisallowed">
<summary>
  Looks up a localized string similar to Cannot infer a return type. Consider adding an &apos;As&apos; clause to specify the return type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LambdaParamShadowLocal1">
<summary>
  Looks up a localized string similar to Lambda parameter &apos;{0}&apos; hides a variable in an enclosing block, a previously defined range variable, or an implicitly declared variable in a query expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LambdasCannotHaveAttributes">
<summary>
  Looks up a localized string similar to Attributes cannot be applied to parameters of lambda expressions..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LambdaTooManyTypesObjectDisallowed">
<summary>
  Looks up a localized string similar to Cannot infer a return type because more than one type is possible. Consider adding an &apos;As&apos; clause to specify the return type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LanguageVersion">
<summary>
  Looks up a localized string similar to Visual Basic {0} does not support {1}..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LateBoundOverloadInterfaceCall1">
<summary>
  Looks up a localized string similar to Late bound overload resolution cannot be applied to &apos;{0}&apos; because the accessing instance is an interface type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LbBadElseif">
<summary>
  Looks up a localized string similar to &apos;#ElseIf&apos; must be preceded by a matching &apos;#If&apos; or &apos;#ElseIf&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LbElseifAfterElse">
<summary>
  Looks up a localized string similar to &apos;#ElseIf&apos; cannot follow &apos;#Else&apos; as part of a &apos;#If&apos; block..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LbElseNoMatchingIf">
<summary>
  Looks up a localized string similar to &apos;#Else&apos; must be preceded by a matching &apos;#If&apos; or &apos;#ElseIf&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LbExpectedEndIf">
<summary>
  Looks up a localized string similar to &apos;#If&apos; block must end with a matching &apos;#End If&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LbNoMatchingIf">
<summary>
  Looks up a localized string similar to &apos;#ElseIf&apos;, &apos;#Else&apos;, or &apos;#End If&apos; must be preceded by a matching &apos;#If&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LibAnycpu32bitPreferredConflict">
<summary>
  Looks up a localized string similar to /platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LibNotFound">
<summary>
  Looks up a localized string similar to could not find library &apos;{0}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LineContWithCommentOrNoPrecSpace">
<summary>
  Looks up a localized string similar to Line continuation character &apos;_&apos; must be preceded by at least one white space and must be the last character on the line..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LinkedNetmoduleMetadataMustProvideFullPEImage">
<summary>
  Looks up a localized string similar to Linked netmodule metadata must provide a full PE image: &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LiteralExpected">
<summary>
  Looks up a localized string similar to Literal expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LocalNamedSameAsParam1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is already declared as a parameter of this method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LocalNamedSameAsParamInLambda1">
<summary>
  Looks up a localized string similar to Variable &apos;{0}&apos; is already declared as a parameter of this or an enclosing lambda expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LocalSameAsFunc">
<summary>
  Looks up a localized string similar to Local variable cannot have the same name as the function containing it..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LocalsCannotHaveAttributes">
<summary>
  Looks up a localized string similar to Attributes cannot be applied to local variables..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LocalTypeNameClash2">
<summary>
  Looks up a localized string similar to Embedding the interop type &apos;{0}&apos; from assembly &apos;{1}&apos; causes a name clash in the current assembly. Consider disabling the embedding of interop types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LoopControlMustNotAwait">
<summary>
  Looks up a localized string similar to Loop control variable cannot include an &apos;Await&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LoopControlMustNotBeProperty">
<summary>
  Looks up a localized string similar to Loop control variable cannot be a property or a late-bound indexed array..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LoopDoubleCondition">
<summary>
  Looks up a localized string similar to &apos;Loop&apos; cannot have a condition if matching &apos;Do&apos; has one..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LoopNoMatchingDo">
<summary>
  Looks up a localized string similar to &apos;Loop&apos; must be preceded by a matching &apos;Do&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_LValueRequired">
<summary>
  Looks up a localized string similar to Expression is a value and therefore cannot be the target of an assignment..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MarshalUnmanagedTypeNotValidForFields">
<summary>
  Looks up a localized string similar to Unmanaged type &apos;{0}&apos; not valid for fields..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MarshalUnmanagedTypeOnlyValidForFields">
<summary>
  Looks up a localized string similar to Unmanaged type &apos;{0}&apos; is only valid for fields..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MatchingOperatorExpected2">
<summary>
  Looks up a localized string similar to Matching &apos;{0}&apos; operator is required for &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MaximumNumberOfErrors">
<summary>
  Looks up a localized string similar to Maximum number of errors has been exceeded..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MemberClashesWithSynth6">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; conflicts with a member implicitly declared for {2} &apos;{3}&apos; in {4} &apos;{5}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MemberConflictWithSynth4">
<summary>
  Looks up a localized string similar to Conflicts with &apos;{0}&apos;, which is implicitly declared for &apos;{1}&apos; in {2} &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MetaDataIsNotAssembly">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is a module and cannot be referenced as an assembly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MetaDataIsNotModule">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is an assembly and cannot be referenced as a module..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MetadataMembersAmbiguous3">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is ambiguous because multiple kinds of members with this name exist in {1} &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MetadataReferencesNotSupported">
<summary>
  Looks up a localized string similar to Metadata references not supported..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MethodAlreadyImplemented2">
<summary>
  Looks up a localized string similar to &apos;{0}.{1}&apos; cannot be implemented more than once..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MethodBodyNotAtLineStart">
<summary>
  Looks up a localized string similar to First statement of a method body cannot be on the same line as the method declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MethodMustBeFirstStatementOnLine">
<summary>
  Looks up a localized string similar to Method declaration statements must be the first statement on a logical line..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MethodTypeArgsUnexpected">
<summary>
  Looks up a localized string similar to Method type arguments unexpected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MismatchedXmlEndTag">
<summary>
  Looks up a localized string similar to End tag &lt;/{0}{1}{2}&gt; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingAddHandlerDef1">
<summary>
  Looks up a localized string similar to &apos;AddHandler&apos; definition missing for event &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingEndAddHandler">
<summary>
  Looks up a localized string similar to &apos;AddHandler&apos; declaration must end with a matching &apos;End AddHandler&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingEndBrack">
<summary>
  Looks up a localized string similar to Bracketed identifier is missing closing &apos;]&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingEndEnum">
<summary>
  Looks up a localized string similar to &apos;Enum&apos; must end with a matching &apos;End Enum&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingEndEvent">
<summary>
  Looks up a localized string similar to &apos;Custom Event&apos; must end with a matching &apos;End Event&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingEndGet">
<summary>
  Looks up a localized string similar to &apos;Get&apos; statement must end with a matching &apos;End Get&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingEndInterface">
<summary>
  Looks up a localized string similar to &apos;Interface&apos; must end with a matching &apos;End Interface&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingEndRaiseEvent">
<summary>
  Looks up a localized string similar to &apos;RaiseEvent&apos; declaration must end with a matching &apos;End RaiseEvent&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingEndRemoveHandler">
<summary>
  Looks up a localized string similar to &apos;RemoveHandler&apos; declaration must end with a matching &apos;End RemoveHandler&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingEndSet">
<summary>
  Looks up a localized string similar to &apos;Set&apos; statement must end with a matching &apos;End Set&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingGuidForOption">
<summary>
  Looks up a localized string similar to Command-line syntax error: Missing Guid for option &apos;{1}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingIsInTypeOf">
<summary>
  Looks up a localized string similar to &apos;Is&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingLibInDeclare">
<summary>
  Looks up a localized string similar to &apos;Lib&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingNetModuleReference">
<summary>
  Looks up a localized string similar to Reference to &apos;{0}&apos; netmodule missing..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingNext">
<summary>
  Looks up a localized string similar to &apos;Next&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingRaiseEventDef1">
<summary>
  Looks up a localized string similar to &apos;RaiseEvent&apos; definition missing for event &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingRemoveHandlerDef1">
<summary>
  Looks up a localized string similar to &apos;RemoveHandler&apos; definition missing for event &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingRuntimeHelper">
<summary>
  Looks up a localized string similar to Requested operation is not available because the runtime library function &apos;{0}&apos; is not defined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingSubscript">
<summary>
  Looks up a localized string similar to Array subscript expression missing..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingValuesForArraysInApplAttrs">
<summary>
  Looks up a localized string similar to Arrays used as attribute arguments are required to explicitly specify values for all elements..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingVersionInXmlDecl">
<summary>
  Looks up a localized string similar to Required attribute &apos;version&apos; missing from XML declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MissingXmlEndTag">
<summary>
  Looks up a localized string similar to Element is missing an end tag..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MixingWinRTAndNETEvents">
<summary>
  Looks up a localized string similar to Event &apos;{0}&apos; cannot implement a Windows Runtime event &apos;{1}&apos; and a regular .NET event &apos;{2}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ModuleAsType1">
<summary>
  Looks up a localized string similar to Module &apos;{0}&apos; cannot be used as a type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ModuleCantImplement">
<summary>
  Looks up a localized string similar to &apos;Implements&apos; not valid in Modules..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ModuleCantInherit">
<summary>
  Looks up a localized string similar to &apos;Inherits&apos; not valid in Modules..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ModuleCantUseDLLDeclareSpecifier1">
<summary>
  Looks up a localized string similar to &apos;Declare&apos; statements in a Module cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ModuleCantUseEventSpecifier1">
<summary>
  Looks up a localized string similar to Events in a Module cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ModuleCantUseMethodSpecifier1">
<summary>
  Looks up a localized string similar to Methods in a Module cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ModuleCantUseTypeSpecifier1">
<summary>
  Looks up a localized string similar to Type in a Module cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ModuleCantUseVariableSpecifier1">
<summary>
  Looks up a localized string similar to Variables in Modules cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ModuleEmitFailure">
<summary>
  Looks up a localized string similar to Failed to emit module &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ModuleMemberCantImplement">
<summary>
  Looks up a localized string similar to Members in a Module cannot implement interface members..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ModuleNotAtNamespace">
<summary>
  Looks up a localized string similar to &apos;Module&apos; statements can occur only at file or namespace level..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ModulesCannotBeGeneric">
<summary>
  Looks up a localized string similar to Modules cannot be generic..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MoreThanOneValidMainWasFound2">
<summary>
  Looks up a localized string similar to &apos;Sub Main&apos; is declared more than once in &apos;{0}&apos;: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultilineLambdaMissingFunction">
<summary>
  Looks up a localized string similar to Multiline lambda expression is missing &apos;End Function&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultilineLambdaMissingSub">
<summary>
  Looks up a localized string similar to Multiline lambda expression is missing &apos;End Sub&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultilineLambdasCannotContainOnError">
<summary>
  Looks up a localized string similar to &apos;On Error&apos; and &apos;Resume&apos; cannot appear inside a lambda expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultipleClassConstraints1">
<summary>
  Looks up a localized string similar to Type parameter &apos;{0}&apos; can only have one constraint that is a class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultipleEventImplMismatch3">
<summary>
  Looks up a localized string similar to Event &apos;{0}&apos; cannot implement event &apos;{2}.{1}&apos; because its delegate type does not match the delegate type of another event implemented by &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultipleExtends">
<summary>
  Looks up a localized string similar to &apos;Inherits&apos; can appear only once within a &apos;Class&apos; statement and can only specify one class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultipleNewConstraints">
<summary>
  Looks up a localized string similar to &apos;New&apos; constraint cannot be specified multiple times for the same type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultipleOptionalParameterSpecifiers">
<summary>
  Looks up a localized string similar to &apos;Optional&apos; and &apos;ParamArray&apos; cannot be combined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultipleParameterSpecifiers">
<summary>
  Looks up a localized string similar to &apos;ByVal&apos; and &apos;ByRef&apos; cannot be combined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultipleReferenceConstraints">
<summary>
  Looks up a localized string similar to &apos;Class&apos; constraint cannot be specified multiple times for the same type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultipleValueConstraints">
<summary>
  Looks up a localized string similar to &apos;Structure&apos; constraint cannot be specified multiple times for the same type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultiplyDefined1">
<summary>
  Looks up a localized string similar to Label &apos;{0}&apos; is already defined in the current method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultiplyDefinedEnumMember2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is already declared in this {1}..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MultiplyDefinedType3">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is already declared as &apos;{1}&apos; in this {2}..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MustBeInCatchToRethrow">
<summary>
  Looks up a localized string similar to &apos;Throw&apos; statement cannot omit operand outside a &apos;Catch&apos; statement or inside a &apos;Finally&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MustBeOverloads2">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; must be declared &apos;Overloads&apos; because another &apos;{1}&apos; is declared &apos;Overloads&apos; or &apos;Overrides&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MustInheritEventNotOverridden">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is a MustOverride event in the base class &apos;{1}&apos;. Visual Basic does not support event overriding. You must either provide an implementation for the event in the base class, or make class &apos;{2}&apos; MustInherit..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MustInheritForNewConstraint2">
<summary>
  Looks up a localized string similar to Type argument &apos;{0}&apos; is declared &apos;MustInherit&apos; and does not satisfy the &apos;New&apos; constraint for type parameter &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MustOverOnNotInheritPartClsMem1">
<summary>
  Looks up a localized string similar to &apos;MustOverride&apos; cannot be specified on this member because it is in a partial type that is declared &apos;NotInheritable&apos; in another partial definition..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MustOverridesInClass1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; must be declared &apos;MustInherit&apos; because it contains methods declared &apos;MustOverride&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MustShadow2">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; must be declared &apos;Shadows&apos; because another member with this name is declared &apos;Shadows&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MutuallyExclusiveOptions">
<summary>
  Looks up a localized string similar to Compilation options &apos;{0}&apos; and &apos;{1}&apos; can&apos;t both be specified at the same time..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MyBaseAbstractCall1">
<summary>
  Looks up a localized string similar to &apos;MyBase&apos; cannot be used with method &apos;{0}&apos; because it is declared &apos;MustOverride&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MyClassAbstractCall1">
<summary>
  Looks up a localized string similar to &apos;MustOverride&apos; method &apos;{0}&apos; cannot be called with &apos;MyClass&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MyClassNotInClass">
<summary>
  Looks up a localized string similar to &apos;MyClass&apos; cannot be used outside of a class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_MyGroupCollectionAttributeCycle">
<summary>
  Looks up a localized string similar to MyGroupCollectionAttribute cannot be applied to itself..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamedArgAlsoOmitted1">
<summary>
  Looks up a localized string similar to Parameter &apos;{0}&apos; already has a matching omitted argument..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamedArgAlsoOmitted2">
<summary>
  Looks up a localized string similar to Parameter &apos;{0}&apos; in &apos;{1}&apos; already has a matching omitted argument..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamedArgAlsoOmitted3">
<summary>
  Looks up a localized string similar to Parameter &apos;{0}&apos; in extension method &apos;{1}&apos; defined in &apos;{2}&apos; already has a matching omitted argument..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamedArgUsedTwice1">
<summary>
  Looks up a localized string similar to Parameter &apos;{0}&apos; already has a matching argument..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamedArgUsedTwice2">
<summary>
  Looks up a localized string similar to Parameter &apos;{0}&apos; of &apos;{1}&apos; already has a matching argument..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamedArgUsedTwice3">
<summary>
  Looks up a localized string similar to Parameter &apos;{0}&apos; of extension method &apos;{1}&apos; defined in &apos;{2}&apos; already has a matching argument..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamedParamArrayArgument">
<summary>
  Looks up a localized string similar to Named argument cannot match a ParamArray parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamedParamNotFound1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not a method parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamedParamNotFound2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not a parameter of &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamedParamNotFound3">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not a parameter of extension method &apos;{1}&apos; defined in &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamedSubscript">
<summary>
  Looks up a localized string similar to Named arguments are not valid as array subscripts..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NameNotDeclared1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not declared. It may be inaccessible due to its protection level..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NameNotEvent2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not an event of &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NameNotMember2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not a member of &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NameNotMemberOfAnonymousType2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not a member of &apos;{1}&apos;; it does not exist in the current context..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NameSameAsMethodTypeParam1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is already declared as a type parameter of this method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamespaceNotAllowedInScript">
<summary>
  Looks up a localized string similar to You cannot declare Namespace in script code.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamespaceNotAtNamespace">
<summary>
  Looks up a localized string similar to &apos;Namespace&apos; statements can occur only at file or namespace level..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NamespaceNotExpression1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is a namespace and cannot be used as an expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NarrowingConversionCollection2">
<summary>
  Looks up a localized string similar to Option Strict On disallows implicit conversions from &apos;{0}&apos; to &apos;{1}&apos;; the Visual Basic 6.0 collection type is not compatible with the .NET Framework collection type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NarrowingConversionDisallowed2">
<summary>
  Looks up a localized string similar to Option Strict On disallows implicit conversions from &apos;{0}&apos; to &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NeedModule">
<summary>
  Looks up a localized string similar to the /moduleassemblyname option may only be specified when building a target of type &apos;module&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NegativeArraySize">
<summary>
  Looks up a localized string similar to Array dimensions cannot have a negative size..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NestedBase2">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; cannot inherit from a type nested within it..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NestedExternalSource">
<summary>
  Looks up a localized string similar to &apos;#ExternalSource&apos; directives cannot be nested..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NestedFunctionArgumentNarrowing3">
<summary>
  Looks up a localized string similar to Return type of nested function matching parameter &apos;{0}&apos; narrows from &apos;{1}&apos; to &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NestedGlobalNamespace">
<summary>
  Looks up a localized string similar to Global namespace may not be nested in another namespace..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NestedInteropType">
<summary>
  Looks up a localized string similar to Nested type &apos;{0}&apos; cannot be embedded..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NestedTypeInInheritsClause2">
<summary>
  Looks up a localized string similar to Class &apos;{0}&apos; cannot reference its nested type &apos;{1}&apos; in Inherits clause..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NestingViolatesCLS1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; does not inherit the generic type parameters of its container..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NetModuleNameMismatch">
<summary>
  Looks up a localized string similar to Module name &apos;{0}&apos; stored in &apos;{1}&apos; must match its filename..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NetModuleNameMustBeUnique">
<summary>
  Looks up a localized string similar to Module &apos;{0}&apos; is already defined in this assembly. Each module must have a unique filename..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NewAndValueConstraintsCombined">
<summary>
  Looks up a localized string similar to &apos;New&apos; constraint and &apos;Structure&apos; constraint cannot be combined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NewArgsDisallowedForTypeParam">
<summary>
  Looks up a localized string similar to Arguments cannot be passed to a &apos;New&apos; used on a type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NewCannotHandleEvents">
<summary>
  Looks up a localized string similar to &apos;Sub New&apos; cannot handle events..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NewIfNullOnGenericParam">
<summary>
  Looks up a localized string similar to &apos;New&apos; cannot be used on a type parameter that does not have a &apos;New&apos; constraint..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NewIfNullOnNonClass">
<summary>
  Looks up a localized string similar to &apos;New&apos; cannot be used on an interface..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NewInInterface">
<summary>
  Looks up a localized string similar to &apos;Sub New&apos; cannot be declared in an interface..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NewInStruct">
<summary>
  Looks up a localized string similar to Structures cannot declare a non-shared &apos;Sub New&apos; with no parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NewOnAbstractClass">
<summary>
  Looks up a localized string similar to &apos;New&apos; cannot be used on a class that is declared &apos;MustInherit&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NextForMismatch1">
<summary>
  Looks up a localized string similar to Next control variable does not match For loop control variable &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NextNoMatchingFor">
<summary>
  Looks up a localized string similar to &apos;Next&apos; must be preceded by a matching &apos;For&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoAccessibleConstructorOnBase">
<summary>
  Looks up a localized string similar to Class &apos;{0}&apos; has no accessible &apos;Sub New&apos; and cannot be inherited..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoAccessibleGet">
<summary>
  Looks up a localized string similar to &apos;Get&apos; accessor of property &apos;{0}&apos; is not accessible..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoAccessibleSet">
<summary>
  Looks up a localized string similar to &apos;Set&apos; accessor of property &apos;{0}&apos; is not accessible..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoAddMethod1">
<summary>
  Looks up a localized string similar to Cannot initialize the type &apos;{0}&apos; with a collection initializer because it does not have an accessible &apos;Add&apos; method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoArgumentCountOverloadCandidates1">
<summary>
  Looks up a localized string similar to Overload resolution failed because no accessible &apos;{0}&apos; accepts this number of arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoCallableOverloadCandidates2">
<summary>
  Looks up a localized string similar to Overload resolution failed because no accessible &apos;{0}&apos; can be called with these arguments:{1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoConstituentArraySizes">
<summary>
  Looks up a localized string similar to Bounds can be specified only for the top-level array when initializing an array of arrays..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoConstructorOnBase2">
<summary>
  Looks up a localized string similar to Class &apos;{0}&apos; must declare a &apos;Sub New&apos; because its base class &apos;{1}&apos; does not have an accessible &apos;Sub New&apos; that can be called with no arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoDefaultNotExtend1">
<summary>
  Looks up a localized string similar to Class &apos;{0}&apos; cannot be indexed because it has no default property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoDirectDelegateConstruction1">
<summary>
  Looks up a localized string similar to Delegate &apos;{0}&apos; requires an &apos;AddressOf&apos; expression or lambda expression as the only argument to its constructor..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoExplicitArraySizes">
<summary>
  Looks up a localized string similar to Array bounds cannot appear in type specifiers..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoGetProperty1">
<summary>
  Looks up a localized string similar to Property &apos;{0}&apos; is &apos;WriteOnly&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoGlobalExpectedIdentifier">
<summary>
  Looks up a localized string similar to &apos;Global&apos; not allowed in this context; identifier expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoGlobalInHandles">
<summary>
  Looks up a localized string similar to &apos;Global&apos; not allowed in handles; local name expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoMostSpecificOverload2">
<summary>
  Looks up a localized string similar to Overload resolution failed because no accessible &apos;{0}&apos; is most specific for these arguments:{1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NonFieldPropertyAggrMemberInit1">
<summary>
  Looks up a localized string similar to Member &apos;{0}&apos; cannot be initialized in an object initializer expression because it is not a field or property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NonNamespaceOrClassOnImport2">
<summary>
  Looks up a localized string similar to &apos;{1}&apos; for the Imports &apos;{0}&apos; does not refer to a Namespace, Class, Structure, Enum or Module..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoNonIndexProperty1">
<summary>
  Looks up a localized string similar to Property &apos;{0}&apos; with no parameters cannot be found..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoNonNarrowingOverloadCandidates2">
<summary>
  Looks up a localized string similar to Overload resolution failed because no accessible &apos;{0}&apos; can be called without a narrowing conversion:{1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoNonObsoleteConstructorOnBase3">
<summary>
  Looks up a localized string similar to Class &apos;{0}&apos; must declare a &apos;Sub New&apos; because the &apos;{1}&apos; in its base class &apos;{2}&apos; is marked obsolete..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoNonObsoleteConstructorOnBase4">
<summary>
  Looks up a localized string similar to Class &apos;{0}&apos; must declare a &apos;Sub New&apos; because the &apos;{1}&apos; in its base class &apos;{2}&apos; is marked obsolete: &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoPartialMethodInAddressOf1">
<summary>
  Looks up a localized string similar to &apos;AddressOf&apos; cannot be applied to &apos;{0}&apos; because &apos;{0}&apos; is a partial method without an implementation..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoPIAAttributeMissing2">
<summary>
  Looks up a localized string similar to Interop type &apos;{0}&apos; cannot be embedded because it is missing the required &apos;{1}&apos; attribute..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoResponseFile">
<summary>
  Looks up a localized string similar to unable to open response file &apos;{0}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoSetProperty1">
<summary>
  Looks up a localized string similar to Property &apos;{0}&apos; is &apos;ReadOnly&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoSources">
<summary>
  Looks up a localized string similar to no input sources specified.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoSourcesOut">
<summary>
  Looks up a localized string similar to cannot infer an output file name from resource only input files; provide the &apos;/out&apos; option.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoSuitableNewForNewConstraint2">
<summary>
  Looks up a localized string similar to Type argument &apos;{0}&apos; must have a public parameterless instance constructor to satisfy the &apos;New&apos; constraint for type parameter &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoSuitableWidestType1">
<summary>
  Looks up a localized string similar to Type of &apos;{0}&apos; cannot be inferred because the loop bounds and the step clause do not convert to the same type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NotACollection1">
<summary>
  Looks up a localized string similar to Cannot initialize the type &apos;{0}&apos; with a collection initializer because it is not a collection type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NotMostSpecificOverload">
<summary>
  Looks up a localized string similar to Not most specific..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NotOverridableRequiresOverrides">
<summary>
  Looks up a localized string similar to &apos;NotOverridable&apos; cannot be specified for methods that do not override another method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoTypeArgumentCountOverloadCand1">
<summary>
  Looks up a localized string similar to Overload resolution failed because no accessible &apos;{0}&apos; accepts this number of type arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoTypecharInAlias">
<summary>
  Looks up a localized string similar to Type characters are not allowed on Imports aliases..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoTypecharInLabel">
<summary>
  Looks up a localized string similar to Type characters are not allowed in label identifiers..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoUniqueConstructorOnBase2">
<summary>
  Looks up a localized string similar to Class &apos;{0}&apos; must declare a &apos;Sub New&apos; because its base class &apos;{1}&apos; has more than one accessible &apos;Sub New&apos; that can be called with no arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoViableOverloadCandidates1">
<summary>
  Looks up a localized string similar to Overload resolution failed because no &apos;{0}&apos; is accessible..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoWithEventsVarOnHandlesList">
<summary>
  Looks up a localized string similar to Handles clause requires a WithEvents variable defined in the containing type or one of its base types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoXmlAxesLateBinding">
<summary>
  Looks up a localized string similar to XML axis properties do not support late binding..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NoZeroCountArgumentInitCandidates1">
<summary>
  Looks up a localized string similar to Property &apos;{0}&apos; cannot be initialized in an object initializer expression because all accessible overloads require arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NullableCharNotSupported">
<summary>
  Looks up a localized string similar to The &apos;?&apos; character cannot be used here..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NullableDisallowedForStructConstr1">
<summary>
  Looks up a localized string similar to &apos;System.Nullable&apos; does not satisfy the &apos;Structure&apos; constraint for type parameter &apos;{0}&apos;. Only non-nullable &apos;Structure&apos; types are allowed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NullableImplicit">
<summary>
  Looks up a localized string similar to Nullable modifier cannot be used with a variable whose implicit type is &apos;Object&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NullableParameterMustSpecifyType">
<summary>
  Looks up a localized string similar to Nullable parameters must specify a type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NullableTypeInferenceNotSupported">
<summary>
  Looks up a localized string similar to Nullable type inference is not supported in this context..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_NullPropagatingOpInExpressionTree">
<summary>
  Looks up a localized string similar to A null propagating operator cannot be converted into an expression tree..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObjectInitializerRequiresFieldName">
<summary>
  Looks up a localized string similar to Object initializers require a field name to initialize..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObjectReferenceNotSupplied">
<summary>
  Looks up a localized string similar to Reference to a non-shared member requires an object reference..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteArgumentsNeedParens">
<summary>
  Looks up a localized string similar to Method arguments must be enclosed in parentheses..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteAsAny">
<summary>
  Looks up a localized string similar to &apos;As Any&apos; is not supported in &apos;Declare&apos; statements..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteEndIf">
<summary>
  Looks up a localized string similar to &apos;EndIf&apos; statements are no longer supported; use &apos;End If&apos; instead..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteExponent">
<summary>
  Looks up a localized string similar to &apos;D&apos; can no longer be used to indicate an exponent, use &apos;E&apos; instead..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteGetStatement">
<summary>
  Looks up a localized string similar to &apos;Get&apos; statements are no longer supported. File I/O functionality is available in the &apos;Microsoft.VisualBasic&apos; namespace..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteGosub">
<summary>
  Looks up a localized string similar to &apos;GoSub&apos; statements are no longer supported..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteInvalidOnEventMember">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be applied to the &apos;AddHandler&apos;, &apos;RemoveHandler&apos;, or &apos;RaiseEvent&apos; definitions. If required, apply the attribute directly to the event..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteLetSetNotNeeded">
<summary>
  Looks up a localized string similar to &apos;Let&apos; and &apos;Set&apos; assignment statements are no longer supported..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteLineNumbersAreLabels">
<summary>
  Looks up a localized string similar to Labels that are numbers must be followed by colons..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteObjectNotVariant">
<summary>
  Looks up a localized string similar to &apos;Variant&apos; is no longer a supported type; use the &apos;Object&apos; type instead..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteOnGotoGosub">
<summary>
  Looks up a localized string similar to &apos;On GoTo&apos; and &apos;On GoSub&apos; statements are no longer supported..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteOptionalWithoutValue">
<summary>
  Looks up a localized string similar to Optional parameters must specify a default value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoletePropertyGetLetSet">
<summary>
  Looks up a localized string similar to Property Get/Let/Set are no longer supported; use the new Property declaration syntax..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteRedimAs">
<summary>
  Looks up a localized string similar to &apos;ReDim&apos; statements can no longer be used to declare array variables..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteStructureNotType">
<summary>
  Looks up a localized string similar to &apos;Type&apos; statements are no longer supported; use &apos;Structure&apos; statements instead..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ObsoleteWhileWend">
<summary>
  Looks up a localized string similar to &apos;Wend&apos; statements are no longer supported; use &apos;End While&apos; statements instead..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OfExpected">
<summary>
  Looks up a localized string similar to &apos;Of&apos; required when specifying type arguments for a generic type or method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OmittedArgument1">
<summary>
  Looks up a localized string similar to Argument not specified for parameter &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OmittedArgument2">
<summary>
  Looks up a localized string similar to Argument not specified for parameter &apos;{0}&apos; of &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OmittedArgument3">
<summary>
  Looks up a localized string similar to Argument not specified for parameter &apos;{0}&apos; of extension method &apos;{1}&apos; defined in &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OmittedParamArrayArgument">
<summary>
  Looks up a localized string similar to Omitted argument cannot match a ParamArray parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OneOrTwoParametersRequired1">
<summary>
  Looks up a localized string similar to Operator &apos;{0}&apos; must have either one or two parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OneParameterRequired1">
<summary>
  Looks up a localized string similar to Operator &apos;{0}&apos; must have one parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OnErrorInSyncLock">
<summary>
  Looks up a localized string similar to &apos;On Error&apos; statements are not valid within &apos;SyncLock&apos; statements..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OnErrorInUsing">
<summary>
  Looks up a localized string similar to &apos;On Error&apos; statements are not valid within &apos;Using&apos; statements..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OnlyNullLowerBound">
<summary>
  Looks up a localized string similar to Array lower bounds can be only &apos;0&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OnlyOneAccessorForGetSet">
<summary>
  Looks up a localized string similar to Access modifier can only be applied to either &apos;Get&apos; or &apos;Set&apos;, but not both..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OnlyOneImplementingMethodAllowed3">
<summary>
  Looks up a localized string similar to Method &apos;{0}&apos; cannot implement partial method &apos;{1}&apos; because &apos;{2}&apos; already implements it. Only one method can implement a partial method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OnlyOnePartialMethodAllowed2">
<summary>
  Looks up a localized string similar to Method &apos;{0}&apos; cannot be declared &apos;Partial&apos; because only one method &apos;{1}&apos; can be marked &apos;Partial&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OnlyPrivatePartialMethods1">
<summary>
  Looks up a localized string similar to Partial methods must be declared &apos;Private&apos; instead of &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OpenTypeDisallowed">
<summary>
  Looks up a localized string similar to Type parameters or types constructed with type parameters are not allowed in attribute arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OperatorDeclaredInModule">
<summary>
  Looks up a localized string similar to Operators cannot be declared in modules..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OperatorMustBePublic">
<summary>
  Looks up a localized string similar to Operators must be declared &apos;Public&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OperatorMustBeShared">
<summary>
  Looks up a localized string similar to Operators must be declared &apos;Shared&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OperatorNotOverloadable">
<summary>
  Looks up a localized string similar to Operator is not overloadable. Operator declaration must be one of:  +, -, *, \, /, ^, &amp;, Like, Mod, And, Or, Xor, Not, &lt;&lt;, &gt;&gt;, =, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=, CType, IsTrue, IsFalse..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OperatorRequiresBoolReturnType1">
<summary>
  Looks up a localized string similar to Operator &apos;{0}&apos; must have a return type of Boolean..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OperatorRequiresIntegerParameter1">
<summary>
  Looks up a localized string similar to Operator &apos;{0}&apos; must have a second parameter of type &apos;Integer&apos; or &apos;Integer?&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OptionalIllegal1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; parameters cannot be declared &apos;Optional&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OptionalsCantBeStructGenericParams">
<summary>
  Looks up a localized string similar to Generic parameters used as optional parameter types must be class constrained..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OptionStmtWrongOrder">
<summary>
  Looks up a localized string similar to &apos;Option&apos; statements must precede any declarations or &apos;Imports&apos; statements..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_Overflow">
<summary>
  Looks up a localized string similar to Overflow..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverloadCandidate1">
<summary>
  Looks up a localized string similar to 
    {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverloadCandidate2">
<summary>
  Looks up a localized string similar to 
    &apos;{0}&apos;: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverloadingPropertyKind2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; and &apos;{1}&apos; cannot overload each other because they differ only by &apos;ReadOnly&apos; or &apos;WriteOnly&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverloadsModifierInModule">
<summary>
  Looks up a localized string similar to Inappropriate use of &apos;{0}&apos; keyword in a module..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverloadWithArrayVsParamArray2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; and &apos;{1}&apos; cannot overload each other because they differ only by parameters declared &apos;ParamArray&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverloadWithByref2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; and &apos;{1}&apos; cannot overload each other because they differ only by parameters declared &apos;ByRef&apos; or &apos;ByVal&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverloadWithDefault2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; and &apos;{1}&apos; cannot overload each other because they differ only by the default values of optional parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverloadWithOptional2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; and &apos;{1}&apos; cannot overload each other because they differ only by optional parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverloadWithReturnType2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; and &apos;{1}&apos; cannot overload each other because they differ only by return types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverriddenCandidate1">
<summary>
  Looks up a localized string similar to 
   &apos;{0}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverrideNotNeeded3">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; cannot be declared &apos;Overrides&apos; because it does not override a {0} in a base class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverridesImpliesOverridable">
<summary>
  Looks up a localized string similar to Methods declared &apos;Overrides&apos; cannot be declared &apos;Overridable&apos; because they are implicitly overridable..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverrideWithArrayVsParamArray2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot override &apos;{1}&apos; because they differ by parameters declared &apos;ParamArray&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverrideWithByref2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot override &apos;{1}&apos; because they differ by a parameter that is marked as &apos;ByRef&apos; versus &apos;ByVal&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverrideWithConstraintMismatch2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot override &apos;{1}&apos; because they differ by type parameter constraints..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverrideWithDefault2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot override &apos;{1}&apos; because they differ by the default values of optional parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverrideWithOptional2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot override &apos;{1}&apos; because they differ by optional parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverrideWithOptionalTypes2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot override &apos;{1}&apos; because they differ by the types of optional parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_OverridingPropertyKind2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot override &apos;{1}&apos; because they differ by &apos;ReadOnly&apos; or &apos;WriteOnly&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ParamArrayArgumentMismatch">
<summary>
  Looks up a localized string similar to Argument cannot match a ParamArray parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ParamArrayIllegal1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; parameters cannot be declared &apos;ParamArray&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ParamArrayMustBeByVal">
<summary>
  Looks up a localized string similar to ParamArray parameters must be declared &apos;ByVal&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ParamArrayMustBeLast">
<summary>
  Looks up a localized string similar to End of parameter list expected. Cannot define parameters after a paramarray parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ParamArrayNotArray">
<summary>
  Looks up a localized string similar to ParamArray parameter must be an array..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ParamArrayRank">
<summary>
  Looks up a localized string similar to ParamArray parameter must be a one-dimensional array..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ParamArrayWithOptArgs">
<summary>
  Looks up a localized string similar to Method cannot have both a ParamArray and Optional parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ParamArrayWrongType">
<summary>
  Looks up a localized string similar to ParamArray parameters must have an array type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ParamDefaultValueDiffersFromAttribute">
<summary>
  Looks up a localized string similar to The parameter has multiple distinct default values..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ParameterizedPropertyInAggrInit1">
<summary>
  Looks up a localized string similar to Property &apos;{0}&apos; cannot be initialized in an object initializer expression because it requires arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ParameterNotValidForType">
<summary>
  Looks up a localized string similar to Parameter not valid for the specified unmanaged type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ParamNameFunctionNameCollision">
<summary>
  Looks up a localized string similar to Parameter cannot have the same name as its defining function..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ParamTypingInconsistency">
<summary>
  Looks up a localized string similar to All parameters must be explicitly typed if any of them are explicitly typed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialDeclarationImplements1">
<summary>
  Looks up a localized string similar to Partial method &apos;{0}&apos; cannot use the &apos;Implements&apos; keyword..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialMethodDefaultParameterValueMismatch2">
<summary>
  Looks up a localized string similar to Optional parameter of a method &apos;{0}&apos; does not have the same default value as the corresponding parameter of the partial method &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialMethodGenericConstraints2">
<summary>
  Looks up a localized string similar to Method &apos;{0}&apos; does not have the same generic constraints as the partial method &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialMethodMustBeEmpty">
<summary>
  Looks up a localized string similar to Partial methods must have empty method bodies..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialMethodParamArrayMismatch2">
<summary>
  Looks up a localized string similar to Parameter of a method &apos;{0}&apos; differs by ParamArray modifier from the corresponding parameter of the partial method &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialMethodParamNamesMustMatch3">
<summary>
  Looks up a localized string similar to Parameter name &apos;{0}&apos; does not match the name of the corresponding parameter, &apos;{1}&apos;, defined on the partial method declaration &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialMethodsMustBePrivate">
<summary>
  Looks up a localized string similar to Partial methods must be declared &apos;Private&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialMethodsMustBeSub1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be declared &apos;Partial&apos; because partial methods must be Subs..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialMethodsMustNotBeAsync1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be declared &apos;Partial&apos; because it has the &apos;Async&apos; modifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialMethodTypeParamNameMismatch3">
<summary>
  Looks up a localized string similar to Name of type parameter &apos;{0}&apos; does not match &apos;{1}&apos;, the corresponding type parameter defined on the partial method declaration &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialTypeAccessMismatch3">
<summary>
  Looks up a localized string similar to Specified access &apos;{0}&apos; for &apos;{1}&apos; does not match the access &apos;{2}&apos; specified on one of its other partial types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialTypeBadMustInherit1">
<summary>
  Looks up a localized string similar to &apos;MustInherit&apos; cannot be specified for partial type &apos;{0}&apos; because it cannot be combined with &apos;NotInheritable&apos; specified for one of its other partial types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialTypeConstraintMismatch1">
<summary>
  Looks up a localized string similar to Constraints for this type parameter do not match the constraints on the corresponding type parameter defined on one of the other partial types of &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PartialTypeTypeParamNameMismatch3">
<summary>
  Looks up a localized string similar to Type parameter name &apos;{0}&apos; does not match the name &apos;{1}&apos; of the corresponding type parameter defined on one of the other partial types of &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PDBWritingFailed">
<summary>
  Looks up a localized string similar to Failure writing debug information: {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PermissionSetAttributeFileReadError">
<summary>
  Looks up a localized string similar to Error reading file &apos;{0}&apos; specified for the named argument &apos;{1}&apos; for PermissionSet attribute: &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PermissionSetAttributeInvalidFile">
<summary>
  Looks up a localized string similar to Unable to resolve file path &apos;{0}&apos; specified for the named argument &apos;{1}&apos; for PermissionSet attribute..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PIAHasNoAssemblyGuid1">
<summary>
  Looks up a localized string similar to Cannot embed interop types from assembly &apos;{0}&apos; because it is missing the &apos;{1}&apos; attribute..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PIAHasNoTypeLibAttribute1">
<summary>
  Looks up a localized string similar to Cannot embed interop types from assembly &apos;{0}&apos; because it is missing either the &apos;{1}&apos; attribute or the &apos;{2}&apos; attribute..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PlatformDoesntSupport">
<summary>
  Looks up a localized string similar to {0} is not supported in current project type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PrincipalPermissionInvalidAction">
<summary>
  Looks up a localized string similar to SecurityAction value &apos;{0}&apos; is invalid for PrincipalPermission attribute..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PrivateTypeOutsideType">
<summary>
  Looks up a localized string similar to Types declared &apos;Private&apos; must be inside another type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ProjectCCError1">
<summary>
  Looks up a localized string similar to Project-level conditional compilation constant &apos;{1}&apos; is not valid: {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PropertyAccessIgnored">
<summary>
  Looks up a localized string similar to Property access must assign to the property or use its value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PropertyDoesntImplementAllAccessors">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be implemented by a {1} property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PropertyNameConflictInMyCollection">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; has the same name as a member used for type &apos;{1}&apos; exposed in a &apos;My&apos; group. Rename the type or its enclosing namespace..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PropertyOrFieldNotDefined1">
<summary>
  Looks up a localized string similar to Field or property &apos;{0}&apos; is not found..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PropertySetParamCollisionWithValue">
<summary>
  Looks up a localized string similar to Property parameters cannot have the name &apos;Value&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PropMustHaveGetSet">
<summary>
  Looks up a localized string similar to Property without a &apos;ReadOnly&apos; or &apos;WriteOnly&apos; specifier must provide both a &apos;Get&apos; and a &apos;Set&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ProtectedTypeOutsideClass">
<summary>
  Looks up a localized string similar to Protected types can only be declared inside of a class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PublicKeyContainerFailure">
<summary>
  Looks up a localized string similar to Error extracting public key from container &apos;{0}&apos;: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PublicKeyFileFailure">
<summary>
  Looks up a localized string similar to Error extracting public key from file &apos;{0}&apos;: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_PublicSignNoKey">
<summary>
  Looks up a localized string similar to Public sign was specified and requires a public key, but no public key was specified.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_QualifiedNameNotAllowed">
<summary>
  Looks up a localized string similar to &apos;:&apos; is not allowed. XML qualified names cannot be used in this context..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_QualNotObjectRecord1">
<summary>
  Looks up a localized string similar to &apos;!&apos; requires its left operand to have a type parameter, class or interface type, but this operand has the type &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_QueryAnonTypeFieldXMLNameInference">
<summary>
  Looks up a localized string similar to Range variable name cannot be inferred from an XML identifier that is not a valid Visual Basic identifier..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_QueryAnonymousTypeDisallowsTypeChar">
<summary>
  Looks up a localized string similar to Type characters cannot be used in range variable declarations..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_QueryAnonymousTypeFieldNameInference">
<summary>
  Looks up a localized string similar to Range variable name can be inferred only from a simple or qualified name with no arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_QueryDuplicateAnonTypeMemberName1">
<summary>
  Looks up a localized string similar to Range variable &apos;{0}&apos; is already declared..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_QueryInvalidControlVariableName1">
<summary>
  Looks up a localized string similar to Range variable name cannot match the name of a member of the &apos;Object&apos; class..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_QueryNameNotDeclared">
<summary>
  Looks up a localized string similar to Name &apos;{0}&apos; is either not declared or not in the current scope..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_QueryOperatorNotFound">
<summary>
  Looks up a localized string similar to Definition of method &apos;{0}&apos; is not accessible in this context..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_QueryStrictDisallowImplicitObject">
<summary>
  Looks up a localized string similar to Type of the range variable cannot be inferred, and late binding is not allowed with Option Strict on. Use an &apos;As&apos; clause to specify the type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_QuotedEmbeddedExpression">
<summary>
  Looks up a localized string similar to Embedded expression cannot appear inside a quoted attribute value.  Try removing quotes..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RaiseEventShapeMismatch1">
<summary>
  Looks up a localized string similar to &apos;RaiseEvent&apos; method must have the same signature as the containing event&apos;s delegate type &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReadOnlyAssignment">
<summary>
  Looks up a localized string similar to &apos;ReadOnly&apos; variable cannot be the target of an assignment..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReadOnlyHasNoGet">
<summary>
  Looks up a localized string similar to &apos;ReadOnly&apos; property must provide a &apos;Get&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReadOnlyHasSet">
<summary>
  Looks up a localized string similar to Properties declared &apos;ReadOnly&apos; cannot have a &apos;Set&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReadOnlyInClosure">
<summary>
  Looks up a localized string similar to &apos;ReadOnly&apos; variable cannot be the target of an assignment in a lambda expression inside a constructor..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReadOnlyNoAccessorFlag">
<summary>
  Looks up a localized string similar to &apos;ReadOnly&apos; properties cannot have an access modifier on &apos;Get&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReadOnlyProperty1">
<summary>
  Looks up a localized string similar to &apos;ReadOnly&apos; property &apos;{0}&apos; cannot be the target of an assignment..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RecordCycle2">
<summary>
  Looks up a localized string similar to Structure &apos;{0}&apos; cannot contain an instance of itself: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RecordEmbeds2">
<summary>
  Looks up a localized string similar to 
    &apos;{0}&apos; contains &apos;{1}&apos; (variable &apos;{2}&apos;)..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RedimNoSizes">
<summary>
  Looks up a localized string similar to &apos;ReDim&apos; statements require a parenthesized list of the new bounds of each dimension of the array..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RedimRankMismatch">
<summary>
  Looks up a localized string similar to &apos;ReDim&apos; cannot change the number of dimensions of an array..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RefAndClassTypeConstrCombined">
<summary>
  Looks up a localized string similar to &apos;Class&apos; constraint and a specific class type constraint cannot be combined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RefAndValueConstraintsCombined">
<summary>
  Looks up a localized string similar to &apos;Class&apos; constraint and &apos;Structure&apos; constraint cannot be combined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReferenceComparison3">
<summary>
  Looks up a localized string similar to Operator &apos;{0}&apos; is not defined for types &apos;{1}&apos; and &apos;{2}&apos;. Use &apos;Is&apos; operator to compare two reference types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReferenceDirectiveOnlyAllowedInScripts">
<summary>
  Looks up a localized string similar to #R is only allowed in scripts.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReImplementingWinRTInterface4">
<summary>
  Looks up a localized string similar to &apos;{0}.{1}&apos; is already implemented by the base class &apos;{2}&apos;. Re-implementation of Windows Runtime Interface &apos;{3}&apos; is not allowed.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReImplementingWinRTInterface5">
<summary>
  Looks up a localized string similar to &apos;{0}.{1}&apos; from &apos;implements {2}&apos; is already implemented by the base class &apos;{3}&apos;. Re-implementation of Windows Runtime Interface &apos;{4}&apos; is not allowed.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RemoveParamWrongForWinRT">
<summary>
  Looks up a localized string similar to In a Windows Runtime event, the type of the &apos;RemoveHandler&apos; method parameter must be &apos;EventRegistrationToken&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RequiredAttributeConstConversion2">
<summary>
  Looks up a localized string similar to Conversion from &apos;{0}&apos; to &apos;{1}&apos; cannot occur in a constant expression used as an argument to an attribute..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RequiredConstConversion2">
<summary>
  Looks up a localized string similar to Conversion from &apos;{0}&apos; to &apos;{1}&apos; cannot occur in a constant expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RequiredConstExpr">
<summary>
  Looks up a localized string similar to Constant expression is required..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RequiredNewCall2">
<summary>
  Looks up a localized string similar to First statement of this &apos;Sub New&apos; must be a call to &apos;MyBase.New&apos; or &apos;MyClass.New&apos; because base class &apos;{0}&apos; of &apos;{1}&apos; does not have an accessible &apos;Sub New&apos; that can be called with no arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RequiredNewCallTooMany2">
<summary>
  Looks up a localized string similar to First statement of this &apos;Sub New&apos; must be a call to &apos;MyBase.New&apos; or &apos;MyClass.New&apos; because base class &apos;{0}&apos; of &apos;{1}&apos; has more than one accessible &apos;Sub New&apos; that can be called with no arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RequiredNonObsoleteNewCall3">
<summary>
  Looks up a localized string similar to First statement of this &apos;Sub New&apos; must be an explicit call to &apos;MyBase.New&apos; or &apos;MyClass.New&apos; because the &apos;{0}&apos; in the base class &apos;{1}&apos; of &apos;{2}&apos; is marked obsolete..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RequiredNonObsoleteNewCall4">
<summary>
  Looks up a localized string similar to First statement of this &apos;Sub New&apos; must be an explicit call to &apos;MyBase.New&apos; or &apos;MyClass.New&apos; because the &apos;{0}&apos; in the base class &apos;{1}&apos; of &apos;{2}&apos; is marked obsolete: &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReservedAssemblyName">
<summary>
  Looks up a localized string similar to The assembly name &apos;{0}&apos; is reserved and cannot be used as a reference in an interactive session.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReservedXmlNamespace">
<summary>
  Looks up a localized string similar to Prefix &apos;{0}&apos; cannot be bound to namespace name reserved for &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReservedXmlPrefix">
<summary>
  Looks up a localized string similar to XML namespace prefix &apos;{0}&apos; is reserved for use by XML and the namespace URI cannot be changed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ResourceInModule">
<summary>
  Looks up a localized string similar to Cannot link resource files when building a module.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RestrictedAccess">
<summary>
  Looks up a localized string similar to Expression has the type &apos;{0}&apos; which is a restricted type and cannot be used to access members inherited from &apos;Object&apos; or &apos;ValueType&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RestrictedConversion1">
<summary>
  Looks up a localized string similar to Expression of type &apos;{0}&apos; cannot be converted to &apos;Object&apos; or &apos;ValueType&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RestrictedResumableType1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be used as a parameter type for an Iterator or Async method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RestrictedType1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be made nullable, and cannot be used as the data type of an array element, field, anonymous type member, type argument, &apos;ByRef&apos; parameter, or return statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ResumableLambdaInExpressionTree">
<summary>
  Looks up a localized string similar to Lambdas with the &apos;Async&apos; or &apos;Iterator&apos; modifiers cannot be converted to expression trees..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ResumablesCannotContainOnError">
<summary>
  Looks up a localized string similar to &apos;On Error&apos; and &apos;Resume&apos; cannot appear inside async or iterator methods..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReturnFromNonFunction">
<summary>
  Looks up a localized string similar to &apos;Return&apos; statement in a Sub or a Set cannot return a value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReturnFromNonGenericTaskAsync">
<summary>
  Looks up a localized string similar to &apos;Return&apos; statements in this Async method cannot return a value since the return type of the function is &apos;Task&apos;. Consider changing the function&apos;s return type to &apos;Task(Of T)&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ReturnWithoutValue">
<summary>
  Looks up a localized string similar to &apos;Return&apos; statement in a Function, Get, or Operator must return a value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_RuntimeMemberNotFound2">
<summary>
  Looks up a localized string similar to Member &apos;{0}&apos; cannot be found in class &apos;{1}&apos;. This condition is usually the result of a mismatched &apos;Microsoft.VisualBasic.dll&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SecurityAttributeInvalidAction">
<summary>
  Looks up a localized string similar to Security attribute &apos;{0}&apos; has an invalid SecurityAction value &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SecurityAttributeInvalidActionAssembly">
<summary>
  Looks up a localized string similar to SecurityAction value &apos;{0}&apos; is invalid for security attributes applied to an assembly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SecurityAttributeInvalidActionTypeOrMethod">
<summary>
  Looks up a localized string similar to SecurityAction value &apos;{0}&apos; is invalid for security attributes applied to a type or a method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SecurityAttributeInvalidTarget">
<summary>
  Looks up a localized string similar to Security attribute &apos;{0}&apos; is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SecurityAttributeMissingAction">
<summary>
  Looks up a localized string similar to First argument to a security attribute must be a valid SecurityAction..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SecurityCriticalAsync">
<summary>
  Looks up a localized string similar to Security attribute &apos;{0}&apos; cannot be applied to an Async or Iterator method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SecurityCriticalAsyncInClassOrStruct">
<summary>
  Looks up a localized string similar to Async and Iterator methods are not allowed in a [Class|Structure|Interface|Module] that has the &apos;SecurityCritical&apos; or &apos;SecuritySafeCritical&apos; attribute..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SetHasOnlyOneParam">
<summary>
  Looks up a localized string similar to &apos;Set&apos; method cannot have more than one parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SetHasToBeByVal1">
<summary>
  Looks up a localized string similar to &apos;Set&apos; parameter cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SetValueNotPropertyType">
<summary>
  Looks up a localized string similar to &apos;Set&apos; parameter must have the same type as the containing property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ShadowingGenericParamWithMember1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; has the same name as a type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ShadowingTypeOutsideClass1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be declared &apos;Shadows&apos; outside of a class, structure, or interface..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SharedConstructorIllegalSpec1">
<summary>
  Looks up a localized string similar to Shared &apos;Sub New&apos; cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SharedConstructorWithParams">
<summary>
  Looks up a localized string similar to Shared &apos;Sub New&apos; cannot have any parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SharedEventNeedsSharedHandler">
<summary>
  Looks up a localized string similar to Events of shared WithEvents variables cannot be handled by non-shared methods..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SharedMemberAggrMemberInit1">
<summary>
  Looks up a localized string similar to Member &apos;{0}&apos; cannot be initialized in an object initializer expression because it is shared..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SharedOnProcThatImpl">
<summary>
  Looks up a localized string similar to Methods or events that implement interface members cannot be declared &apos;Shared&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SharedStructMemberCannotSpecifyNew">
<summary>
  Looks up a localized string similar to Non-shared members in a Structure cannot be declared &apos;New&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SignButNoPrivateKey">
<summary>
  Looks up a localized string similar to Key file &apos;{0}&apos; is missing the private key needed for signing..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SourceInterfaceMustBeInterface">
<summary>
  Looks up a localized string similar to Interface &apos;{0}&apos; has an invalid source interface which is required to embed event &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SpecifiersInvalidOnInheritsImplOpt">
<summary>
  Looks up a localized string similar to Specifiers and attributes are not valid on this statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SpecifiersInvOnEventMethod">
<summary>
  Looks up a localized string similar to Specifiers are not valid on &apos;AddHandler&apos;, &apos;RemoveHandler&apos; and &apos;RaiseEvent&apos; methods..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StandaloneAttribute">
<summary>
  Looks up a localized string similar to Attribute specifier is not a complete statement. Use a line continuation to apply the attribute to the following statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StartAttributeValue">
<summary>
  Looks up a localized string similar to Expected quoted XML attribute value or embedded expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StartupCodeNotFound1">
<summary>
  Looks up a localized string similar to &apos;Sub Main&apos; was not found in &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StatementLambdaInExpressionTree">
<summary>
  Looks up a localized string similar to Statement lambdas cannot be converted to expression trees..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_STAThreadAndMTAThread0">
<summary>
  Looks up a localized string similar to &apos;System.STAThreadAttribute&apos; and &apos;System.MTAThreadAttribute&apos; cannot both be applied to the same method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StaticInLambda">
<summary>
  Looks up a localized string similar to Static local variables cannot be declared inside lambda expressions..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StrictArgumentCopyBackNarrowing3">
<summary>
  Looks up a localized string similar to Option Strict On disallows narrowing from type &apos;{1}&apos; to type &apos;{2}&apos; in copying the value of &apos;ByRef&apos; parameter &apos;{0}&apos; back to the matching argument..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StrictDisallowImplicitObject">
<summary>
  Looks up a localized string similar to Option Strict On requires all variable declarations to have an &apos;As&apos; clause..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StrictDisallowImplicitObjectLambda">
<summary>
  Looks up a localized string similar to Option Strict On requires each lambda expression parameter to be declared with an &apos;As&apos; clause if its type cannot be inferred..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StrictDisallowsImplicitArgs">
<summary>
  Looks up a localized string similar to Option Strict On requires that all method parameters have an &apos;As&apos; clause..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StrictDisallowsImplicitProc">
<summary>
  Looks up a localized string similar to Option Strict On requires all Function, Property, and Operator declarations to have an &apos;As&apos; clause..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StrictDisallowsLateBinding">
<summary>
  Looks up a localized string similar to Option Strict On disallows late binding..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StrictDisallowsObjectComparison1">
<summary>
  Looks up a localized string similar to Option Strict On disallows operands of type Object for operator &apos;{0}&apos;. Use the &apos;Is&apos; operator to test for object identity..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StrictDisallowsObjectOperand1">
<summary>
  Looks up a localized string similar to Option Strict On prohibits operands of type Object for operator &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StructCantInherit">
<summary>
  Looks up a localized string similar to Structures cannot have &apos;Inherits&apos; statements..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StructCantUseDLLDeclareSpecifier1">
<summary>
  Looks up a localized string similar to &apos;Declare&apos; statements in a structure cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StructCantUseVarSpecifier1">
<summary>
  Looks up a localized string similar to Members in a Structure cannot be declared &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StructLayoutAttributeNotAllowed">
<summary>
  Looks up a localized string similar to Attribute &apos;StructLayout&apos; cannot be applied to a generic type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StructsCannotHandleEvents">
<summary>
  Looks up a localized string similar to Methods declared in structures cannot have &apos;Handles&apos; clauses..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StructureCantUseProtected">
<summary>
  Looks up a localized string similar to Method in a structure cannot be declared &apos;Protected&apos; or &apos;Protected Friend&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StructureNoDefault1">
<summary>
  Looks up a localized string similar to Structure &apos;{0}&apos; cannot be indexed because it has no default property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_StructureNotExpression1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is a structure type and cannot be used as an expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SubDisallowsStatement">
<summary>
  Looks up a localized string similar to Statement is not valid inside a single-line statement lambda..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SubNewCycle1">
<summary>
  Looks up a localized string similar to Constructor &apos;{0}&apos; cannot call itself: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SubNewCycle2">
<summary>
  Looks up a localized string similar to 
    &apos;{0}&apos; calls &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SubRequiresParenthesesBang">
<summary>
  Looks up a localized string similar to This single-line statement lambda must be enclosed in parentheses. For example: (Sub() &lt;statement&gt;)!key.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SubRequiresParenthesesDot">
<summary>
  Looks up a localized string similar to This single-line statement lambda must be enclosed in parentheses. For example: (Sub() &lt;statement&gt;).Invoke().
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SubRequiresParenthesesLParen">
<summary>
  Looks up a localized string similar to This single-line statement lambda must be enclosed in parentheses. For example: Call (Sub() &lt;statement&gt;) ().
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SubRequiresSingleStatement">
<summary>
  Looks up a localized string similar to Single-line statement lambdas must include exactly one statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SwitchNeedsBool">
<summary>
  Looks up a localized string similar to option &apos;{0}&apos; can be followed only by &apos;+&apos; or &apos;-&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SxSIndirectRefHigherThanDirectRef3">
<summary>
  Looks up a localized string similar to The project currently contains references to more than one version of &apos;{0}&apos;, a direct reference to version {2} and an indirect reference to version {1}. Change the direct reference to use version {1} (or higher) of {0}..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SynchronizedAsyncMethod">
<summary>
  Looks up a localized string similar to &apos;MethodImplOptions.Synchronized&apos; cannot be applied to an Async method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SyncLockRequiresReferenceType1">
<summary>
  Looks up a localized string similar to &apos;SyncLock&apos; operand cannot be of type &apos;{0}&apos; because &apos;{0}&apos; is not a reference type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_Syntax">
<summary>
  Looks up a localized string similar to Syntax error..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SyntaxInCastOp">
<summary>
  Looks up a localized string similar to Syntax error in cast operator; two arguments separated by comma are required..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SynthMemberClashesWithMember5">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; implicitly defines &apos;{2}&apos;, which conflicts with a member of the same name in {3} &apos;{4}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SynthMemberClashesWithSynth7">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; implicitly defines &apos;{2}&apos;, which conflicts with a member implicitly declared for {3} &apos;{4}&apos; in {5} &apos;{6}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SynthMemberShadowsMustOverride5">
<summary>
  Looks up a localized string similar to &apos;{0}&apos;, implicitly declared for {1} &apos;{2}&apos;, cannot shadow a &apos;MustOverride&apos; method in the base {3} &apos;{4}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_SyntMemberShadowsGenericParam3">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; implicitly defines a member &apos;{2}&apos; which has the same name as a type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TooFewGenericArguments1">
<summary>
  Looks up a localized string similar to Too few type arguments to &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TooFewGenericArguments2">
<summary>
  Looks up a localized string similar to Too few type arguments to extension method &apos;{0}&apos; defined in &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TooFewIndices">
<summary>
  Looks up a localized string similar to Number of indices is less than the number of dimensions of the indexed array..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TooLongMetadataName">
<summary>
  Looks up a localized string similar to Name &apos;{0}&apos; exceeds the maximum length allowed in metadata..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TooLongOrComplexExpression">
<summary>
  Looks up a localized string similar to An expression is too long or complex to compile.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TooManyArgs">
<summary>
  Looks up a localized string similar to Too many arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TooManyArgs1">
<summary>
  Looks up a localized string similar to Too many arguments to &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TooManyArgs2">
<summary>
  Looks up a localized string similar to Too many arguments to extension method &apos;{0}&apos; defined in &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TooManyGenericArguments1">
<summary>
  Looks up a localized string similar to Too many type arguments to &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TooManyGenericArguments2">
<summary>
  Looks up a localized string similar to Too many type arguments to extension method &apos;{0}&apos; defined in &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TooManyIndices">
<summary>
  Looks up a localized string similar to Number of indices exceeds the number of dimensions of the indexed array..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TooManyUserStrings">
<summary>
  Looks up a localized string similar to Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string or XML literals..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TryAndOnErrorDoNotMix">
<summary>
  Looks up a localized string similar to Method cannot contain both a &apos;Try&apos; statement and an &apos;On Error&apos; or &apos;Resume&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TryCastOfUnconstrainedTypeParam1">
<summary>
  Looks up a localized string similar to &apos;TryCast&apos; operands must be class-constrained type parameter, but &apos;{0}&apos; has no class constraint..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TryCastOfValueType1">
<summary>
  Looks up a localized string similar to &apos;TryCast&apos; operand must be reference type, but &apos;{0}&apos; is a value type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TryWithoutCatchOrFinally">
<summary>
  Looks up a localized string similar to Try must have at least one &apos;Catch&apos; or a &apos;Finally&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TwoParametersRequired1">
<summary>
  Looks up a localized string similar to Operator &apos;{0}&apos; must have two parameters..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeArgsUnexpected">
<summary>
  Looks up a localized string similar to Type arguments unexpected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypecharNoMatch2">
<summary>
  Looks up a localized string similar to Type character &apos;{0}&apos; does not match declared data type &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypecharNotallowed">
<summary>
  Looks up a localized string similar to Type declaration characters are not valid in this context..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeCharOnAggregation">
<summary>
  Looks up a localized string similar to Aggregate function name cannot be used with a type character..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeCharOnGenericParam">
<summary>
  Looks up a localized string similar to Type character cannot be used in a type parameter declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeCharOnSub">
<summary>
  Looks up a localized string similar to Type character cannot be used in a &apos;Sub&apos; declaration because a &apos;Sub&apos; doesn&apos;t return a value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeCharWithType1">
<summary>
  Looks up a localized string similar to Type character &apos;{0}&apos; cannot be used in a declaration with an explicit type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeClashesWithVbCoreType4">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; conflicts with a Visual Basic Runtime {2} &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeConflict6">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; and {2} &apos;{3}&apos; conflict in {4} &apos;{5}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeDisallowsAttributes">
<summary>
  Looks up a localized string similar to XML attributes cannot be selected from type &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeDisallowsDescendants">
<summary>
  Looks up a localized string similar to XML descendant elements cannot be selected from type &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeDisallowsElements">
<summary>
  Looks up a localized string similar to XML elements cannot be selected from type &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeFwdCycle2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; in assembly &apos;{1}&apos; has been forwarded to itself and so is an unsupported type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceArrayRankMismatch1">
<summary>
  Looks up a localized string similar to Cannot infer a data type for &apos;{0}&apos; because the array dimensions do not match..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailure1">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) cannot be inferred from these arguments. Specifying the data type(s) explicitly might correct this error..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailure2">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) in method &apos;{0}&apos; cannot be inferred from these arguments. Specifying the data type(s) explicitly might correct this error..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailure3">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) in extension method &apos;{0}&apos; defined in &apos;{1}&apos; cannot be inferred from these arguments. Specifying the data type(s) explicitly might correct this error..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureAmbiguous1">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) cannot be inferred from these arguments because more than one type is possible. Specifying the data type(s) explicitly might correct this error..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureAmbiguous2">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) in method &apos;{0}&apos; cannot be inferred from these arguments because more than one type is possible. Specifying the data type(s) explicitly might correct this error..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureAmbiguous3">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) in extension method &apos;{0}&apos; defined in &apos;{1}&apos; cannot be inferred from these arguments because more than one type is possible. Specifying the data type(s) explicitly might correct this error..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureNoBest1">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) cannot be inferred from these arguments because they do not convert to the same type. Specifying the data type(s) explicitly might correct this error..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureNoBest2">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) in method &apos;{0}&apos; cannot be inferred from these arguments because they do not convert to the same type. Specifying the data type(s) explicitly might correct this error..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureNoBest3">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) in extension method &apos;{0}&apos; defined in &apos;{1}&apos; cannot be inferred from these arguments because they do not convert to the same type. Specifying the data type(s) explicitly might correct this error..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureNoExplicit1">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) cannot be inferred from these arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureNoExplicit2">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) in method &apos;{0}&apos; cannot be inferred from these arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureNoExplicit3">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) in extension method &apos;{0}&apos; defined in &apos;{1}&apos; cannot be inferred from these arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureNoExplicitAmbiguous1">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) cannot be inferred from these arguments because more than one type is possible..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureNoExplicitAmbiguous2">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) in method &apos;{0}&apos; cannot be inferred from these arguments because more than one type is possible..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureNoExplicitAmbiguous3">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) in extension method &apos;{0}&apos; defined in &apos;{1}&apos; cannot be inferred from these arguments because more than one type is possible..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureNoExplicitNoBest1">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) cannot be inferred from these arguments because they do not convert to the same type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureNoExplicitNoBest2">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) in method &apos;{0}&apos; cannot be inferred from these arguments because they do not convert to the same type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInferenceFailureNoExplicitNoBest3">
<summary>
  Looks up a localized string similar to Data type(s) of the type parameter(s) in extension method &apos;{0}&apos; defined in &apos;{1}&apos; cannot be inferred from these arguments because they do not convert to the same type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeInItsInheritsClause1">
<summary>
  Looks up a localized string similar to Class &apos;{0}&apos; cannot reference itself in Inherits clause..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeMismatch2">
<summary>
  Looks up a localized string similar to Value of type &apos;{0}&apos; cannot be converted to &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeMismatchForXml3">
<summary>
  Looks up a localized string similar to Value of type &apos;{0}&apos; cannot be converted to &apos;{1}&apos;. You can use the &apos;Value&apos; property to get the string value of the first element of &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeNotExpression1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is a type and cannot be used as an expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeOfExprAlwaysFalse2">
<summary>
  Looks up a localized string similar to Expression of type &apos;{0}&apos; can never be of type &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeOfRequiresReferenceType1">
<summary>
  Looks up a localized string similar to &apos;TypeOf ... Is&apos; requires its left operand to have a reference type, but this operand has the value type &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeOrMemberNotGeneric1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; has no type parameters and so cannot have type arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeOrMemberNotGeneric2">
<summary>
  Looks up a localized string similar to Extension method &apos;{0}&apos; defined in &apos;{1}&apos; is not generic (or has no free type parameters) and so cannot have type arguments..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeParamMissingAsCommaOrRParen">
<summary>
  Looks up a localized string similar to &apos;As&apos;, comma or &apos;)&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeParamMissingCommaOrRParen">
<summary>
  Looks up a localized string similar to Comma or &apos;)&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeParamNameFunctionNameCollision">
<summary>
  Looks up a localized string similar to Type parameter cannot have the same name as its defining function..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeParamQualifierDisallowed">
<summary>
  Looks up a localized string similar to Type parameters cannot be used as qualifiers..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeParamWithStructConstAsConst">
<summary>
  Looks up a localized string similar to Type parameter with a &apos;Structure&apos; constraint cannot be used as a constraint..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_TypeRefResolutionError3">
<summary>
  Looks up a localized string similar to Import of type &apos;{0}&apos; from assembly or module &apos;{1}&apos; failed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnableToCreateTempFile">
<summary>
  Looks up a localized string similar to Cannot create temporary file: {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnableToOpenResourceFile1">
<summary>
  Looks up a localized string similar to Unable to open resource file &apos;{0}&apos;: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnableToReadUacManifest2">
<summary>
  Looks up a localized string similar to Unable to open Win32 manifest file &apos;{0}&apos; : {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnacceptableForLoopOperator2">
<summary>
  Looks up a localized string similar to Return and parameter types of &apos;{0}&apos; must be &apos;{1}&apos; to be used in a &apos;For&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnacceptableForLoopRelOperator2">
<summary>
  Looks up a localized string similar to Parameter types of &apos;{0}&apos; must be &apos;{1}&apos; to be used in a &apos;For&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnacceptableLogicalOperator3">
<summary>
  Looks up a localized string similar to Return and parameter types of &apos;{0}&apos; must be &apos;{1}&apos; to be used in a &apos;{2}&apos; expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnaryOperand2">
<summary>
  Looks up a localized string similar to Operator &apos;{0}&apos; is not defined for type &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnaryParamMustBeContainingType1">
<summary>
  Looks up a localized string similar to Parameter of this unary operator must be of the containing type &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnboundTypeParam1">
<summary>
  Looks up a localized string similar to Type parameter &apos;{0}&apos; cannot be inferred..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnboundTypeParam2">
<summary>
  Looks up a localized string similar to Type parameter &apos;{0}&apos; for &apos;{1}&apos; cannot be inferred..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnboundTypeParam3">
<summary>
  Looks up a localized string similar to Type parameter &apos;{0}&apos; for extension method &apos;{1}&apos; defined in &apos;{2}&apos; cannot be inferred..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UndefinedType1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; is not defined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UndefinedTypeOrNamespace1">
<summary>
  Looks up a localized string similar to Type or namespace &apos;{0}&apos; is not defined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UndefinedXmlPrefix">
<summary>
  Looks up a localized string similar to XML namespace prefix &apos;{0}&apos; is not defined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnexpectedExpressionStatement">
<summary>
  Looks up a localized string similar to Expression statement is only allowed at the end of an interactive submission..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnexpectedGroup">
<summary>
  Looks up a localized string similar to &apos;Group&apos; not allowed in this context; identifier expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnimplementedMember3">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; must implement &apos;{2}&apos; for interface &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnimplementedMustOverride">
<summary>
  Looks up a localized string similar to 
    {0}: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnknownOperator">
<summary>
  Looks up a localized string similar to Operator declaration must be one of:  +, -, *, \, /, ^, &amp;, Like, Mod, And, Or, Xor, Not, &lt;&lt;, &gt;&gt;, =, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=, CType, IsTrue, IsFalse..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnrecognizedEnd">
<summary>
  Looks up a localized string similar to &apos;End&apos; statement not valid..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnrecognizedType">
<summary>
  Looks up a localized string similar to Type expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnrecognizedTypeKeyword">
<summary>
  Looks up a localized string similar to Keyword does not name a type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnrecognizedTypeOrWith">
<summary>
  Looks up a localized string similar to Type or &apos;With&apos; expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnreferencedAssembly3">
<summary>
  Looks up a localized string similar to Reference required to assembly &apos;{0}&apos; containing the type &apos;{1}&apos;. Add one to your project..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnreferencedAssemblyBase3">
<summary>
  Looks up a localized string similar to Reference required to assembly &apos;{0}&apos; containing the base class &apos;{1}&apos;. Add one to your project..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnreferencedAssemblyEvent3">
<summary>
  Looks up a localized string similar to Reference required to assembly &apos;{0}&apos; containing the definition for event &apos;{1}&apos;. Add one to your project..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnreferencedAssemblyImplements3">
<summary>
  Looks up a localized string similar to Reference required to assembly &apos;{0}&apos; containing the implemented interface &apos;{1}&apos;. Add one to your project..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnreferencedModule3">
<summary>
  Looks up a localized string similar to Reference required to module &apos;{0}&apos; containing the type &apos;{1}&apos;. Add one to your project..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnreferencedModuleBase3">
<summary>
  Looks up a localized string similar to Reference required to module &apos;{0}&apos; containing the base class &apos;{1}&apos;. Add one to your project..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnreferencedModuleEvent3">
<summary>
  Looks up a localized string similar to Reference required to module &apos;{0}&apos; containing the definition for event &apos;{1}&apos;. Add one to your project..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnreferencedModuleImplements3">
<summary>
  Looks up a localized string similar to Reference required to module &apos;{0}&apos; containing the implemented interface &apos;{1}&apos;. Add one to your project..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnsupportedConstant2">
<summary>
  Looks up a localized string similar to Field &apos;{0}.{1}&apos; has an invalid constant value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnsupportedEvent1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is an unsupported event..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnsupportedField1">
<summary>
  Looks up a localized string similar to Field &apos;{0}&apos; is of an unsupported type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnsupportedMethod1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; has a return type that is not supported or parameter types that are not supported..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnsupportedModule1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is an unsupported .NET module..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnsupportedProperty1">
<summary>
  Looks up a localized string similar to Property &apos;{0}&apos; is of an unsupported type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnsupportedType1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is an unsupported type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UnterminatedStringLiteral">
<summary>
  Looks up a localized string similar to String constants must end with a double quote..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UseOfKeywordFromModule1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid within a Module..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UseOfKeywordFromStructure1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not valid within a structure..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UseOfKeywordNotInInstanceMethod1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is valid only within an instance method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UseOfLocalBeforeDeclaration1">
<summary>
  Looks up a localized string similar to Local variable &apos;{0}&apos; cannot be referred to before it is declared..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UseOfObsoletePropertyAccessor2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; accessor of &apos;{1}&apos; is obsolete..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UseOfObsoletePropertyAccessor3">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; accessor of &apos;{1}&apos; is obsolete: &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UseOfObsoleteSymbol2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is obsolete: &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UseOfObsoleteSymbolNoMessage1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is obsolete..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UsingRequiresDisposePattern">
<summary>
  Looks up a localized string similar to &apos;Using&apos; operand of type &apos;{0}&apos; must implement &apos;System.IDisposable&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UsingResourceVarCantBeArray">
<summary>
  Looks up a localized string similar to &apos;Using&apos; resource variable type can not be array type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_UsingResourceVarNeedsInitializer">
<summary>
  Looks up a localized string similar to &apos;Using&apos; resource variable must have an explicit initialization..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ValueAndClassTypeConstrCombined">
<summary>
  Looks up a localized string similar to &apos;Structure&apos; constraint and a specific class type constraint cannot be combined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceConversionFailedIn6">
<summary>
  Looks up a localized string similar to &apos;{4}&apos; cannot be converted to &apos;{5}&apos; because &apos;{0}&apos; is not derived from &apos;{1}&apos;, as required for the &apos;In&apos; generic parameter &apos;{2}&apos; in &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceConversionFailedOut6">
<summary>
  Looks up a localized string similar to &apos;{4}&apos; cannot be converted to &apos;{5}&apos; because &apos;{0}&apos; is not derived from &apos;{1}&apos;, as required for the &apos;Out&apos; generic parameter &apos;{2}&apos; in &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceConversionFailedTryIn4">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be converted to &apos;{1}&apos;. Consider changing the &apos;{2}&apos; in the definition of &apos;{3}&apos; to an In type parameter, &apos;In {2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceConversionFailedTryOut4">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be converted to &apos;{1}&apos;. Consider changing the &apos;{2}&apos; in the definition of &apos;{3}&apos; to an Out type parameter, &apos;Out {2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceDisallowedHere">
<summary>
  Looks up a localized string similar to Keywords &apos;Out&apos; and &apos;In&apos; can only be used in interface and delegate declarations..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceIEnumerableSuggestion3">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be converted to &apos;{1}&apos;. Consider using &apos;{2}&apos; instead..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceInByRefDisallowed1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used in this context because &apos;In&apos; and &apos;Out&apos; type parameters cannot be used for ByRef parameter types, and &apos;{0}&apos; is an &apos;In&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceInNullableDisallowed2">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used in &apos;{1}&apos; because &apos;In&apos; and &apos;Out&apos; type parameters cannot be made nullable, and &apos;{0}&apos; is an &apos;In&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceInParamDisallowed1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used in this context because &apos;{0}&apos; is an &apos;In&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceInParamDisallowedForGeneric3">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used for the &apos;{1}&apos; in &apos;{2}&apos; in this context because &apos;{0}&apos; is an &apos;In&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceInParamDisallowedHere2">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used in &apos;{1}&apos; in this context because &apos;{0}&apos; is an &apos;In&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceInParamDisallowedHereForGeneric4">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used for the &apos;{2}&apos; of &apos;{3}&apos; in &apos;{1}&apos; in this context because &apos;{0}&apos; is an &apos;In&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceInPropertyDisallowed1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used as a property type in this context because &apos;{0}&apos; is an &apos;In&apos; type parameter and the property is not marked WriteOnly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceInReadOnlyPropertyDisallowed1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used as a ReadOnly property type because &apos;{0}&apos; is an &apos;In&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceInReturnDisallowed1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used as a return type because &apos;{0}&apos; is an &apos;In&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceInterfaceNesting">
<summary>
  Looks up a localized string similar to Enumerations, classes, and structures cannot be declared in an interface that has an &apos;In&apos; or &apos;Out&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceOutByRefDisallowed1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used in this context because &apos;In&apos; and &apos;Out&apos; type parameters cannot be used for ByRef parameter types, and &apos;{0}&apos; is an &apos;Out&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceOutByValDisallowed1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used as a ByVal parameter type because &apos;{0}&apos; is an &apos;Out&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceOutConstraintDisallowed1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used as a generic type constraint because &apos;{0}&apos; is an &apos;Out&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceOutNullableDisallowed2">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used in &apos;{1}&apos; because &apos;In&apos; and &apos;Out&apos; type parameters cannot be made nullable, and &apos;{0}&apos; is an &apos;Out&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceOutParamDisallowed1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used in this context because &apos;{0}&apos; is an &apos;Out&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceOutParamDisallowedForGeneric3">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used for the &apos;{1}&apos; in &apos;{2}&apos; in this context because &apos;{0}&apos; is an &apos;Out&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceOutParamDisallowedHere2">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used in &apos;{1}&apos; in this context because &apos;{0}&apos; is an &apos;Out&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceOutParamDisallowedHereForGeneric4">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used for the &apos;{2}&apos; of &apos;{3}&apos; in &apos;{1}&apos; in this context because &apos;{0}&apos; is an &apos;Out&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceOutPropertyDisallowed1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used as a property type in this context because &apos;{0}&apos; is an &apos;Out&apos; type parameter and the property is not marked ReadOnly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceOutWriteOnlyPropertyDisallowed1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used as a WriteOnly property type because &apos;{0}&apos; is an &apos;Out&apos; type parameter..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VariancePreventsSynthesizedEvents2">
<summary>
  Looks up a localized string similar to Event definitions with parameters are not allowed in an interface such as &apos;{0}&apos; that has &apos;In&apos; or &apos;Out&apos; type parameters. Consider declaring the event by using a delegate type which is not defined within &apos;{0}&apos;. For example, &apos;Event {1} As Action(Of ...)&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceTypeDisallowed2">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used in this context because both the context and the definition of &apos;{0}&apos; are nested within interface &apos;{1}&apos;, and &apos;{1}&apos; has &apos;In&apos; or &apos;Out&apos; type parameters. Consider moving the definition of &apos;{0}&apos; outside of &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceTypeDisallowedForGeneric4">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used for the &apos;{2}&apos; in &apos;{3}&apos; in this context because both the context and the definition of &apos;{0}&apos; are nested within interface &apos;{1}&apos;, and &apos;{1}&apos; has &apos;In&apos; or &apos;Out&apos; type parameters. Consider moving the definition of &apos;{0}&apos; outside of &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceTypeDisallowedHere3">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used in &apos;{2}&apos; in this context because both the context and the definition of &apos;{0}&apos; are nested within interface &apos;{1}&apos;, and &apos;{1}&apos; has &apos;In&apos; or &apos;Out&apos; type parameters. Consider moving the definition of &apos;{0}&apos; outside of &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VarianceTypeDisallowedHereForGeneric5">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; cannot be used for the &apos;{3}&apos; of &apos;{4}&apos; in &apos;{2}&apos; in this context because both the context and the definition of &apos;{0}&apos; are nested within interface &apos;{1}&apos;, and &apos;{1}&apos; has &apos;In&apos; or &apos;Out&apos; type parameters. Consider moving the definition of &apos;{0}&apos; outside of &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VBCoreNetModuleConflict">
<summary>
  Looks up a localized string similar to The options /vbruntime* and /target:module cannot be combined..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VersionMustBeFirstInXmlDecl">
<summary>
  Looks up a localized string similar to XML attribute &apos;version&apos; must be the first attribute in XML declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VoidArrayDisallowed">
<summary>
  Looks up a localized string similar to Arrays of type &apos;System.Void&apos; are not allowed in this expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_VoidValue">
<summary>
  Looks up a localized string similar to Expression does not produce a value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_WinRTEventWithoutDelegate">
<summary>
  Looks up a localized string similar to Event declarations that target WinMD must specify a delegate type.  Add an As clause to the event declaration..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_WithEventsAsStruct">
<summary>
  Looks up a localized string similar to &apos;WithEvents&apos; variables can only be typed as classes, interfaces or type parameters with class constraints..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_WithEventsRequiresClass">
<summary>
  Looks up a localized string similar to &apos;WithEvents&apos; variables must have an &apos;As&apos; clause..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_WriteOnlyHasGet">
<summary>
  Looks up a localized string similar to Properties declared &apos;WriteOnly&apos; cannot have a &apos;Get&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_WriteOnlyHasNoWrite">
<summary>
  Looks up a localized string similar to &apos;WriteOnly&apos; property must provide a &apos;Set&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_WriteOnlyNoAccessorFlag">
<summary>
  Looks up a localized string similar to &apos;WriteOnly&apos; properties cannot have an access modifier on &apos;Set&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_XmlEndCDataNotAllowedInContent">
<summary>
  Looks up a localized string similar to The literal string &apos;]]&gt;&apos; is not allowed in element content..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_XmlEndElementNoMatchingStart">
<summary>
  Looks up a localized string similar to XML end element must be preceded by a matching start element..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_XmlEntityReference">
<summary>
  Looks up a localized string similar to XML entity references are not supported..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_XmlFeaturesNotAvailable">
<summary>
  Looks up a localized string similar to XML literals and XML axis properties are not available. Add references to System.Xml, System.Xml.Linq, and System.Core or other assemblies declaring System.Linq.Enumerable, System.Xml.Linq.XElement, System.Xml.Linq.XName, System.Xml.Linq.XAttribute and System.Xml.Linq.XNamespace types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_XmlPrefixNotExpression">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is an XML prefix and cannot be used as an expression.  Use the GetXmlNamespace operator to create a namespace object..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ERR_ZeroDivide">
<summary>
  Looks up a localized string similar to Division by zero occurred while evaluating this expression..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_ArrayLiterals">
<summary>
  Looks up a localized string similar to array literal expressions.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_AsyncExpressions">
<summary>
  Looks up a localized string similar to async methods or lambdas.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_AutoProperties">
<summary>
  Looks up a localized string similar to auto-implemented properties.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_CObjInAttributeArguments">
<summary>
  Looks up a localized string similar to CObj in attribute arguments.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_CoContraVariance">
<summary>
  Looks up a localized string similar to variance.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_CollectionInitializers">
<summary>
  Looks up a localized string similar to collection initializers.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_GlobalNamespace">
<summary>
  Looks up a localized string similar to declaring a Global namespace.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_ImplementingReadonlyOrWriteonlyPropertyWithReadwrite">
<summary>
  Looks up a localized string similar to implementing read-only or write-only property with read-write property.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_Iterators">
<summary>
  Looks up a localized string similar to iterators.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_LineContinuation">
<summary>
  Looks up a localized string similar to implicit line continuation.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_LineContinuationComments">
<summary>
  Looks up a localized string similar to line continuation comments.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_MultilineStringLiterals">
<summary>
  Looks up a localized string similar to multiline string literals.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_NameOfExpressions">
<summary>
  Looks up a localized string similar to &apos;nameof&apos; expressions.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_NullPropagatingOperator">
<summary>
  Looks up a localized string similar to null conditional operations.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_PartialInterfaces">
<summary>
  Looks up a localized string similar to partial interfaces.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_PartialModules">
<summary>
  Looks up a localized string similar to partial modules.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_ReadonlyAutoProperties">
<summary>
  Looks up a localized string similar to readonly auto-implemented properties.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_RegionsEverywhere">
<summary>
  Looks up a localized string similar to region directives within method bodies or regions crossing boundaries of declaration blocks.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_StatementLambdas">
<summary>
  Looks up a localized string similar to multi-line lambda expressions.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_SubLambdas">
<summary>
  Looks up a localized string similar to &apos;Sub&apos; lambda expressions.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_TypeOfIsNot">
<summary>
  Looks up a localized string similar to TypeOf IsNot expression.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_WarningDirectives">
<summary>
  Looks up a localized string similar to warning directives.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FEATURE_YearFirstDateLiterals">
<summary>
  Looks up a localized string similar to year-first date literals.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FieldInitializerSyntaxNotWithinSyntaxTree">
<summary>
  Looks up a localized string similar to FieldInitializerSyntax not within syntax tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FTL_InputFileNameTooLong">
<summary>
  Looks up a localized string similar to File name &apos;{0}&apos; is empty, contains invalid characters, has a drive specification without an absolute path, or is too long.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.FunctionSyntaxNotWithinSyntaxTree">
<summary>
  Looks up a localized string similar to FunctionSyntax not within syntax tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.HDN_UnusedImportClause">
<summary>
  Looks up a localized string similar to Unused import clause..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.HDN_UnusedImportClause_Title">
<summary>
  Looks up a localized string similar to Unused import clause.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.HDN_UnusedImportStatement">
<summary>
  Looks up a localized string similar to Unused import statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.HDN_UnusedImportStatement_Title">
<summary>
  Looks up a localized string similar to Unused import statement.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.IdentifierSyntaxNotWithinSyntaxTree">
<summary>
  Looks up a localized string similar to IdentifierSyntax not within syntax tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.IDS_FunctionReturnType">
<summary>
  Looks up a localized string similar to function return type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.IDS_InvalidPreprocessorConstantType">
<summary>
  Looks up a localized string similar to Preprocessor constant &apos;{0}&apos; of type &apos;{1}&apos; is not supported, only primitive types are allowed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.IDS_LogoLine1">
<summary>
  Looks up a localized string similar to {0} version {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.IDS_LogoLine2">
<summary>
  Looks up a localized string similar to Copyright (C) Microsoft Corporation. All rights reserved..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.IDS_MSG_ADDLINKREFERENCE">
<summary>
  Looks up a localized string similar to Adding embedded assembly reference &apos;{0}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.IDS_MSG_ADDMODULE">
<summary>
  Looks up a localized string similar to Adding module reference &apos;{0}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.IDS_MSG_ADDREFERENCE">
<summary>
  Looks up a localized string similar to Adding assembly reference &apos;{0}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.IDS_ProjectSettingsLocationName">
<summary>
  Looks up a localized string similar to &lt;project settings&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.IDS_TheSystemCannotFindThePathSpecified">
<summary>
  Looks up a localized string similar to The system cannot find the path specified.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.IDS_ToolName">
<summary>
  Looks up a localized string similar to Microsoft (R) Visual Basic Compiler.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.IDS_UnrecognizedFileFormat">
<summary>
  Looks up a localized string similar to Unrecognized file format..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.IDS_VBCHelp">
<summary>
  Looks up a localized string similar to                   Visual Basic Compiler Options

                                  - OUTPUT FILE -
/out:&lt;file&gt;                       Specifies the output file name.
/target:exe                       Create a console application (default). 
                                  (Short form: /t)
/target:winexe                    Create a Windows application.
/target:library                   Create a library assembly.
/target:module                    Create a module that can be added to an 
             [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.INF_UnableToLoadSomeTypesInAnalyzer">
<summary>
  Looks up a localized string similar to Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.INF_UnableToLoadSomeTypesInAnalyzer_Title">
<summary>
  Looks up a localized string similar to Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.LocationMustBeProvided">
<summary>
  Looks up a localized string similar to Location must be provided in order to provide minimal type qualification..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.NodeIsNotWithinSyntaxTree">
<summary>
  Looks up a localized string similar to Node is not within syntax tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.NoNoneSearchCriteria">
<summary>
  Looks up a localized string similar to SearchCriteria is expected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.NotAVbSymbol">
<summary>
  Looks up a localized string similar to Not a VB symbol..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.NotWithinTree">
<summary>
  Looks up a localized string similar to  not within tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.NumberOfTypeParametersAndArgumentsMustMatch">
<summary>
  Looks up a localized string similar to the number of type parameters and arguments should be the same.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.PositionIsNotWithinSyntax">
<summary>
  Looks up a localized string similar to Position is not within syntax tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.PositionNotWithinTree">
<summary>
  Looks up a localized string similar to Position must be within span of the syntax tree..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.PositionOfTypeParameterTooLarge">
<summary>
  Looks up a localized string similar to position of type parameter too large.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.PropertiesCanNotHaveTypeArguments">
<summary>
  Looks up a localized string similar to Properties can not have type arguments.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.RangeVariableSyntaxNotWithinSyntaxTree">
<summary>
  Looks up a localized string similar to RangeVariableSyntax not within syntax tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.SemanticModelMustBeProvided">
<summary>
  Looks up a localized string similar to SemanticModel must be provided in order to provide minimal type qualification..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.SpeculatedSyntaxNodeCannotBelongToCurrentCompilation">
<summary>
  Looks up a localized string similar to Syntax node to be speculated cannot belong to a syntax tree from the current compilation..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.StatementOrExpressionIsNotAValidType">
<summary>
  Looks up a localized string similar to StatementOrExpression is not an ExecutableStatementSyntax or an ExpressionSyntax.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.SubmissionCanHaveAtMostOneSyntaxTree">
<summary>
  Looks up a localized string similar to Submission can have at most one syntax tree..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.SyntaxTreeAlreadyPresent">
<summary>
  Looks up a localized string similar to Syntax tree already present.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.SyntaxTreeIsNotASubmission">
<summary>
  Looks up a localized string similar to Syntax tree should be created from a submission..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.SyntaxTreeNotFoundToRemove">
<summary>
  Looks up a localized string similar to SyntaxTree &apos;{0}&apos; not found to remove.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ThereAreNoPointerTypesInVB">
<summary>
  Looks up a localized string similar to There are no pointer types in VB..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.ThereIsNoDynamicTypeInVB">
<summary>
  Looks up a localized string similar to There is no dynamic type in VB..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.TreeMustHaveARootNodeWithCompilationUnit">
<summary>
  Looks up a localized string similar to Tree must have a root node with SyntaxKind.CompilationUnit.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.Trees0">
<summary>
  Looks up a localized string similar to trees({0}).
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.TreesMustHaveRootNode">
<summary>
  Looks up a localized string similar to trees({0}) must have root node with SyntaxKind.CompilationUnit..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.TypeArgumentCannotBeNothing">
<summary>
  Looks up a localized string similar to Type argument cannot be Nothing.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.TypeParameterNotWithinTree">
<summary>
  Looks up a localized string similar to TypeParameter not within tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.VariableSyntaxNotWithinSyntaxTree">
<summary>
  Looks up a localized string similar to variableSyntax not within syntax tree.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AmbiguousCastConversion2">
<summary>
  Looks up a localized string similar to Conversion from &apos;{0}&apos; to &apos;{1}&apos; may be ambiguous..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AmbiguousCastConversion2_Title">
<summary>
  Looks up a localized string similar to Conversion may be ambiguous.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AnalyzerCannotBeCreated">
<summary>
  Looks up a localized string similar to An instance of analyzer {0} cannot be created from {1} : {2}..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AnalyzerCannotBeCreated_Title">
<summary>
  Looks up a localized string similar to Instance of analyzer cannot be created.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ArrayInitNoTypeObjectAssumed">
<summary>
  Looks up a localized string similar to Cannot infer an element type; &apos;Object&apos; assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ArrayInitNoTypeObjectAssumed_Title">
<summary>
  Looks up a localized string similar to Cannot infer an element type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ArrayInitTooManyTypesObjectAssumed">
<summary>
  Looks up a localized string similar to Cannot infer an element type because more than one type is possible; &apos;Object&apos; assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ArrayInitTooManyTypesObjectAssumed_Title">
<summary>
  Looks up a localized string similar to Cannot infer an element type because more than one type is possible.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ArrayOverloadsNonCLS2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not CLS-compliant because it overloads &apos;{1}&apos; which differs from it only by array of array parameter types or by the rank of the array parameter types..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ArrayOverloadsNonCLS2_Title">
<summary>
  Looks up a localized string similar to Method is not CLS-compliant because it overloads method which differs from it only by array of array parameter types or by the rank of the array parameter types.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AssemblyAttributeFromModuleIsOverridden">
<summary>
  Looks up a localized string similar to Attribute &apos;{0}&apos; from module &apos;{1}&apos; will be ignored in favor of the instance appearing in source..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AssemblyAttributeFromModuleIsOverridden_Title">
<summary>
  Looks up a localized string similar to Attribute from module will be ignored in favor of the instance appearing in source.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AssemblyGeneration0">
<summary>
  Looks up a localized string similar to Possible problem detected while building assembly: {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AssemblyGeneration0_Title">
<summary>
  Looks up a localized string similar to Possible problem detected while building assembly.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AssemblyGeneration1">
<summary>
  Looks up a localized string similar to Possible problem detected while building assembly &apos;{0}&apos;: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AssemblyGeneration1_Title">
<summary>
  Looks up a localized string similar to Possible problem detected while building assembly.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AsyncLacksAwaits">
<summary>
  Looks up a localized string similar to This async method lacks &apos;Await&apos; operators and so will run synchronously. Consider using the &apos;Await&apos; operator to await non-blocking API calls, or &apos;Await Task.Run(...)&apos; to do CPU-bound work on a background thread..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AsyncLacksAwaits_Title">
<summary>
  Looks up a localized string similar to This async method lacks &apos;Await&apos; operators and so will run synchronously.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AsyncSubCouldBeFunction">
<summary>
  Looks up a localized string similar to Some overloads here take an Async Function rather than an Async Sub. Consider either using an Async Function, or casting this Async Sub explicitly to the desired type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_AsyncSubCouldBeFunction_Title">
<summary>
  Looks up a localized string similar to Some overloads here take an Async Function rather than an Async Sub.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_BadChecksumValExtChecksum">
<summary>
  Looks up a localized string similar to Bad checksum value, non hex digits or odd number of hex digits..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_BadChecksumValExtChecksum_Title">
<summary>
  Looks up a localized string similar to Bad checksum value, non hex digits or odd number of hex digits.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_BadGUIDFormatExtChecksum">
<summary>
  Looks up a localized string similar to Bad GUID format..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_BadGUIDFormatExtChecksum_Title">
<summary>
  Looks up a localized string similar to Bad GUID format.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_BadSwitch">
<summary>
  Looks up a localized string similar to unrecognized option &apos;{0}&apos;; ignored.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_BadSwitch_Title">
<summary>
  Looks up a localized string similar to Unrecognized command-line option.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_BadUILang">
<summary>
  Looks up a localized string similar to The language name &apos;{0}&apos; is invalid..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_BadUILang_Title">
<summary>
  Looks up a localized string similar to The language name for /preferreduilang is invalid.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_BaseClassNotCLSCompliant2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not CLS-compliant because it derives from &apos;{1}&apos;, which is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_BaseClassNotCLSCompliant2_Title">
<summary>
  Looks up a localized string similar to Type is not CLS-compliant because it derives from base type that is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_CannotFindStandardLibrary1">
<summary>
  Looks up a localized string similar to Could not find standard library &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_CannotFindStandardLibrary1_Title">
<summary>
  Looks up a localized string similar to Could not find standard library.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_CLSAttrInvalidOnGetSet">
<summary>
  Looks up a localized string similar to System.CLSCompliantAttribute cannot be applied to property &apos;Get&apos; or &apos;Set&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_CLSAttrInvalidOnGetSet_Title">
<summary>
  Looks up a localized string similar to System.CLSCompliantAttribute cannot be applied to property &apos;Get&apos; or &apos;Set&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_CLSEventMethodInNonCLSType3">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; method for event &apos;{1}&apos; cannot be marked CLS compliant because its containing type &apos;{2}&apos; is not CLS compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_CLSEventMethodInNonCLSType3_Title">
<summary>
  Looks up a localized string similar to AddHandler or RemoveHandler method for event cannot be marked CLS compliant because its containing type is not CLS compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_CLSMemberInNonCLSType3">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; cannot be marked CLS-compliant because its containing type &apos;{2}&apos; is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_CLSMemberInNonCLSType3_Title">
<summary>
  Looks up a localized string similar to Member cannot be marked CLS-compliant because its containing type is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ComClassInterfaceShadows5">
<summary>
  Looks up a localized string similar to &apos;Microsoft.VisualBasic.ComClassAttribute&apos; on class &apos;{0}&apos; implicitly declares {1} &apos;{2}&apos;, which conflicts with a member of the same name in {3} &apos;{4}&apos;. Use &apos;Microsoft.VisualBasic.ComClassAttribute(InterfaceShadows:=True)&apos; if you want to hide the name on the base {4}..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ComClassInterfaceShadows5_Title">
<summary>
  Looks up a localized string similar to &apos;Microsoft.VisualBasic.ComClassAttribute&apos; on class implicitly declares member, which conflicts with a member of the same name.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ComClassNoMembers1">
<summary>
  Looks up a localized string similar to &apos;Microsoft.VisualBasic.ComClassAttribute&apos; is specified for class &apos;{0}&apos; but &apos;{0}&apos; has no public members that can be exposed to COM; therefore, no COM interfaces are generated..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ComClassNoMembers1_Title">
<summary>
  Looks up a localized string similar to &apos;Microsoft.VisualBasic.ComClassAttribute&apos; is specified for class but class has no public members that can be exposed to COM.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ComClassPropertySetObject1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be exposed to COM as a property &apos;Let&apos;. You will not be able to assign non-object values (such as numbers or strings) to this property from Visual Basic 6.0 using a &apos;Let&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ComClassPropertySetObject1_Title">
<summary>
  Looks up a localized string similar to Property cannot be exposed to COM as a property &apos;Let&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ConditionalNotValidOnFunction">
<summary>
  Looks up a localized string similar to Attribute &apos;Conditional&apos; is only valid on &apos;Sub&apos; declarations..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ConditionalNotValidOnFunction_Title">
<summary>
  Looks up a localized string similar to Attribute &apos;Conditional&apos; is only valid on &apos;Sub&apos; declarations.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ConflictingMachineAssembly">
<summary>
  Looks up a localized string similar to Referenced assembly &apos;{0}&apos; targets a different processor..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ConflictingMachineAssembly_Title">
<summary>
  Looks up a localized string similar to Referenced assembly targets a different processor.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ConstraintsFailedForInferredArgs2">
<summary>
  Looks up a localized string similar to Type arguments inferred for method &apos;{0}&apos; result in the following warnings :{1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ConstraintsFailedForInferredArgs2_Title">
<summary>
  Looks up a localized string similar to Type arguments inferred for method result in warnings.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DebuggerHiddenIgnoredOnProperties">
<summary>
  Looks up a localized string similar to System.Diagnostics.DebuggerHiddenAttribute does not affect &apos;Get&apos; or &apos;Set&apos; when applied to the Property definition.  Apply the attribute directly to the &apos;Get&apos; and &apos;Set&apos; procedures as appropriate..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DebuggerHiddenIgnoredOnProperties_Title">
<summary>
  Looks up a localized string similar to System.Diagnostics.DebuggerHiddenAttribute does not affect &apos;Get&apos; or &apos;Set&apos; when applied to the Property definition.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValFuncRef1">
<summary>
  Looks up a localized string similar to Function &apos;{0}&apos; doesn&apos;t return a value on all code paths. A null reference exception could occur at run time when the result is used..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValFuncRef1_Title">
<summary>
  Looks up a localized string similar to Function doesn&apos;t return a value on all code paths.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValFuncVal1">
<summary>
  Looks up a localized string similar to Function &apos;{0}&apos; doesn&apos;t return a value on all code paths. Are you missing a &apos;Return&apos; statement?.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValFuncVal1_Title">
<summary>
  Looks up a localized string similar to Function doesn&apos;t return a value on all code paths.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValOpRef1">
<summary>
  Looks up a localized string similar to Operator &apos;{0}&apos; doesn&apos;t return a value on all code paths. A null reference exception could occur at run time when the result is used..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValOpRef1_Title">
<summary>
  Looks up a localized string similar to Operator doesn&apos;t return a value on all code paths.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValOpVal1">
<summary>
  Looks up a localized string similar to Operator &apos;{0}&apos; doesn&apos;t return a value on all code paths. Are you missing a &apos;Return&apos; statement?.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValOpVal1_Title">
<summary>
  Looks up a localized string similar to Operator doesn&apos;t return a value on all code paths.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValPropRef1">
<summary>
  Looks up a localized string similar to Property &apos;{0}&apos; doesn&apos;t return a value on all code paths. A null reference exception could occur at run time when the result is used..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValPropRef1_Title">
<summary>
  Looks up a localized string similar to Property doesn&apos;t return a value on all code paths.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValPropVal1">
<summary>
  Looks up a localized string similar to Property &apos;{0}&apos; doesn&apos;t return a value on all code paths. Are you missing a &apos;Return&apos; statement?.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValPropVal1_Title">
<summary>
  Looks up a localized string similar to Property doesn&apos;t return a value on all code paths.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValWinRtEventVal1">
<summary>
  Looks up a localized string similar to The AddHandler for Windows Runtime event &apos;{0}&apos; doesn&apos;t return a value on all code paths. Are you missing a &apos;Return&apos; statement?.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgNoRetValWinRtEventVal1_Title">
<summary>
  Looks up a localized string similar to The AddHandler for Windows Runtime event doesn&apos;t return a value on all code paths.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgUseNullRef">
<summary>
  Looks up a localized string similar to Variable &apos;{0}&apos; is used before it has been assigned a value. A null reference exception could result at runtime..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgUseNullRef_Title">
<summary>
  Looks up a localized string similar to Variable is used before it has been assigned a value.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgUseNullRefByRef">
<summary>
  Looks up a localized string similar to Variable &apos;{0}&apos; is passed by reference before it has been assigned a value. A null reference exception could result at runtime..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgUseNullRefByRef_Title">
<summary>
  Looks up a localized string similar to Variable is passed by reference before it has been assigned a value.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgUseNullRefByRefStr">
<summary>
  Looks up a localized string similar to Variable &apos;{0}&apos; is passed by reference before it has been assigned a value. A null reference exception could result at runtime. Make sure the structure or all the reference members are initialized before use.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgUseNullRefByRefStr_Title">
<summary>
  Looks up a localized string similar to Variable is passed by reference before it has been assigned a value.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgUseNullRefStr">
<summary>
  Looks up a localized string similar to Variable &apos;{0}&apos; is used before it has been assigned a value. A null reference exception could result at runtime. Make sure the structure or all the reference members are initialized before use.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefAsgUseNullRefStr_Title">
<summary>
  Looks up a localized string similar to Variable is used before it has been assigned a value.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefaultnessShadowed4">
<summary>
  Looks up a localized string similar to Default property &apos;{0}&apos; conflicts with the default property &apos;{1}&apos; in the base {2} &apos;{3}&apos;. &apos;{0}&apos; will be the default property. &apos;{0}&apos; should be declared &apos;Shadows&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DefaultnessShadowed4_Title">
<summary>
  Looks up a localized string similar to Default property conflicts with the default property in the base type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DelaySignButNoKey">
<summary>
  Looks up a localized string similar to Delay signing was specified and requires a public key, but no public key was specified..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DelaySignButNoKey_Title">
<summary>
  Looks up a localized string similar to Delay signing was specified and requires a public key, but no public key was specified.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DuplicateCatch">
<summary>
  Looks up a localized string similar to &apos;Catch&apos; block never reached; &apos;{0}&apos; handled above in the same Try statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_DuplicateCatch_Title">
<summary>
  Looks up a localized string similar to &apos;Catch&apos; block never reached; exception type handled above in the same Try statement.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_EmptyPrefixAndXmlnsLocalName">
<summary>
  Looks up a localized string similar to The xmlns attribute has special meaning and should not be written with a prefix..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_EmptyPrefixAndXmlnsLocalName_Title">
<summary>
  Looks up a localized string similar to The xmlns attribute has special meaning and should not be written with a prefix.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_EnumUnderlyingTypeNotCLS1">
<summary>
  Looks up a localized string similar to Underlying type &apos;{0}&apos; of Enum is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_EnumUnderlyingTypeNotCLS1_Title">
<summary>
  Looks up a localized string similar to Underlying type of Enum is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_EqualToLiteralNothing">
<summary>
  Looks up a localized string similar to This expression will always evaluate to Nothing (due to null propagation from the equals operator). To check if the value is null consider using &apos;Is Nothing&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_EqualToLiteralNothing_Title">
<summary>
  Looks up a localized string similar to This expression will always evaluate to Nothing.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_EventDelegateTypeNotCLSCompliant2">
<summary>
  Looks up a localized string similar to Delegate type &apos;{0}&apos; of event &apos;{1}&apos; is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_EventDelegateTypeNotCLSCompliant2_Title">
<summary>
  Looks up a localized string similar to Delegate type of event is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ExpectedInitComponentCall2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; in designer-generated type &apos;{1}&apos; should call InitializeComponent method..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ExpectedInitComponentCall2_Title">
<summary>
  Looks up a localized string similar to Constructor in designer-generated type should call InitializeComponent method.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_FieldNotCLSCompliant1">
<summary>
  Looks up a localized string similar to Type of member &apos;{0}&apos; is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_FieldNotCLSCompliant1_Title">
<summary>
  Looks up a localized string similar to Type of member is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_FileAlreadyIncluded">
<summary>
  Looks up a localized string similar to source file &apos;{0}&apos; specified multiple times.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_FileAlreadyIncluded_Title">
<summary>
  Looks up a localized string similar to Source file specified multiple times.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_GenericConstraintNotCLSCompliant1">
<summary>
  Looks up a localized string similar to Generic parameter constraint type &apos;{0}&apos; is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_GenericConstraintNotCLSCompliant1_Title">
<summary>
  Looks up a localized string similar to Generic parameter constraint type is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_IfNoTypeObjectAssumed">
<summary>
  Looks up a localized string similar to Cannot infer a common type; &apos;Object&apos; assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_IfNoTypeObjectAssumed_Title">
<summary>
  Looks up a localized string similar to Cannot infer a common type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_IfTooManyTypesObjectAssumed">
<summary>
  Looks up a localized string similar to Cannot infer a common type because more than one type is possible; &apos;Object&apos; assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_IfTooManyTypesObjectAssumed_Title">
<summary>
  Looks up a localized string similar to Cannot infer a common type because more than one type is possible.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_IgnoreModuleManifest">
<summary>
  Looks up a localized string similar to Option /win32manifest ignored. It can be specified only when the target is an assembly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_IgnoreModuleManifest_Title">
<summary>
  Looks up a localized string similar to Option /win32manifest ignored.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ImplicitConversion2">
<summary>
  Looks up a localized string similar to Implicit conversion from &apos;{0}&apos; to &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ImplicitConversion2_Title">
<summary>
  Looks up a localized string similar to Implicit conversion.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ImplicitConversionCopyBack">
<summary>
  Looks up a localized string similar to Implicit conversion from &apos;{1}&apos; to &apos;{2}&apos; in copying the value of &apos;ByRef&apos; parameter &apos;{0}&apos; back to the matching argument..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ImplicitConversionCopyBack_Title">
<summary>
  Looks up a localized string similar to Implicit conversion in copying the value of &apos;ByRef&apos; parameter back to the matching argument.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ImplicitConversionSubst1">
<summary>
  Looks up a localized string similar to {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ImplicitConversionSubst1_Title">
<summary>
  Looks up a localized string similar to Implicit conversion.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_IndirectRefToLinkedAssembly2">
<summary>
  Looks up a localized string similar to A reference was created to embedded interop assembly &apos;{0}&apos; because of an indirect reference to that assembly from assembly &apos;{1}&apos;. Consider changing the &apos;Embed Interop Types&apos; property on either assembly..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_IndirectRefToLinkedAssembly2_Title">
<summary>
  Looks up a localized string similar to A reference was created to embedded interop assembly because of an indirect reference to that assembly.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_InheritedInterfaceNotCLSCompliant2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is not CLS-compliant because the interface &apos;{1}&apos; it inherits from is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_InheritedInterfaceNotCLSCompliant2_Title">
<summary>
  Looks up a localized string similar to Type is not CLS-compliant because the interface it inherits from is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_InterfaceConversion2">
<summary>
  Looks up a localized string similar to Runtime errors might occur when converting &apos;{0}&apos; to &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_InterfaceConversion2_Title">
<summary>
  Looks up a localized string similar to Runtime errors might occur when converting to or from interface type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_InvalidAssemblyName">
<summary>
  Looks up a localized string similar to Assembly reference &apos;{0}&apos; is invalid and cannot be resolved..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_InvalidAssemblyName_Title">
<summary>
  Looks up a localized string similar to Assembly reference is invalid and cannot be resolved.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_InvalidVersionFormat">
<summary>
  Looks up a localized string similar to The specified version string does not conform to the recommended format - major.minor.build.revision.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_InvalidVersionFormat_Title">
<summary>
  Looks up a localized string similar to The specified version string does not conform to the recommended format.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_InvalidWarningId">
<summary>
  Looks up a localized string similar to warning number &apos;{0}&apos; for the option &apos;{1}&apos; is either not configurable or not valid.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_InvalidWarningId_Title">
<summary>
  Looks up a localized string similar to Warning number is either not configurable or not valid.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_LambdaNoTypeObjectAssumed">
<summary>
  Looks up a localized string similar to Cannot infer a return type; &apos;Object&apos; assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_LambdaNoTypeObjectAssumed_Title">
<summary>
  Looks up a localized string similar to Cannot infer a return type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_LambdaPassedToRemoveHandler">
<summary>
  Looks up a localized string similar to Lambda expression will not be removed from this event handler. Assign the lambda expression to a variable and use the variable to add and remove the event..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_LambdaPassedToRemoveHandler_Title">
<summary>
  Looks up a localized string similar to Lambda expression will not be removed from this event handler.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_LambdaTooManyTypesObjectAssumed">
<summary>
  Looks up a localized string similar to Cannot infer a return type because more than one type is possible; &apos;Object&apos; assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_LambdaTooManyTypesObjectAssumed_Title">
<summary>
  Looks up a localized string similar to Cannot infer a return type because more than one type is possible.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_LateBindingResolution">
<summary>
  Looks up a localized string similar to Late bound resolution; runtime errors could occur..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_LateBindingResolution_Title">
<summary>
  Looks up a localized string similar to Late bound resolution.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_LiftControlVariableLambda">
<summary>
  Looks up a localized string similar to Using the iteration variable in a lambda expression may have unexpected results.  Instead, create a local variable within the loop and assign it the value of the iteration variable..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_LiftControlVariableLambda_Title">
<summary>
  Looks up a localized string similar to Using the iteration variable in a lambda expression may have unexpected results.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_LiftControlVariableQuery">
<summary>
  Looks up a localized string similar to Using the iteration variable in a query expression may have unexpected results.  Instead, create a local variable within the loop and assign it the value of the iteration variable..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_LiftControlVariableQuery_Title">
<summary>
  Looks up a localized string similar to Using the iteration variable in a query expression may have unexpected results.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MainIgnored">
<summary>
  Looks up a localized string similar to The entry point of the program is global script code; ignoring &apos;{0}&apos; entry point..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MainIgnored_Title">
<summary>
  Looks up a localized string similar to The entry point of the program is global script code; ignoring entry point.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MemberShadowsSynthMember6">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; conflicts with a member implicitly declared for {2} &apos;{3}&apos; in the base {4} &apos;{5}&apos; and should be declared &apos;Shadows&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MemberShadowsSynthMember6_Title">
<summary>
  Looks up a localized string similar to Member conflicts with a member implicitly declared for property or event in the base type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MissingAsClauseinFunction">
<summary>
  Looks up a localized string similar to Function without an &apos;As&apos; clause; return type of Object assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MissingAsClauseinFunction_Title">
<summary>
  Looks up a localized string similar to Function without an &apos;As&apos; clause.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MissingAsClauseinOperator">
<summary>
  Looks up a localized string similar to Operator without an &apos;As&apos; clause; type of Object assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MissingAsClauseinOperator_Title">
<summary>
  Looks up a localized string similar to Operator without an &apos;As&apos; clause.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MissingAsClauseinProperty">
<summary>
  Looks up a localized string similar to Property without an &apos;As&apos; clause; type of Object assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MissingAsClauseinProperty_Title">
<summary>
  Looks up a localized string similar to Property without an &apos;As&apos; clause.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MissingAsClauseinVarDecl">
<summary>
  Looks up a localized string similar to Variable declaration without an &apos;As&apos; clause; type of Object assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MissingAsClauseinVarDecl_Title">
<summary>
  Looks up a localized string similar to Variable declaration without an &apos;As&apos; clause.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MultipleDeclFileExtChecksum">
<summary>
  Looks up a localized string similar to File name already declared with a different GUID and checksum value..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MultipleDeclFileExtChecksum_Title">
<summary>
  Looks up a localized string similar to File name already declared with a different GUID and checksum value.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MustOverloadBase4">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; shadows an overloadable member declared in the base {2} &apos;{3}&apos;.  If you want to overload the base method, this method must be declared &apos;Overloads&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MustOverloadBase4_Title">
<summary>
  Looks up a localized string similar to Member shadows an overloadable member declared in the base type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MustOverride2">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; shadows an overridable method in the base {2} &apos;{3}&apos;. To override the base method, this method must be declared &apos;Overrides&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MustOverride2_Title">
<summary>
  Looks up a localized string similar to Member shadows an overridable method in the base type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MustShadowOnMultipleInheritance2">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; conflicts with other members of the same name across the inheritance hierarchy and so should be declared &apos;Shadows&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MustShadowOnMultipleInheritance2_Title">
<summary>
  Looks up a localized string similar to Method conflicts with other members of the same name across the inheritance hierarchy and so should be declared &apos;Shadows&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MutableGenericStructureInUsing">
<summary>
  Looks up a localized string similar to Local variable &apos;{0}&apos; is read-only. When its type is a structure, invoking its members or passing it ByRef does not change its content and might lead to unexpected results. Consider declaring this variable outside of the &apos;Using&apos; block..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MutableGenericStructureInUsing_Title">
<summary>
  Looks up a localized string similar to Local variable declared by Using statement is read-only and its type may be a structure.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MutableStructureInUsing">
<summary>
  Looks up a localized string similar to Local variable &apos;{0}&apos; is read-only and its type is a structure. Invoking its members or passing it ByRef does not change its content and might lead to unexpected results. Consider declaring this variable outside of the &apos;Using&apos; block..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_MutableStructureInUsing_Title">
<summary>
  Looks up a localized string similar to Local variable declared by Using statement is read-only and its type is a structure.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NameNotCLSCompliant1">
<summary>
  Looks up a localized string similar to Name &apos;{0}&apos; is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NameNotCLSCompliant1_Title">
<summary>
  Looks up a localized string similar to Name is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NamespaceCaseMismatch3">
<summary>
  Looks up a localized string similar to Casing of namespace name &apos;{0}&apos; does not match casing of namespace name &apos;{1}&apos; in &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NamespaceCaseMismatch3_Title">
<summary>
  Looks up a localized string similar to Casing of namespace name does not match.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NoAnalyzerInAssembly">
<summary>
  Looks up a localized string similar to The assembly {0} does not contain any analyzers..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NoAnalyzerInAssembly_Title">
<summary>
  Looks up a localized string similar to Assembly does not contain any analyzers.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NoConfigInResponseFile">
<summary>
  Looks up a localized string similar to ignoring /noconfig option because it was specified in a response file.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NoConfigInResponseFile_Title">
<summary>
  Looks up a localized string similar to Ignoring /noconfig option because it was specified in a response file.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NonCLSMemberInCLSInterface1">
<summary>
  Looks up a localized string similar to Non CLS-compliant &apos;{0}&apos; is not allowed in a CLS-compliant interface..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NonCLSMemberInCLSInterface1_Title">
<summary>
  Looks up a localized string similar to Non CLS-compliant member is not allowed in a CLS-compliant interface.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NonCLSMustOverrideInCLSType1">
<summary>
  Looks up a localized string similar to Non CLS-compliant &apos;MustOverride&apos; member is not allowed in CLS-compliant type &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NonCLSMustOverrideInCLSType1_Title">
<summary>
  Looks up a localized string similar to Non CLS-compliant &apos;MustOverride&apos; member is not allowed in CLS-compliant type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NoNonObsoleteConstructorOnBase3">
<summary>
  Looks up a localized string similar to Class &apos;{0}&apos; should declare a &apos;Sub New&apos; because the &apos;{1}&apos; in its base class &apos;{2}&apos; is marked obsolete..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NoNonObsoleteConstructorOnBase3_Title">
<summary>
  Looks up a localized string similar to Class should declare a &apos;Sub New&apos; because the constructor in its base class is marked obsolete.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NoNonObsoleteConstructorOnBase4">
<summary>
  Looks up a localized string similar to Class &apos;{0}&apos; should declare a &apos;Sub New&apos; because the &apos;{1}&apos; in its base class &apos;{2}&apos; is marked obsolete: &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NoNonObsoleteConstructorOnBase4_Title">
<summary>
  Looks up a localized string similar to Class should declare a &apos;Sub New&apos; because the constructor in its base class is marked obsolete.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NotEqualToLiteralNothing">
<summary>
  Looks up a localized string similar to This expression will always evaluate to Nothing (due to null propagation from the equals operator). To check if the value is not null consider using &apos;IsNot Nothing&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_NotEqualToLiteralNothing_Title">
<summary>
  Looks up a localized string similar to This expression will always evaluate to Nothing.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectAssumed1">
<summary>
  Looks up a localized string similar to {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectAssumed1_Title">
<summary>
  Looks up a localized string similar to Function without an &apos;As&apos; clause.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectAssumedProperty1">
<summary>
  Looks up a localized string similar to {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectAssumedProperty1_Title">
<summary>
  Looks up a localized string similar to Property without an &apos;As&apos; clause.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectAssumedVar1">
<summary>
  Looks up a localized string similar to {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectAssumedVar1_Title">
<summary>
  Looks up a localized string similar to Variable declaration without an &apos;As&apos; clause.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectMath1">
<summary>
  Looks up a localized string similar to Operands of type Object used for operator &apos;{0}&apos;; use the &apos;Is&apos; operator to test object identity..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectMath1_Title">
<summary>
  Looks up a localized string similar to Operands of type Object used for operator.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectMath1Not">
<summary>
  Looks up a localized string similar to Operands of type Object used for operator &apos;{0}&apos;; use the &apos;IsNot&apos; operator to test object identity..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectMath1Not_Title">
<summary>
  Looks up a localized string similar to Operands of type Object used for operator &lt;&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectMath2">
<summary>
  Looks up a localized string similar to Operands of type Object used for operator &apos;{0}&apos;; runtime errors could occur..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectMath2_Title">
<summary>
  Looks up a localized string similar to Operands of type Object used for operator.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectMathSelectCase">
<summary>
  Looks up a localized string similar to Operands of type Object used in expressions for &apos;Select&apos;, &apos;Case&apos; statements; runtime errors could occur..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObjectMathSelectCase_Title">
<summary>
  Looks up a localized string similar to Operands of type Object used in expressions for &apos;Select&apos;, &apos;Case&apos; statements.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObsoleteIdentityDirectCastForValueType">
<summary>
  Looks up a localized string similar to Using DirectCast operator to cast a value-type to the same type is obsolete..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ObsoleteIdentityDirectCastForValueType_Title">
<summary>
  Looks up a localized string similar to Using DirectCast operator to cast a value-type to the same type is obsolete.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_OptionalValueNotCLSCompliant1">
<summary>
  Looks up a localized string similar to Type of optional value for optional parameter &apos;{0}&apos; is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_OptionalValueNotCLSCompliant1_Title">
<summary>
  Looks up a localized string similar to Type of optional value for optional parameter is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_OverlappingCatch">
<summary>
  Looks up a localized string similar to &apos;Catch&apos; block never reached, because &apos;{0}&apos; inherits from &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_OverlappingCatch_Title">
<summary>
  Looks up a localized string similar to &apos;Catch&apos; block never reached; exception type&apos;s base type handled above in the same Try statement.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_OverrideType5">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; conflicts with {2} &apos;{1}&apos; in the base {3} &apos;{4}&apos; and should be declared &apos;Shadows&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_OverrideType5_Title">
<summary>
  Looks up a localized string similar to Member conflicts with member in the base type and should be declared &apos;Shadows&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ParamNotCLSCompliant1">
<summary>
  Looks up a localized string similar to Type of parameter &apos;{0}&apos; is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ParamNotCLSCompliant1_Title">
<summary>
  Looks up a localized string similar to Type of parameter is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_PdbLocalNameTooLong">
<summary>
  Looks up a localized string similar to Local name &apos;{0}&apos; is too long for PDB.  Consider shortening or compiling without /debug..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_PdbLocalNameTooLong_Title">
<summary>
  Looks up a localized string similar to Local name is too long for PDB.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_PdbUsingNameTooLong">
<summary>
  Looks up a localized string similar to Import string &apos;{0}&apos; is too long for PDB.  Consider shortening or compiling without /debug..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_PdbUsingNameTooLong_Title">
<summary>
  Looks up a localized string similar to Import string is too long for PDB.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_PrefixAndXmlnsLocalName">
<summary>
  Looks up a localized string similar to It is not recommended to have attributes named xmlns. Did you mean to write &apos;xmlns:{0}&apos; to define a prefix named &apos;{0}&apos;?.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_PrefixAndXmlnsLocalName_Title">
<summary>
  Looks up a localized string similar to It is not recommended to have attributes named xmlns.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ProcTypeNotCLSCompliant1">
<summary>
  Looks up a localized string similar to Return type of function &apos;{0}&apos; is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ProcTypeNotCLSCompliant1_Title">
<summary>
  Looks up a localized string similar to Return type of function is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_QueryMissingAsClauseinVarDecl">
<summary>
  Looks up a localized string similar to Range variable is assumed to be of type Object because its type cannot be inferred. Use an &apos;As&apos; clause to specify a different type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_QueryMissingAsClauseinVarDecl_Title">
<summary>
  Looks up a localized string similar to Range variable is assumed to be of type Object because its type cannot be inferred.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RecursiveAddHandlerCall">
<summary>
  Looks up a localized string similar to Statement recursively calls the containing &apos;{0}&apos; for event &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RecursiveAddHandlerCall_Title">
<summary>
  Looks up a localized string similar to Statement recursively calls the event&apos;s containing AddHandler.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RecursiveOperatorCall">
<summary>
  Looks up a localized string similar to Expression recursively calls the containing Operator &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RecursiveOperatorCall_Title">
<summary>
  Looks up a localized string similar to Expression recursively calls the containing Operator.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RecursivePropertyCall">
<summary>
  Looks up a localized string similar to Expression recursively calls the containing property &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RecursivePropertyCall_Title">
<summary>
  Looks up a localized string similar to Expression recursively calls the containing property.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RefCultureMismatch">
<summary>
  Looks up a localized string similar to Referenced assembly &apos;{0}&apos; has different culture setting of &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RefCultureMismatch_Title">
<summary>
  Looks up a localized string similar to Referenced assembly has different culture setting.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ReferencedAssemblyDoesNotHaveStrongName">
<summary>
  Looks up a localized string similar to Referenced assembly &apos;{0}&apos; does not have a strong name..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ReferencedAssemblyDoesNotHaveStrongName_Title">
<summary>
  Looks up a localized string similar to Referenced assembly does not have a strong name.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RelDelegatePassedToRemoveHandler">
<summary>
  Looks up a localized string similar to The &apos;AddressOf&apos; expression has no effect in this context because the method argument to &apos;AddressOf&apos; requires a relaxed conversion to the delegate type of the event. Assign the &apos;AddressOf&apos; expression to a variable, and use the variable to add or remove the method as the handler..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RelDelegatePassedToRemoveHandler_Title">
<summary>
  Looks up a localized string similar to The &apos;AddressOf&apos; expression has no effect in this context because the method argument to &apos;AddressOf&apos; requires a relaxed conversion to the delegate type of the event.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RequiredNonObsoleteNewCall3">
<summary>
  Looks up a localized string similar to First statement of this &apos;Sub New&apos; should be an explicit call to &apos;MyBase.New&apos; or &apos;MyClass.New&apos; because the &apos;{0}&apos; in the base class &apos;{1}&apos; of &apos;{2}&apos; is marked obsolete..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RequiredNonObsoleteNewCall3_Title">
<summary>
  Looks up a localized string similar to First statement of this &apos;Sub New&apos; should be an explicit call to &apos;MyBase.New&apos; or &apos;MyClass.New&apos; because the constructor in the base class is marked obsolete.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RequiredNonObsoleteNewCall4">
<summary>
  Looks up a localized string similar to First statement of this &apos;Sub New&apos; should be an explicit call to &apos;MyBase.New&apos; or &apos;MyClass.New&apos; because the &apos;{0}&apos; in the base class &apos;{1}&apos; of &apos;{2}&apos; is marked obsolete: &apos;{3}&apos;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RequiredNonObsoleteNewCall4_Title">
<summary>
  Looks up a localized string similar to First statement of this &apos;Sub New&apos; should be an explicit call to &apos;MyBase.New&apos; or &apos;MyClass.New&apos; because the constructor in the base class is marked obsolete.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ReturnTypeAttributeOnWriteOnlyProperty">
<summary>
  Looks up a localized string similar to Attributes applied on a return type of a WriteOnly Property have no effect..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ReturnTypeAttributeOnWriteOnlyProperty_Title">
<summary>
  Looks up a localized string similar to Attributes applied on a return type of a WriteOnly Property have no effect.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RootNamespaceNotCLSCompliant1">
<summary>
  Looks up a localized string similar to Root namespace &apos;{0}&apos; is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RootNamespaceNotCLSCompliant1_Title">
<summary>
  Looks up a localized string similar to Root namespace is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RootNamespaceNotCLSCompliant2">
<summary>
  Looks up a localized string similar to Name &apos;{0}&apos; in the root namespace &apos;{1}&apos; is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_RootNamespaceNotCLSCompliant2_Title">
<summary>
  Looks up a localized string similar to Part of the root namespace is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_SelectCaseInvalidRange">
<summary>
  Looks up a localized string similar to Range specified for &apos;Case&apos; statement is not valid. Make sure that the lower bound is less than or equal to the upper bound..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_SelectCaseInvalidRange_Title">
<summary>
  Looks up a localized string similar to Range specified for &apos;Case&apos; statement is not valid.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ShadowingGenericParamWithParam1">
<summary>
  Looks up a localized string similar to Type parameter &apos;{0}&apos; has the same name as a type parameter of an enclosing type. Enclosing type&apos;s type parameter will be shadowed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_ShadowingGenericParamWithParam1_Title">
<summary>
  Looks up a localized string similar to Type parameter has the same name as a type parameter of an enclosing type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_SharedMemberThroughInstance">
<summary>
  Looks up a localized string similar to Access of shared member, constant member, enum member or nested type through an instance; qualifying expression will not be evaluated..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_SharedMemberThroughInstance_Title">
<summary>
  Looks up a localized string similar to Access of shared member, constant member, enum member or nested type through an instance.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_StaticLocalNoInference">
<summary>
  Looks up a localized string similar to Static variable declared without an &apos;As&apos; clause; type of Object assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_StaticLocalNoInference_Title">
<summary>
  Looks up a localized string similar to Static variable declared without an &apos;As&apos; clause.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_SynthMemberShadowsMember5">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; implicitly declares &apos;{2}&apos;, which conflicts with a member in the base {3} &apos;{4}&apos;, and so the {0} should be declared &apos;Shadows&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_SynthMemberShadowsMember5_Title">
<summary>
  Looks up a localized string similar to Property or event implicitly declares type or member that conflicts with a member in the base type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_SynthMemberShadowsSynthMember7">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; implicitly declares &apos;{2}&apos;, which conflicts with a member implicitly declared for {3} &apos;{4}&apos; in the base {5} &apos;{6}&apos;. {0} should be declared &apos;Shadows&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_SynthMemberShadowsSynthMember7_Title">
<summary>
  Looks up a localized string similar to Property or event implicitly declares member, which conflicts with a member implicitly declared for property or event in the base type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_TypeConflictButMerged6">
<summary>
  Looks up a localized string similar to {0} &apos;{1}&apos; and partial {2} &apos;{3}&apos; conflict in {4} &apos;{5}&apos;, but are being merged because one of them is declared partial..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_TypeConflictButMerged6_Title">
<summary>
  Looks up a localized string similar to Type and partial type conflict, but are being merged because one of them is declared partial.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_TypeInferenceAssumed3">
<summary>
  Looks up a localized string similar to Data type of &apos;{0}&apos; in &apos;{1}&apos; could not be inferred. &apos;{2}&apos; assumed..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_TypeInferenceAssumed3_Title">
<summary>
  Looks up a localized string similar to Data type could not be inferred.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_TypeNotCLSCompliant1">
<summary>
  Looks up a localized string similar to Type &apos;{0}&apos; is not CLS-compliant..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_TypeNotCLSCompliant1_Title">
<summary>
  Looks up a localized string similar to Type is not CLS-compliant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnableToLoadAnalyzer">
<summary>
  Looks up a localized string similar to Unable to load analyzer assembly {0} : {1}..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnableToLoadAnalyzer_Title">
<summary>
  Looks up a localized string similar to Unable to load analyzer assembly.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UndefinedOrEmptyNamespaceOrClass1">
<summary>
  Looks up a localized string similar to Namespace or type specified in the Imports &apos;{0}&apos; doesn&apos;t contain any public member or cannot be found. Make sure the namespace or the type is defined and contains at least one public member. Make sure the imported element name doesn&apos;t use any aliases..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UndefinedOrEmptyNamespaceOrClass1_Title">
<summary>
  Looks up a localized string similar to Namespace or type specified in Imports statement doesn&apos;t contain any public member or cannot be found.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UndefinedOrEmptyProjectNamespaceOrClass1">
<summary>
  Looks up a localized string similar to Namespace or type specified in the project-level Imports &apos;{0}&apos; doesn&apos;t contain any public member or cannot be found. Make sure the namespace or the type is defined and contains at least one public member. Make sure the imported element name doesn&apos;t use any aliases..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UndefinedOrEmptyProjectNamespaceOrClass1_Title">
<summary>
  Looks up a localized string similar to Namespace or type imported at project level doesn&apos;t contain any public member or cannot be found.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnimplementedCommandLineSwitch">
<summary>
  Looks up a localized string similar to The command line switch &apos;{0}&apos; is not yet implemented and was ignored..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnimplementedCommandLineSwitch_Title">
<summary>
  Looks up a localized string similar to Command line switch is not yet implemented.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnobservedAwaitableDelegate">
<summary>
  Looks up a localized string similar to The Task returned from this Async Function will be dropped, and any exceptions in it ignored. Consider changing it to an Async Sub so its exceptions are propagated..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnobservedAwaitableDelegate_Title">
<summary>
  Looks up a localized string similar to The Task returned from this Async Function will be dropped, and any exceptions in it ignored.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnobservedAwaitableExpression">
<summary>
  Looks up a localized string similar to Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the Await operator to the result of the call..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnobservedAwaitableExpression_Title">
<summary>
  Looks up a localized string similar to Because this call is not awaited, execution of the current method continues before the call is completed.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnreachableCode">
<summary>
  Looks up a localized string similar to Unreachable code detected..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnreachableCode_Title">
<summary>
  Looks up a localized string similar to Unreachable code detected.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnusedLocal">
<summary>
  Looks up a localized string similar to Unused local variable: &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnusedLocal_Title">
<summary>
  Looks up a localized string similar to Unused local variable.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnusedLocalConst">
<summary>
  Looks up a localized string similar to Unused local constant: &apos;{0}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UnusedLocalConst_Title">
<summary>
  Looks up a localized string similar to Unused local constant.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UseOfObsoletePropertyAccessor2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; accessor of &apos;{1}&apos; is obsolete..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UseOfObsoletePropertyAccessor2_Title">
<summary>
  Looks up a localized string similar to Property accessor is obsolete.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UseOfObsoletePropertyAccessor3">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; accessor of &apos;{1}&apos; is obsolete: &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UseOfObsoletePropertyAccessor3_Title">
<summary>
  Looks up a localized string similar to Property accessor is obsolete.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UseOfObsoleteSymbol2">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is obsolete: &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UseOfObsoleteSymbol2_Title">
<summary>
  Looks up a localized string similar to Type or member is obsolete.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UseOfObsoleteSymbolNoMessage1">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; is obsolete..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UseOfObsoleteSymbolNoMessage1_Title">
<summary>
  Looks up a localized string similar to Type or member is obsolete.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UseSwitchInsteadOfAttribute">
<summary>
  Looks up a localized string similar to Use command-line option &apos;{0}&apos; or appropriate project settings instead of &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UseSwitchInsteadOfAttribute_Title">
<summary>
  Looks up a localized string similar to Use command-line option /keyfile, /keycontainer, or /delaysign instead of AssemblyKeyFileAttribute, AssemblyKeyNameAttribute, or AssemblyDelaySignAttribute.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UseValueForXmlExpression3">
<summary>
  Looks up a localized string similar to Cannot convert &apos;{0}&apos; to &apos;{1}&apos;. You can use the &apos;Value&apos; property to get the string value of the first element of &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_UseValueForXmlExpression3_Title">
<summary>
  Looks up a localized string similar to Cannot convert IEnumerable(Of XElement) to String.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_VarianceConversionFailedIn6">
<summary>
  Looks up a localized string similar to Implicit conversion from &apos;{4}&apos; to &apos;{5}&apos;; this conversion may fail because &apos;{0}&apos; is not derived from &apos;{1}&apos;, as required for the &apos;In&apos; generic parameter &apos;{2}&apos; in &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_VarianceConversionFailedIn6_Title">
<summary>
  Looks up a localized string similar to Implicit conversion; this conversion may fail because the target type is not derived from the source type, as required for &apos;In&apos; generic parameter.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_VarianceConversionFailedOut6">
<summary>
  Looks up a localized string similar to Implicit conversion from &apos;{4}&apos; to &apos;{5}&apos;; this conversion may fail because &apos;{0}&apos; is not derived from &apos;{1}&apos;, as required for the &apos;Out&apos; generic parameter &apos;{2}&apos; in &apos;{3}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_VarianceConversionFailedOut6_Title">
<summary>
  Looks up a localized string similar to Implicit conversion; this conversion may fail because the target type is not derived from the source type, as required for &apos;Out&apos; generic parameter.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_VarianceConversionFailedTryIn4">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be converted to &apos;{1}&apos;. Consider changing the &apos;{2}&apos; in the definition of &apos;{3}&apos; to an In type parameter, &apos;In {2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_VarianceConversionFailedTryIn4_Title">
<summary>
  Looks up a localized string similar to Type cannot be converted to target type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_VarianceConversionFailedTryOut4">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be converted to &apos;{1}&apos;. Consider changing the &apos;{2}&apos; in the definition of &apos;{3}&apos; to an Out type parameter, &apos;Out {2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_VarianceConversionFailedTryOut4_Title">
<summary>
  Looks up a localized string similar to Type cannot be converted to target type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_VarianceDeclarationAmbiguous3">
<summary>
  Looks up a localized string similar to Interface &apos;{0}&apos; is ambiguous with another implemented interface &apos;{1}&apos; due to the &apos;In&apos; and &apos;Out&apos; parameters in &apos;{2}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_VarianceDeclarationAmbiguous3_Title">
<summary>
  Looks up a localized string similar to Interface is ambiguous with another implemented interface due to &apos;In&apos; and &apos;Out&apos; parameters.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_VarianceIEnumerableSuggestion3">
<summary>
  Looks up a localized string similar to &apos;{0}&apos; cannot be converted to &apos;{1}&apos;. Consider using &apos;{2}&apos; instead..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_VarianceIEnumerableSuggestion3_Title">
<summary>
  Looks up a localized string similar to Type cannot be converted to target collection type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLCannotWriteToXMLDocFile2">
<summary>
  Looks up a localized string similar to Unable to create XML documentation file &apos;{0}&apos;: {1}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLCannotWriteToXMLDocFile2_Title">
<summary>
  Looks up a localized string similar to Unable to create XML documentation file.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocBadFormedXML">
<summary>
  Looks up a localized string similar to Unable to include XML fragment &apos;{1}&apos; of file &apos;{0}&apos;. {2}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocBadFormedXML_Title">
<summary>
  Looks up a localized string similar to Unable to include XML fragment.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocBadGenericParamTag2">
<summary>
  Looks up a localized string similar to XML comment type parameter &apos;{0}&apos; does not match a type parameter on the corresponding &apos;{1}&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocBadGenericParamTag2_Title">
<summary>
  Looks up a localized string similar to XML comment type parameter does not match a type parameter on the corresponding declaration statement.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocBadParamTag2">
<summary>
  Looks up a localized string similar to XML comment parameter &apos;{0}&apos; does not match a parameter on the corresponding &apos;{1}&apos; statement..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocBadParamTag2_Title">
<summary>
  Looks up a localized string similar to XML comment parameter does not match a parameter on the corresponding declaration statement.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocBadXMLLine">
<summary>
  Looks up a localized string similar to XML comment block must immediately precede the language element to which it applies. XML comment will be ignored..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocBadXMLLine_Title">
<summary>
  Looks up a localized string similar to XML comment block must immediately precede the language element to which it applies.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocCrefAttributeNotFound1">
<summary>
  Looks up a localized string similar to XML comment has a tag with a &apos;cref&apos; attribute &apos;{0}&apos; that could not be resolved..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocCrefAttributeNotFound1_Title">
<summary>
  Looks up a localized string similar to XML comment has a tag with a &apos;cref&apos; attribute that could not be resolved.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocCrefToTypeParameter">
<summary>
  Looks up a localized string similar to XML comment has a tag with a &apos;cref&apos; attribute &apos;{0}&apos; that bound to a type parameter.  Use the &lt;typeparamref&gt; tag instead..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocCrefToTypeParameter_Title">
<summary>
  Looks up a localized string similar to XML comment has a tag with a &apos;cref&apos; attribute that bound to a type parameter.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocDuplicateXMLNode1">
<summary>
  Looks up a localized string similar to XML comment tag &apos;{0}&apos; appears with identical attributes more than once in the same XML comment block..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocDuplicateXMLNode1_Title">
<summary>
  Looks up a localized string similar to XML comment tag appears with identical attributes more than once in the same XML comment block.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocExceptionTagWithoutCRef">
<summary>
  Looks up a localized string similar to XML comment exception must have a &apos;cref&apos; attribute..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocExceptionTagWithoutCRef_Title">
<summary>
  Looks up a localized string similar to XML comment exception must have a &apos;cref&apos; attribute.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocGenericParamTagWithoutName">
<summary>
  Looks up a localized string similar to XML comment type parameter must have a &apos;name&apos; attribute..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocGenericParamTagWithoutName_Title">
<summary>
  Looks up a localized string similar to XML comment type parameter must have a &apos;name&apos; attribute.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocIllegalTagOnElement2">
<summary>
  Looks up a localized string similar to XML comment tag &apos;{0}&apos; is not permitted on a &apos;{1}&apos; language element..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocIllegalTagOnElement2_Title">
<summary>
  Looks up a localized string similar to XML comment tag is not permitted on language element.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocInsideMethod">
<summary>
  Looks up a localized string similar to XML comment cannot appear within a method or a property. XML comment will be ignored..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocInsideMethod_Title">
<summary>
  Looks up a localized string similar to XML comment cannot appear within a method or a property.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocInvalidXMLFragment">
<summary>
  Looks up a localized string similar to Unable to include XML fragment &apos;{0}&apos; of file &apos;{1}&apos;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocInvalidXMLFragment_Title">
<summary>
  Looks up a localized string similar to Unable to include XML fragment.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocMoreThanOneCommentBlock">
<summary>
  Looks up a localized string similar to Only one XML comment block is allowed per language element..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocMoreThanOneCommentBlock_Title">
<summary>
  Looks up a localized string similar to Only one XML comment block is allowed per language element.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocNotFirstOnLine">
<summary>
  Looks up a localized string similar to XML comment must be the first statement on a line. XML comment will be ignored..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocNotFirstOnLine_Title">
<summary>
  Looks up a localized string similar to XML comment must be the first statement on a line.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocOnAPartialType">
<summary>
  Looks up a localized string similar to XML comment cannot be applied more than once on a partial {0}. XML comments for this {0} will be ignored..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocOnAPartialType_Title">
<summary>
  Looks up a localized string similar to XML comment cannot be applied more than once on a partial type.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocParamTagWithoutName">
<summary>
  Looks up a localized string similar to XML comment parameter must have a &apos;name&apos; attribute..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocParamTagWithoutName_Title">
<summary>
  Looks up a localized string similar to XML comment parameter must have a &apos;name&apos; attribute.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocParseError1">
<summary>
  Looks up a localized string similar to XML documentation parse error: {0} XML comment will be ignored..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocParseError1_Title">
<summary>
  Looks up a localized string similar to XML documentation parse error.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocReturnsOnADeclareSub">
<summary>
  Looks up a localized string similar to XML comment tag &apos;returns&apos; is not permitted on a &apos;declare sub&apos; language element..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocReturnsOnADeclareSub_Title">
<summary>
  Looks up a localized string similar to XML comment tag &apos;returns&apos; is not permitted on a &apos;declare sub&apos; language element.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocReturnsOnWriteOnlyProperty">
<summary>
  Looks up a localized string similar to XML comment tag &apos;returns&apos; is not permitted on a &apos;WriteOnly&apos; Property..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocReturnsOnWriteOnlyProperty_Title">
<summary>
  Looks up a localized string similar to XML comment tag &apos;returns&apos; is not permitted on a &apos;WriteOnly&apos; Property.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocStartTagWithNoEndTag">
<summary>
  Looks up a localized string similar to XML documentation parse error: Start tag &apos;{0}&apos; doesn&apos;t have a matching end tag. XML comment will be ignored..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocStartTagWithNoEndTag_Title">
<summary>
  Looks up a localized string similar to XML documentation parse error: Start tag doesn&apos;t have a matching end tag.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocWithoutLanguageElement">
<summary>
  Looks up a localized string similar to XML documentation comments must precede member or type declarations..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLDocWithoutLanguageElement_Title">
<summary>
  Looks up a localized string similar to XML documentation comments must precede member or type declarations.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLMissingFileOrPathAttribute1">
<summary>
  Looks up a localized string similar to XML comment tag &apos;include&apos; must have a &apos;{0}&apos; attribute. XML comment will be ignored..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WRN_XMLMissingFileOrPathAttribute1_Title">
<summary>
  Looks up a localized string similar to XML comment tag &apos;include&apos; must have &apos;file&apos; and &apos;path&apos; attributes.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WrongNumberOfTypeArguments">
<summary>
  Looks up a localized string similar to Wrong number of type arguments.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBResources.WrongSemanticModelType">
<summary>
  Looks up a localized string similar to Expected a {0} SemanticModel..
</summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions">
 <summary>
 A class representing Visual Basic compilation Options.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.#ctor(Microsoft.CodeAnalysis.OutputKind,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.VisualBasic.GlobalImport},System.String,Microsoft.CodeAnalysis.VisualBasic.OptionStrict,System.Boolean,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions,System.Boolean,Microsoft.CodeAnalysis.OptimizationLevel,System.Boolean,System.String,System.String,System.Collections.Immutable.ImmutableArray{System.Byte},System.Nullable{System.Boolean},Microsoft.CodeAnalysis.Platform,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,Microsoft.CodeAnalysis.ReportDiagnostic}},System.Boolean,System.Boolean,Microsoft.CodeAnalysis.XmlReferenceResolver,Microsoft.CodeAnalysis.SourceReferenceResolver,Microsoft.CodeAnalysis.MetadataReferenceResolver,Microsoft.CodeAnalysis.AssemblyIdentityComparer,Microsoft.CodeAnalysis.StrongNameProvider,System.Boolean,System.Boolean)">
 <summary>
 Initializes a new instance of the VisualBasicCompilationOptions type with various options.
 </summary>
 <param name="outputKind">The compilation output kind. <see cref="T:Microsoft.CodeAnalysis.OutputKind"/></param>
 <param name="moduleName">An optional parameter to specify the name of the assembly that this module will be a part of.</param>
 <param name="mainTypeName">An optional parameter to specify the class or module that contains the Sub Main procedure.</param>
 <param name="scriptClassName">An optional parameter to specify an alternate DefaultScriptClassName object to be used.</param>
 <param name="globalImports">An optional collection of GlobalImports <see cref="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.GlobalImports"/> .</param>
 <param name="rootNamespace">An optional parameter to specify the name of the default root namespace.</param>
 <param name="optionStrict">An optional parameter to specify the default Option Strict behavior. <see cref="T:Microsoft.CodeAnalysis.VisualBasic.OptionStrict"/></param>
 <param name="optionInfer">An optional parameter to specify default Option Infer behavior.</param>
 <param name="optionExplicit">An optional parameter to specify the default Option Explicit behavior.</param>
 <param name="optionCompareText">An optional parameter to specify the default Option Compare Text behavior.</param>
 <param name="embedVbCoreRuntime">An optional parameter to specify the embedded Visual Basic Core Runtime behavior.</param>
 <param name="checkOverflow">An optional parameter to specify enabling/disabling overflow checking.</param>
 <param name="concurrentBuild">An optional parameter to specify enabling/disabling concurrent build.</param>
 <param name="cryptoKeyContainer">An optional parameter to specify a key container name for a key pair to give an assembly a strong name.</param>
 <param name="cryptoKeyFile">An optional parameter to specify a file containing a key or key pair to give an assembly a strong name.</param>
 <param name="cryptoPublicKey">An optional parameter to specify a public key used to give an assembly a strong name.</param>
 <param name="delaySign">An optional parameter to specify whether the assembly will be fully or partially signed.</param>
 <param name="platform">An optional parameter to specify which platform version of common language runtime (CLR) can run compilation. <see cref="T:Microsoft.CodeAnalysis.Platform"/></param>
 <param name="generalDiagnosticOption">An optional parameter to specify the general warning level.</param>
 <param name="specificDiagnosticOptions">An optional collection representing specific warnings that differ from general warning behavior.</param>
 <param name="optimizationLevel">An optional parameter to enabled/disable optimizations. </param>
 <param name="parseOptions">An optional parameter to specify the parse options. <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions"/></param>
 <param name="xmlReferenceResolver">An optional parameter to specify the XML file resolver.</param>
 <param name="sourceReferenceResolver">An optional parameter to specify the source file resolver.</param>
 <param name="metadataReferenceResolver">An optional parameter to specify <see cref="T:Microsoft.CodeAnalysis.MetadataReferenceResolver"/>.</param>
 <param name="assemblyIdentityComparer">An optional parameter to specify <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentityComparer"/>.</param>
 <param name="strongNameProvider">An optional parameter to specify <see cref="T:Microsoft.CodeAnalysis.StrongNameProvider"/>.</param>
 <param name="publicSign">An optional parameter to specify whether the assembly will be public signed.</param>
 <param name="reportSuppressedDiagnostics">An optional parameter to specify whether or not suppressed diagnostics should be reported.</param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.GlobalImports">
 <summary>
 Gets the global imports collection.
 </summary>
 <returns>The global imports.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.RootNamespace">
 <summary>
 Gets the default namespace for all source code in the project. Corresponds to the 
 "RootNamespace" project option or the "/rootnamespace" command line option.
 </summary>
 <returns>The default namespace.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.OptionStrict">
 <summary>
 Gets the Option Strict Setting.
 </summary>
 <returns>The Option Strict setting.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.OptionInfer">
 <summary>
 Gets the Option Infer setting.
 </summary>
 <returns>The Option Infer setting. True if Option Infer On is in effect by default. False if Option Infer Off is on effect by default. </returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.OptionExplicit">
 <summary>
 Gets the Option Explicit setting.
 </summary>
 <returns>The Option Explicit setting. True if Option Explicit On is in effect by default. False if Option Explicit Off is on by default.</returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.OptionCompareText">
 <summary>
 Gets the Option Compare Text setting.
 </summary>
 <returns>        
 The Option Compare Text Setting, True if Option Compare Text is in effect by default. False if Option Compare Binary is
 in effect by default.
 </returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.EmbedVbCoreRuntime">
 <summary>
 Gets the Embed Visual Basic Core Runtime setting.
 </summary>
 <returns>
 The EmbedVbCoreRuntime setting, True if VB core runtime should be embedded in the compilation. Equal to '/vbruntime*'
 </returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.SuppressEmbeddedDeclarations">
 <summary>
 Gets the embedded declaration suppression setting.
 </summary>
 <returns>
 The embedded declaration suppression setting.
 </returns>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.ParseOptions">
 <summary>
 Gets the Parse Options setting.
 Compilation level parse options.  Used when compiling synthetic embedded code such as My template
 </summary>
 <returns>The Parse Options Setting.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithOutputKind(Microsoft.CodeAnalysis.OutputKind)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different OutputKind specified.
 </summary>
 <param name="kind">The Output Kind.</param>
 <returns>A new instance of VisualBasicCompilationOptions, if the output kind is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithModuleName(System.String)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance With a different ModuleName specified.
 </summary>
 <param name="moduleName">The moduleName.</param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the module name is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithScriptClassName(System.String)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a Script Class Name specified.
 </summary>
 <param name="name">The name for the ScriptClassName.</param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the script class name is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithMainTypeName(System.String)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different Main Type name specified.
 </summary>
 <param name="name">The name for the MainType .</param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the main type name is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithGlobalImports(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.VisualBasic.GlobalImport})">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different global imports specified.
 </summary>
 <param name="globalImports">A collection of Global Imports <see cref="T:Microsoft.CodeAnalysis.VisualBasic.GlobalImport"/>.</param>        
 <returns>A new instance of VisualBasicCompilationOptions.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithGlobalImports(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.VisualBasic.GlobalImport})">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different global imports specified.
 </summary>
 <param name="globalImports">A collection of Global Imports <see cref="T:Microsoft.CodeAnalysis.VisualBasic.GlobalImport"/>.</param>        
 <returns>A new instance of VisualBasicCompilationOptions.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithGlobalImports(Microsoft.CodeAnalysis.VisualBasic.GlobalImport[])">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different global imports specified.
 </summary>
 <param name="globalImports">A collection of Global Imports <see cref="T:Microsoft.CodeAnalysis.VisualBasic.GlobalImport"/>.</param>        
 <returns>A new instance of VisualBasicCompilationOptions.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithRootNamespace(System.String)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different root namespace specified.
 </summary>
 <param name="rootNamespace">The root namespace.</param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the root namespace is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithOptionStrict(Microsoft.CodeAnalysis.VisualBasic.OptionStrict)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different option strict specified.
 </summary>
 <param name="value">The Option Strict setting.  <see cref="T:Microsoft.CodeAnalysis.VisualBasic.OptionStrict"/></param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the option strict is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithOptionInfer(System.Boolean)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different option infer specified.
 </summary>
 <param name="value">The Option infer setting. </param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the option infer is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithOptionExplicit(System.Boolean)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different option explicit specified.
 </summary>
 <param name="value">The Option Explicit setting. </param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the option explicit is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithOptionCompareText(System.Boolean)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different Option Compare Text specified.
 </summary>
 <param name="value">The Option Compare Text setting. </param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the option compare text is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithEmbedVbCoreRuntime(System.Boolean)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different Embed VB Core Runtime specified.
 </summary>
 <param name="value">The Embed VB Core Runtime setting. </param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the embed vb core runtime is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithOverflowChecks(System.Boolean)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different Overflow checks specified.
 </summary>
 <param name="enabled">The overflow check setting. </param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the overflow check is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithConcurrentBuild(System.Boolean)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different concurrent build specified.
 </summary>
 <param name="concurrentBuild">The concurrent build setting. </param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the concurrent build is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithDeterministic(System.Boolean)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different deterministic mode specified.
 <param name="deterministic"> The deterministic mode. </param>
 <returns> A new instance of VisualBasicCompilationOptions, if the concurrent build is different; otherwise the current instance.</returns>
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithExtendedCustomDebugInformation(System.Boolean)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different extended custom debug information specified.
 </summary>
 <param name="extendedCustomDebugInformation">The extended custom debug information setting. </param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the extended custom debug information is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithDebugPlusMode(System.Boolean)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different extended custom debug information specified.
 </summary>
 <param name="debugPlusMode">The extended custom debug information setting. </param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the extended custom debug information is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithSuppressEmbeddedDeclarations(System.Boolean)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with different embedded declaration suppression setting specified.
 </summary>
 <param name="suppressEmbeddedDeclarations">The embedded declaration suppression setting. </param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the embedded declaration suppression setting is different; otherwise current instance.</returns>
 <remarks>Only expected to be called from the expression compiler.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithCryptoKeyContainer(System.String)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different cryptography key container specified
 </summary>
 <param name="name">The name of the cryptography key container. </param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the cryptography key container name is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithCryptoKeyFile(System.String)">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different cryptography key file path specified.
 </summary>
 <param name="path">The cryptography key file path. </param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the cryptography key path is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithCryptoPublicKey(System.Collections.Immutable.ImmutableArray{System.Byte})">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different public key.
 </summary>
 <param name="value">The cryptography key file path. </param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the public key is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithDelaySign(System.Nullable{System.Boolean})">
 <summary>
 Creates a new VisualBasicCompilationOptions instance with a different delay signing specified.
 </summary>
 <param name="value">The delay signing setting. </param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the delay sign is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithPlatform(Microsoft.CodeAnalysis.Platform)">
 <summary>
 Creates a new <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions"/> instance with a different platform specified.
 </summary>
 <param name="value">The platform setting. <see cref="T:Microsoft.CodeAnalysis.Platform"/></param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the platform is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithGeneralDiagnosticOption(Microsoft.CodeAnalysis.ReportDiagnostic)">
 <summary>
 Creates a new <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions"/> instance with a different report warning specified.
 </summary>
 <param name="value">The Report Warning setting. <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/></param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the report warning is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithSpecificDiagnosticOptions(System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic})">
 <summary>
 Creates a new <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions"/> instance with different specific warnings specified.
 </summary>
 <param name="value">Specific report warnings. <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/></param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the dictionary of report warning is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithSpecificDiagnosticOptions(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,Microsoft.CodeAnalysis.ReportDiagnostic}})">
 <summary>
 Creates a new <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions"/> instance with different specific warnings specified.
 </summary>
 <param name="value">Specific report warnings. <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/></param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the dictionary of report warning is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithReportSuppressedDiagnostics(System.Boolean)">
 <summary>
 Creates a new <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions"/> instance with specified suppress diagnostics reporting option.
 </summary>
 <param name="value">Report suppressed diagnostics setting.</param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the value is different from the current value; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithOptimizationLevel(Microsoft.CodeAnalysis.OptimizationLevel)">
 <summary>
 Creates a new <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions"/> instance with a specified <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.OptimizationLevel"/>.
 </summary>
 <returns>A new instance of <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions"/>, if the value is different; otherwise the current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.WithParseOptions(Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions)">
 <summary>
 Creates a new <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions"/> instance with a different parse option specified.
 </summary>
 <param name="options">The parse option setting. <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions"/></param>        
 <returns>A new instance of VisualBasicCompilationOptions, if the parse options is different; otherwise current instance.</returns>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.Equals(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions)">
 <summary>
 Determines whether the current object is equal to another object of the same type.
 </summary>
 <param name="other">A VisualBasicCompilationOptions to compare with this object</param>
 <returns>A boolean value.  True if the current object is equal to the other parameter; otherwise, False.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.Equals(System.Object)">
 <summary>
 Indicates whether the current object is equal to another object.
 </summary>
 <param name="obj">A object to compare with this object</param>
 <returns>A boolean value.  True if the current object is equal to the other parameter; otherwise, False.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions.GetHashCode">
 <summary>
 Creates a hashcode for this instance.
 </summary>
 <returns>A hashcode representing this instance.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)">
 <summary>
 Returns <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> for <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/> nodes.
 </summary> 
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> for <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/> from <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind"/> property.
 </summary>       
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Returns <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> for <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> from <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind"/> property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
 <summary>
 Returns <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> for <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> from <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind"/> property.
 </summary>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsBracketed(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Checks to see if SyntaxToken is a bracketed identifier.
 </summary>
 <param name="token">The source SyntaxToken.</param>
 <returns>A boolean value, True if token represents a bracketed Identifier.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeCharacter(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns the Type character for a given syntax token.  This returns type character for Identifiers or Integer, Floating Point or Decimal Literals.
 Examples: Dim a$   or Dim l1 = 1L
 </summary>
 <param name="token">The source SyntaxToken.</param>
 <returns>A type character used for the specific Internal Syntax Token Types.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetBase(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 The source token base for Integer literals.  Base can be Decimal, Hex or Octal.
 </summary>
 <param name="token">The source SyntaxToken.</param>
 <returns>An instance representing the integer literal base.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Determines if the token represents a reserved or contextual keyword
 </summary>
 <param name="token">The source SyntaxToken.</param>
 <returns>A boolean value True if token is a keyword.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Determines if the token represents a reserved keyword
 </summary>
 <param name="token">The source SyntaxToken.</param>
 <returns>A boolean value True if token is a reserved keyword.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Determines if the token represents a contextual keyword
 </summary>
 <returns>A boolean value True if token is a contextual keyword.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsPreprocessorKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Determines if the token  represents a preprocessor keyword
 </summary>
 <param name="token">The source SyntaxToken.</param>
 <returns> A boolean value True if token is a pre processor keyword.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetIdentifierText(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Returns the Identifiertext for a specified SyntaxToken.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])">
 <summary>
 Insert one or more tokens in the list at the specified index.
 </summary>
 <returns>A new list with the tokens inserted.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Add(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken[])">
 <summary>
 Add one or more tokens to the end of the list.
 </summary>
 <returns>A new list with the tokens added.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)">
 <summary>
  Replaces trivia on a specified SyntaxToken.
 </summary>
 <param name="token">The source SyntaxToken to change trivia on.</param>
 <param name="oldTrivia">The original Trivia.</param>
 <param name="newTrivia">The updated Trivia.</param>
 <returns>The updated SyntaxToken with replaced trivia.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})">
 <summary>
  Replaces trivia on a specified SyntaxToken.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDirectives(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})">
 <summary>
 Gets the DirectiveTriviaSyntax items for a specified SyntaxNode with optional filtering.
 </summary>
 <param name="node">The source SyntaxNode.</param>
 <param name="filter">The optional DirectiveTrivia Syntax filter predicate.</param>
 <returns>A list of DirectiveTriviaSyntax items</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})">
 <summary>
 Gets the first DirectiveTriviaSyntax item for a specified SyntaxNode.
 </summary>
 <param name="node">The source SyntaxNode.</param>
 <param name="predicate">The optional DirectiveTriviaSyntax filter predicate.</param>
 <returns>The first DirectiveSyntaxTrivia item.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})">
 <summary>
 Gets the last DirectiveTriviaSyntax item for a specified SyntaxNode.
 </summary>
 <param name="node">The source node</param>
 <param name="predicate">The optional DirectiveTriviaSyntax filter predicate.</param>
 <returns>The last DirectiveSyntaxTrivia item.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree)">
 <summary>
 Gets the root CompilationUnitSyntax for a specified SyntaxTree.
 </summary>
 <param name="tree">The source SyntaxTree.</param>
 <returns>A CompilationUnitSyntax.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetWarningState(Microsoft.CodeAnalysis.SyntaxTree,System.String,System.Int32)">
 <summary>
  Gets the reporting state for a warning at a given source location based on warning directives.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsShared(Microsoft.CodeAnalysis.ISymbol)">
 <summary>
 Determines if symbol is Shared.
 </summary>
 <param name="symbol">The source symbol.</param>
 <returns>A boolean value, True if symbol is Shared; otherwise False.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetModuleMembers(Microsoft.CodeAnalysis.INamespaceSymbol)">
 <summary>
 Gets all module members in a namespace.
 </summary>
 <param name="[namespace]">The source namespace symbol.</param>
 <returns>An ImmutableArray of NamedTypeSymbol for all module members in namespace.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetModuleMembers(Microsoft.CodeAnalysis.INamespaceSymbol,System.String)">
 <summary>
 Gets all module members in a specified namespace.
 </summary>
 <param name="[namespace]">The source namespace symbol.</param>
 <param name="name">The name of the namespace.</param>
 <returns>An ImmutableArray of NamedTypeSymbol for all module members in namespace.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionStrict(Microsoft.CodeAnalysis.SemanticModel)">
 <summary>
 Gets the Semantic Model OptionStrict property.
 </summary>
 <param name="semanticModel">A source Semantic model object.</param>
 <returns>The OptionStrict object for the semantic model instance OptionStrict property, otherwise Null if semantic model is Null. </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionInfer(Microsoft.CodeAnalysis.SemanticModel)">
 <summary>
 Gets the Semantic Model OptionInfer property.
 </summary>
 <param name="semanticModel">A source Semantic model object.</param>
 <returns>A boolean values, for the semantic model instance OptionInfer property. otherwise Null if semantic model is Null. </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionExplicit(Microsoft.CodeAnalysis.SemanticModel)">
 <summary>
 Gets the Semantic Model OptionExplicit property.
 </summary>
 <param name="semanticModel">A source Semantic model object.</param>
 <returns>A boolean values, for the semantic model instance OptionExplicit property. otherwise Null if semantic model is Null. </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionCompareText(Microsoft.CodeAnalysis.SemanticModel)">
 <summary>
 Gets the Semantic Model OptionCompareText property.
 </summary>
 <param name="semanticModel">A source Semantic model object.</param>
 <returns>A boolean values, for the semantic model instance OptionCompareText property. otherwise Null if semantic model is Null. </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.RootNamespace(Microsoft.CodeAnalysis.Compilation)">
 <summary>
 Gets the compilation RootNamespace property.
 </summary>      
 <param name="compilation">A source Compilation object.</param>
 <returns>A NamespaceSymbol instance, for the compilation instance RootNamespace property. otherwise Null if compilation instance is Null. </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AliasImports(Microsoft.CodeAnalysis.Compilation)">
 <summary>
 Gets the compilation AliasImports property.
 </summary>
 <param name="compilation">A source Compilation object.</param>
 <returns>An ImmutableArray of AliasSymbol, from the compilation instance AliasImports property; otherwise an empty ImmutableArray if compilation instance is Null.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.MemberImports(Microsoft.CodeAnalysis.Compilation)">
 <summary>
  Gets the compilation MemberImports property.
 </summary>
 <param name="compilation">A source Compilation object.</param>
 <returns>An ImmutableArray of NamespaceOrTypeSymbol, from the compilation instance MemberImports property; otherwise an empty ImmutableArray if compilation instance is Null.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
 <summary>
 Determines what kind of conversion there is between the specified types.
 </summary>
 <param name="compilation">A source Compilation object.</param>
 <param name="source">A source Typesymbol</param>
 <param name="destination">A destination Typesymbol</param>
 <returns>A Conversion instance, representing the kind of conversion between the two type symbols; otherwise Null if compilation instance is Null.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpecialType(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.SpecialType)">
 <summary>
 Gets the special type symbol in current compilation.
 </summary>
 <param name="compilation">A source Compilation object.</param>
 <param name="typeId">The SpecialType to get.</param>
 <returns>A NamedTypeSymbol for the specified type in compilation; Null if compilation is Null.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol)">
 <summary>
 Determines what kind of conversion there is between the expression syntax and a specified type.
 </summary>
 <param name="semanticModel">A source semantic model.</param>
 <param name="expression">A source expression syntax.</param>
 <param name="destination">A destination TypeSymbol.</param>
 <returns>A Conversion instance, representing the kind of conversion between the expression and type symbol; otherwise Null if semantic model instance is Null.</returns>     
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol)">
 <summary>
 Determines what kind of conversion there is between the expression syntax and a specified type.
 </summary>
 <param name="semanticModel">A source semantic model.</param>
 <param name="position">A position within the expression syntax.</param>
 <param name="expression">A source expression syntax.</param>
 <param name="destination">A destination TypeSymbol.</param>
 <returns>A Conversion instance, representing the kind of conversion between the expression and type symbol; otherwise Null if semantic model instance is Null.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding symbol for a specified identifier.
 </summary>
 <param name="semanticModel">A source semantic model.</param>
 <param name="identifierSyntax">A IdentifierSyntax object.</param>
 <param name="cancellationToken">A cancellation token.</param>
 <returns>A symbol, for the specified identifier; otherwise Null if semantic model is Null. </returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding PropertySymbol for a specified FieldInitializerSyntax.
 </summary>
 <param name="semanticModel">A source semantic model.</param>
 <param name="fieldInitializerSyntax">A FieldInitializerSyntax object.</param>
 <param name="cancellationToken">A cancellation token.</param>
 <returns>A PropertySymbol. Null if semantic model is null.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding  NamedTypeSymbol for a specified  AnonymousObjectCreationExpressionSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding RangeVariableSymbol for a specified ExpressionRangeVariableSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding RangeVariableSymbol for a specified CollectionRangeVariableSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding RangeVariableSymbol for a specified AggregationRangeVariableSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding LabelSymbol for a specified LabelStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding FieldSymbol for a specified EnumMemberDeclarationSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding NamedTypeSymbol for a specified TypeStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding NamedTypeSymbol for a specified TypeBlockSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding NamedTypeSymbol for a specified EnumStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding NamedTypeSymbol for a specified EnumBlockSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding NamespaceSymbol for a specified NamespaceStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding NamespaceSymbol for a specified NamespaceBlockSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding ParameterSymbol for a specified ParameterSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding TypeParameterSymbol Symbol for a specified TypeParameterSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding NamedTypeSymbol for a specified DelegateStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding MethodSymbol for a specified SubNewStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding MethodSymbol for a specified MethodStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding symbol for a specified  DeclareStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding MethodSymbol for a specified OperatorStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding MethodSymbol for a specified MethodBlockBaseSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding PropertySymbol for a specified PropertyStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding EventSymbol for a specified EventStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding PropertySymbol for a specified PropertyBlockSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding EventSymbol for a specified EventBlockSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding LocalSymbol for a specified CatchStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding MethodSymbol for a specified AccessorStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding AliasSymbol for a specified AliasImportsClauseSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax)">
 <summary>
 Gets the corresponding ForEachStatementInfo containing semantic info for a specified ForEachStatementSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax)">
 <summary>
 Gets the corresponding ForEachStatementInfo containing semantic info for a specified ForBlockSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding AwaitExpressionInfo containing semantic info for a specified AwaitExpressionSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)">
 <summary>
 If the given node is within a preprocessing directive, gets the preprocessing symbol info for it.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding SymbolInfo containing semantic info for a specified ExpressionSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax 
 within <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax.Initializer"/>.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding SymbolInfo containing semantic info for a specified CrefReferenceSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding SymbolInfo containing semantic info for a specified AttributeSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
 <summary>
 Gets the corresponding SymbolInfo containing semantic info for a specified AttributeSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax)">
 <summary>
 Gets the corresponding SymbolInfo containing semantic info for specified  AttributeSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding TypeInfo containing semantic info for a specified ExpressionSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
 <summary>
 Gets the corresponding TypeInfo  containing semantic info for a speculating an ExpressionSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding TypeInfo containing semantic info for a specified AttributeSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding ImmutableArray of Symbols for a specified ExpressionSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeMemberGroup(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Gets the corresponding ImmutableArray of Symbols for a speculating an ExpressionSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
 <summary>
 Gets the corresponding ImmutableArray of Symbols for a specified AttributeSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)">
 <summary>
 If "nameSyntax" resolves to an alias name, return the AliasSymbol corresponding
 to A. Otherwise return null.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
 <summary>
 Binds the name in the context of the specified location and sees if it resolves to an
 alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCollectionRangeVariableSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns information about methods associated with CollectionRangeVariableSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAggregateClauseSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns information about methods associated with AggregateClauseSyntax.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns symbol information for a query clause.
 </summary>
 <remarks>
 <list type="table">
 <listheader>
     <term>Syntax node type</term>
     <description>Symbol information returned</description>
 </listheader>
 <item>
     <term><see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax"/></term>
     <description>Returns Distinct method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax"/>.</description>
 </item>
 <item>
     <term><see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax"/></term>
     <description>Returns Where method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax"/>.</description>
 </item>
 <item>
     <term><see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax"/></term>
     <description>Returns TakeWhile/SkipWhile method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax"/>.</description>
 </item>
 <item>
     <term><see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax"/></term>
     <description>Returns Take/Skip method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax"/>.</description>
 </item>
 <item>
     <term><see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax"/></term>
     <description>Returns GroupBy method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax"/>.</description>
 </item>
 <item>
     <term><see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax"/></term>
     <description>Returns Join/GroupJoin method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax"/>.</description>
 </item>
 <item>
     <term><see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax"/></term>
     <description>Returns Select method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax"/>, or <see cref="F:Microsoft.CodeAnalysis.SymbolInfo.None"/> if none is.</description>
 </item>
 <item>
     <term><see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax"/></term>
     <description>
         Returns Select method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax"/>, which has only one 
         <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax"/> and is the only query clause within 
         <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax"/>. <see cref="F:Microsoft.CodeAnalysis.SymbolInfo.None"/> otherwise. 
         The method call is injected by the compiler to make sure that query is translated to at 
         least one method call. 
     </description>
 </item>
 <item>
     <term><see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax"/></term>
     <description><see cref="F:Microsoft.CodeAnalysis.SymbolInfo.None"/></description>
 </item>
 <item>
     <term><see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax"/></term>
     <description><see cref="F:Microsoft.CodeAnalysis.SymbolInfo.None"/></description>
 </item>
 <item>
     <term><see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax"/></term>
     <description>
         <see cref="F:Microsoft.CodeAnalysis.SymbolInfo.None"/>.
         Use <see cref="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAggregateClauseSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax,System.Threading.CancellationToken)"/> instead.
     </description>
 </item>
 </list>
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns Select method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax"/> within a <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax"/>, 
 or <see cref="F:Microsoft.CodeAnalysis.SymbolInfo.None"/> otherwise if none is.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns aggregate function associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax"/>.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax,System.Threading.CancellationToken)">
 <summary>
 Returns OrderBy/OrderByDescending/ThenBy/ThenByDescending method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax"/>.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)">
 <summary>
 Analyze control-flow within a part of a method body.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)">
 <summary>
 Analyze control-flow within a part of a method body.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Analyze data-flow within an expression. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)">
 <summary>
 Analyze data-flow within a set of contiguous statements.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)">
 <summary>
 Analyze data-flow within a statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
 <summary>
 Gets the SemanticModel for a MethodBlockBaseSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
 <summary>
 Gets the SemanticModel for a RangeArgumentSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
 <summary>
 Gets the SemanticModel for a ExecutableStatementSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
 <summary>
 Gets the SemanticModel for a EqualsValueSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
 <summary>
 Gets the SemanticModel for a AttributeSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
 <summary>
 Gets the SemanticModel for a TypeSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicFileSystemExtensions.Emit(Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},System.Threading.CancellationToken)">
 <summary>
 Emit the IL for the compilation into the specified stream.
 </summary>
 <param name="compilation">Compilation.</param>
 <param name="outputPath">Path of the file to which the compilation will be written.</param>
 <param name="pdbPath">
 Path of the file to which the compilation's debug info will be written.
 Also embedded in the output file. <c>Nothing</c> to forego PDB generation.
 </param>
 <param name="xmlDocPath">Path of the file to which the compilation's XML documentation will be written. <c>Nothing</c> to forego XML generation.</param>
 <param name="win32ResourcesPath">Path of the file from which the compilation's Win32 resources will be read (in RES format).  
 Null to indicate that there are none.</param>
 <param name="manifestResources">List of the compilation's managed resources. <c>Nothing</c> to indicate that there are none.</param>
 <param name="cancellationToken">To cancel the emit process.</param>
 <exception cref="T:System.ArgumentNullException">Compilation or path is null.</exception>
 <exception cref="T:System.ArgumentException">Path is empty or invalid.</exception>
 <exception cref="T:System.IO.IOException">An error occurred while reading or writing a file.</exception>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions">
 <summary>
 Represents Visual Basic parse options.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.#ctor(Microsoft.CodeAnalysis.VisualBasic.LanguageVersion,Microsoft.CodeAnalysis.DocumentationMode,Microsoft.CodeAnalysis.SourceCodeKind,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
 <summary>
 Creates an instance of VisualBasicParseOptions.
 </summary>
 <param name="languageVersion">The parser language version.</param>
 <param name="documentationMode">The documentation mode.</param>
 <param name="kind">The kind of source code.<see cref="T:Microsoft.CodeAnalysis.SourceCodeKind"/></param>
 <param name="preprocessorSymbols">An enumerable sequence of KeyValuePair representing preprocessor symbols.</param>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.LanguageVersion">
 <summary>
 Returns the parser language version.
 </summary>        
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.PreprocessorSymbols">
 <summary>
 The preprocessor symbols to parse with. 
 </summary>
 <remarks>
 May contain duplicate keys. The last one wins. 
 </remarks>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.PreprocessorSymbolNames">
 <summary>
 Returns a collection of preprocessor symbol names. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.WithLanguageVersion(Microsoft.CodeAnalysis.VisualBasic.LanguageVersion)">
 <summary>
 Returns a VisualBasicParseOptions instance for a specified language version.
 </summary>
 <param name="version">The parser language version.</param>
 <returns>A new instance of VisualBasicParseOptions if different language version is different; otherwise current instance.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.WithKind(Microsoft.CodeAnalysis.SourceCodeKind)">
 <summary>
 Returns a VisualBasicParseOptions instance for a specified source code kind.
 </summary>
 <param name="kind">The parser source code kind.</param>
 <returns>A new instance of VisualBasicParseOptions if source code kind is different; otherwise current instance.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.WithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode)">
 <summary>
 Returns a VisualBasicParseOptions instance for a specified documentation mode.
 </summary>
 <param name="documentationMode"></param>
 <returns>A new instance of VisualBasicParseOptions if documentation mode is different; otherwise current instance.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.WithPreprocessorSymbols(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
 <summary>
 Returns a VisualBasicParseOptions instance for a specified collection of KeyValuePairs representing pre-processor symbols.
 </summary>
 <param name="symbols">A collection representing pre-processor symbols</param>
 <returns>A new instance of VisualBasicParseOptions.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.WithPreprocessorSymbols(System.Collections.Generic.KeyValuePair{System.String,System.Object}[])">
 <summary>
 Returns a VisualBasicParseOptions instance for a specified collection of KeyValuePairs representing pre-processor symbols.
 </summary>
 <param name="symbols">An parameter array of KeyValuePair representing pre-processor symbols.</param>
 <returns>A new instance of VisualBasicParseOptions.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.WithPreprocessorSymbols(System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
 <summary>
 Returns a VisualBasicParseOptions instance for a specified collection of KeyValuePairs representing pre-processor symbols.
 </summary>
 <param name="symbols">An ImmutableArray of KeyValuePair representing pre-processor symbols.</param>
 <returns>A new instance of VisualBasicParseOptions.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.CommonWithKind(Microsoft.CodeAnalysis.SourceCodeKind)">
 <summary>
 Returns a ParseOptions instance for a specified Source Code Kind.
 </summary>
 <param name="kind">The parser source code kind.</param>
 <returns>A new instance of ParseOptions.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.CommonWithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode)">
 <summary>
 Returns a ParseOptions instance for a specified Documentation Mode.
 </summary>
 <param name="documentationMode">The documentation mode.</param>
 <returns>A new instance of ParseOptions.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.WithFeatures(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
 <summary>
 Enable some experimental language features for testing.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.Equals(Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions)">
 <summary>
 Determines whether the current object is equal to another object of the same type.
 </summary>
 <param name="other">An VisualBasicParseOptions object to compare with this object</param>
 <returns>A boolean value.  True if the current object is equal to the other parameter; otherwise, False.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.Equals(System.Object)">
 <summary>
 Indicates whether the current object is equal to another object.
 </summary>
 <param name="obj">An object to compare with this object</param>
 <returns>A boolean value.  True if the current object is equal to the other parameter; otherwise, False.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions.GetHashCode">
 <summary>
 Returns a hashcode for this instance.
 </summary>
 <returns>A hashcode representing this instance.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.GeneratedExtensionSyntaxFacts.GetText(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Return keyword or punctuation text based on SyntaxKind
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.Diagnostics.VisualBasic.VisualBasicCompilerDiagnosticAnalyzer">
 <summary>
 DiagnosticAnalyzer for VB compiler's syntax/semantic/compilation diagnostics.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasicExtensions">
 <summary>
 Addition Visual Basic syntax extension methods.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Determines if SyntaxTrivia is a specified kind.
 </summary>        
<param name="trivia">The Source SyntaxTrivia.</param>
 <param name="kind">The SyntaxKind to test for.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Determines if SyntaxToken is a specified kind.
 </summary>
<param name="token">The Source SyntaxToken.</param>
 <param name="kind">The SyntaxKind to test for.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Determines if SyntaxNode is a specified kind.
 </summary>
 <param name="node">The Source SyntaxNode.</param>
 <param name="kind">The SyntaxKind to test for.</param>
 <returns>A boolean value if node is of specified kind; otherwise false.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Determines if a SyntaxNodeOrToken is a specified kind.
 </summary>
 <param name="nodeOrToken">The source SyntaxNodeOrToke.</param>
 <param name="kind">The SyntaxKind to test for.</param>
 <returns>A boolean value if nodeOrToken is of specified kind; otherwise false.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Returns the index of the first node of a specified kind in the node list.
 </summary>
 <param name="list">Node list.</param>
 <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> to find.</param>
 <returns>Returns non-negative index if the list contains a node which matches <paramref name="kind"/>, -1 otherwise.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Tests whether a list contains node of a particular kind.
 </summary>
 <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> to test for.</param>
 <returns>Returns true if the list contains a token which matches <paramref name="kind"/></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Returns the index of the first node of a specified kind in the node list.
 </summary>
 <param name="list">Node list.</param>
 <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> to find.</param>
 <returns>Returns non-negative index if the list contains a node which matches <paramref name="kind"/>, -1 otherwise.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Tests whether a list contains node of a particular kind.
 </summary>
 <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> to test for.</param>
 <returns>Returns true if the list contains a token which matches <paramref name="kind"/></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Returns the index of the first trivia of a specified kind in the trivia list.
 </summary>
 <param name="list">Trivia list.</param>
 <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> to find.</param>
 <returns>Returns non-negative index if the list contains a trivia which matches <paramref name="kind"/>, -1 otherwise.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Tests whether a list contains trivia of a particular kind.
 </summary>
 <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> to test for.</param>
 <returns>Returns true if the list contains a trivia which matches <paramref name="kind"/></returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Returns the index of the first token of a specified kind in the token list.
 </summary>
 <param name="list">Token list.</param>
 <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> to find.</param>
 <returns>Returns non-negative index if the list contains a token which matches <paramref name="kind"/>, -1 otherwise.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Tests whether a list contains token of a particular kind.
 </summary>
 <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> to test for.</param>
 <returns>Returns true if the list contains a token which matches <paramref name="kind"/></returns>
</member>
</members>
</doc>
