<?xml version="1.0"?>
<doc>
<assembly>
<name>
Microsoft.CodeAnalysis.VisualBasic.Workspaces
</name>
</assembly>
<members>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Classification.ClassificationHelpers.GetClassification(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Return the classification type associated with this token.
 </summary>
 <param name="token">The token to be classified.</param>
 <returns>The classification type for the token</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.BreakpointSpans.TryGetEnclosingBreakpointSpan(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.Text.TextSpan@)">
 <summary>
 Given a syntax token determines a text span delimited by the closest applicable sequence points 
 encompassing the token.
 </summary>
 <remarks>
 If the span exists it Is possible To place a breakpoint at the given position.
 </remarks>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.IsStatementTerminatingTokenVisitor">
 <summary>
 A visitor that determines if the targetToken passed in the constructor can be considered
 the end of the visited statement. Tokens in the token stream of the file after
 targetToken are ignored. This means that in some cases, say "Throw" vs. "Throw x" there
 is more than one keyword that could terminate the statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTokenExtensions.HasNonContinuableEndOfLineBeforePosition(Microsoft.CodeAnalysis.SyntaxToken,System.Int32,System.Boolean)">
 <summary>
 We need to check for EOL trivia not preceded by LineContinuation trivia.
 
 This is slightly complicated since we need to get TrailingTrivia from missing tokens 
 and then get LeadingTrivia for the next non-missing token
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsTypeDeclarationContext(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
 <summary>
 The specified position is where we can declare some .NET type, such as classes, structures, etc.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsTypeMemberDeclarationKeywordContext(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
 <summary>
 The specified position is where a keyword can go like "Sub", "Function", etc. in a classes, structures, and modules
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsInterfaceMemberDeclarationKeywordContext(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
 <summary>
 The specified position is where a keyword can go like "Sub", "Function" in an interface
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsTypeDeclarationKeywordContext(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
 <summary>
 The specified position is where we can declare some .NET type, such as classes, structures, etc.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsSingleLineStatementContext(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
 <summary>
 The specified position is where I could start a statement in a place where exactly one
 statement could exist.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsMultiLineStatementStartContext(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
 <summary>
 The specified position is where I could start a statement in a place where one or more
 statements could exist.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsAfterStatementOfKind(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind[])">
 <summary>
 The specified position is immediately following a statement of one of the given kinds.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.GetExpressionTerminatingToken(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Given a syntax node, this returns the token that is the "end" token that ends this
 expression.
 </summary>
 <param name="expression">The expression to get the last token of.</param>
 <returns>The last token, or SyntaxKind.None if the last token is missing.</returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.VisualBasicSyntaxContext">
 <summary>
 Helper structure to store some context about a position for keyword completion
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.VisualBasicSyntaxContext.FollowsEndOfStatement">
 <summary>
 True if position is after a colon, or an
 EOL that was not preceded by an explicit line continuation
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.VisualBasicSyntaxContext.MustBeginNewStatement">
 <summary>
 True if position is definitely the beginning of a new statement (after a colon
 or two line breaks).
 
 Dim q = From a In args
 $1
 $2
 
 $1 may continue the previous statement, but $2 definitely starts a 
 new statement since there are two line breaks before it.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.VisualBasicSyntaxTreeExtensions.IsAfterStatementOfKind(Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.VisualBasicSyntaxContext,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind[])">
 <summary>
 The specified position is immediately following a statement of one of the given kinds.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Extensions.DirectiveSyntaxExtensions.DirectiveInfo.StartEndMap">
 <summary>
 Returns a map which maps from a DirectiveTriviaSyntax to it's corresponding start/end directive.
 Directives like #ElseIf which exist in the middle of a start/end pair are not included.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Extensions.DirectiveSyntaxExtensions.DirectiveInfo.ConditionalMap">
 <summary>
 Maps a #If/#ElseIf/#Else/#EndIf directive to its list of matching #If/#ElseIf/#Else/#End directives.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.DirectiveSyntaxExtensions.GetMatchingStartOrEndDirective(Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a starting or ending directive, return the matching directive, if it exists. For directives that live
 the "middle" of a start/end pair, such as #ElseIf or #Else, this method will throw.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.DirectiveSyntaxExtensions.GetMatchingConditionalDirectives(Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a conditional directive (#If, #ElseIf, #Else, or #End If), returns a IEnumerable of all directives in
 the set.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ExpressionSyntaxExtensions.DecomposeName(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax@,System.String@,System.Int32@)">
 <summary>
 Decompose a name or member access expression into its component parts.
 </summary>
 <param name="expression">The name or member access expression.</param>
 <param name="qualifier">The qualifier (or left-hand-side) of the name expression. This may be null if there is no qualifier.</param>
 <param name="name">The name of the expression.</param>
 <param name="arity">The number of generic type parameters.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ExpressionSyntaxExtensions.IsPartOfNamespaceDeclarationName(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Checks if the SyntaxNode is a name of a namespace declaration. To be a namespace name, the syntax
 must be parented by an namespace declaration and the node itself must be equal to the declaration's Name
 property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ExpressionSyntaxExtensions.GetPredefinedKeywordKind(Microsoft.CodeAnalysis.SpecialType)">
 <summary>
 Returns the predefined keyword kind for a given special type.
 </summary>
 <param name="type">The specialtype of this type.</param>
 <returns>The keyword kind for a given special type, or SyntaxKind.None if the type name is not a predefined type.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.IMethodSymbolExtensions.IsAggregateFunction(Microsoft.CodeAnalysis.IMethodSymbol)">
 <summary>
 Determines whether the given IMethodSymbol can be used as an aggregate function
 in a Group..By..Into or an Aggregate..Into clause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.CommonSemanticModelExtensions.GenerateNameForExpression(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Boolean)">
 <summary>
 Given an expression node, tries to generate an appropriate name that can be used for
 that expression.
 </summary> 
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.SplitNodesOnPreprocessorBoundaries``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
 <summary>
 Breaks up the list of provided nodes, based on how they are 
 interspersed with pp directives, into groups.  Within these groups
 nodes can be moved around safely, without breaking any pp 
 constructs.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.ContainsInterleavedDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
 <summary>
 Returns true if the passed in node contains an interleaved pp 
 directive.
 
 i.e. The following returns false:
 
   void Foo() {
 #if true
 #endif
   }
 
 #if true
   void Foo() {
   }
 #endif
 
 but these return true:
 
 #if true
   void Foo() {
 #endif
   }
 
   void Foo() {
 #if true
   }
 #endif
 
 #if true
   void Foo() {
 #else
   }
 #endif
 
 i.e. the method returns true if it contains a PP directive that 
 belongs to a grouping constructs (like #if/#endif or 
 #region/#endregion), but the grouping construct isn't entirely c
 contained within the span of the node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.IsExecutableBlock(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Returns true if this is a block that can contain multiple executable statements.  i.e.
 this node is the VB equivalent of a BlockSyntax in C#.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.FindTokenOnRightOfPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 If the position is inside of token, return that token; otherwise, return the token to right.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.FindTokenOnLeftOfPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 If the position is inside of token, return that token; otherwise, return the token to left. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.ChildThatContainsPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Int32@)">
 <summary>
 Returns child node or token that contains given position.
 </summary>
 <remarks>
 This is a copy of <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)"/>  that also returns the index of the child node.
 </remarks>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.FindSkippedTokenForward">
 <summary>
 Look inside a trivia list for a skipped token that contains the given position.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.FindSkippedTokenBackward">
 <summary>
 Look inside a trivia list for a skipped token that contains the given position.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.GetSkippedTokens(Microsoft.CodeAnalysis.SyntaxTriviaList)">
 <summary>
 get skipped tokens from the trivia list
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTokenExtensions.IsChildToken``1(Microsoft.CodeAnalysis.SyntaxToken,System.Func{``0,Microsoft.CodeAnalysis.SyntaxToken})">
 <summary>
 Returns true if is a given token is a child token of of a certain type of parent node.
 </summary>
 <typeparam name="TParent">The type of the parent node.</typeparam>
 <param name="token">The token that we are testing.</param>
 <param name="childGetter">A function that, when given the parent node, returns the child token we are interested in.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTokenExtensions.IsChildSeparatorToken``2(Microsoft.CodeAnalysis.SyntaxToken,System.Func{``0,Microsoft.CodeAnalysis.SeparatedSyntaxList{``1}})">
 <summary>
 Returns true if is a given token is a separator token in a given parent list.
 </summary>
 <typeparam name="TParent">The type of the parent node containing the separated list.</typeparam>
 <param name="token">The token that we are testing.</param>
 <param name="childGetter">A function that, when given the parent node, returns the separated list.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTokenExtensions.IsFirstTokenOnLine(Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
 <summary>
 Determines whether the given SyntaxToken is the first token on a line
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTreeExtensions.FindTriviaToLeft(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken)">
 <summary>
 Finds the token being touched by this position. Unlike the normal FindTrivia helper, this helper will prefer
 trivia to the left rather than the right if the position is on the border.
 </summary>
 <param name="syntaxTree">The syntaxTree to search.</param>
 <param name="position">The position to find trivia.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTreeExtensions.FindTokenOnRightOfPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 If the position is inside of token, return that token; otherwise, return the token to right.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTreeExtensions.FindTokenOnLeftOfPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 If the position is inside of token, return that token; otherwise, return the token to left. 
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTreeExtensions.IsLastTokenOfStatementWithEndOfLine(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 check whether given token is the last token of a statement that ends with end of line trivia or an elastic trivia
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTreeExtensions.IsLastTokenOfStatement(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
 <summary>
 check whether given token is the last token of a statement by walking up the spine
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Formatting.FormattingResult">
 <summary>
 this holds onto changes made by formatting engine.
 
 currently it only has an ability to apply those changes to buffer. but it could be expanded to
 support other cases as well such as tree or etc.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Formatting.TriviaDataFactory">
 <summary>
 trivia factory.
 
 it will cache some commonly used trivia to reduce memory footprint and heap allocation
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Formatting.TriviaDataFactory.ComplexTrivia">
 <summary>   
 represents a general trivia between two tokens. slightly more expensive than others since it
 needs to calculate stuff unlike other cases
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Formatting.TriviaDataFactory.LineContinuationTrivia">
 <summary>   
 represents a general trivia between two tokens. slightly more expensive than others since it
 needs to calculate stuff unlike other cases
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSymbolDeclarationService.GetDeclarations(Microsoft.CodeAnalysis.ISymbol)">
 <summary>
 Get the declaring syntax node for a Symbol. Unlike the DeclaringSyntaxReferences property,
 this function always returns a block syntax, if there is one.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSymbolDeclarationService.GetBlockFromBegin(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 If "node" is the begin statement of a declaration block, return that block, otherwise
 return node.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTreeFactoryServiceFactory.VisualBasicSyntaxTreeFactoryService.NullSyntaxReference">
 <summary>
 Represents a syntax reference that was passed a null
 reference to a node. In this case, we just hold onto the
 weak tree reference and throw if any invalid properties
 are accessed.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTreeFactoryServiceFactory.VisualBasicSyntaxTreeFactoryService.PathSyntaxReference">
 <summary>
 Represents a syntax reference that doesn't actually hold onto the 
 referenced node.  Instead, enough data is held onto so that the node
 can be recovered and returned if necessary.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTreeFactoryServiceFactory.VisualBasicSyntaxTreeFactoryService.PositionalSyntaxReference">
 <summary>
 Represents a syntax reference that doesn't actually hold onto the referenced node.
 Instead, enough data is held onto so that the node can be recovered and returned if
 necessary.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTreeFactoryServiceFactory.VisualBasicSyntaxTreeFactoryService.RecoverableSyntaxTree">
 <summary>
 Represents a syntax tree that only has a weak reference to its 
 underlying data.  This way it can be passed around without forcing
 the underlying full tree to stay alive.  Think of it more as a 
 key that can be used to identify a tree rather than the tree itself.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Recommendations.VisualBasicRecommendationService.FilterEventsAndGeneratedSymbols(Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax,Microsoft.CodeAnalysis.ISymbol)">
 <summary>
 In MemberAccessExpression Contexts, filter out event symbols, except inside AddRemoveHandler Statements
 Also, filter out any implicitly declared members generated by event declaration or property declaration
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Rename.VisualBasicRenameRewriterLanguageService.GetExpansionTargetForLocation(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Gets the top most enclosing statement as target to call MakeExplicit on.
 It's either the enclosing statement, or if this statement is inside of a lambda expression, the enclosing
 statement of this lambda.
 </summary>
 <param name="token">The token to get the complexification target for.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Rename.VisualBasicRenameRewriterLanguageService.GetSemanticModelForNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel)">
 <summary>
 Gets the semantic model for the given node. 
 If the node belongs to the syntax tree of the original semantic model, then returns originalSemanticModel.
 Otherwise, returns a speculative model.
 The assumption for the later case is that span start position of the given node in it's syntax tree is same as
 the span start of the original node in the original syntax tree.
 </summary>
 <param name="node"></param>
 <param name="originalSemanticModel"></param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicSimplificationService.NodesAndTokensToReduceComputer.Compute(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.SyntaxNodeOrToken,System.Boolean})">
 <summary>
 Computes a list of nodes and tokens that need to be reduced in the given syntax root.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Utilities.ModifierCollectionFacts">
 <summary>
 A helper class that is constructed giving a set of modifiers. It takes these modifiers, and
 breaks them down into separate categories, as well as determines what type of declaration is
 being forced if certain modifiers are present.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Utilities.SpeculationAnalyzer">
 <summary>
 Helper class to analyze the semantic effects of a speculated syntax node replacement on the parenting nodes.
 Given an expression node from a syntax tree and a new expression from a different syntax tree,
 it replaces the expression with the new expression to create a speculated syntax tree.
 It uses the original tree's semantic model to create a speculative semantic model and verifies that
 the syntax replacement doesn't break the semantics of any parenting nodes of the original expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Utilities.SpeculationAnalyzer.#ctor(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken,System.Boolean,System.Boolean)">
 <summary>
 Creates a semantic analyzer for speculative syntax replacement.
 </summary>
 <param name="expression">Original expression to be replaced.</param>
 <param name="newExpression">New expession to replace the orginal expression.</param>
 <param name="semanticModel">Semantic model of <paramref name="expression"/> node's syntax tree.</param>
 <param name="cancellationToken">Cancellation token.</param>
 <param name="skipVerificationForReplacedNode">
 True if semantic analysis should be skipped for the replaced node and performed starting from parent of the original and replaced nodes.
 This could be the case when custom verifications are required to be done by the caller or
 semantics of the replaced expression are different from the original expression.
 </param>
 <param name="failOnOverloadResolutionFailuresInOriginalCode">
 True if semantic analysis should fail when any of the invocation expression ancestors of <paramref name="expression"/> in original code has overload resolution failures.
 </param>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Utilities.SpeculationAnalyzer.ReplacementChangesSemanticsOfUnchangedLambda(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Determines whether performing the syntax replacement in one of the sibling nodes of the given lambda expressions will change the lambda binding semantics.
 This is done by first determining the lambda parameters whose type differs in the replaced lambda node.
 For each of these parameters, we find the descendant identifier name nodes in the lambda body and check if semantics of any of the parenting nodes of these
 identifier nodes have changed in the replaced lambda.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.AssociatesAnEvent">
<summary>
  Looks up a localized string similar to Associates an event with an event handler, delegate or lambda expression at run time..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Condition">
<summary>
  Looks up a localized string similar to &lt;condition&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ConvertsToDataType">
<summary>
  Looks up a localized string similar to Converts an expression to the {0} data type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.EvaluatedAndReturnedIfTrue">
<summary>
  Looks up a localized string similar to Evaluated and returned if &lt;condition&gt; evaluates to True..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.EvaluatedAndReturnedIfFalse">
<summary>
  Looks up a localized string similar to Evaluated and returned if &lt;condition&gt; evaluates to False..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ReturnedIfNothing">
<summary>
  Looks up a localized string similar to Evaluated and returned if &lt;expression&gt; evaluates to Nothing..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Event1">
<summary>
  Looks up a localized string similar to &lt;event&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Expression1">
<summary>
  Looks up a localized string similar to &lt;expression&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ExpressionIfFalse">
<summary>
  Looks up a localized string similar to &lt;expressionIfFalse&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ExpressionIfNothing">
<summary>
  Looks up a localized string similar to &lt;expressionIfNothing&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ExpressionIfTrue">
<summary>
  Looks up a localized string similar to &lt;expressionIfTrue&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Handler">
<summary>
  Looks up a localized string similar to &lt;handler&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.IfConditionReturnsResults">
<summary>
  Looks up a localized string similar to If &lt;condition&gt; returns True, the function calculates and returns &lt;expressionIfTrue&gt;. Otherwise, it returns &lt;expressionIfFalse&gt;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ExpressionEvalReturns">
<summary>
  Looks up a localized string similar to If &lt;expression&gt; evaluates to a reference or Nullable value that is not Nothing, the function returns that value. Otherwise, it calculates and returns &lt;expressionIfNothing&gt;..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.IntroducesTypeConversion">
<summary>
  Looks up a localized string similar to Introduces a type conversion operation similar to CType. The difference is that CType succeeds as long as there is a valid conversion, whereas DirectCast requires that one type inherit from or implement the other type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.IntroducesSafeTypeConversion">
<summary>
  Looks up a localized string similar to Introduces a type conversion operation that does not throw an exception. If an attempted conversion fails, TryCast returns Nothing, which your program can test for..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Length">
<summary>
  Looks up a localized string similar to &lt;length&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.NamespaceCannotBeAdded">
<summary>
  Looks up a localized string similar to Namespace can not be added in this destination..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.NewValueText">
<summary>
  Looks up a localized string similar to {0}.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.NodeDoesNotDescendFromRoot">
<summary>
  Looks up a localized string similar to Node does not descend from root..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.NodeNotInParentsChildList">
<summary>
  Looks up a localized string similar to Node not in parent&apos;s child list.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.CannotMakeExplicit">
<summary>
  Looks up a localized string similar to Only attributes, expressions or statements can be made explicit.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.RemovesEventAssociation">
<summary>
  Looks up a localized string similar to Removes the association between an event and an event handler or delegate at run time..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ReplacesChars">
<summary>
  Looks up a localized string similar to Replaces a specified number of characters in a String variable with characters from another string..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ReturnedIfINotNothing">
<summary>
  Looks up a localized string similar to Returned if it evaluates to a reference or nullable type that is not Nothing..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ReturnsSystemTypeObject">
<summary>
  Looks up a localized string similar to Returns a System.Type object for the specified type name..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ReturnsConvertResult">
<summary>
  Looks up a localized string similar to Returns the result of explicitly converting an expression to a specified data type..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ReturnsXNamespaceObject">
<summary>
  Looks up a localized string similar to Returns the System.Xml.Linq.XNamespace object corresponding to the specified XML namespace prefix..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.StartIndex">
<summary>
  Looks up a localized string similar to &lt;startIndex&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.StringExpression">
<summary>
  Looks up a localized string similar to &lt;stringExpression&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.StringName">
<summary>
  Looks up a localized string similar to &lt;stringName&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.EventHandlerToAssociate">
<summary>
  Looks up a localized string similar to The event handler to associate with the event. This may take the form of { AddressOf &lt;eventHandler&gt; | &lt;delegate&gt; | &lt;lambdaExpression&gt; }..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.EventHandlerToDisassociate">
<summary>
  Looks up a localized string similar to The event handler to disassociate with the event. This may take the form of { AddressOf &lt;eventHandler&gt; | &lt;delegate&gt; }..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.EventToAssociate">
<summary>
  Looks up a localized string similar to The event to associate an event handler, delegate or lambda expression with..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.EventToDisassociate">
<summary>
  Looks up a localized string similar to The event to disassociate an event handler or delegate with..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ExpressionToConvert">
<summary>
  Looks up a localized string similar to The expression to be evaluated and converted..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.ExpressionToEvaluate">
<summary>
  Looks up a localized string similar to The expression to evaluate..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.NameOfTypeToConvert">
<summary>
  Looks up a localized string similar to The name of the data type to which the value of expression will be converted..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.NameOfStringVariable">
<summary>
  Looks up a localized string similar to The name of the string variable to modify..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.NumberOfCharsToReplace">
<summary>
  Looks up a localized string similar to The number of characters to replace. If omitted, the length of &lt;stringExpression&gt; is used..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.OneBasedStartPos">
<summary>
  Looks up a localized string similar to The one-based character position in the string where the replacement of text begins..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.TypeToReturnObjectFor">
<summary>
  Looks up a localized string similar to The type name to return a System.Type object for..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.XMLNSToReturnObjectFor">
<summary>
  Looks up a localized string similar to The XML namespace prefix to return a System.Xml.Linq.XNamespace object for. If this is omitted, the object for the default XML namespace is returned..
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.TriviaIsNotAssociatedWithToken">
<summary>
  Looks up a localized string similar to Trivia is not associated with token.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Typename">
<summary>
  Looks up a localized string similar to &lt;typeName&gt;.
</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.XmlNamespacePrefix">
<summary>
  Looks up a localized string similar to &lt;xmlNamespacePrefix&gt;.
</summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.FixIncorrectTokensCodeCleanupProvider.FixIncorrectTokensRewriter.RewriteEndIfStatementOrDirectiveSyntax(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Rewrite "EndIf" to "End If" for an EndIfStatementSyntax/EndIfDirectiveSyntax node.
 </summary>
 <param name="curNode">Syntax node for the EndIfStatementSyntax or EndIfDirectiveSyntax to be rewritten.</param>
 <param name="curEndKeyword">"End" keyword token for <paramref name="curNode"/>.</param>
 <param name="curIfKeyword">"If" keyword token for <paramref name="curNode"/>.</param>
 <returns>Rewritten EndIfStatementSyntax/EndIfDirectiveSyntax node.</returns>
 <remarks>
 This method checks for the following:
 (a) Both the End keyword and If keyword, <paramref name="curEndKeyword"/> and <paramref name="curIfKeyword"/> respectively, are Missing tokens AND
 (b) Descendant Trivia under the given <paramref name="curEndKeyword"/> token or <paramref name="curIfKeyword"/> token has an "EndIf" keyword token.
 
 If the above conditions are met, it does the following node rewrites:
 (a) Replace the missing <paramref name="curEndKeyword"/> and <paramref name="curIfKeyword"/> tokens with new "End" and "If" keywords tokens respectively.
 (b) Remove the first "EndIf" keyword token from the descendant trivia and adjust the leading and trailing trivia appropriately.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.OperatorStatementSpecialFixup(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax)">
 <summary>
 this will put operator token and modifier tokens in right order
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.ValidOperatorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax)">
 <summary>
 check whether given operator statement is valid or not
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.NormalizeOperator(Microsoft.CodeAnalysis.SyntaxToken,System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Boolean},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTriviaList},System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.List{Microsoft.CodeAnalysis.VisualBasic.SyntaxKind}},System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Int32,Microsoft.CodeAnalysis.SyntaxToken})">
 <summary>
 normalize operator
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.ReorderModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 reorder modifiers in the list
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.NormalizeModifiers``1(``0,Microsoft.CodeAnalysis.SyntaxNode,System.Func{``0,Microsoft.CodeAnalysis.SyntaxTokenList},System.Func{``0,Microsoft.CodeAnalysis.SyntaxTokenList,``0})">
 <summary>
 normalize modifier list of the node and record changes if there is any change
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.NormalizeModifiers``1(``0,``0,System.Func{``0,Microsoft.CodeAnalysis.SyntaxTokenList},System.Func{``0,Microsoft.CodeAnalysis.SyntaxTokenList,``0})">
 <summary>
 normalize modifier list of the node and record changes if there is any change
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.RemoveDimKeyword``1(``0,System.Func{``0,Microsoft.CodeAnalysis.SyntaxTokenList})">
 <summary>
 remove "Dim" keyword if present
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.RemoveByValKeyword(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax,System.Int32)">
 <summary>
 remove ByVal keyword from parameter list
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.RemoveModifierKeyword``1(``0,System.Func{``0,Microsoft.CodeAnalysis.SyntaxTokenList},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 remove a modifier from the given node
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.IsModifiersInRightOrder(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 check whether given modifiers are in right order (in sync with ModifierKindsInOrder list)
 </summary>
</member>
</members>
</doc>
