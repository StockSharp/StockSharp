<?xml version="1.0" encoding="utf-8"?>
<topic id="99da6499-9ac1-4e7e-bcaf-a0c832dce4de" revisionNumber="1">
	<developerWalkthroughDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    
	<introduction>
		<para><token>stocksharp</token> allows you to expand the possibilities of 
		building candles, giving the opportunity to work with arbitrary candle types. 
		This is useful when you want to work with candles that are not currently supported 
		by <token>stocksharp</token>. Below is a plan of action for the addition 
		of tick candles (candles, which are generated by the number of trades).</para>
    </introduction>
    
	<procedure>
		<title>The implementation of tick candles</title>
		<steps class="ordered">
			<step>
				<content>
<para>First, you need to create your own candle type. The type must inherit from the <codeEntityReference>T:StockSharp.Algo.Candles.Candle</codeEntityReference> class:</para>

<alert class="caution">ТTick candles are supported by <token>stocksharp</token> as standard and this step is presented only as an example.</alert>

<code language="C#">
<![CDATA[
/// <summary>
/// Time-frame candle
/// </summary>
public class TickCandle : Candle
{
    /// <summary>
    /// The candle parameter
    /// </summary>
    public override object Arg
    {
        get
        {
            return this.TradeCount;
        }
        set
        {
            this.TradeCount = (int) value;
        }
    }

    /// <summary>
    /// Maximum tick count
    /// </summary>
    public int TradeCount { get; set; }
}
]]>
</code>
				</content>
			</step>

			<step>
				<content>
<para>Additionally, you need to create your own candle message type. More about <link xlink:href="5794f4b0-c536-4713-ad08-955a4a01b196" />.
The type must inherit from the <codeEntityReference>T:StockSharp.Messages.CandleMessage</codeEntityReference> class:</para>

<code language="C#">
<![CDATA[
/// <summary>
/// Tick candle
/// </summary>
public class TickCandleMessage : CandleMessage
{
	public TickCandleMessage()
		: base(MessageTypes.CandleTick)
	{
	}

	/// <summary>
	/// Maximum tick count
	/// </summary>
	public int MaxTradeCount { get; set; }

	/// <summary>
	/// Clone <see cref="TickCandleMessage"/>.
	/// </summary>
	/// <returns>Clone</returns>
	public override Message Clone()
	{
		return CopyTo(new TickCandleMessage
		{
			MaxTradeCount = MaxTradeCount
		});
	}

	/// <summary>
	/// The candle parameter
	/// </summary>
	public override object Arg
	{
		get => MaxTradeCount;
		set => MaxTradeCount = (int)value;
	}
}]]>
</code>
				</content>
			</step>
     
			<step>
				<content>
<para>3.	Next, you need to create a candle builder for a new candle type. To do this, you need to create the 
<codeEntityReference qualifyHint="false">T:StockSharp.Algo.Candles.Compression.CandleBuilder`1</codeEntityReference>.
implementation. The 
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:StockSharp.Algo.Candles.Compression.CandleBuilder`1.ProcessValue(StockSharp.Messages.MarketDataMessage,`0,StockSharp.Algo.Candles.Compression.ICandleBuilderValueTransform)</codeEntityReference> 
method will receive a value of the 
<codeEntityReference qualifyHint="false">T:StockSharp.Algo.Candles.Compression.ICandleBuilderValueTransform</codeEntityReference>.
type. Depending on the settings, it can contain data about both the 
<codeEntityReference qualifyHint="false">T:StockSharp.Algo.Candles.Compression.TickCandleBuilderValueTransform</codeEntityReference>,
tick trade and the 
<codeEntityReference qualifyHint="false">T:StockSharp.Algo.Candles.Compression.QuoteCandleBuilderValueTransform</codeEntityReference>.</para>

<para>The  
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:StockSharp.Algo.Candles.Compression.CandleBuilder`1.ProcessValue(StockSharp.Messages.MarketDataMessage,`0,StockSharp.Algo.Candles.Compression.ICandleBuilderValueTransform)</codeEntityReference> 
method shall return either a new candle (if new data led to the candle generation), or update the passed one (if the data is not enough to create a new candle). If the 
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:StockSharp.Algo.Candles.Compression.CandleBuilder`1.ProcessValue(StockSharp.Messages.MarketDataMessage,`0,StockSharp.Algo.Candles.Compression.ICandleBuilderValueTransform)</codeEntityReference> 
method returns a new candle, 
<codeEntityReference qualifyHint="false">T:StockSharp.Algo.Candles.Compression.CandleBuilder`1</codeEntityReference> 
calls it again, passing the same 
<codeEntityReference qualifyHint="false">T:StockSharp.Algo.Candles.Compression.ICandleBuilderValueTransform</codeEntityReference>. 
value to the method. The method will be called until 
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:StockSharp.Algo.Candles.Compression.CandleBuilder`1.ProcessValue(StockSharp.Messages.MarketDataMessage,`0,StockSharp.Algo.Candles.Compression.ICandleBuilderValueTransform)</codeEntityReference> 
 returns the passed candle. This is done for those cases when for one 
<codeEntityReference qualifyHint="false">T:StockSharp.Algo.Candles.Compression.ICandleBuilderValueTransform</codeEntityReference>
input value can be generated several candles:
</para>
<code language="C#">
<![CDATA[

/// <summary>
/// The builder of candles of <see cref="T:StockSharp.Algo.Candles.TickCandle" />.
/// </summary>
public class TickCandleBuilder : CandleBuilder<TickCandleMessage>
{
    /// <summary>
    /// Create <see cref="T:StockSharp.Algo.Candles.Compression.TickCandleBuilder" />.
    /// </summary>
    public TickCandleBuilder()
    {
    }

    /// <summary>
    /// Create <see cref="T:StockSharp.Algo.Candles.Compression.TickCandleBuilder" />.
    /// </summary>
    public TickCandleBuilder()
    {
    }

    /// <summary>
    /// To create a new candle
    /// </summary>
    /// <param name="series">Candles series</param>
    /// <param name="transform">Data with which a new candle should be created</param>
    /// <returns>Created candle</returns>
    protected override TickCandle CreateCandle(CandleSeries series, ICandleBuilderValueTransform transform)
    {
        var candle = new TickCandleMessage
        {
            TradeCount = (int)series.Arg,
            OpenTime = transform.Time,
            CloseTime = transform.Time
        };
        return this.FirstInitCandle(series, candle, transform);
    }

    /// <summary>
    /// To get time ranges for which this source of passed candles series has data
    /// </summary>
    /// <param name="series">Candles series</param>
    /// <returns>Time ranges.</returns>
    public override IEnumerable<Range<DateTime>> GetSupportedRanges(CandleSeries series)
    {
        IEnumerable<Range<DateTime>> supportedRanges = base.GetSupportedRanges(series);
        if (!supportedRanges.IsEmpty<Range<DateTime>>())
        {
            if (!(series.Arg is int))
            {
                throw new ArgumentException();
            }
            if (((int) series.Arg) <= 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }
        return supportedRanges;
    }

    /// <summary>
    /// Whether the candle is created before data adding
    /// </summary>
    /// <param name="series">Candles series.</param>
    /// <param name="candle">Candle</param>
    /// <param name="transform">Data by which it is decided to end the current candle creation.</param>
    /// <returns>True, if the candle should be finished. Otherwise, false.</returns>
    protected override bool IsCandleFinishedBeforeChange(CandleSeries series, TickCandleMessage candle, ICandleBuilderValueTransform transform)
    {
        return candle.TotalTicks != null && candle.TotalTicks.Value >= candle.MaxTradeCount;
    }

    /// <summary>
    /// To update the candle data.
    /// </summary>
    /// <param name="series">Candles series.</param>
    /// <param name="candle">Candle.</param>
    /// <param name="transform">Data.</param>
    protected override void UpdateCandle(CandleSeries series, TickCandleMessage candle, ICandleBuilderValueTransform transform)
    {
		base.UpdateCandle(series, candle, transform);
		candle.TotalTicks++;
    }
}
]]>
</code>				
				</content>
			</step>
				
			<step>
				<content>
<para>Then, you need to get the <codeEntityReference>T:StockSharp.Algo.Candles.Compression.CandleBuilderProvider</codeEntityReference> from the connection, and add 
to it: <codeEntityReference qualifyHint="false">T:StockSharp.Algo.Candles.Compression.TickCandleBuilder</codeEntityReference>:</para>
<alert class="caution"><codeEntityReference qualifyHint="false">T:StockSharp.Algo.Candles.Compression.TickCandleBuilder</codeEntityReference>, 
as a candle source, is normally present in <codeEntityReference>T:StockSharp.Algo.Candles.Compression.CandleBuilderProvider</codeEntityReference>.
This step is presented only as an example.</alert>

<code language="C#">
<![CDATA[
private Connector _connector;

...

_connector.Adapter.CandleBuilderProvider.Register(new TickCandleBuilder());
]]>
</code>

				</content>
			</step>
        
			<step>
				<content>
				<para>Create a <codeEntityReference qualifyHint="false">T:StockSharp.Algo.Candles.CandleSeries</codeEntityReference> and request data on it:</para>
<code language="C#">
<![CDATA[
var series = new CandleSeries(typeof(TickCandle), _security, 1000);

...

_connector.SubscribeCandles(series);
]]>
</code>				
				</content>
			</step>
       
		</steps>
	</procedure>

	</developerWalkthroughDocument>
</topic>